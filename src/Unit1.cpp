// Conversion issues for Linux version
// (i) void TForm1::export_ABA(char gVFTnameStem[])
//   system("copy omnibusAba.inp+scratchAba2.tmp+scratchAba3.tmp+scratchAba4.tmp");
//   system("del scratchAba2.tmp");system("del scratchAba3.tmp");system("del scratchAba4.tmp");


// Unit1.cpp=TForm1 (Main form)
// Unit2.cpp=TForm2 (Results selector)
// Unit3.cpp=TForm3 (Custom legend)
// Unit4.cpp=TForm4 (Incremental rotation)
// Unit5.cpp=TForm5 (Nodal query)
// Unit6.cpp=TForm6 (Query element)
// Unit7.cpp=TForm7 (Section)
// Unit8.cpp=TForm8 (Deformed shape [Modeless] & Scale results [Modal])
// Unit9.cpp=TForm9 (Wedge section)
// Unit10.cpp=TForm10 (General axis)
// Unit11.cpp=TForm11 (Section 3-point)
// Unit12.cpp=TForm12 (Section by rotations)
// Unit13.cpp=TForm13 (Section by P1 stress direction)
// Unit14.cpp=TForm14 (Specify single crack)
// Unit15.cpp=TForm15 (Query nodal distance)
// Unit16.cpp=TForm16 (FE statistics)
// Unit17.cpp=TForm17 (Plottable GID selector, et al.)
// Unit18.cpp=TForm18 (Fixed rotation dialog box)
// Unit19.cpp=TForm19 (Analysis progress box)
// Unit20.cpp=TForm20 (Annotation box)
//
// Modal forms: GenCylAxForm,ScaleForm,FEstatForm,AnnotForm
// Modeless: Form1,ResultsForm,CustomLeg,RotaForm,QNode,QElem,SectionForm,ShapeForm,SectWedgeForm,Sect3ptForm,Sect1p2rForm,SectqsdForm,SpecSCkForm,
//           QNDist,GIDSelForm,RotaFixForm,AnalysisProgressForm
//
// OpenDialog:1 FE Geom; 2 FE Results; 3 Crack data; 4 Control;
//
// crHourGlass cursor: FDrotate,FDelemfacets2,FDorderfacet,FDjuxtapose,FDsect_base_indat_mem,
//   FDsect_base_indat,FDsect_base_indatw_mem,FDsect_base_indatw,
//   diagiiz4_icx,diagiiz4_icy,triding,seigvntt1/D/Doc,WriteGIF,chol_decompi,chol_decompo,fracini4,fracini4b,combo_rr,combo_rrn,FDsort_low
//
// Global file streams: ntapeL,ntapeS,ntapeS1
//
// Discrepancy:
//   1. TForm1::secthea1() Why does "delete SectionForm" sometimes fail? (Fixed by FDdynmem_manage??)
//   2. TForm1::Section_XExecute/Y/Z uses base_c1[] but SectionForm uses indat_c1[]  FIXED...
//   3. How to close SectionBox without crash....?      (OK now ???)
//      SectionBox/Continuous sometimes crashes at last section (illegal memory)...
//   4. CAPformatOpenExecute()      NONE
//                                  npoin  npoin  hrh  npoin  nwid
//                                  NONE
//                                  NONE          is essential             FIXED....
//   5. GenCylAxForm ---> Close this form using border icon X.
//   6. CAUTION: closing the modeless forms using X-click might not delete/NULL their memory?
//   7. FDmetal replaces shade fType (11-25) with 2. To reactivated shade--> FDrotate.
//   8. All SECTIONWEDGE/3PT/1P2R max/min inoperative........???
//   9. SectWedgeForm sometimes crashes--> change section planes slightly   FIXED....
//  10. base_c1[] vs. indat_c1[] issues in FormMouseDown/QNode, secthea2() et al. FIXED....
//  11. No left/right section during second CONTINUOUS operation.
//  12. When importing geom files, you MUST use appropos File/Open/(e.g.)NEU..., not file selector.
//  13. FDcontourplot() floating point overflow                             FIXED....
//  14. ntapeL & ntapeS & DiskFree test together--> separate                FIXED....
//  15. FDculledge() problem with transparent (MAX_GID-1) element edges
//  16. ThermDynAnalyzeExecute/EigenAnalyzeExecute() bug in out-of-core iterative solver     FIXED....
//  17. AnimMultiResult() activates without submenu/click?????
//  18. Occasional "contouring" crash when POST/FDmodalAnalysis/Opening two files
//        in a row (but OK if you i.e. "rotate" in between)
//  19. FDelem_subc8 unable to add elnum35_d8/elnum44_d8()--> wedge crashes  FIXED....
//  20. NoShowFEMesh causes ShowEdge, even when HideEdge is active
//  21. psect_outline() does not always identify section outlines, because E1(n1,n2) & corresponding E2(n1,n2) not found
//  22. sloan() failure for large meshes... (Bypass with idirv[i]==i)     FIXED....
//  23. Disaster: In order to "close" modeless forms, the user must have File/Open & Paint & Post/Result
//      THEN use FileClose, and then do it ALL OVER AGAIN....
//      Otherwise the program will crash at        delete FormXXX;
//      TEMPORARY FIX: delete... statements have been commented out.
//
// Observation:
//   1. LE/EP/ThermDynAnalyzeExecute() Indig_analysis plots results on orig mesh, even though calc on renumbered mesh??
//   2. GlobalMemoryStatus(&ms);
//      honk<<ms.dwTotalPhys<<" TPhys0 "<<ms.dwAvailPhys<<" "<<ms.dwAvailPhys/4<<"\n";
//      honk<<ms.dwTotalVirtual<<" TVirt0 "<<ms.dwAvailVirtual<<" "<<ms.dwAvailVirtual/4<<"\n";
//      Note that "new memory" must be used in order to be counted as UNAVAILABLE in the above.
//      i.e.   array= new long[nval];for(ia=0;ia<nval;ia++)array[ia]=0;  ----> Used
//   3. Timing in seconds
//         time_t t0,t1;t0 = time(NULL)/CLK_TCK;
//         .......code........
//         t1 = time(NULL)/CLK_TCK;honk<<t1<<" "<<t0<<" TIME ELAPSED "<<t1-t0<<"\n";
//   4. Note that you can not follow a VFTlistbox->ShowModal() with a CreateWeldingParamSet->ShowModal()

////Sample Colors EFP 3/23/2012
//65535 deeper yellow
//16711935 mauve
//16777088 sky blue
//33023 burnt sienna
//4259584 green
//16711808 dull blue
//32896 brown
//8421631 deeper pink

#include <vcl.h>
#include <fstream.h>
#include <math.h>
#include <iomanip.h>

//KKKKKKKKKKKKKKKKK EFP 8/04/2010
#include <Jpeg.hpp>
//#include <GIFImg.hpp> // Bug in CodeGear: Unable to load *.gif ???
#include <memory>
//KKKKKKKKKKKKKKKKK

#pragma hdrstop

#include "Unit1.h"
#include "Unit2.h"
#include "unit3.h"
#include "Unit4.h"
#include "Unit5.h"
#include "Unit6.h"
#include "Unit7.h"
#include "Unit8.h"
#include "Unit9.h"
#include "Unit10.h"
#include "Unit11.h"
#include "Unit12.h"
#include "Unit13.h"
#include "Unit14.h"
#include "Unit15.h"
#include "Unit16.h"
#include "Unit17.h"
#include "Unit18.h"
#include "Unit19.h"
#include "Unit20.h"
#include "Unit21.h"
#include "Unit22.h"
#include "Unit23.h"
#include "Unit24.h"
#include "Unit25.h"
#include "Unit26.h"
#include "Unit27.h"
#include "Unit28.h"
#include "Unit29.h"
#include "Unit30.h"
#include "Unit31.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;TForm2 *ResultsForm;TForm3 *CustomLeg;TForm4 *RotaForm;
TForm5 *QNode;TForm6 *QElem;TForm7 *SectionForm;
TForm8 *ShapeForm,*ScaleForm,*tshiftCTSP,*tdeltCTSP;
TForm9 *SectWedgeForm;TForm10 *GenCylAxForm;TForm11 *Sect3ptForm;TForm12 *Sect1p2rForm;
TForm13 *SectqsdForm;TForm14 *SpecSCkForm;
//TForm15 *QNDist; //Renamed TForm24
TForm15 *CreateLinWeldPass;TForm16 *FEstatForm;
TForm17 *GIDSelForm,*FwriteUNVselGID; // Used for FwriteUNVselGID & WriteResultbyCol & EditWeldPass_selector
TForm18 *RotaFixForm;TForm19 *AnalysisProgressForm;TForm20 *AnnotForm;

TForm21 *CreateMatPropSet;TForm22 *CreateWeldingParamSet;TForm24 *QNDist;
TForm25 *ABAQnames; //Reuse for WARP3D because ShowModal() EFP 12/16/2012
TForm26 *VFTlistbox;TForm27 *StartElemListForm;TForm28 *F28_Form;
TForm29 *CTSPnames;TForm30 *WeldPassEditSeqn;TForm31 *About_VFT;

int iResSel=0,a_count=0;

ofstream GIFfile,honk("VFTlogfile.txt");
//fstream ntapeL;fstream ntapeS;fstream ntapeS1;
fstream ntapeL,ntapeS,ntapeS1;
float timeVFTarr[64],timeVEDarr[64]; // Cats ass programming

//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner) : TForm(Owner)
{

 TJPEGImage *jp;
//TGIFImage *gp;
 Form1->Caption="VFTsolid version 3.2.56g 2014"; //Remember to change in TForm31 & FileClose


 int ic=0;base.nop1=indat.nop1=NULL;  // Pointer NULL applies to int & long only
 iplotflag=iCircleplot=iCullyesno=nGIDmax=nGID=fl_feres=nMultFile=iplotType=GIFcount=CAPres_count=GIFsw=ANNOTcount=ANLINcount=iBackGroundColor=0;
 wp.PAINT_SEL=1;
 base.GIDcol=indat.GIDcol=2; // i.e. Prioritize plotting of WP
 //Convention: For multiple GIDs per element, use GID in column 2 (of 0,1,2...) if extant.
//                In VFTsolid, Col=0 is base metal, 1 is WG, 2 is WP
//                In VFTshell, Col=0 is base metal, 1 is WG, 2 is 2nd WG (if extant), 3 is WP
 flag_VFTrSave=0;//EFP 10/02/2011
 IntervalT4=TIMER4_INTV;//EFP 10/05/2011
 gl_indatMedian[0]=gl_indatMedian[1]=gl_indatMedian[2]=0.;glGdiff=1.;


/////////////// Caution: ShowWP_XXX depends upon iPersistVFT    EFP 1/21/2011
 iPersistVFT=0;
 ShowWP_hide->Checked=true;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=false;
 ShowWPstartelem_list->Checked=false;ShowWPstartelem_Hide->Checked=true;
 AutoSaveOn->Checked=false;AutoSaveOff->Checked=true;
 if(wp.PAINT_SEL){ShowWG_polychrome->Checked=true; ShowWG_red->Checked=false;}
 else            {ShowWG_polychrome->Checked=false;ShowWG_red->Checked=true;}
///////////////
 iplotSWT=1;
 icTimer5=0;// iPaintyesno=1; //Paint surface only
 iPaintyesno=0; //AllGIDs
 nColRes=0;MXNPEL=MXNPEI=0;stateVFT=0;
 new_nelt=new_npoin=new_nvfix=new_nedge=new_mat=0;

 Form1->WindowState=wsMaximized;
// strcpy(AnnotArr,"");
 for(ic=0;ic<3*ANNOT_CHAR;ic++)AnnotIndex[ic]=0;for(ic=0;ic<4*ANNOT_CHAR;ic++)AnLINIndex[ic]=0;
/////////
 arbFacet=NULL;rbTemp=NULL;edgFacet=NULL;mutFacet=NULL;iswFace=NULL;
/////////
 Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;
 iResSel= -1;qndNodeNum1= -1;
 illumDirect[0]=1./sqrt(3.);illumDirect[1]=1./sqrt(3.);illumDirect[2]=1./sqrt(3.);
 section_frame=0;isectsw=1;sect_plane[0]=sect_plane[1]=0.;sect_plane[2]=1.;
 for(ic=0;ic<6;ic++)sectdval[ic]=0.;
 sectmx=1.E20;sectmn= -1.E20;resscale=1.;
 shapecombo=0.;Undeformedmesh1->Checked=true;Deformedshape1->Checked=false;Defshapeundefmesh1->Checked=false;
 rangle[0]=rangle[1]=rangle[2]=0.;rangle0[0]=rangle0[1]=rangle0[2]=0.;
 trans_op[0]=trans_op[1]=trans_op[2]=0.;prod_op[0][0]=prod_op[1][1]=prod_op[2][2]=1.;
 prod_op[0][1]=prod_op[0][2]=prod_op[1][0]=0.;prod_op[1][2]=prod_op[2][0]=prod_op[2][1]=0.;
 trans_zoom[0]=0.;trans_zoom[1]=0.;trans_zoom[2]=0.;
 prod_zoom[0]=1.;prod_zoom[1]=1.;prod_zoom[2]=1.;rot_op[0][0]=rot_op[1][1]=rot_op[2][2]=1.;
 rot_op[0][1]=rot_op[0][2]=rot_op[1][0]=0.;rot_op[1][2]=rot_op[2][0]=rot_op[2][1]=0.;
 zoomDrag=false;FD_LButtonstatus=0;
 leg_rmin= -1.e28;leg_rmax=1.e28;
 Legend_auto->Checked=true;Legend_custom->Checked=1-Legend_auto->Checked;
 ApperGID->Checked=true;ApperMetal->Checked=false;ApperShade->Checked=false;
 ContourAll->Checked=true;ContourSection->Checked=1-ContourAll->Checked;
 CylXaxis1->Checked=false;CylYaxis1->Checked=false;CylZaxis1->Checked=true;CylGaxis1->Checked=false;
 ShowFEMesh->Checked=true;NoShowFEMesh->Checked=1-ShowFEMesh->Checked;
 for(ic=0;ic<9;ic++)genaxispts[ic]=0.;
 ResultsForm=NULL;CustomLeg=NULL;RotaForm=NULL;QNode=NULL;QElem=NULL;
 SectionForm=NULL;SectWedgeForm=NULL;ShapeForm=NULL;GenCylAxForm=NULL;
 ScaleForm=NULL;tshiftCTSP=NULL;tdeltCTSP=NULL;
 Sect3ptForm=NULL;Sect1p2rForm=NULL;SectqsdForm=NULL;SpecSCkForm=NULL;QNDist=NULL;FEstatForm=NULL;
 GIDSelForm=NULL;RotaFixForm=NULL;AnalysisProgressForm=NULL;AnnotForm=NULL;

 CreateLinWeldPass=NULL;
 CreateMatPropSet=NULL;CreateWeldingParamSet=NULL;
 WeldPassEditSeqn=NULL;
 ABAQnames=NULL;VFTlistbox=NULL;

 iSpecRes=0;Timer2->Enabled=false;Timer3->Enabled=false;Timer4->Enabled=false;
nDefects=0;iSpecCrack= -1;Timer1->Enabled=false;
ShowCracks1->Checked=false;
//Pointwise1->Checked=false;
//ShowElliptic1->Checked=true;
//ShowEdge1->Checked=true;HideEdge->Checked=1-ShowEdge1->Checked;
base.nofix=NULL;base.nldel=NULL;base.lodpt=NULL;base.matyp=NULL;base.ebody=NULL;
// tBitmap = new Graphics::TBitmap(); // Borland Graphics::TBitmap to distinguish from MSWin Bitmap

// Start from VFTgen

// Panel1->TabOrder=2;
 tBitmap = new Graphics::TBitmap(); // Borland Graphics::TBitmap to distinguish from MSWin Bitmap

//KKKKKKKKKKKKKKKK
// jpeg=new Graphics::TJPEGImage();
//std::auto_ptr<TJPEGImage> jp(new TJPEGImage());
 jp= new TJPEGImage();

//Image1=new TImage();
//std::auto_ptr<TImage> jp(new TImage());
//KKKKKKKKKKKKKKKK
 jp->LoadFromFile(L"icons/image035.jpg");jp->DIBNeeded();// Selection mode of graphics (Arrow graphic)

 Image1->Visible=false;
// Image1->Picture->LoadFromFile("image035.jpg");

// jp->Assign(Image1->Picture);
// Image1->Picture->Assign(TPersistent(jp));
 Image1->Picture->Bitmap->Assign(jp);
// jp->FreeBitmap();
 BitBtn1->Glyph->Monochrome=false;BitBtn1->Glyph=Image1->Picture->Bitmap;


 jp->LoadFromFile(L"icons/image037.jpg");jp->DIBNeeded();// View mode: pivot or pan (Hand graphic)
 Image1->Picture->Bitmap->Assign(jp);
 BitBtn2->Glyph->Monochrome=false;
 BitBtn2->Glyph=Image1->Picture->Bitmap;


 jp->LoadFromFile(L"icons/image039.jpg");jp->DIBNeeded();// 3DMasterSuiteHelp (not used)
 Image1->Picture->Bitmap->Assign(jp);
 BitBtn3->Glyph->Monochrome=false;BitBtn3->Glyph=Image1->Picture->Bitmap;

 jp->LoadFromFile(L"icons/image041.jpg");jp->DIBNeeded();// Set current view as home view
 Image1->Picture->Bitmap->Assign(jp);
 BitBtn4->Glyph->Monochrome=false;BitBtn4->Glyph=Image1->Picture->Bitmap;

 jp->LoadFromFile(L"icons/image042.jpg");jp->DIBNeeded();//Return to this home view
 Image1->Picture->Bitmap->Assign(jp);
 BitBtn5->Glyph->Monochrome=false;BitBtn5->Glyph=Image1->Picture->Bitmap;

 jp->LoadFromFile(L"icons/image043.jpg");jp->DIBNeeded();//View all regions of model
 Image1->Picture->Bitmap->Assign(jp);
 BitBtn6->Glyph->Monochrome=false;BitBtn6->Glyph=Image1->Picture->Bitmap;

 jp->LoadFromFile(L"icons/image050.jpg");jp->DIBNeeded();//Target zoom
 Image1->Picture->Bitmap->Assign(jp);
 BitBtn7->Glyph->Monochrome=false;BitBtn7->Glyph=Image1->Picture->Bitmap;

// Image1->Visible=true;
//BitBtn1->Glyph=Image1->Picture->Metafile;
//BitBtn1->Glyph=Assign(Bitmap.jp);
//BitBtn1->Glyph=jp->Bitmap;

 jp->LoadFromFile(L"icons/image034.JPEG");jp->DIBNeeded();// Box zoom. I had to name this *.JPEG to get code to read it???
 Image1->Picture->Bitmap->Assign(jp);
 BitBtn8->Glyph->Monochrome=false;BitBtn8->Glyph=Image1->Picture->Bitmap;

//jp->Bitmap=AssignTo(BitBtn1->Glyph);

//////////////////
 jp->LoadFromFile(L"icons/image001.jpg");jp->DIBNeeded(); //VFT image
 Image1->Visible=true;
 Image1->Picture->Bitmap->Assign(jp);
//////////////////
delete jp;


char bufCWD[128];
getcwd(bufCWD,128);
base.comboCWD=new char[strlen(bufCWD)+19+1+1];
StringCchCopy(base.comboCWD,strlen(bufCWD)+strlen("\\icons\\image001.jpg")+1,bufCWD);
StringCchCat(base.comboCWD,strlen(bufCWD)+strlen("\\icons\\image001.jpg")+1,"\\icons\\image001.jpg");
honk<<bufCWD<<" wheeeeee\n";
honk<<" wheeeeee "<<base.comboCWD<<"\n";


axis_plot_init();

 wp.memWGa=wp.highest=wp.avis=wms.highest=wps.highest=0;
 wp.PRECORD=wp.EDIT_SEL=wp.elStart= -1;wp.pending=0;
 wp.nWeldPass=wp.nWeldGroup=wp.nWeldPassEl=wms.nMatPropSet=wps.nWeldParamSet=VFTon=wp.Record=wp.edit_sel=wp.paint_sel=0;
 wp.VEDsteps=wp.VFTresSteps=0; // Cats ass programming
 wp.CreateWPassMode=0;
///////////////////////////////////
 wpRes.wIndex=NULL;wpRes.wActiven=NULL;wpRes.wActiveR=NULL;
 wpRes.timeVFTarr=NULL;wpRes.timeVEDarr=NULL;
///////////////////////////////////
// gWsiAlias="****";
 gWsiAlias=L"Model"; //Correction EFP 1/07/2011
 VFTr_name="Model.VFTr";

if((wp.avis-100*(wp.avis/100))/10){Normal_direction1->Checked=false;
								   Complem_direction1->Checked=true;
								  }
else {Normal_direction1->Checked=true;
	  Complem_direction1->Checked=false;
	 }

/////////////////
 if(Mouse->MousePresent) // EFP 10/9/2009
//   (if(Mouse->WheelPresent);  //honk<< Mouse->WheelScrollLines <<" #WheelScrollLines per Mouse notch\n";
   {if(Mouse->WheelPresent)honk<<"Confirmation: Mouse wheel found.\n";
	else honk<<"Warning: Mouse wheel not found.\n";
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Mouse not found.",L"Terminate",MB_OK);exit(0);}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
////////////////
randomize();
////////////////


}
//---------------------------------------------------------------------------
void __fastcall TForm1::ExitExecute(TObject *Sender){exit(0);}
//void __fastcall TForm1::ExitExecute(){exit(0);}
//---------------------------------------------------------------------------
void __fastcall TForm1::FileCloseExecute(TObject *Sender)
{int ic=0;long dummy=0;
 Form1->Caption="VFTsolid version 3.2.56g 2014"; //Remember to change in TForm31
/////////////// Caution: ShowWP_XXX depends upon iPersistVFT    EFP 1/21/2011
 wp.PAINT_SEL=1;
 iPersistVFT=0;
 gl_indatMedian[0]=gl_indatMedian[1]=gl_indatMedian[2]=0.;glGdiff=1.;
 ShowWP_hide->Checked=true;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=false;
 ShowWPstartelem_list->Checked=false;ShowWPstartelem_Hide->Checked=true;
 AutoSaveOn->Checked=false;AutoSaveOff->Checked=true;
  if(wp.PAINT_SEL){ShowWG_polychrome->Checked=true;ShowWG_red->Checked=false;}
 else            {ShowWG_polychrome->Checked=false;ShowWG_red->Checked=true;}
///////////////

 if(base.nop1)
   {FDdynmem_manage(-1,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	if(fl_feres){FDdynmem_manage(-3,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);nColRes=0;
				 FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);}
	FDdynmem_manage(-13,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy); //EFP 3/15/2011
//	FDdynmem_manage(-14,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy); //EFP 3/15/2011
	FDdynmem_manage(-15,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy); //EFP 3/15/2011
//	FDdynmem_manage(-16,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy); //EFP 3/15/2011
	FDdynmem_manage(-17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy); //EFP 3/15/2011
	base.nop1=indat.nop1=NULL;     // Pointer NULL applies to int & long only
	if(iCullyesno){delete [] arbFacet;delete [] rbTemp;delete [] edgFacet;delete [] mutFacet;delete [] iswFace;
				   arbFacet=NULL;rbTemp=NULL;edgFacet=NULL;mutFacet=NULL;iswFace=NULL;iCullyesno=0;
				  }
	if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
	iplotflag=iCircleplot=nGIDmax=nGID=fl_feres=nMultFile=iplotType=GIFsw=GIFcount=ANNOTcount=ANLINcount=0;
 base.GIDcol=indat.GIDcol=2; // i.e. Prioritize plotting of WP
 flag_VFTrSave=0;//EFP 10/02/2011
 IntervalT4=TIMER4_INTV;//EFP 10/05/2011
//	wp.PRECORD= -1;wp.EDIT_SEL= -1;
// From VFTgen iplotType
 iplotSWT=1;
	iResSel= -1;polypts=0;icTimer5=0;

	// iPaintyesno=1; //Paint surface only
 iPaintyesno=0; //AllGIDs
 new_nelt=new_npoin=new_nvfix=new_nedge=new_mat=0;
//    strcpy(AnnotArr,"");
	for(ic=0;ic<3*ANNOT_CHAR;ic++)AnnotIndex[ic]=0;
	for(ic=0;ic<4*ANNOT_CHAR;ic++)AnLINIndex[ic]=0;
	Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;
	iResSel= -1;qndNodeNum1= -1;MXNPEL=MXNPEI=0;
	illumDirect[0]=1./sqrt(3.);illumDirect[1]=1./sqrt(3.);illumDirect[2]=1./sqrt(3.);
	section_frame=0;isectsw=1;sect_plane[0]=sect_plane[1]=0.;sect_plane[2]=1.;
	for(ic=0;ic<6;ic++)sectdval[ic]=0.;
	sectmx=1.E20;sectmn= -1.E20;resscale=1.;
	shapecombo=0.;Undeformedmesh1->Checked=true;Deformedshape1->Checked=false;Defshapeundefmesh1->Checked=false;
	rangle0[0]=0.;rangle0[1]=0.;rangle0[2]=0.;
	trans_op[0]=trans_op[1]=trans_op[2]=0.;prod_op[0][0]=prod_op[1][1]=prod_op[2][2]=1.;
	prod_op[0][1]=prod_op[0][2]=prod_op[1][0]=0.;prod_op[1][2]=prod_op[2][0]=prod_op[2][1]=0.;
	trans_zoom[0]=0.;trans_zoom[1]=0.;trans_zoom[2]=0.;
	prod_zoom[0]=1.;prod_zoom[1]=1.;prod_zoom[2]=1.;rot_op[0][0]=rot_op[1][1]=rot_op[2][2]=1.;
	rot_op[0][1]=rot_op[0][2]=rot_op[1][0]=0.;rot_op[1][2]=rot_op[2][0]=rot_op[2][1]=0.;
	zoomDrag=false;FD_LButtonstatus=0;
	leg_rmin= -1.e28;leg_rmax=1.e28;
	Legend_auto->Checked=true;Legend_custom->Checked=1-Legend_auto->Checked;
 CylXaxis1->Checked=false;CylYaxis1->Checked=false;CylZaxis1->Checked=true;CylGaxis1->Checked=false;
 for(ic=0;ic<9;ic++)genaxispts[ic]=0.;
	ApperGID->Checked=true;ApperMetal->Checked=false;ApperShade->Checked=false;
 ContourAll->Checked=true;ContourSection->Checked=1-ContourAll->Checked;
 ShowFEMesh->Checked=true;NoShowFEMesh->Checked=1-ShowFEMesh->Checked;
	if(CustomLeg){delete CustomLeg;CustomLeg=NULL;}if(RotaForm){delete RotaForm;RotaForm=NULL;}
	if(QNode){delete QNode;QNode=NULL;}if(QElem){delete QElem;QElem=NULL;}
	if(SectionForm){delete SectionForm;SectionForm=NULL;}if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
	if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;}if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
	if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}if(SpecSCkForm){delete SpecSCkForm;SpecSCkForm=NULL;}
	if(ShapeForm){delete ShapeForm;ShapeForm=NULL;}if(GenCylAxForm){delete GenCylAxForm;GenCylAxForm=NULL;}
	if(ScaleForm){delete ScaleForm;ScaleForm=NULL;}
	if(tshiftCTSP){delete tshiftCTSP;tshiftCTSP=NULL;}if(tdeltCTSP){delete tdeltCTSP;tdeltCTSP=NULL;}
	if(QNDist){delete QNDist;QNDist=NULL;}
	if(FEstatForm){delete FEstatForm;FEstatForm=NULL;}if(GIDSelForm){delete GIDSelForm;GIDSelForm=NULL;}
	if(RotaFixForm){delete RotaFixForm;RotaFixForm=NULL;}if(AnalysisProgressForm){delete AnalysisProgressForm;AnalysisProgressForm=NULL;}
	if(AnnotForm){delete AnnotForm;AnnotForm=NULL;}

if(CreateLinWeldPass){delete CreateLinWeldPass;CreateLinWeldPass=NULL;}
if(CreateMatPropSet){delete CreateMatPropSet;CreateMatPropSet=NULL;}
if(CreateWeldingParamSet){delete CreateWeldingParamSet;CreateWeldingParamSet=NULL;}
if(WeldPassEditSeqn){delete WeldPassEditSeqn;WeldPassEditSeqn=NULL;}
if(ABAQnames){delete ABAQnames;ABAQnames=NULL;}

	Timer1->Enabled=false;iSpecRes=0;Timer2->Enabled=false;Timer3->Enabled=false;
	if(nDefects)FDdynmem_manage(-5,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	nDefects=0;iSpecCrack= -1;Timer4->Enabled=false;
	ShowCracks1->Checked=false;
//	Pointwise1->Checked=false;
//	ShowElliptic1->Checked=true;
//ShowEdge1->Checked=true;HideEdge->Checked=1-ShowEdge1->Checked;
	base.matyp=base.matno=base.orig_matno=base.nldel=base.nofix=base.lodpt=NULL;indat.nfsect=0;
// gWsiAlias="****";
 gWsiAlias=L"Model"; //Correction EFP 1/07/2011
 VFTr_name="Model.VFTr";
 FD_LButtonstatus=FD_LBrec=0;stateVFTrec=0;
stateVFT=VFTon=wp.Record=wp.edit_sel=0;
	if(wp.nWeldPass){wp.nWeldPass=wp.nWeldPassEl=wp.nWeldGroup=0; //nGID= 1 base + #weldgroups
//					 wp.VEDsteps=wp.VFTresSteps=0; // Cats ass programming
					 FDdynmem_manage(-6,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			}

 axis_plot_init();

///////////////////////////////////
// glWPRECORD= -1;glEDIT_SEL= -1;
 wp.memWGa=wp.highest=wp.avis=wms.highest=wps.highest=0;
 wp.PRECORD=wp.EDIT_SEL=wp.elStart= -1;wp.pending=0;
 wp.VEDsteps=wp.VFTresSteps=0; // Cats ass programming (i.e. wp & wpRes)
 wp.CreateWPassMode=0;
if(wpRes.wIndex){delete [] wpRes.wIndex;wpRes.wIndex=NULL;}
if(wpRes.wActiven){delete [] wpRes.wActiven;wpRes.wActiven=NULL;}
if(wpRes.wActiveR){delete [] wpRes.wActiveR;wpRes.wActiveR=NULL;}
if(wpRes.timeVFTarr){delete [] wpRes.timeVFTarr;wpRes.timeVFTarr=NULL;}
if(wpRes.timeVEDarr){delete [] wpRes.timeVEDarr;wpRes.timeVEDarr=NULL;}

if((wp.avis-100*(wp.avis/100))/10){Normal_direction1->Checked=false;
								   Complem_direction1->Checked=true;
								  }
else {Normal_direction1->Checked=true;
	  Complem_direction1->Checked=false;
	 }

if(VFTlistbox){delete [] VFTlistbox;VFTlistbox=NULL;}
///////////////////////////////////
	if(wp.nWeldPass){wp.nWeldPass=wp.nWeldPassEl=wp.nWeldGroup=0; //nGID= 1 base + #weldgroups
					 FDdynmem_manage(-6,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
					}
	if(wms.nMatPropSet){wms.nMatPropSet=0;
						FDdynmem_manage(-7,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
					   }
	if(wps.nWeldParamSet){wps.nWeldParamSet=0;
						  FDdynmem_manage(-8,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
						 }
//	VFTmenu_active();
	base.nofix=NULL;base.nldel=NULL;base.lodpt=NULL;base.matyp=NULL;base.ebody=NULL;Invalidate();
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No open file",L"Halt",MB_OK);}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
}
//---------------------------------------------------------------------------
void TForm1::FDdynmem_manage(int isel,long bnpoin,long bnelt,long inpoin,long inelt,long nCR,long bnvfix,long bnedge,long bpload,long bnblod,long bmat,long bcoorf,long infsect,long MXNP)
// Global NDF
{
//**************** Start from VFTgen
 int *SWTseqNum=NULL,*SWTboolFlags=NULL,*SWTtype=NULL,*SWTshape=NULL,*SWTstepInterval=NULL,
	 *SWThp=NULL,*SWTnsegs=NULL,*SWTiselect=NULL,*SWTmcr=NULL,*SWTsource=NULL,*SWTutil_arr=NULL
//	 ,*SWTedgeFlag,*SWTcircFlag,*SWTmerge
	 ;
// GIDwp: 1st col= current iside, remainder=GID
 long in=0,dum=0,*SWTeles=NULL,*SWTsttEles=NULL,*SWTstpEle=NULL,*SWTfirstEle=NULL,
	  *SWTnextEle=NULL,*SWTsnorm1=NULL,*SWTsnorm2=NULL,
	  *SWTcircEles=NULL,*SWTedgeEles=NULL,*SWTedgeNodes=NULL,*SWTsttEleNodes=NULL,
	  *SWThlightel=NULL,*SWTn_curr_sttEl=NULL,*SWTprevGID=NULL,*SWTreset=NULL;
 float *SWTcurr=NULL,*SWTvolt=NULL,*SWTeff=NULL,*SWTspeed=NULL,*SWTtroom=NULL,*SWTtmelt=NULL,
	   *SWTtcutl=NULL,*SWTtcuth=NULL,*SWTtimeInterval=NULL,
	   *SWTmaxiHeatStep=NULL,*SWTminiHeatStep=NULL,*SWTthk1=NULL,*SWTthk2=NULL,*SWTwpTimes=NULL;
 double *SWTlstart=NULL,*SWTlend=NULL,*SWTarrows=NULL;
 String *SWTname=NULL,*SWTmatName=NULL;
 TColor *SWTWeldColor=NULL;
// boolFlags[]: showFlag=1st digit,circFlag=2nd,edgeFlag=3rd,merge=4th,girthFlag=5th

 int *SWMTmcr=NULL,*SWMTannjd=NULL,*SWMTved=NULL,*SWMThetjd=NULL,*SWMTnprops=NULL;
 float *SWMTcond=NULL,*SWMTheat=NULL,*SWMTden=NULL,*SWMTTi=NULL,*SWMTTa=NULL,*SWMTTm=NULL;
 String *SWMTname=NULL,*SWMTmatFileName=NULL,*SWMTSteps=NULL;
 bool *SWMTswitc=NULL;

 float *SWPTcurr=NULL,*SWPTvolt=NULL,*SWPTeff=NULL,*SWPTspeed=NULL;
 String *SWPTname=NULL;
//**************** End from VFTgen

 if(isel==1)
  {
   try {
		base.nop1=new long[MXNP*bnelt];base.matno=new long[bnelt];base.c1=new float[NDF*bnpoin];
		base.el_map=new long[bnelt];base.arELEM=new int[bnelt];
		base.node_map=new long[bnpoin];base.orig_matno=new long[bnelt];
// SuperEl
		base.nlp=new long[bnelt];base.beta=new float[NDF*bnelt];
// New FE-related arrays
		if(bnvfix){base.nofix=new long[2*bnvfix];base.nrfix=new long[bnvfix];base.presc=new float[NDF*bnvfix];}
		if(bcoorf)base.cangl=new float[9*bcoorf];
		if(bnedge){base.nldel=new long[2*bnedge];base.press=new float[3*bnedge];}
		if(bpload){base.lodpt=new long[bpload];base.pointld=new float[NDF*bpload];}
		if(bnblod){base.ebody=new long[bnblod];base.body=new float[NDF*bnblod];}
		if(bmat){base.matyp=new long[bmat];base.prop=new float[MPROP*bmat];}
	   }
   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory",L"Exit",MB_OK);exit(0);}
  }
 else if(isel==2)
  {
   try {
		indat.nop1=new long[MXNP*inelt];indat.matno=new long[inelt];
		indat.matnoW=new long[inelt];
		indat.c1=new float[NDF*inpoin];indat.bc1=new float[NDF*inpoin];
		if(infsect)indat.fsect=new long[infsect];
// SuperEl
		indat.nlp=new long[inelt];indat.beta=new float[NDF*inelt];
	   }
   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory",L"Exit",MB_OK);exit(0);}
  }
 else if(isel==3)
  {
   try {
		base.res1=new float[nCR*bnpoin];
	   }
   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory",L"Exit",MB_OK);exit(0);}
  }
 else if(isel==4)
  {
   try {
		indat.res1=new float[nCR*inpoin];indat.result=new float[inpoin];
	   }
   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory",L"Exit",MB_OK);exit(0);}
  }
 else if(isel==5)
  {
   try {
		bCrackCor=new float[nCR*9];bCrackAng=new float[nCR*2];CrackCor=new float[nCR*9];CrackTyp=new int[nCR];
	   }
   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory",L"Exit",MB_OK);exit(0);}
  }
//
 else if(isel==6)
  {
//   try {
/*              // Taken from WeldPass.java
	protected String name="";
	protected int seqNum;
	protected Vector eles;
	protected Vector sttEles;
	protected int stpEle;
	protected int firstEle;
	protected int nextEle;
	protected int[] snorm1, snorm2;
	protected Color color;
	protected boolean showFlag;
	protected String matName="";
	protected float curr;
	protected float volt;
	protected float eff;
	protected float speed;
	protected float troom;
	protected float tmelt;
	protected float tcutl;
	protected float tcuth;
	protected int source=11;
	protected int type;
	protected int shape;
	protected float timeInterval;
	protected int stepInterval;
	protected float maxiHeatStep;
	protected float miniHeatStep;
	protected float thk1, thk2;
	protected double lstart,lend;
	protected boolean circFlag=false;
	protected int[] circEles;
	protected boolean edgeFlag=false;
	protected Vector edgeEles;
	protected Vector edgeNodes;

	protected Hashtable secHt;
	protected Vector sttEleNodes;
//  Lump Pass Version
	protected int hp=0;
//    protected float thaz=70;
//    protected float halfw;
//    protected float halfs;
	protected boolean merge=false;
	protected int nsegs=1;
//
// Girth Weld Added
	protected boolean girthFlag=false;
// Edit Purposes added selected group for weld pass
	protected int iselect=0;
*/
/* // Start temporary disconnect of VFTmisc code
		wp.seqNum=new int[MAX_WELDPASSES];
		wp.boolFlags=new int[MAX_WELDPASSES];
		wp.type=new int[MAX_WELDPASSES];
		wp.shape=new int[MAX_WELDPASSES];
		wp.stepInterval=new int[MAX_WELDPASSES];
		wp.hp=new int[MAX_WELDPASSES];
		wp.nsegs=new int[MAX_WELDPASSES];
		wp.iselect=new int[MAX_WELDPASSES];
		wp.eles=new long[MAX_WELDPASSES*bnelt];  // Elements in this weld pass
//		wp.sttEles=new long[MAX_WELDPASSES*bnelt*4];  // No need for *4 ????
		wp.sttEles=new long[MAX_WELDPASSES*bnelt];  // No need for *4 ????
//		wp.stpEle=new long[MAX_WELDPASSES*bnelt];  // No need for *bnelt
		wp.stpEle=new long[MAX_WELDPASSES];  // No need for *bnelt
		wp.firstEle=new long[MAX_WELDPASSES*bnelt];
		wp.nextEle=new long[MAX_WELDPASSES*bnelt];
		wp.snorm1=new long[MAX_WELDPASSES*4];
		wp.snorm2=new long[MAX_WELDPASSES*4];
		wp.circEles=new long[MAX_WELDPASSES*3];
		wp.edgeEles=new long[MAX_WELDPASSES*bnelt];
		wp.edgeNodes=new long[MAX_WELDPASSES*4]; // correct???
		wp.sttEleNodes=new long[MAX_WELDPASSES*bnelt*4];
		wp.curr=new float[MAX_WELDPASSES];
		wp.volt=new float[MAX_WELDPASSES];
		wp.eff=new float[MAX_WELDPASSES];
		wp.speed=new float[MAX_WELDPASSES];
		wp.troom=new float[MAX_WELDPASSES];
		wp.tmelt=new float[MAX_WELDPASSES];
		wp.tcutl=new float[MAX_WELDPASSES];
		wp.tcuth=new float[MAX_WELDPASSES];
		wp.timeInterval=new float[MAX_WELDPASSES];
		wp.maxiHeatStep=new float[MAX_WELDPASSES];
		wp.miniHeatStep=new float[MAX_WELDPASSES];
		wp.thk1=new float[MAX_WELDPASSES];
		wp.thk2=new float[MAX_WELDPASSES];
		wp.lstart=new double[MAX_WELDPASSES];
		wp.lend=new double[MAX_WELDPASSES];
		wp.hlightel=new long[MAX_WELDPASSES*bnelt]; //Convention: 1st col= elem side#
		wp.arrows=new double[3*NDF*MAX_WELDPASSES]; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		wp.n_curr_sttEl=new long[MAX_WELDPASSES];
		wp.wpTimes=new long[MAX_WELDPASSES];
		wp.source=new float[MAX_WELDPASSES];
			// End temporary disconnect of VFTmisc code
*/
//	  wp.edgeFlag=new int[MAX_WELDPASSES];
//        wp.circFlag=new int[MAX_WELDPASSES];
//        wp.merge==new int[MAX_WELDPASSES];

//	   }
//   catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory",L"Exit",MB_OK);exit(0);}

//**************** Start from VFTgen
   if(wp.nWeldPass){
		SWTname=new String[wp.nWeldPass+1];
		SWTmatName=new String[wp.nWeldPass+1];
		SWTseqNum=new int[wp.nWeldPass+1];
		SWTboolFlags=new int[wp.nWeldPass+1];
		SWTtype=new int[wp.nWeldPass+1];
		SWTshape=new int[wp.nWeldPass+1];
		SWTstepInterval=new int[wp.nWeldPass+1];
		SWThp=new int[wp.nWeldPass+1];
		SWTnsegs=new int[wp.nWeldPass+1];
		SWTiselect=new int[wp.nWeldPass+1];
		SWTeles=new long[(wp.nWeldPass+1)*bnelt];  // Elements in this weld pass
//		SWTsttEles=new long[wp.nWeldPass*bnelt*4];  // No need for *4 ????
		SWTsttEles=new long[(wp.nWeldPass+1)*bnelt];  // No need for *4 ????
//		SWTstpEle=new long[wp.nWeldPass*bnelt];  // No need for *bnelt
		SWTstpEle=new long[wp.nWeldPass+1];  // No need for *bnelt
		SWTfirstEle=new long[(wp.nWeldPass+1)*bnelt];
		SWTnextEle=new long[(wp.nWeldPass+1)*bnelt];
		SWTsnorm1=new long[(wp.nWeldPass+1)*4]; //These are actually NODE NUMBERS
		SWTsnorm2=new long[(wp.nWeldPass+1)*4]; //These are actually NODE NUMBERS
		SWTcircEles=new long[(wp.nWeldPass+1)*3]; //These are actually NODE NUMBERS
		SWTedgeEles=new long[(wp.nWeldPass+1)*bnelt];
		SWTedgeNodes=new long[(wp.nWeldPass+1)*4]; // correct???
		SWTsttEleNodes=new long[(wp.nWeldPass+1)*bnelt*4];
		SWTcurr=new float[wp.nWeldPass+1];
		SWTvolt=new float[wp.nWeldPass+1];
		SWTeff=new float[wp.nWeldPass+1];
		SWTspeed=new float[wp.nWeldPass+1];
		SWTtroom=new float[wp.nWeldPass+1];
		SWTtmelt=new float[wp.nWeldPass+1];
		SWTtcutl=new float[wp.nWeldPass+1];
		SWTtcuth=new float[wp.nWeldPass+1];
		SWTtimeInterval=new float[wp.nWeldPass+1];
		SWTmaxiHeatStep=new float[wp.nWeldPass+1];
		SWTminiHeatStep=new float[wp.nWeldPass+1];
		SWTthk1=new float[wp.nWeldPass+1];
		SWTthk2=new float[wp.nWeldPass+1];
		SWTlstart=new double[wp.nWeldPass+1];
		SWTlend=new double[wp.nWeldPass+1];
		SWThlightel=new long[(wp.nWeldPass+1)*bnelt]; //Convention: 1st col= elem side#
		SWTarrows=new double[3*NDF*(wp.nWeldPass+1)]; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		SWTn_curr_sttEl=new long[wp.nWeldPass+1];
		SWTreset=new long[wp.nWeldPass+1];
//		SWTwpTimes=new long[wp.nWeldPass];
		SWTwpTimes=new float[wp.nWeldPass+1];
		SWTsource=new int[wp.nWeldPass+1];
		SWTmcr=new int[wp.nWeldPass+1]; // Not part of original VFT
		SWTWeldColor=new TColor[wp.nWeldPass+1];
		SWTprevGID=new long[wp.nWeldPass+1];
		SWTutil_arr=new int[wp.nWeldPass+1];

		for(in=0;in<wp.nWeldPass;in++) *(SWTname+in)= *(wp.name+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTmatName+in)= *(wp.matName+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTseqNum+in)= *(wp.seqNum+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTboolFlags+in)= *(wp.boolFlags+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTtype+in)= *(wp.type+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTshape+in)= *(wp.shape+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTstepInterval+in)= *(wp.stepInterval+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWThp+in)= *(wp.hp+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTnsegs+in)= *(wp.nsegs+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTiselect+in)= *(wp.iselect+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(SWTeles+in)= *(wp.eles+in);  // Elements in this weld pass
//		SWTsttEles=new long[wp.nWeldPass*bnelt*4];  // No need for *4 ????
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(SWTsttEles+in)= *(wp.sttEles+in);  // No need for *4 ????
//		SWTstpEle=new long[wp.nWeldPass*bnelt];  // No need for *bnelt
		for(in=0;in<wp.nWeldPass;in++) *(SWTstpEle+in)= *(wp.stpEle+in);  // No need for *bnelt
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(SWTfirstEle+in)= *(wp.firstEle+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(SWTnextEle+in)= *(wp.nextEle+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(SWTsnorm1+in)= *(wp.snorm1+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(SWTsnorm2+in)= *(wp.snorm2+in);
		for(in=0;in<wp.nWeldPass*3;in++) *(SWTcircEles+in)= *(wp.circEles+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(SWTedgeEles+in)= *(wp.edgeEles+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(SWTedgeNodes+in)= *(wp.edgeNodes+in); // correct???
		for(in=0;in<wp.nWeldPass*bnelt*4;in++) *(SWTsttEleNodes+in)= *(wp.sttEleNodes+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTcurr+in)= *(wp.curr+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTvolt+in)= *(wp.volt+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTeff+in)= *(wp.eff+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTspeed+in)= *(wp.speed+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTtroom+in)= *(wp.troom+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTtmelt+in)= *(wp.tmelt+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTtcutl+in)= *(wp.tcutl+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTtcuth+in)= *(wp.tcuth+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTtimeInterval+in)= *(wp.timeInterval+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTmaxiHeatStep+in)= *(wp.maxiHeatStep+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTminiHeatStep+in)= *(wp.miniHeatStep+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTthk1+in)= *(wp.thk1+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTthk2+in)= *(wp.thk2+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTlstart+in)= *(wp.lstart+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTlend+in)= *(wp.lend+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(SWThlightel+in)= *(wp.hlightel+in); //Convention: 1st col= elem side#
		for(in=0;in<wp.nWeldPass*3*NDF;in++) *(SWTarrows+in)= *(wp.arrows+in); //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		for(in=0;in<wp.nWeldPass;in++) *(SWTn_curr_sttEl+in)= *(wp.n_curr_sttEl+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTreset+in)= *(wp.reset+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTwpTimes+in)= *(wp.wpTimes+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTsource+in)= *(wp.source+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTmcr+in)= *(wp.mcr+in); // Not part of original VFT
		for(in=0;in<wp.nWeldPass;in++) *(SWTWeldColor+in)= *(wp.WeldColor+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTprevGID+in)= *(wp.prevGID+in);
		for(in=0;in<wp.nWeldPass;in++) *(SWTutil_arr+in)= *(wp.util_arr+in);

//		FDdynmem_manageD(-6,dum,bnelt,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
		FDdynmem_manage(-6,dum,bnelt,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
//
		wp.name=new String[wp.nWeldPass+1+MXNP];
		wp.matName=new String[wp.nWeldPass+1+MXNP];
		wp.seqNum=new int[wp.nWeldPass+1+MXNP];
		wp.boolFlags=new int[wp.nWeldPass+1+MXNP];
		wp.type=new int[wp.nWeldPass+1+MXNP];
		wp.shape=new int[wp.nWeldPass+1+MXNP];
		wp.stepInterval=new int[wp.nWeldPass+1+MXNP];
		wp.hp=new int[wp.nWeldPass+1+MXNP];
		wp.nsegs=new int[wp.nWeldPass+1+MXNP];
		wp.iselect=new int[wp.nWeldPass+1+MXNP];
		wp.eles=new long[(wp.nWeldPass+1+MXNP)*bnelt];  // Elements in this weld pass
//		wp.sttEles=new long[wp.nWeldPass+2*bnelt*4];  // No need for *4 ????
		wp.sttEles=new long[(wp.nWeldPass+1+MXNP)*bnelt];  // No need for *4 ????
//		wp.stpEle=new long[wp.nWeldPass+2*bnelt];  // No need for *bnelt
		wp.stpEle=new long[wp.nWeldPass+1+MXNP];  // No need for *bnelt
		wp.firstEle=new long[(wp.nWeldPass+1+MXNP)*bnelt];
		wp.nextEle=new long[(wp.nWeldPass+1+MXNP)*bnelt];
		wp.snorm1=new long[(wp.nWeldPass+1+MXNP)*4]; //These are actually NODE NUMBERS
		wp.snorm2=new long[(wp.nWeldPass+1+MXNP)*4]; //These are actually NODE NUMBERS
		wp.circEles=new long[(wp.nWeldPass+1+MXNP)*3]; //These are actually NODE NUMBERS
		wp.edgeEles=new long[(wp.nWeldPass+1+MXNP)*bnelt];
		wp.edgeNodes=new long[(wp.nWeldPass+1+MXNP)*4]; // correct???
		wp.sttEleNodes=new long[(wp.nWeldPass+1+MXNP)*bnelt*4];
		wp.curr=new float[wp.nWeldPass+1+MXNP];
		wp.volt=new float[wp.nWeldPass+1+MXNP];
		wp.eff=new float[wp.nWeldPass+1+MXNP];
		wp.speed=new float[wp.nWeldPass+1+MXNP];
		wp.troom=new float[wp.nWeldPass+1+MXNP];
		wp.tmelt=new float[wp.nWeldPass+1+MXNP];
		wp.tcutl=new float[wp.nWeldPass+1+MXNP];
		wp.tcuth=new float[wp.nWeldPass+1+MXNP];
		wp.timeInterval=new float[wp.nWeldPass+1+MXNP];
		wp.maxiHeatStep=new float[wp.nWeldPass+1+MXNP];
		wp.miniHeatStep=new float[wp.nWeldPass+1+MXNP];
		wp.thk1=new float[wp.nWeldPass+1+MXNP];
		wp.thk2=new float[wp.nWeldPass+1+MXNP];
		wp.lstart=new double[wp.nWeldPass+1+MXNP];
		wp.lend=new double[wp.nWeldPass+1+MXNP]; //Unused so use it for weld-set time  EFP 5/19/2012
		wp.hlightel=new long[(wp.nWeldPass+1+MXNP)*bnelt]; //Convention: 1st col= elem side#
		wp.arrows=new double[3*NDF*(wp.nWeldPass+1+MXNP)]; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		wp.n_curr_sttEl=new long[wp.nWeldPass+1+MXNP];
		wp.reset=new long[wp.nWeldPass+1+MXNP];
//		wp.wpTimes=new long[wp.nWeldPass+2];
		wp.wpTimes=new float[wp.nWeldPass+1+MXNP];
		wp.source=new int[wp.nWeldPass+1+MXNP];
		wp.mcr=new int[wp.nWeldPass+1+MXNP]; // Not part of original VFT
		wp.WeldColor=new TColor[wp.nWeldPass+1+MXNP];
		wp.prevGID=new long[wp.nWeldPass+1+MXNP];
//		wp.util_arr=new int[wp.nWeldPass+2];
		wp.util_arr=new long[wp.nWeldPass+1+MXNP];

		for(in=0;in<wp.nWeldPass;in++) *(wp.name+in)= *(SWTname+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.matName+in)= *(SWTmatName+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.seqNum+in)= *(SWTseqNum+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.boolFlags+in)= *(SWTboolFlags+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.type+in)= *(SWTtype+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.shape+in)= *(SWTshape+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.stepInterval+in)= *(SWTstepInterval+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.hp+in)= *(SWThp+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.nsegs+in)= *(SWTnsegs+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.iselect+in)= *(SWTiselect+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.eles+in)= *(SWTeles+in);  // Elements in this weld pass
//		wp.sttEles=new long[wp.nWeldPass*bnelt*4];  // No need for *4 ????
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.sttEles+in)= *(SWTsttEles+in);  // No need for *4 ????
//		wp.stpEle=new long[wp.nWeldPass*bnelt];  // No need for *bnelt
		for(in=0;in<wp.nWeldPass;in++) *(wp.stpEle+in)= *(SWTstpEle+in);  // No need for *bnelt
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.firstEle+in)= *(SWTfirstEle+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.nextEle+in)= *(SWTnextEle+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(wp.snorm1+in)= *(SWTsnorm1+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(wp.snorm2+in)= *(SWTsnorm2+in);
		for(in=0;in<wp.nWeldPass*3;in++) *(wp.circEles+in)= *(SWTcircEles+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.edgeEles+in)= *(SWTedgeEles+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(wp.edgeNodes+in)= *(SWTedgeNodes+in); // correct???
		for(in=0;in<wp.nWeldPass*bnelt*4;in++) *(wp.sttEleNodes+in)= *(SWTsttEleNodes+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.curr+in)= *(SWTcurr+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.volt+in)= *(SWTvolt+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.eff+in)= *(SWTeff+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.speed+in)= *(SWTspeed+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.troom+in)= *(SWTtroom+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.tmelt+in)= *(SWTtmelt+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.tcutl+in)= *(SWTtcutl+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.tcuth+in)= *(SWTtcuth+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.timeInterval+in)= *(SWTtimeInterval+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.maxiHeatStep+in)= *(SWTmaxiHeatStep+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.miniHeatStep+in)= *(SWTminiHeatStep+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.thk1+in)= *(SWTthk1+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.thk2+in)= *(SWTthk2+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.lstart+in)= *(SWTlstart+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.lend+in)= *(SWTlend+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.hlightel+in)= *(SWThlightel+in); //Convention: 1st col= elem side#
		for(in=0;in<wp.nWeldPass*3*NDF;in++) *(wp.arrows+in)= *(SWTarrows+in); //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		for(in=0;in<wp.nWeldPass;in++) *(wp.n_curr_sttEl+in)= *(SWTn_curr_sttEl+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.reset+in)= *(SWTreset+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.wpTimes+in)= *(SWTwpTimes+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.source+in)= *(SWTsource+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.mcr+in)= *(SWTmcr+in); // Not part of original VFT
		for(in=0;in<wp.nWeldPass;in++) *(wp.WeldColor+in)= *(SWTWeldColor+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.prevGID+in)= *(SWTprevGID+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.util_arr+in)= *(SWTutil_arr+in);

					delete [] SWTname;SWTname=NULL;
					delete [] SWTmatName;SWTmatName=NULL;
					delete [] SWTseqNum;SWTseqNum=NULL;
					delete [] SWTboolFlags;SWTboolFlags=NULL;
					delete [] SWTtype;SWTtype=NULL;
					delete [] SWTshape;SWTshape=NULL;
					delete [] SWTstepInterval;SWTstepInterval=NULL;
					delete [] SWThp;SWThp=NULL;
					delete [] SWTnsegs;SWTnsegs=NULL;
					delete [] SWTiselect;SWTiselect=NULL;
					delete [] SWTeles;SWTeles=NULL;
					delete [] SWTsttEles;SWTsttEles=NULL;
					delete [] SWTstpEle;SWTstpEle=NULL;
					delete [] SWTfirstEle;SWTfirstEle=NULL;
					delete [] SWTnextEle;SWTnextEle=NULL;
					delete [] SWTsnorm1;SWTsnorm1=NULL;
					delete [] SWTsnorm2;SWTsnorm2=NULL;
					delete [] SWTcircEles;SWTcircEles=NULL;
					delete [] SWTedgeEles;SWTedgeEles=NULL;
					delete [] SWTedgeNodes;SWTedgeNodes=NULL;
					delete [] SWTsttEleNodes;SWTsttEleNodes=NULL;
					delete [] SWTcurr;SWTcurr=NULL;
					delete [] SWTvolt;SWTvolt=NULL;
					delete [] SWTeff;SWTeff=NULL;
					delete [] SWTspeed;SWTspeed=NULL;
					delete [] SWTtroom;SWTtroom=NULL;
					delete [] SWTtmelt;SWTtmelt=NULL;
					delete [] SWTtcutl;SWTtcutl=NULL;
					delete [] SWTtcuth;SWTtcuth=NULL;
					delete [] SWTtimeInterval;SWTtimeInterval=NULL;
					delete [] SWTmaxiHeatStep;SWTmaxiHeatStep=NULL;
					delete [] SWTminiHeatStep;SWTminiHeatStep=NULL;
					delete [] SWTthk1;SWTthk1=NULL;
					delete [] SWTthk2;SWTthk2=NULL;
					delete [] SWTlstart;SWTlstart=NULL;
					delete [] SWTlend;SWTlend=NULL;
					delete [] SWThlightel;SWThlightel=NULL;
					delete [] SWTarrows;SWTarrows=NULL;
					delete [] SWTn_curr_sttEl;SWTn_curr_sttEl=NULL;
					delete [] SWTreset;SWTreset=NULL;
					delete [] SWTwpTimes;SWTwpTimes=NULL;
					delete [] SWTsource;SWTsource=NULL;
					delete [] SWTmcr;SWTmcr=NULL;// Not part of original VFT
					delete [] SWTWeldColor;SWTWeldColor=NULL;
					delete [] SWTprevGID;SWTprevGID=NULL;
					delete [] SWTutil_arr;SWTutil_arr=NULL;

//			   for(in=(wp.nWeldPass-1)*bnelt;in<wp.nWeldPass*bnelt;in++)wp.eles[in]= -1;
//			   for(in=(wp.nWeldPass-1)*bnelt;in<wp.nWeldPass*bnelt;in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=wp.nWeldPass*bnelt;in<(wp.nWeldPass+1+MXNP)*bnelt;in++)wp.eles[in]= -1;
			   for(in=wp.nWeldPass*bnelt;in<(wp.nWeldPass+1+MXNP)*bnelt;in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=wp.nWeldPass*bnelt;in<(wp.nWeldPass+1+MXNP)*bnelt;in++)wp.firstEle[in]= -1;// No need for *4 ????
			   for(in=wp.nWeldPass*bnelt;in<(wp.nWeldPass+1+MXNP)*bnelt;in++)wp.nextEle[in]= -1;// No need for *4 ????
			   for(in=wp.nWeldPass*bnelt;in<(wp.nWeldPass+1+MXNP)*bnelt;in++)wp.edgeEles[in]= -1;// No need for *4 ????
			   for(in=wp.nWeldPass*bnelt*4;in<(wp.nWeldPass+1+MXNP)*bnelt*4;in++)wp.sttEleNodes[in]= -1;// No need for *4 ????
			   for(in=wp.nWeldPass;in<wp.nWeldPass+1+MXNP;in++)wp.stpEle[in]= -1;  // No need for *bnelt
//			   for(in=(wp.nWeldPass-1)*4;in<wp.nWeldPass*4;in++)wp.snorm1[in]= -1;
//			   for(in=(wp.nWeldPass-1)*4;in<wp.nWeldPass*4;in++)wp.snorm2[in]= -1;
			   for(in=wp.nWeldPass*4;in<(wp.nWeldPass+1+MXNP)*4;in++)wp.snorm1[in]= -1;
			   for(in=wp.nWeldPass*4;in<(wp.nWeldPass+1+MXNP)*4;in++)wp.snorm2[in]= -1;
			   for(in=wp.nWeldPass*bnelt;in<(wp.nWeldPass+1+MXNP)*bnelt;in++)wp.hlightel[in]= -1;// No need for *4 ????

////        wp.firstEle=new long[MAX_WELDPASSES*bnet],
////        wp.nextEle=new long[MAX_WELDPASSES],
////        wp.snorm1=new long[MAX_WELDPASSES*4],
////        wp.snorm2=new long[MAX_WELDPASSES*4],
////        wp.circEles=new long[MAX_WELDPASSES*3],
////        wp.edgeEles=new long[MAX_WELDPASSES*bnelt],
////        wp.edgeNodes=new long[MAX_WELDPASSES*4],
////        wp.sttEleNodes=new long[MAX_WELDPASSES*bnelt*4],
			   for(in=wp.nWeldPass;in<wp.nWeldPass+1+MXNP;in++)wp.source[in]=11; //#heat reflections, which must be odd
// Ref. "Input Instructions and User's Guide for CTSP-Shell," Zhenning Cao, Battelle, Feb. 2005
			   for(in=wp.nWeldPass;in<wp.nWeldPass+1+MXNP;in++)wp.hp[in]=0;//Lump Pass (1) or Moving Arc (0) Heating Procedure
			   for(in=wp.nWeldPass;in<wp.nWeldPass+1+MXNP;in++)wp.nsegs[in]=1;
			   for(in=wp.nWeldPass;in<wp.nWeldPass+1+MXNP;in++)wp.iselect[in]=0;

				   }
   else {
		wp.name=new String[1+MXNP];
		wp.matName=new String[1+MXNP];
		wp.seqNum=new int[1+MXNP];
		wp.boolFlags=new int[1+MXNP];
		wp.type=new int[1+MXNP];
		wp.shape=new int[1+MXNP];
		wp.stepInterval=new int[1+MXNP];
		wp.hp=new int[1+MXNP];
		wp.nsegs=new int[1+MXNP];
		wp.iselect=new int[1+MXNP];
		wp.eles=new long[(1+MXNP)*bnelt];  // Elements in this weld pass
//		wp.sttEles=new long[bnelt*4];  // No need for *4 ????
		wp.sttEles=new long[(1+MXNP)*bnelt];  // No need for *4 ????
//		wp.stpEle=new long[bnelt];  // No need for *bnelt
		wp.stpEle=new long[1+MXNP];  // No need for *bnelt
		wp.firstEle=new long[(1+MXNP)*bnelt];
		wp.nextEle=new long[(1+MXNP)*bnelt];
		wp.snorm1=new long[(1+MXNP)*4];
		wp.snorm2=new long[(1+MXNP)*4];
		wp.circEles=new long[(1+MXNP)*3];
		wp.edgeEles=new long[(1+MXNP)*bnelt];
		wp.edgeNodes=new long[(1+MXNP)*4]; // correct???
		wp.sttEleNodes=new long[(1+MXNP)*bnelt*4];
		wp.curr=new float[1+MXNP];
		wp.volt=new float[1+MXNP];
		wp.eff=new float[1+MXNP];
		wp.speed=new float[1+MXNP];
		wp.troom=new float[1+MXNP];
		wp.tmelt=new float[1+MXNP];
		wp.tcutl=new float[1+MXNP];
		wp.tcuth=new float[1+MXNP];
		wp.timeInterval=new float[1+MXNP];
		wp.maxiHeatStep=new float[1+MXNP];
		wp.miniHeatStep=new float[1+MXNP];
		wp.thk1=new float[1+MXNP];
		wp.thk2=new float[1+MXNP];
		wp.lstart=new double[1+MXNP];
		wp.lend=new double[1+MXNP];
		wp.hlightel=new long[(1+MXNP)*bnelt]; //Convention: 1st col= elem side#
		wp.arrows=new double[(1+MXNP)*NDF*3]; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		wp.n_curr_sttEl=new long[1+MXNP];
		wp.reset=new long[1+MXNP];
//		wp.wpTimes=new long[2];
		wp.wpTimes=new float[1+MXNP];
		wp.source=new int[1+MXNP];
		wp.mcr=new int[1+MXNP]; // Not part of original VFT
		wp.WeldColor=new TColor[1+MXNP];
		wp.prevGID=new long[1+MXNP];
//		wp.util_arr=new int[2];
		wp.util_arr=new long[1+MXNP];

			   for(in=0;in<bnelt*(1+MXNP);in++)wp.eles[in]= -1;
			   for(in=0;in<bnelt*(1+MXNP);in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=0;in<bnelt*(1+MXNP);in++)wp.firstEle[in]= -1;// No need for *4 ????
			   for(in=0;in<bnelt*(1+MXNP);in++)wp.nextEle[in]= -1;// No need for *4 ????
			   for(in=0;in<bnelt*(1+MXNP);in++)wp.edgeEles[in]= -1;// No need for *4 ????
			   for(in=0;in<bnelt*4*(1+MXNP);in++)wp.sttEleNodes[in]= -1;// No need for *4 ????
			   for(in=0;in<1+MXNP;in++)wp.stpEle[in]= -1;  // No need for *bnelt
			   for(in=0;in<4*(1+MXNP);in++)wp.snorm1[in]= -1;
			   for(in=0;in<4*(1+MXNP);in++)wp.snorm2[in]= -1;
////        wp.firstEle=new long[bnet],
////        wp.nextEle=new long[1],
////        wp.snorm1=new long[4],
////        wp.snorm2=new long[4],
////        wp.circEles=new long[3],
////        wp.edgeEles=new long[bnelt],
////        wp.edgeNodes=new long[4],
////        wp.sttEleNodes=new long[bnelt*4],
			   for(in=0;in<1+MXNP;in++)wp.source[in]=11;
			   for(in=0;in<1+MXNP;in++)wp.hp[in]=0;//Lump Pass (1) or Moving Arc (0) Heating Procedure
			   for(in=0;in<1+MXNP;in++)wp.nsegs[in]=1;
			   for(in=0;in<1+MXNP;in++)wp.iselect[in]=0;
			   for(in=0;in<bnelt*(1+MXNP);in++)wp.hlightel[in]= -1;// No need for *4 ????
		}
//**************** End from VFTgen

  }
//**************** Start from VFTgen
 else if(isel==9)
  {
		wp.name=new String[wp.nWeldPass+1];
		wp.matName=new String[wp.nWeldPass+1];
		wp.seqNum=new int[wp.nWeldPass+1];
		wp.boolFlags=new int[wp.nWeldPass+1];
		wp.type=new int[wp.nWeldPass+1];
		wp.shape=new int[wp.nWeldPass+1];
		wp.stepInterval=new int[wp.nWeldPass+1];
		wp.hp=new int[wp.nWeldPass+1];
		wp.nsegs=new int[wp.nWeldPass+1];
		wp.iselect=new int[wp.nWeldPass+1];
		wp.eles=new long[(wp.nWeldPass+1)*bnelt];  // Elements in this weld pass
//		sttEles=new long[wp.nWeldPass*bnelt*4];  // No need for *4 ????
		wp.sttEles=new long[(wp.nWeldPass+1)*bnelt];  // No need for *4 ????
//		stpEle=new long[wp.nWeldPass*bnelt];  // No need for *bnelt
		wp.stpEle=new long[wp.nWeldPass+1];  // No need for *bnelt
		wp.firstEle=new long[(wp.nWeldPass+1)*bnelt];
		wp.nextEle=new long[(wp.nWeldPass+1)*bnelt];
		wp.snorm1=new long[(wp.nWeldPass+1)*4];
		wp.snorm2=new long[(wp.nWeldPass+1)*4];
		wp.circEles=new long[(wp.nWeldPass+1)*3];
		wp.edgeEles=new long[(wp.nWeldPass+1)*bnelt];
		wp.edgeNodes=new long[(wp.nWeldPass+1)*4]; // correct???
		wp.sttEleNodes=new long[(wp.nWeldPass+1)*bnelt*4];
		wp.curr=new float[wp.nWeldPass+1];
		wp.volt=new float[wp.nWeldPass+1];
		wp.eff=new float[wp.nWeldPass+1];
		wp.speed=new float[wp.nWeldPass+1];
		wp.troom=new float[wp.nWeldPass+1];
		wp.tmelt=new float[wp.nWeldPass+1];
		wp.tcutl=new float[wp.nWeldPass+1];
		wp.tcuth=new float[wp.nWeldPass+1];
		wp.timeInterval=new float[wp.nWeldPass+1];
		wp.maxiHeatStep=new float[wp.nWeldPass+1];
		wp.miniHeatStep=new float[wp.nWeldPass+1];
		wp.thk1=new float[wp.nWeldPass+1];
		wp.thk2=new float[wp.nWeldPass+1];
		wp.lstart=new double[wp.nWeldPass+1];
		wp.lend=new double[wp.nWeldPass+1];
		wp.hlightel=new long[(wp.nWeldPass+1)*bnelt]; //Convention: 1st col= elem side#
		wp.arrows=new double[3*NDF*(wp.nWeldPass+1)]; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		wp.n_curr_sttEl=new long[wp.nWeldPass+1];
		wp.reset=new long[wp.nWeldPass+1];
//		wp.wpTimes=new long[wp.nWeldPass+1];
		wp.wpTimes=new float[wp.nWeldPass+1];
		wp.source=new int[wp.nWeldPass+1];
		wp.mcr=new int[wp.nWeldPass+1]; // Not part of original VFT
		wp.WeldColor=new TColor[wp.nWeldPass+1];
		wp.prevGID=new long[wp.nWeldPass+1];
//		wp.util_arr=new int[wp.nWeldPass+1];
		wp.util_arr=new long[wp.nWeldPass+1];

//			   for(in=(wp.nWeldPass-1)*bnelt;in<wp.nWeldPass*bnelt;in++)wp.eles[in]= -1;
//			   for(in=(wp.nWeldPass-1)*bnelt;in<wp.nWeldPass*bnelt;in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=0;in<wp.nWeldPass*bnelt;in++)wp.eles[in]= -1;
			   for(in=0;in<wp.nWeldPass*bnelt;in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=0;in<wp.nWeldPass*bnelt;in++)wp.firstEle[in]= -1;// No need for *4 ????
			   for(in=0;in<wp.nWeldPass*bnelt;in++)wp.nextEle[in]= -1;// No need for *4 ????
			   for(in=0;in<wp.nWeldPass*bnelt;in++)wp.edgeEles[in]= -1;// No need for *4 ????
			   for(in=0;in<wp.nWeldPass*bnelt*4;in++)wp.sttEleNodes[in]= -1;// No need for *4 ????
			   for(in=0;in<wp.nWeldPass;in++)wp.stpEle[in]= -1;  // No need for *bnelt
//			   for(in=(wp.nWeldPass-1)*4;in<wp.nWeldPass*4;in++)wp.snorm1[in]= -1;
//			   for(in=(wp.nWeldPass-1)*4;in<wp.nWeldPass*4;in++)wp.snorm2[in]= -1;
			   for(in=0;in<wp.nWeldPass*4;in++)wp.snorm1[in]= -1;
			   for(in=0;in<wp.nWeldPass*4;in++)wp.snorm2[in]= -1;

////        wp.firstEle=new long[MAX_WELDPASSES*bnet],
////        wp.nextEle=new long[MAX_WELDPASSES],
////        wp.snorm1=new long[MAX_WELDPASSES*4],
////        wp.snorm2=new long[MAX_WELDPASSES*4],
////        wp.circEles=new long[MAX_WELDPASSES*3],
////        wp.edgeEles=new long[MAX_WELDPASSES*bnelt],
////        wp.edgeNodes=new long[MAX_WELDPASSES*4],
////        wp.sttEleNodes=new long[MAX_WELDPASSES*bnelt*4],
			   for(in=0;in<wp.nWeldPass;in++)wp.source[in]=11;
			   for(in=0;in<wp.nWeldPass;in++)wp.hp[in]=0;//Lump Pass (1) or Moving Arc (0) Heating Procedure
			   for(in=0;in<wp.nWeldPass;in++)wp.nsegs[in]=1;
			   for(in=0;in<wp.nWeldPass;in++)wp.iselect[in]=0;
			   for(in=0;in<wp.nWeldPass;in++)wp.prevGID[in]=0;
			   for(in=0;in<wp.nWeldPass;in++)wp.util_arr[in]=0;
			   for(in=0;in<wp.nWeldPass*bnelt;in++)wp.hlightel[in]= -1;// No need for *4 ????
  }
 else if(isel==7)
  {
/*
//		wms.name=new char[MAX_MATPROPSET*64];
//		wms.matFileName=new char[MAX_MATPROPSET*64];
//		wms.Steps=new char[MAX_MATPROPSET*64];
		wms.name=new String[MAX_MATPROPSET];
		wms.matFileName=new String[MAX_MATPROPSET];
		wms.Steps=new String[MAX_MATPROPSET];
		wms.cond=new float[MAX_MATPROPSET];
		wms.heat=new float[MAX_MATPROPSET];
		wms.den=new float[MAX_MATPROPSET];
		wms.Ti=new float[MAX_MATPROPSET];
		wms.Ta=new float[MAX_MATPROPSET];
		wms.Tm=new float[MAX_MATPROPSET];
		wms.mcr=new int[MAX_MATPROPSET];
		wms.ved=new int[MAX_MATPROPSET];
		wms.annjd=new int[MAX_MATPROPSET];
		wms.hetjd=new int[MAX_MATPROPSET];
		wms.nprops=new int[MAX_MATPROPSET];
		wms.switc=new bool[MAX_MATPROPSET];
*/
   if(wms.nMatPropSet){
//		SWMTname=new char[wms.nMatPropSet*64];
//		SWMTmatFileName=new char[wms.nMatPropSet*64];
//		SWMTSteps=new char[wms.nMatPropSet*64];
		SWMTname=new String[wms.nMatPropSet];
		SWMTmatFileName=new String[wms.nMatPropSet];
		SWMTSteps=new String[wms.nMatPropSet];
		SWMTcond=new float[wms.nMatPropSet];
		SWMTheat=new float[wms.nMatPropSet];
		SWMTden=new float[wms.nMatPropSet];
		SWMTTi=new float[wms.nMatPropSet];
		SWMTTa=new float[wms.nMatPropSet];
		SWMTTm=new float[wms.nMatPropSet];
		SWMTmcr=new int[wms.nMatPropSet];
		SWMTved=new int[wms.nMatPropSet];
		SWMTannjd=new int[wms.nMatPropSet];
		SWMThetjd=new int[wms.nMatPropSet];
		SWMTnprops=new int[wms.nMatPropSet];
		SWMTswitc=new bool[wms.nMatPropSet];

//		SWMTname=new char[wms.nMatPropSet*64];
//		SWMTmatFileName=new char[wms.nMatPropSet*64];
//		SWMTSteps=new char[wms.nMatPropSet*64];
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTname+in)= *(wms.name+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTmatFileName+in)= *(wms.matFileName+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTSteps+in)= *(wms.Steps+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTcond+in)= *(wms.cond+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTheat+in)= *(wms.heat+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTden+in)= *(wms.den+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTTi+in)= *(wms.Ti+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTTa+in)= *(wms.Ta+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTTm+in)= *(wms.Tm+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTmcr+in)= *(wms.mcr+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTved+in)= *(wms.ved+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTannjd+in)= *(wms.annjd+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMThetjd+in)= *(wms.hetjd+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTnprops+in)= *(wms.nprops+in);
		for(in=0;in<wms.nMatPropSet;in++) *(SWMTswitc+in)= *(wms.switc+in);

//		FDdynmem_manageD(-7,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
		FDdynmem_manage(-7,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);

//		wms.name=new char[MAX_MATPROPSET*64];
//		wms.matFileName=new char[MAX_MATPROPSET*64];
//		wms.Steps=new char[MAX_MATPROPSET*64];
		wms.name=new String[wms.nMatPropSet+1];
		wms.matFileName=new String[wms.nMatPropSet+1];
		wms.Steps=new String[wms.nMatPropSet+1];
		wms.cond=new float[wms.nMatPropSet+1];
		wms.heat=new float[wms.nMatPropSet+1];
		wms.den=new float[wms.nMatPropSet+1];
		wms.Ti=new float[wms.nMatPropSet+1];
		wms.Ta=new float[wms.nMatPropSet+1];
		wms.Tm=new float[wms.nMatPropSet+1];
		wms.mcr=new int[wms.nMatPropSet+1];
		wms.ved=new int[wms.nMatPropSet+1];
		wms.annjd=new int[wms.nMatPropSet+1];
		wms.hetjd=new int[wms.nMatPropSet+1];
		wms.nprops=new int[wms.nMatPropSet+1];
		wms.switc=new bool[wms.nMatPropSet+1];

//		SWMTname=new char[wms.nMatPropSet*64];
//		SWMTmatFileName=new char[wms.nMatPropSet*64];
//		SWMTSteps=new char[wms.nMatPropSet*64];
		for(in=0;in<wms.nMatPropSet;in++) *(wms.name+in)= *(SWMTname+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.matFileName+in)= *(SWMTmatFileName+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.Steps+in)= *(SWMTSteps+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.cond+in)= *(SWMTcond+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.heat+in)= *(SWMTheat+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.den+in)= *(SWMTden+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.Ti+in)= *(SWMTTi+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.Ta+in)= *(SWMTTa+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.Tm+in)= *(SWMTTm+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.mcr+in)= *(SWMTmcr+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.ved+in)= *(SWMTved+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.annjd+in)= *(SWMTannjd+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.hetjd+in)= *(SWMThetjd+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.nprops+in)= *(SWMTnprops+in);
		for(in=0;in<wms.nMatPropSet;in++) *(wms.switc+in)= *(SWMTswitc+in);

		delete [] SWMTname;SWMTname=NULL;
		delete [] SWMTmatFileName;SWMTmatFileName=NULL;
		delete [] SWMTSteps;SWMTSteps=NULL;
		delete [] SWMTcond;SWMTcond=NULL;
		delete [] SWMTheat;SWMTheat=NULL;
		delete [] SWMTden;SWMTden=NULL;
		delete [] SWMTTi;SWMTTi=NULL;
		delete [] SWMTTa;SWMTTa=NULL;
		delete [] SWMTTm;SWMTTm=NULL;
		delete [] SWMTmcr;SWMTmcr=NULL;
		delete [] SWMTved;SWMTved=NULL;
		delete [] SWMTannjd;SWMTannjd=NULL;
		delete [] SWMThetjd;SWMThetjd=NULL;
		delete [] SWMTnprops;SWMTnprops=NULL;
		delete [] SWMTswitc;SWMTswitc=NULL;

					  }
   else {
//		wms.name=new char[MAX_MATPROPSET*64];
//		wms.matFileName=new char[MAX_MATPROPSET*64];
//		wms.Steps=new char[MAX_MATPROPSET*64];
		wms.name=new String[1];
		wms.matFileName=new String[1];
		wms.Steps=new String[1];
		wms.cond=new float[1];
		wms.heat=new float[1];
		wms.den=new float[1];
		wms.Ti=new float[1];
		wms.Ta=new float[1];
		wms.Tm=new float[1];
		wms.mcr=new int[1];
		wms.ved=new int[1];
		wms.annjd=new int[1];
		wms.hetjd=new int[1];
		wms.nprops=new int[1];
		wms.switc=new bool[1];
		}
  }
 else if(isel==10)
  {
		wms.name=new String[wms.nMatPropSet];
		wms.matFileName=new String[wms.nMatPropSet];
		wms.Steps=new String[wms.nMatPropSet];
		wms.cond=new float[wms.nMatPropSet];
		wms.heat=new float[wms.nMatPropSet];
		wms.den=new float[wms.nMatPropSet];
		wms.Ti=new float[wms.nMatPropSet];
		wms.Ta=new float[wms.nMatPropSet];
		wms.Tm=new float[wms.nMatPropSet];
		wms.mcr=new int[wms.nMatPropSet];
		wms.ved=new int[wms.nMatPropSet];
		wms.annjd=new int[wms.nMatPropSet];
		wms.hetjd=new int[wms.nMatPropSet];
		wms.nprops=new int[wms.nMatPropSet];
		wms.switc=new bool[wms.nMatPropSet];
  }
 else if(isel==8)
  {
/*
	   wps.name=new String[MAX_WELDPARSET];
	   wps.curr=new float[MAX_WELDPARSET];
	   wps.volt=new float[MAX_WELDPARSET];
	   wps.eff=new float[MAX_WELDPARSET];
	   wps.speed=new float[MAX_WELDPARSET];
*/
//honk<<isel<<" "<<wps.nWeldParamSet<<" In FDdyn\n";

   if(wps.nWeldParamSet){
	   SWPTname=new String[wps.nWeldParamSet];
	   SWPTcurr=new float[wps.nWeldParamSet];
	   SWPTvolt=new float[wps.nWeldParamSet];
	   SWPTeff=new float[wps.nWeldParamSet];
	   SWPTspeed=new float[wps.nWeldParamSet];

//for(in=0;in<wms.nMatPropSet;in++) *(SWMTname+in)= *(wms.name+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(SWPTname+in)= *(wps.name+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(SWPTcurr+in)= *(wps.curr+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(SWPTvolt+in)= *(wps.volt+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(SWPTeff+in)= *(wps.eff+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(SWPTspeed+in)= *(wps.speed+in);

//	   FDdynmem_manageD(-8,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	   FDdynmem_manage(-8,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);

	   wps.name=new String[wps.nWeldParamSet+1];
	   wps.curr=new float[wps.nWeldParamSet+1];
	   wps.volt=new float[wps.nWeldParamSet+1];
	   wps.eff=new float[wps.nWeldParamSet+1];
	   wps.speed=new float[wps.nWeldParamSet+1];

	   for(in=0;in<wps.nWeldParamSet;in++) *(wps.name+in)= *(SWPTname+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(wps.curr+in)= *(SWPTcurr+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(wps.volt+in)= *(SWPTvolt+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(wps.eff+in)= *(SWPTeff+in);
	   for(in=0;in<wps.nWeldParamSet;in++) *(wps.speed+in)= *(SWPTspeed+in);

	   delete [] SWPTname;SWPTname=NULL;
	   delete [] SWPTcurr;SWPTcurr=NULL;
	   delete [] SWPTvolt;SWPTvolt=NULL;
	   delete [] SWPTeff;SWPTeff=NULL;
	   delete [] SWPTspeed;SWPTspeed=NULL;
						}
   else {
	   wps.name=new String[1];
	   wps.curr=new float[1];
	   wps.volt=new float[1];
	   wps.eff=new float[1];
	   wps.speed=new float[1];
		}
  }
 else if(isel==11)
  {
//honk<<isel<<" "<<wps.nWeldParamSet<<" In FDdyn\n";

	   wps.name=new String[wps.nWeldParamSet];
	   wps.curr=new float[wps.nWeldParamSet];
	   wps.volt=new float[wps.nWeldParamSet];
	   wps.eff=new float[wps.nWeldParamSet];
	   wps.speed=new float[wps.nWeldParamSet];
  }
 else if(isel==12)
  {wpRes.timeVFTarr=new float[infsect];wpRes.timeVEDarr=new float[infsect];
  }
//// else if(isel==13){base.groupsname=new String[wp.nWeldGroup+1];} //EFP 3/15/2011
// else if(isel==13){base.groupsname=new String[128];} //Temporary coding: Up to 128  EFP 1/08/2012
////                                                     Note that this 128 limit is cited in ImportVFTrExecute() EFP 1/23/2012
// else if(isel==13){base.groupsname=new String[base.allGrp];} //EFP 3/15/2011 & 2/08/2012
 else if(isel==13){base.groupsname=new String[wp.nWeldGroup+1];} //Return to pragmatic storage EFP 3/12/2012
// else if(isel==14){base.trackELSET=new long[bnelt+1];//EFP 8/07/2011 & 2/08/2012
//				  } //EFP 8/07/2011 & 2/08/2012
 else if(isel==15){//EFP 8/07/2011 & 2/08/2012
//				   base.arrELSET=new int[MXNP];//Warning: highest number of ELSETs=127
//				   base.orig_arrELSET=new int[MXNP];
				   base.arrELSET=new long[MXNP];//Warning: highest number of ELSETs=unlimited
//				   base.orig_arrELSET=new long[MXNP];
				  } //EFP 8/07/2011 & 2/08/2012
// else if(isel==16){indat.trackELSET=new long[bnelt+1];
//				  }
 else if(isel==17){//EFP 8/25/2013
				   indat.arrELSET=new long[MXNP];//Warning: highest number of ELSETs=unlimited
//				   indat.orig_arrELSET=new long[MXNP];
				  }

//**************** End from VFTgen
//
 else if(isel== -1)
  {if(base.nop1)
	 {delete [] base.nop1;delete [] base.matno;delete [] base.c1;
	  delete [] base.el_map;delete [] base.node_map;delete [] base.nlp;
	  delete [] base.beta;delete [] base.orig_matno; // SuperEl
	  base.nop1=NULL;base.matno=NULL;base.c1=NULL;base.el_map=NULL;base.node_map=NULL;
	  base.nlp=NULL;base.beta=NULL;base.orig_matno=NULL;
// SuperEl
//	delete [] base.lbce;delete [] base.lbcn;
//	base.lbce=NULL;base.lbcn=NULL;
	  if(base.nofix){delete [] base.nofix;base.nofix=NULL;delete [] base.nrfix;base.nrfix=NULL;delete [] base.presc;base.presc=NULL;}
	  if(base.ncoorf){delete [] base.cangl;base.cangl=NULL;}
	  if(base.nldel){delete [] base.nldel;base.nldel=NULL;delete [] base.press;base.press=NULL;}
	  if(base.lodpt){delete [] base.lodpt;base.lodpt=NULL;delete [] base.pointld;base.pointld=NULL;}
	  if(base.ebody){delete [] base.ebody;base.ebody=NULL;delete [] base.body;base.body=NULL;}
	  if(base.matyp){delete [] base.matyp;base.matyp=NULL;delete [] base.prop;base.prop=NULL;}
	 }
  }
 else if(isel== -2)
  {if(indat.nop1)
	 {delete [] indat.nop1;delete [] indat.matno;delete [] indat.c1;delete [] indat.bc1;
	  if(indat.fsect)delete [] indat.fsect;

	  delete [] indat.nlp;delete [] indat.beta; // SuperEl
	  indat.nop1=NULL;indat.matno=NULL;indat.c1=NULL;indat.bc1=NULL;indat.fsect=NULL;indat.nlp=NULL;indat.beta=NULL;
// SuperEl
//   ,nofix[2*MXIMEM],nldel[2*MXIMEM],lbce[2*MXIMEM],lbcn[2*MXIMEM]
	 }
  }
 else if(isel== -3){if(base.res1){delete [] base.res1;base.res1=NULL;}}
 else if(isel== -4){if(indat.res1){delete [] indat.res1;indat.res1=NULL;}
					if(indat.result){delete [] indat.result;indat.result=NULL;}
				   }
 else if(isel== -5){if(bCrackCor){delete [] bCrackCor;bCrackCor=NULL;}if(bCrackAng){delete [] bCrackAng;bCrackAng=NULL;}
					if(CrackCor){delete [] CrackCor;CrackCor=NULL;}if(CrackTyp){delete [] CrackTyp;CrackTyp=NULL;}
				   }
/*
				   // Start temporary disconnect VFTmisc coding
 else if(isel== -6){delete [] wp.seqNum;wp.seqNum=NULL;
					delete [] wp.boolFlags;wp.boolFlags=NULL;
					delete [] wp.type;wp.type=NULL;
					delete [] wp.shape;wp.shape=NULL;
					delete [] wp.stepInterval;wp.stepInterval=NULL;
					delete [] wp.hp;wp.hp=NULL;
					delete [] wp.nsegs;wp.nsegs=NULL;
					delete [] wp.iselect;wp.iselect=NULL;
					delete [] wp.eles;wp.eles=NULL;
					delete [] wp.sttEles;wp.sttEles=NULL;
					delete [] wp.stpEle;wp.stpEle=NULL;
					delete [] wp.firstEle;wp.firstEle=NULL;
					delete [] wp.nextEle;wp.nextEle=NULL;
					delete [] wp.snorm1;wp.snorm1=NULL;
					delete [] wp.snorm2;wp.snorm2=NULL;
					delete [] wp.circEles;wp.circEles=NULL;
					delete [] wp.edgeEles;wp.edgeEles=NULL;
					delete [] wp.edgeNodes;wp.edgeNodes=NULL;
					delete [] wp.sttEleNodes;wp.sttEleNodes=NULL;
					delete [] wp.curr;wp.curr=NULL;
					delete [] wp.volt;wp.volt=NULL;
					delete [] wp.eff;wp.eff=NULL;
					delete [] wp.speed;wp.speed=NULL;
					delete [] wp.troom;wp.troom=NULL;
					delete [] wp.tmelt;wp.tmelt=NULL;
					delete [] wp.tcutl;wp.tcutl=NULL;
					delete [] wp.tcuth;wp.tcuth=NULL;
					delete [] wp.timeInterval;wp.timeInterval=NULL;
					delete [] wp.maxiHeatStep;wp.maxiHeatStep=NULL;
					delete [] wp.miniHeatStep;wp.miniHeatStep=NULL;
					delete [] wp.thk1;wp.thk1=NULL;
					delete [] wp.thk2;wp.thk2=NULL;
					delete [] wp.lstart;wp.lstart=NULL;
					delete [] wp.lend;wp.lend=NULL;
					delete [] wp.hlightel;wp.hlightel=NULL;
					delete [] wp.arrows;wp.arrows=NULL;
					delete [] wp.n_curr_sttEl;wp.n_curr_sttEl=NULL;
					delete [] wp.reset;wp.reset=NULL;
					delete [] wp.wpTimes;wp.wpTimes=NULL;
					delete [] wp.source;wp.source=NULL;

//                    delete [] wp.edgeFlag;wp.edgeFlag=NULL;
//                    delete [] wp.circFlag;wp.circFlag=NULL;
//                    delete [] wp.merge;wp.merge=NULL;
				   }
				   //End temporary disconnect VFTmisc coding
*/
//**************** Start from VFTgen
 else if(isel== -6 || isel== -9){
					delete [] wp.name;wp.name=NULL;
					delete [] wp.matName;wp.matName=NULL;
					delete [] wp.seqNum;wp.seqNum=NULL;
					delete [] wp.boolFlags;wp.boolFlags=NULL;
					delete [] wp.type;wp.type=NULL;
					delete [] wp.shape;wp.shape=NULL;
					delete [] wp.stepInterval;wp.stepInterval=NULL;
					delete [] wp.hp;wp.hp=NULL;
					delete [] wp.nsegs;wp.nsegs=NULL;
					delete [] wp.iselect;wp.iselect=NULL;
					delete [] wp.eles;wp.eles=NULL;
					delete [] wp.sttEles;wp.sttEles=NULL;
					delete [] wp.stpEle;wp.stpEle=NULL;
					delete [] wp.firstEle;wp.firstEle=NULL;
					delete [] wp.nextEle;wp.nextEle=NULL;
					delete [] wp.snorm1;wp.snorm1=NULL;
					delete [] wp.snorm2;wp.snorm2=NULL;
					delete [] wp.circEles;wp.circEles=NULL;
					delete [] wp.edgeEles;wp.edgeEles=NULL;
					delete [] wp.edgeNodes;wp.edgeNodes=NULL;
					delete [] wp.sttEleNodes;wp.sttEleNodes=NULL;
					delete [] wp.curr;wp.curr=NULL;
					delete [] wp.volt;wp.volt=NULL;
					delete [] wp.eff;wp.eff=NULL;
					delete [] wp.speed;wp.speed=NULL;
					delete [] wp.troom;wp.troom=NULL;
					delete [] wp.tmelt;wp.tmelt=NULL;
					delete [] wp.tcutl;wp.tcutl=NULL;
					delete [] wp.tcuth;wp.tcuth=NULL;
					delete [] wp.timeInterval;wp.timeInterval=NULL;
					delete [] wp.maxiHeatStep;wp.maxiHeatStep=NULL;
					delete [] wp.miniHeatStep;wp.miniHeatStep=NULL;
					delete [] wp.thk1;wp.thk1=NULL;
					delete [] wp.thk2;wp.thk2=NULL;
					delete [] wp.lstart;wp.lstart=NULL;
					delete [] wp.lend;wp.lend=NULL;
					delete [] wp.hlightel;wp.hlightel=NULL;
					delete [] wp.arrows;wp.arrows=NULL;
					delete [] wp.n_curr_sttEl;wp.n_curr_sttEl=NULL;
					delete [] wp.reset;wp.reset=NULL;
					delete [] wp.wpTimes;wp.wpTimes=NULL;
					delete [] wp.source;wp.source=NULL;
					delete [] wp.mcr;wp.mcr=NULL;// Not part of original VFT
					delete [] wp.WeldColor;wp.WeldColor=NULL;
					delete [] wp.prevGID;wp.prevGID=NULL;
					delete [] wp.util_arr;wp.util_arr=NULL;

//		delete [] wms.name;wms.name=NULL;
//		delete [] wms.matFileName;wms.matFileName=NULL;
//		delete [] wms.Steps;wms.Steps=NULL;
//		delete [] wms.cond;wms.cond=NULL;
//		delete [] wms.heat;wms.heat=NULL;
//		delete [] wms.den;wms.den=NULL;
//		delete [] wms.Ti;wms.Ti=NULL;
//		delete [] wms.Ta;wms.Ta=NULL;
//		delete [] wms.Tm;wms.Tm=NULL;
//		delete [] wms.mcr;wms.mcr=NULL;
//		delete [] wms.ved;wms.ved=NULL;
//		delete [] wms.annjd;wms.annjd=NULL;
//		delete [] wms.hetjd;wms.hetjd=NULL;
//		delete [] wms.nprops;wms.nprops=NULL;
//		delete [] wms.switc;wms.switc=NULL;
//	   delete [] wps.name;wps.name=NULL;
//	   delete [] wps.curr;wps.curr=NULL;
//	   delete [] wps.volt;wps.volt=NULL;
//	   delete [] wps.eff;wps.eff=NULL;
//	   delete [] wps.speed;wps.speed=NULL;
//                    delete [] wp.edgeFlag;wp.edgeFlag=NULL;
//                    delete [] wp.circFlag;wp.circFlag=NULL;
//                    delete [] wp.merge;wp.merge=NULL;
				   }
 else if(isel== -7 || isel== -10){
		delete [] wms.name;wms.name=NULL;
		delete [] wms.matFileName;wms.matFileName=NULL;
		delete [] wms.Steps;wms.Steps=NULL;
		delete [] wms.cond;wms.cond=NULL;
		delete [] wms.heat;wms.heat=NULL;
		delete [] wms.den;wms.den=NULL;
		delete [] wms.Ti;wms.Ti=NULL;
		delete [] wms.Ta;wms.Ta=NULL;
		delete [] wms.Tm;wms.Tm=NULL;
		delete [] wms.mcr;wms.mcr=NULL;
		delete [] wms.ved;wms.ved=NULL;
		delete [] wms.annjd;wms.annjd=NULL;
		delete [] wms.hetjd;wms.hetjd=NULL;
		delete [] wms.nprops;wms.nprops=NULL;
		delete [] wms.switc;wms.switc=NULL;
								 }
 else if(isel== -8 || isel== -11){
	   delete [] wps.name;wps.name=NULL;
	   delete [] wps.curr;wps.curr=NULL;
	   delete [] wps.volt;wps.volt=NULL;
	   delete [] wps.eff;wps.eff=NULL;
	   delete [] wps.speed;wps.speed=NULL;
								 }
 else if(isel== -12)
  {delete [] wpRes.timeVFTarr;wpRes.timeVFTarr=NULL;
   delete [] wpRes.timeVEDarr;wpRes.timeVEDarr=NULL;
  }
 else if(isel== -13){if(base.groupsname){delete [] base.groupsname;base.groupsname=NULL;}} //EFP 3/15/2011
// else if(isel== -14){if(base.trackELSET){delete [] base.trackELSET;base.trackELSET=NULL;} //EFP 2/08/2012
//					}
 else if(isel== -15){if(base.arrELSET){delete [] base.arrELSET;base.arrELSET=NULL;}
//					 if(base.orig_arrELSET){delete [] base.orig_arrELSET;base.orig_arrELSET=NULL;}
					}
// else if(isel== -16){if(indat.trackELSET){delete [] indat.trackELSET;indat.trackELSET=NULL;} //EFP 2/08/2012
//					}
 else if(isel== -17){if(indat.arrELSET){delete [] indat.arrELSET;indat.arrELSET=NULL;}
//					 if(indat.orig_arrELSET){delete [] indat.orig_arrELSET;indat.orig_arrELSET=NULL;}
					}
//**************** End from VFTgen
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported dyn.memory option",L"Exit",MB_OK);exit(0);}
}
//---------------------------------------------------------------------------
void TForm1::parse_cdm(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[])
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,nline=0,ist=0,irflag=0;
 long dii=0,lse=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d'; *nic=0;*nrc=0;isel= -1;
 for(nline=0;nline<ncol;nline++)
  {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;irflag=0;
   for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}
   for(ist=0;ist<25;ist++)
	  {isel++;
	   if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
	   else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
	   else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] || descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
	   else if(descript[isel] == stchar[10])continue;
	   else if(descript[isel] == stchar[0])
		   {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[1])
		   {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[2])
		   {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[3])
		   {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[4])
		   {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[5])
		   {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[6])
		   {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[7])
		   {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[8])
		   {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[9])
		   {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else break;
	  }
   if(irflag)
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}}}
	   div=1.;for(ileft=0;ileft<nright;ileft++){div=div*10.;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
	   if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;parse[*nrc]=rse;*nrc=*nrc+1;
	  }
   else
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}}}
	   dii=1;for(ileft=0;ileft<nright;ileft++){dii=dii*10;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
	   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;iparse[*nic]=lse;*nic=*nic+1;
	  }
  }
}
//---------------------------------------------------------------------------
int TForm1::parse_cdmV(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[])
// Verify integer/float in first place (vflag integer-> -1, float->1)     EFP 8/26/2012
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,nline=0,ist=0,irflag=0,vflag=0;
 long dii=0,lse=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d'; *nic=0;*nrc=0;isel= -1;
 for(nline=0;nline<ncol;nline++)
  {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;irflag=0;
   for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}
   for(ist=0;ist<25;ist++)
	  {isel++;
	   if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
	   else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
	   else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] || descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
	   else if(descript[isel] == stchar[10])continue;
	   else if(descript[isel] == stchar[0])
		   {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[1])
		   {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[2])
		   {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[3])
		   {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[4])
		   {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[5])
		   {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[6])
		   {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[7])
		   {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[8])
		   {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[9])
		   {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else break;
	  }
   if(irflag)
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}}}
	   div=1.;for(ileft=0;ileft<nright;ileft++){div=div*10.;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
	   if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;
	   parse[*nrc]=rse;*nrc=*nrc+1;
	   if(!vflag)vflag=1;
	  }
   else
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}}}
	   dii=1;for(ileft=0;ileft<nright;ileft++){dii=dii*10;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
	   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;
	   iparse[*nic]=lse;*nic=*nic+1;
	   if(!vflag)vflag= -1;
	  }
  }
 return vflag;
}
//---------------------------------------------------------------------------
int TForm1::parse_cdmVc(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[])
// Verify integer/float in first place, comma delimited (vflag integer-> -1, float->1)     EFP 11/24/2012
// This is a questionable blend of parse_cdmV() & parse_cdmQn().
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,nline=0,ist=0,irflag=0,vflag=0,isw=0;
 long dii=0,lse=0,ctcomma=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d';stchar[17]=','; *nic=0;*nrc=0;isel= -1;
 isw=1;
 for(nline=0;nline<ncol;nline++)
  {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;irflag=0;
   for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}
   for(ist=0;ist<25;ist++)
	  {isel++;
	   if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
	   else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
	   else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] || descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
	   else if(descript[isel] == stchar[10])continue;
	   else if(descript[isel] == stchar[0])
		   {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[1])
		   {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[2])
		   {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[3])
		   {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[4])
		   {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[5])
		   {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[6])
		   {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[7])
		   {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[8])
		   {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[9])
		   {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
//	   else break;
	   else if(descript[isel] ==' ')continue;
	   else if(descript[isel] == stchar[17]){ctcomma++;if(ctcomma>=ncol)isw=0;
											 break;
											}
	   else {isw=0;break;}
	  }
   if(irflag)
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}}}
	   div=1.;for(ileft=0;ileft<nright;ileft++){div=div*10.;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
	   if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;
	   parse[*nrc]=rse;*nrc=*nrc+1;
	   if(!vflag)vflag=1;
	  }
   else
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}}}
	   dii=1;for(ileft=0;ileft<nright;ileft++){dii=dii*10;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
	   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;
	   iparse[*nic]=lse;*nic=*nic+1;
	   if(!vflag)vflag= -1;
	  }
//   if(!isw)break;
  }
 return vflag;
}
//---------------------------------------------------------------------------
// The following is not currently used   EFP 8-24-2014
void TForm1::parse_cdm3f(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[])
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,nline=0,ist=0,irflag=0;
 long dii=0,lse=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d'; *nic=0;*nrc=0;isel= -1;
 for(nline=0;nline<ncol;nline++)
  {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;
   if( *nic)irflag=1;
   else irflag=0;
   for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}
   for(ist=0;ist<25;ist++)
	  {isel++;
	   if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
	   else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
	   else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] || descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
	   else if(descript[isel] == stchar[10])continue;
	   else if(descript[isel] == stchar[0])
		   {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[1])
		   {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[2])
		   {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[3])
		   {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[4])
		   {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[5])
		   {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[6])
		   {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[7])
		   {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[8])
		   {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[9])
		   {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else break;
	  }
   if(irflag)
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}}}
	   div=1.;for(ileft=0;ileft<nright;ileft++){div=div*10.;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
	   if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;parse[*nrc]=rse;*nrc=*nrc+1;
	  }
   else
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}}}
	   dii=1;for(ileft=0;ileft<nright;ileft++){dii=dii*10;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
	   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;iparse[*nic]=lse;*nic=*nic+1;
	  }
  }
}
//---------------------------------------------------------------------------
void TForm1::parse_cdm3ff(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[])
// This routine reads comma-delimited coords, driven by #numbers on line==ncol.
// It accommodates spaces before/after commas. It can handle an extra comma at end.
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,nline=0,ist=0,irflag=0,active=0;
 long dii=0,lse=0;float div=0.,rse=0.;char stchar[19],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d';stchar[17]=',';stchar[18]=' '; *nic=0;*nrc=0;isel= -1;
 for(nline=0;nline<ncol;nline++)
  {rse=0.;lse=0;active=pre=nleft=nright=nexp=0;esign=1;sign=1;
   if( *nic)irflag=1;
   else irflag=0;
   for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}
   for(ist=0;ist<25;ist++)
	  {isel++;
	   if(descript[isel] == stchar[11]){active=1;if(pre == 0)sign= -1;else esign= -1;}
	   else if(descript[isel] == stchar[12]){active=1;pre=1;irflag=1;}
	   else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] || descript[isel] == stchar[15] || descript[isel] == stchar[16]){active=1;pre=2;irflag=1;}
	   else if(descript[isel] == stchar[10]){active=1;continue;}
	   else if(descript[isel] == stchar[0])
		   {inel=0;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[1])
		   {inel=1;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[2])
		   {inel=2;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[3])
		   {inel=3;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[4])
		   {inel=4;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[5])
		   {inel=5;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[6])
		   {inel=6;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[7])
		   {inel=7;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[8])
		   {inel=8;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[9])
		   {inel=9;active=1;
				   if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
				   else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
				   else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}else exit(0);
		   }
	   else if(descript[isel] == stchar[17]){active=0;break;}
	   else if(descript[isel] == stchar[18]){if(nline==ncol-1)break;else continue;}
	   else break;
	  }
   if(irflag)
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}}}
	   div=1.;for(ileft=0;ileft<nright;ileft++){div=div*10.;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
	   if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;parse[*nrc]=rse;*nrc=*nrc+1;
	  }
   else
	  {for(ileft=0;ileft<nleft;ileft++){for(inel=0;inel<10;inel++){if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}}}
	   dii=1;for(ileft=0;ileft<nright;ileft++){dii=dii*10;for(inel=1;inel<10;inel++){if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}}}
	   vexp=0;for(ileft=0;ileft<nexp;ileft++){for(inel=0;inel<10;inel++){if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}}}
//
if(vexp>37)vexp=37;
//
	   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
	   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;iparse[*nic]=lse;*nic=*nic+1;
	  }
  }
}
//---------------------------------------------------------------------------
void TForm1::parse_cdmQ(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[],long siza)
// Integers and/or float(E)/double(D) numbers delimited by ' ' or ','
// Read up to ncol "integer + real" or end of record (siza=record length without \n), whichever comes first.
// Delimited by comma, except at end. There may or may not be a space before the comma. (i.e. 7543 , 7544 , etc)
// CORRECTION: EFP 5/11/2010 for possible space before comma
// BIG siza BUG HERE
// Note: This routine can accommodate spaces befor/after commas. It can accommodate an extra comma at end.
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,ist=0,irflag=0,isw=0;
 long dii=0,lse=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d';stchar[17]=','; *nic=0;*nrc=0;isel= -1;

 isw=1;
 do {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;irflag=0;
	 for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}

	 for(ist=0;ist<25;ist++)
		{isel++;
		 if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
		 else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
		 else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] ||
				 descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
		 else if(descript[isel] == stchar[10])continue;
		 else if(descript[isel] == stchar[0])
			 {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[1])
			 {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[2])
			 {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[3])
			 {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[4])
			 {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[5])
			 {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[6])
			 {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[7])
			 {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[8])
			 {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[9])
			 {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
//		 else break;
		 else if(descript[isel] ==' ')continue;
		 else if(descript[isel] == stchar[17])break;
		 else {isw=0;break;}
		}
//if(isw){
	 if(irflag){for(ileft=0;ileft<nleft;ileft++)
				 {for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}
				 }
				div=1.;for(ileft=0;ileft<nright;ileft++)
						 {div=div*10.;
						  for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}
						 }
				vexp=0;for(ileft=0;ileft<nexp;ileft++)
						 {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
						 }
				if(vexp>37)vexp=37; // Revision
				div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
				if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;
				parse[*nrc]=rse;*nrc=*nrc+1;
			   }
	 else {for(ileft=0;ileft<nleft;ileft++)
			{for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}
			}
		   dii=1;for(ileft=0;ileft<nright;ileft++)
				   {dii=dii*10;
					for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}
				   }
		   vexp=0;for(ileft=0;ileft<nexp;ileft++)
				   {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
				   }
		   if(vexp>37)vexp=37; // Revision
		   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
		   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;
		   iparse[*nic]=lse;*nic=*nic+1;
		  }
//	   }

//honk<<isel+1<<" "<<siza<<" FFFFFFFFF "<< *nic<<" "<< *nrc<<" "<<ncol<<"\n";


	}
// while (isel+1<siza && (*nic+ *nrc)<ncol);
 while (isw);
}
//---------------------------------------------------------------------------
void TForm1::parse_cdmQb(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[],long siza)
// Integers and/or float(E)/double(D) numbers delimited by ' '
// Read up to ncol "integer + real" or end of record (siza=record length without \n), whichever comes first.
// CORRECTION: EFP 5/11/2010 for possible space before comma
// BIG siza BUG HERE
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,ist=0,irflag=0,isw=0;
 long dii=0,lse=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d';stchar[17]=','; *nic=0;*nrc=0;isel= -1;

 isw=1;
 do {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;irflag=0;
//	 for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}
	 for(ist=0;ist<siza;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}

	 for(ist=0;ist<25;ist++)
		{isel++;

if(isel>siza)break;

		 if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
		 else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
		 else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] ||
				 descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
		 else if(descript[isel] == stchar[10])continue;
		 else if(descript[isel] == stchar[0])
			 {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[1])
			 {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[2])
			 {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[3])
			 {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[4])
			 {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[5])
			 {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[6])
			 {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[7])
			 {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[8])
			 {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[9])
			 {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
////		 else break;
//		 else if(descript[isel] ==' ')continue;
		 else if(descript[isel] ==' ')break;
//		 else if(descript[isel] == stchar[17])break;
		 else {isw=0;break;}
		}
//if(isw){
	 if(irflag){for(ileft=0;ileft<nleft;ileft++)
				 {for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}
				 }
				div=1.;for(ileft=0;ileft<nright;ileft++)
						 {div=div*10.;
						  for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}
						 }
				vexp=0;for(ileft=0;ileft<nexp;ileft++)
						 {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
						 }
				if(vexp>37)vexp=37; // Revision
				div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
				if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;
				parse[*nrc]=rse;*nrc=*nrc+1;
			   }
	 else {for(ileft=0;ileft<nleft;ileft++)
			{for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}
			}
		   dii=1;for(ileft=0;ileft<nright;ileft++)
				   {dii=dii*10;
					for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}
				   }
		   vexp=0;for(ileft=0;ileft<nexp;ileft++)
				   {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
				   }
		   if(vexp>37)vexp=37; // Revision
		   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
		   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;
		   iparse[*nic]=lse;*nic=*nic+1;
		  }
//	   }

//honk<<isel+1<<" "<<siza<<" FFFFFFFFF "<< *nic<<" "<< *nrc<<" "<<ncol<<"\n";


	}
// while (isel+1<siza && (*nic+ *nrc)<ncol);
 while (isw);
}
//---------------------------------------------------------------------------
void TForm1::parse_cdmQn(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[])
// Integers and/or float(E)/double(D) numbers delimited by ' ' or ','
// Read up to ncol "integer + real" or end of record (siza=record length without \n), whichever comes first.
// Delimited by comma, except at end. There may or may not be a space before the comma. (i.e. 7543 , 7544 , etc)
// CORRECTION: EFP 5/11/2010 for possible space before comma
// BIG siza BUG HERE
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,ist=0,irflag=0,isw=0;
 long dii=0,lse=0,ctcomma=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d';stchar[17]=','; *nic=0;*nrc=0;isel= -1;

 isw=1;
 do {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;irflag=0;
	 for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}

	 for(ist=0;ist<25;ist++)
		{isel++;
		 if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
		 else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
		 else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] ||
				 descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
		 else if(descript[isel] == stchar[10])continue;
		 else if(descript[isel] == stchar[0])
			 {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[1])
			 {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[2])
			 {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[3])
			 {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[4])
			 {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[5])
			 {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[6])
			 {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[7])
			 {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[8])
			 {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[9])
			 {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
//		 else break;
		 else if(descript[isel] ==' ')continue;
		 else if(descript[isel] == stchar[17]){
											   ctcomma++;if(ctcomma>=ncol)isw=0;
											   break;
											  }
		 else {isw=0;break;}
		}
//if(isw){
	 if(irflag){for(ileft=0;ileft<nleft;ileft++)
				 {for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}
				 }
				div=1.;for(ileft=0;ileft<nright;ileft++)
						 {div=div*10.;
						  for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}
						 }
				vexp=0;for(ileft=0;ileft<nexp;ileft++)
						 {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
						 }
				if(vexp>37)vexp=37; // Revision
				div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
				if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;
				parse[*nrc]=rse;*nrc=*nrc+1;
			   }
	 else {for(ileft=0;ileft<nleft;ileft++)
			{for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}
			}
		   dii=1;for(ileft=0;ileft<nright;ileft++)
				   {dii=dii*10;
					for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}
				   }
		   vexp=0;for(ileft=0;ileft<nexp;ileft++)
				   {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
				   }
		   if(vexp>37)vexp=37; // Revision
		   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
		   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;
		   iparse[*nic]=lse;*nic=*nic+1;
		  }
//	   }

//honk<<isel+1<<" "<<siza<<" FFFFFFFFF "<< *nic<<" "<< *nrc<<" "<<ncol<<"\n";


	}
// while (isel+1<siza && (*nic+ *nrc)<ncol);
 while (isw);
}
//---------------------------------------------------------------------------
void TForm1::parse_cdmQc(char descript[],long ncol,int* nic,int* nrc,long iparse[],float parse[])
// Integers and/or float(E)/double(D) numbers delimited by ','
// Read up to ncol "integer + real" or end of record (siza=record length without \n), whichever comes first.
// Delimited by comma only, including at end (EFP 12/03/2010). There may or may not be a space before the comma. (i.e. 7543 , 7544 , etc)
// CORRECTION: EFP 5/11/2010 for possible space before comma
{int isel=0,inel=0,pre=0,ileft=0,nleft=0,nright=0,nexp=0,sign=0,esign=0,vexp=0,ist=0,irflag=0,isw=0;
 long dii=0,lse=0,ctcomma=0;float div=0.,rse=0.;char stchar[17],cleft[25],cright[25],cexp[25];
 stchar[0]='0';stchar[1]='1';stchar[2]='2';stchar[3]='3';stchar[4]='4';
 stchar[5]='5';stchar[6]='6';stchar[7]='7';stchar[8]='8';stchar[9]='9';
 stchar[10]='+';stchar[11]='-';stchar[12]='.';stchar[13]='E';stchar[14]='e';
 stchar[15]='D';stchar[16]='d';stchar[17]=','; *nic=0;*nrc=0;isel= -1;

 isw=1;
 do {rse=0.;lse=0;pre=nleft=nright=nexp=0;esign=1;sign=1;irflag=0;
	 for(ist=0;ist<100;ist++){isel++;if(descript[isel] != ' '){isel--;break;}}

	 for(ist=0;ist<25;ist++)
		{isel++;
		 if(descript[isel] == stchar[11]){if(pre == 0)sign= -1;else esign= -1;}
		 else if(descript[isel] == stchar[12]){pre=1;irflag=1;}
		 else if(descript[isel] == stchar[13] || descript[isel] == stchar[14] ||
				 descript[isel] == stchar[15] || descript[isel] == stchar[16]){pre=2;irflag=1;}
		 else if(descript[isel] == stchar[10])continue;
		 else if(descript[isel] == stchar[0])
			 {inel=0;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[1])
			 {inel=1;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[2])
			 {inel=2;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[3])
			 {inel=3;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[4])
			 {inel=4;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[5])
			 {inel=5;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[6])
			 {inel=6;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[7])
			 {inel=7;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[8])
			 {inel=8;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
		 else if(descript[isel] == stchar[9])
			 {inel=9;if(pre == 0){nleft=nleft+1;cleft[nleft-1]=stchar[inel];}
					 else if(pre == 1){nright=nright+1;cright[nright-1]=stchar[inel];}
					 else if(pre == 2){nexp=nexp+1;cexp[nexp-1]=stchar[inel];}
					 else exit(0);
			 }
////		 else break;
//		 else if(descript[isel] ==' ')continue;
		 else if(descript[isel] == stchar[17]){
											   ctcomma++;if(ctcomma>=ncol)isw=0;
											   break;
											  }
//		 else {isw=0;break;}
		 else return;
		}
//if(isw){
	 if(irflag){for(ileft=0;ileft<nleft;ileft++)
				 {for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){rse=rse*10+float(inel);break;}
				 }
				div=1.;for(ileft=0;ileft<nright;ileft++)
						 {div=div*10.;
						  for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){rse=rse+float(inel)/div;break;}
						 }
				vexp=0;for(ileft=0;ileft<nexp;ileft++)
						 {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
						 }
				if(vexp>37)vexp=37; // Revision
				div=1.;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)div=div*10.;}
				if(esign<0)rse=float(sign)*rse/div;else rse=float(sign)*rse*div;
				parse[*nrc]=rse;*nrc=*nrc+1;
			   }
	 else {for(ileft=0;ileft<nleft;ileft++)
			{for(inel=0;inel<10;inel++)if(cleft[ileft] == stchar[inel]){lse=lse*10+long(inel);break;}
			}
		   dii=1;for(ileft=0;ileft<nright;ileft++)
				   {dii=dii*10;
					for(inel=1;inel<10;inel++)if(cright[ileft] == stchar[inel]){lse=lse+long(inel)/dii;break;}
				   }
		   vexp=0;for(ileft=0;ileft<nexp;ileft++)
				   {for(inel=0;inel<10;inel++)if(cexp[ileft] == stchar[inel]){vexp=vexp*10+inel;break;}
				   }
		   if(vexp>37)vexp=37; // Revision
		   dii=1;if(vexp>0){for(ileft=0;ileft<vexp;ileft++)dii=dii*10;}
		   if(esign<0)lse=long(sign)*lse/dii;else lse=long(sign)*lse*dii;
		   iparse[*nic]=lse;*nic=*nic+1;
		  }
//	   }

//honk<<isel+1<<" "<<siza<<" FFFFFFFFF "<< *nic<<" "<< *nrc<<" "<<ncol<<"\n";


	}
// while (isel+1<siza && (*nic+ *nrc)<ncol);
 while (isw);
}
//---------------------------------------------------------------------------
long TForm1::parse_ch1(long ip,long *im,char descript[],char parse[])
{long in=0,ik= -1; *im=0;
 for(in=ip;in<strlen(descript)-1;in++){if(descript[in]==' ')continue;
									   else if(descript[in]==','){ik=in+1;break;}
									   else {parse[*im]=descript[in]; *im= *im+1;}
									  }
 if(*im){parse[*im]='\0'; *im= *im+1;}
 if(ik<0)return strlen(descript)-1;
 else return ik;
}
//---------------------------------------------------------------------------
void TForm1::FDtrans_results(long indat_npoin,float indat_bc1[],float indat_res1[],long nColRes,int fl_feres)
// Global NDF,Cylindframe1->Checked,etc
{int ic=0,icrec=0;long i=0,is=0;
 float rad=0.,cc=0.,ss=0.,ccp=0.,ssp=0.,tem1=0.,tem2=0.,tem3=0.,tem4=0.,tem5=0.,tem6=0.,norm2=0.,rrec=0.,xtem=0.,ytem=0.,
	   tt11=0.,tt12=0.,tt13=0.,tt21=0.,tt22=0.,tt23=0.,tt31=0.,tt32=0.,tt33=0.,TOL=1.e-3;
// CAUTION: This subr. uses cartesian geom indat_bc1[], instead of screen geom indat_c1[]
 if(Cylindframe1->Checked)
   {if(CylXaxis1->Checked)  // X-axis (Y-axis ---> theta=0)
	  {for(i=0;i<indat_npoin;i++)
		 {rad=sqrt(indat_bc1[NDF*i+1]*indat_bc1[NDF*i+1]+indat_bc1[NDF*i+2]*indat_bc1[NDF*i+2]);
		  if(rad>TOL)
			{ss=indat_bc1[NDF*i+2]/rad;cc=indat_bc1[NDF*i+1]/rad;tem1=cc*indat_res1[nColRes*i+1]+ss*indat_res1[nColRes*i+2];
			 indat_res1[nColRes*i+2]= -ss*indat_res1[nColRes*i+1]+cc*indat_res1[nColRes*i+2];indat_res1[nColRes*i+1]=tem1;
			 if(fl_feres==1)
			   {tem1=cc*cc*indat_res1[nColRes*i+4]+ss*ss*indat_res1[nColRes*i+5]+2.*cc*ss*indat_res1[nColRes*i+8];
				tem2=cc*cc*indat_res1[nColRes*i+5]+ss*ss*indat_res1[nColRes*i+4]-2.*cc*ss*indat_res1[nColRes*i+8];
				indat_res1[nColRes*i+8]=cc*ss*(indat_res1[nColRes*i+5]-indat_res1[nColRes*i+4])+(cc*cc-ss*ss)*indat_res1[nColRes*i+8];
				indat_res1[nColRes*i+4]=tem1;indat_res1[nColRes*i+5]=tem2;
			   }
			 else if(fl_feres==4)
			   {for(is=0;is<7;is=is+6)
				  {tem1=cc*cc*indat_res1[nColRes*i+4+is]+ss*ss*indat_res1[nColRes*i+5+is]+2.*cc*ss*indat_res1[nColRes*i+8+is];
				   tem2=cc*cc*indat_res1[nColRes*i+5+is]+ss*ss*indat_res1[nColRes*i+4+is]-2.*cc*ss*indat_res1[nColRes*i+8+is];
				   indat_res1[nColRes*i+8+is]=cc*ss*(indat_res1[nColRes*i+5+is]-indat_res1[nColRes*i+4+is])+(cc*cc-ss*ss)*indat_res1[nColRes*i+8+is];
				   indat_res1[nColRes*i+4+is]=tem1;indat_res1[nColRes*i+5+is]=tem2;
				  }
			   }
			}
		 }
	  }
	else if(CylYaxis1->Checked) // Y-axis  (X-axis ---> theta=0)
	  {for(i=0;i<indat_npoin;i++)
		 {rad=sqrt(indat_bc1[NDF*i]*indat_bc1[NDF*i]+indat_bc1[NDF*i+2]*indat_bc1[NDF*i+2]);
		  if(rad>TOL)
			{ss=indat_bc1[NDF*i+2]/rad;cc=indat_bc1[NDF*i]/rad;tem1=cc*indat_res1[nColRes*i]+ss*indat_res1[nColRes*i+2];
			 indat_res1[nColRes*i+2]= -ss*indat_res1[nColRes*i]+cc*indat_res1[nColRes*i+2];indat_res1[nColRes*i]=tem1;
			 if(fl_feres==1)
			   {tem1=cc*cc*indat_res1[nColRes*i+3]+ss*ss*indat_res1[nColRes*i+5]+2.*cc*ss*indat_res1[nColRes*i+7];
				tem2=cc*cc*indat_res1[nColRes*i+5]+ss*ss*indat_res1[nColRes*i+3]-2.*cc*ss*indat_res1[nColRes*i+7];
				indat_res1[nColRes*i+7]=cc*ss*(indat_res1[nColRes*i+5]-indat_res1[nColRes*i+3])+(cc*cc-ss*ss)*indat_res1[nColRes*i+7];
				indat_res1[nColRes*i+3]=tem1;indat_res1[nColRes*i+5]=tem2;
			   }
			 else if(fl_feres==4)
			   {for(is=0;is<7;is=is+6)
				  {tem1=cc*cc*indat_res1[nColRes*i+3+is]+ss*ss*indat_res1[nColRes*i+5+is]+2.*cc*ss*indat_res1[nColRes*i+7+is];
				   tem2=cc*cc*indat_res1[nColRes*i+5+is]+ss*ss*indat_res1[nColRes*i+3+is]-2.*cc*ss*indat_res1[nColRes*i+7+is];
				   indat_res1[nColRes*i+7+is]=cc*ss*(indat_res1[nColRes*i+5+is]-indat_res1[nColRes*i+3+is])+(cc*cc-ss*ss)*indat_res1[nColRes*i+7+is];
				   indat_res1[nColRes*i+3+is]=tem1;indat_res1[nColRes*i+5+is]=tem2;
				  }
			   }
			}
		 }
	  }
	else if(CylZaxis1->Checked) // Z-axis  (X-axis ---> theta=0)
	  {for(i=0;i<indat_npoin;i++)
		 {rad=sqrt(indat_bc1[NDF*i]*indat_bc1[NDF*i]+indat_bc1[NDF*i+1]*indat_bc1[NDF*i+1]);
		  if(rad>TOL)
			{ss=indat_bc1[NDF*i+1]/rad;cc=indat_bc1[NDF*i]/rad;tem1=cc*indat_res1[nColRes*i]+ss*indat_res1[nColRes*i+1];
			 indat_res1[nColRes*i+1]= -ss*indat_res1[nColRes*i]+cc*indat_res1[nColRes*i+1];indat_res1[nColRes*i]=tem1;
			 if(fl_feres==1)
			   {tem1=cc*cc*indat_res1[nColRes*i+3]+ss*ss*indat_res1[nColRes*i+4]+2.*cc*ss*indat_res1[nColRes*i+6];
				tem2=cc*cc*indat_res1[nColRes*i+4]+ss*ss*indat_res1[nColRes*i+3]-2.*cc*ss*indat_res1[nColRes*i+6];
				indat_res1[nColRes*i+6]=cc*ss*(indat_res1[nColRes*i+4]-indat_res1[nColRes*i+3])+(cc*cc-ss*ss)*indat_res1[nColRes*i+6];
				indat_res1[nColRes*i+3]=tem1;indat_res1[nColRes*i+4]=tem2;
			   }
			 else if(fl_feres==4)
			   {for(is=0;is<7;is=is+6)
				  {tem1=cc*cc*indat_res1[nColRes*i+3+is]+ss*ss*indat_res1[nColRes*i+4+is]+2.*cc*ss*indat_res1[nColRes*i+6+is];
				   tem2=cc*cc*indat_res1[nColRes*i+4+is]+ss*ss*indat_res1[nColRes*i+3+is]-2.*cc*ss*indat_res1[nColRes*i+6+is];
				   indat_res1[nColRes*i+6+is]=cc*ss*(indat_res1[nColRes*i+4+is]-indat_res1[nColRes*i+3+is])+(cc*cc-ss*ss)*indat_res1[nColRes*i+6+is];
				   indat_res1[nColRes*i+3+is]=tem1;indat_res1[nColRes*i+4+is]=tem2;
				  }
			   }
			}
		 }
	  }
// General cylindrical axis
	else
	  {
//
tt13=genaxispts[3]-genaxispts[0];tt23=genaxispts[4]-genaxispts[1];tt33=genaxispts[5]-genaxispts[2];
norm2=sqrt(tt13*tt13+tt23*tt23+tt33*tt33);tt13=(genaxispts[3]-genaxispts[0])/norm2;
tt23=(genaxispts[4]-genaxispts[1])/norm2;tt33=(genaxispts[5]-genaxispts[2])/norm2;
rrec= -1.E20;for(ic=0;ic<3;ic++)
  {if(rrec<fabs(genaxispts[ic+3]-genaxispts[ic])){rrec=fabs(genaxispts[ic+3]-genaxispts[ic]);icrec=ic;}}
if(icrec==0){tt11=tt13;tt21=tt23;tt31=tt33;tt13= -tt31;tt23=0.;tt33=tt11;
			 norm2=sqrt(tt13*tt13+tt33*tt33);tt13=tt13/norm2;tt33=tt33/norm2;
			 tt12=tt23*tt31-tt33*tt21;tt22=tt33*tt11-tt13*tt31;tt32=tt13*tt21-tt23*tt11;
			}
else if(icrec==1){tt12=tt13;tt22=tt23;tt32=tt33;tt11=tt22;tt21= -tt12;tt31=0.;
				  norm2=sqrt(tt11*tt11+tt21*tt21);tt11=tt11/norm2;tt21=tt21/norm2;
				  tt13=tt21*tt32-tt31*tt22;tt23=tt31*tt12-tt11*tt32;tt33=tt11*tt22-tt21*tt12;
				 }
else {tt11=tt33;tt21=0.;tt31= -tt13;
	  norm2=sqrt(tt11*tt11+tt31*tt31);tt11=tt11/norm2;tt31=tt31/norm2;
	  tt12=tt23*tt31-tt33*tt21;tt22=tt33*tt11-tt13*tt31;tt32=tt13*tt21-tt23*tt11;
	 }
	   for(i=0;i<indat_npoin;i++)
		 {xtem=tt11*(indat_bc1[NDF*i  ]-genaxispts[0])+tt21*(indat_bc1[NDF*i+1]-genaxispts[1])+tt31*(indat_bc1[NDF*i+2]-genaxispts[2]);
		  ytem=tt12*(indat_bc1[NDF*i  ]-genaxispts[0])+tt22*(indat_bc1[NDF*i+1]-genaxispts[1])+tt32*(indat_bc1[NDF*i+2]-genaxispts[2]);
//          ztem=tt13*(indat_bc1[NDF*i  ]-genaxispts[0])+tt23*(indat_bc1[NDF*i+1]-genaxispts[1])+tt33*(indat_bc1[NDF*i+2]-genaxispts[2]);
		  rad=sqrt(xtem*xtem+ytem*ytem);
		  tem1=tt11*indat_res1[nColRes*i]+tt21*indat_res1[nColRes*i+1]+tt31*indat_res1[nColRes*i+2];
		  tem2=tt12*indat_res1[nColRes*i]+tt22*indat_res1[nColRes*i+1]+tt32*indat_res1[nColRes*i+2];
		  tem3=tt13*indat_res1[nColRes*i]+tt23*indat_res1[nColRes*i+1]+tt33*indat_res1[nColRes*i+2];
		  indat_res1[nColRes*i]=tem1;indat_res1[nColRes*i+1]=tem2;indat_res1[nColRes*i+2]=tem3;
		  if(fl_feres==1)
			{tem1=tt11*(tt11*indat_res1[nColRes*i+3]+tt21*indat_res1[nColRes*i+6]+tt31*indat_res1[nColRes*i+7])+
				  tt21*(tt11*indat_res1[nColRes*i+6]+tt21*indat_res1[nColRes*i+4]+tt31*indat_res1[nColRes*i+8])+
				  tt31*(tt11*indat_res1[nColRes*i+7]+tt21*indat_res1[nColRes*i+8]+tt31*indat_res1[nColRes*i+5]);
			 tem2=tt12*(tt12*indat_res1[nColRes*i+3]+tt22*indat_res1[nColRes*i+6]+tt32*indat_res1[nColRes*i+7])+
				  tt22*(tt12*indat_res1[nColRes*i+6]+tt22*indat_res1[nColRes*i+4]+tt32*indat_res1[nColRes*i+8])+
				  tt32*(tt12*indat_res1[nColRes*i+7]+tt22*indat_res1[nColRes*i+8]+tt32*indat_res1[nColRes*i+5]);
			 tem3=tt13*(tt13*indat_res1[nColRes*i+3]+tt23*indat_res1[nColRes*i+6]+tt33*indat_res1[nColRes*i+7])+
				  tt23*(tt13*indat_res1[nColRes*i+6]+tt23*indat_res1[nColRes*i+4]+tt33*indat_res1[nColRes*i+8])+
				  tt33*(tt13*indat_res1[nColRes*i+7]+tt23*indat_res1[nColRes*i+8]+tt33*indat_res1[nColRes*i+5]);
			 tem4=tt11*(tt12*indat_res1[nColRes*i+3]+tt22*indat_res1[nColRes*i+6]+tt32*indat_res1[nColRes*i+7])+
				  tt21*(tt12*indat_res1[nColRes*i+6]+tt22*indat_res1[nColRes*i+4]+tt32*indat_res1[nColRes*i+8])+
				  tt31*(tt12*indat_res1[nColRes*i+7]+tt22*indat_res1[nColRes*i+8]+tt32*indat_res1[nColRes*i+5]);
			 tem5=tt11*(tt13*indat_res1[nColRes*i+3]+tt23*indat_res1[nColRes*i+6]+tt33*indat_res1[nColRes*i+7])+
				  tt21*(tt13*indat_res1[nColRes*i+6]+tt23*indat_res1[nColRes*i+4]+tt33*indat_res1[nColRes*i+8])+
				  tt31*(tt13*indat_res1[nColRes*i+7]+tt23*indat_res1[nColRes*i+8]+tt33*indat_res1[nColRes*i+5]);
			 tem6=tt12*(tt13*indat_res1[nColRes*i+3]+tt23*indat_res1[nColRes*i+6]+tt33*indat_res1[nColRes*i+7])+
				  tt22*(tt13*indat_res1[nColRes*i+6]+tt23*indat_res1[nColRes*i+4]+tt33*indat_res1[nColRes*i+8])+
				  tt32*(tt13*indat_res1[nColRes*i+7]+tt23*indat_res1[nColRes*i+8]+tt33*indat_res1[nColRes*i+5]);
			 indat_res1[nColRes*i+3]=tem1;indat_res1[nColRes*i+4]=tem2;indat_res1[nColRes*i+5]=tem3;
			 indat_res1[nColRes*i+6]=tem4;indat_res1[nColRes*i+7]=tem5;indat_res1[nColRes*i+8]=tem6;
			}
		  else if(fl_feres==4)
			{for(is=0;is<7;is=is+6)
			   {tem1=tt11*(tt11*indat_res1[nColRes*i+3+is]+tt21*indat_res1[nColRes*i+6+is]+tt31*indat_res1[nColRes*i+7+is])+
					 tt21*(tt11*indat_res1[nColRes*i+6+is]+tt21*indat_res1[nColRes*i+4+is]+tt31*indat_res1[nColRes*i+8+is])+
					 tt31*(tt11*indat_res1[nColRes*i+7+is]+tt21*indat_res1[nColRes*i+8+is]+tt31*indat_res1[nColRes*i+5+is]);
				tem2=tt12*(tt12*indat_res1[nColRes*i+3+is]+tt22*indat_res1[nColRes*i+6+is]+tt32*indat_res1[nColRes*i+7+is])+
					 tt22*(tt12*indat_res1[nColRes*i+6+is]+tt22*indat_res1[nColRes*i+4+is]+tt32*indat_res1[nColRes*i+8+is])+
					 tt32*(tt12*indat_res1[nColRes*i+7+is]+tt22*indat_res1[nColRes*i+8+is]+tt32*indat_res1[nColRes*i+5+is]);
				tem3=tt13*(tt13*indat_res1[nColRes*i+3+is]+tt23*indat_res1[nColRes*i+6+is]+tt33*indat_res1[nColRes*i+7+is])+
					 tt23*(tt13*indat_res1[nColRes*i+6+is]+tt23*indat_res1[nColRes*i+4+is]+tt33*indat_res1[nColRes*i+8+is])+
					 tt33*(tt13*indat_res1[nColRes*i+7+is]+tt23*indat_res1[nColRes*i+8+is]+tt33*indat_res1[nColRes*i+5+is]);
				tem4=tt11*(tt12*indat_res1[nColRes*i+3+is]+tt22*indat_res1[nColRes*i+6+is]+tt32*indat_res1[nColRes*i+7+is])+
					 tt21*(tt12*indat_res1[nColRes*i+6+is]+tt22*indat_res1[nColRes*i+4+is]+tt32*indat_res1[nColRes*i+8+is])+
					 tt31*(tt12*indat_res1[nColRes*i+7+is]+tt22*indat_res1[nColRes*i+8+is]+tt32*indat_res1[nColRes*i+5+is]);
				tem5=tt11*(tt13*indat_res1[nColRes*i+3+is]+tt23*indat_res1[nColRes*i+6+is]+tt33*indat_res1[nColRes*i+7+is])+
					 tt21*(tt13*indat_res1[nColRes*i+6+is]+tt23*indat_res1[nColRes*i+4+is]+tt33*indat_res1[nColRes*i+8+is])+
					 tt31*(tt13*indat_res1[nColRes*i+7+is]+tt23*indat_res1[nColRes*i+8+is]+tt33*indat_res1[nColRes*i+5+is]);
				tem6=tt12*(tt13*indat_res1[nColRes*i+3+is]+tt23*indat_res1[nColRes*i+6+is]+tt33*indat_res1[nColRes*i+7+is])+
					 tt22*(tt13*indat_res1[nColRes*i+6+is]+tt23*indat_res1[nColRes*i+4+is]+tt33*indat_res1[nColRes*i+8+is])+
					 tt32*(tt13*indat_res1[nColRes*i+7+is]+tt23*indat_res1[nColRes*i+8+is]+tt33*indat_res1[nColRes*i+5+is]);
				indat_res1[nColRes*i+3+is]=tem1;indat_res1[nColRes*i+4+is]=tem2;indat_res1[nColRes*i+5+is]=tem3;
				indat_res1[nColRes*i+6+is]=tem4;indat_res1[nColRes*i+7+is]=tem5;indat_res1[nColRes*i+8+is]=tem6;
			   }
			}
		  if(rad>TOL)
			{ss=ytem/rad;cc=xtem/rad;tem1=cc*indat_res1[nColRes*i]+ss*indat_res1[nColRes*i+1];
			 indat_res1[nColRes*i+1]= -ss*indat_res1[nColRes*i]+cc*indat_res1[nColRes*i+1];indat_res1[nColRes*i]=tem1;
			 if(fl_feres==1)
			   {tem1=cc*cc*indat_res1[nColRes*i+3]+ss*ss*indat_res1[nColRes*i+4]+2.*cc*ss*indat_res1[nColRes*i+6];
				tem2=cc*cc*indat_res1[nColRes*i+4]+ss*ss*indat_res1[nColRes*i+3]-2.*cc*ss*indat_res1[nColRes*i+6];
				indat_res1[nColRes*i+6]=cc*ss*(indat_res1[nColRes*i+4]-indat_res1[nColRes*i+3])+(cc*cc-ss*ss)*indat_res1[nColRes*i+6];
				indat_res1[nColRes*i+3]=tem1;indat_res1[nColRes*i+4]=tem2;
			   }
			 else if(fl_feres==4)
			   {for(is=0;is<7;is=is+6)
				  {tem1=cc*cc*indat_res1[nColRes*i+3+is]+ss*ss*indat_res1[nColRes*i+4+is]+2.*cc*ss*indat_res1[nColRes*i+6+is];
				   tem2=cc*cc*indat_res1[nColRes*i+4+is]+ss*ss*indat_res1[nColRes*i+3+is]-2.*cc*ss*indat_res1[nColRes*i+6+is];
				   indat_res1[nColRes*i+6+is]=cc*ss*(indat_res1[nColRes*i+4+is]-indat_res1[nColRes*i+3+is])+(cc*cc-ss*ss)*indat_res1[nColRes*i+6+is];
				   indat_res1[nColRes*i+3+is]=tem1;indat_res1[nColRes*i+4+is]=tem2;
				  }
			   }
			}
		 }
//
	  }
   }
 else if(Spherframe1->Checked)
   {for(i=0;i<indat_npoin;i++)
	   {rad=sqrt(indat_bc1[NDF*i]*indat_bc1[NDF*i]+indat_bc1[NDF*i+1]*indat_bc1[NDF*i+1]+indat_bc1[NDF*i+2]*indat_bc1[NDF*i+2]);
		if(rad>TOL)
		  {if(sqrt(indat_bc1[NDF*i]*indat_bc1[NDF*i]+indat_bc1[NDF*i+1]*indat_bc1[NDF*i+1])>TOL)
			 {ssp=indat_bc1[NDF*i+2]/rad;
			  ccp=sqrt(indat_bc1[NDF*i]*indat_bc1[NDF*i]+indat_bc1[NDF*i+1]*indat_bc1[NDF*i+1])/rad;
			  ss=indat_bc1[NDF*i+1]/(rad*ccp);
			  cc=indat_bc1[NDF*i]/(rad*ccp);
			  tt11=indat_bc1[NDF*i]/rad;tt21=indat_bc1[NDF*i+1]/rad;tt31=ssp;
			  tt12= -ssp*ss*tt31-ccp*tt21;tt22= ccp*tt11+ssp*cc*tt31;tt32= -ssp*cc*tt21+ssp*ss*tt11;
			  tt13= -ssp*cc;tt23= -ssp*ss;tt33=ccp;
			 }
		   else {tt11=tt21=0.;tt31=1.;tt12=0.;tt22=1.;tt32=0.;tt13= -1.;tt23=tt33=0.;}
		   tem1=tt11*indat_res1[nColRes*i]+tt21*indat_res1[nColRes*i+1]+tt31*indat_res1[nColRes*i+2];
		   tem2=tt12*indat_res1[nColRes*i]+tt22*indat_res1[nColRes*i+1]+tt32*indat_res1[nColRes*i+2];
		   tem3=tt13*indat_res1[nColRes*i]+tt23*indat_res1[nColRes*i+1]+tt33*indat_res1[nColRes*i+2];
		   indat_res1[nColRes*i]=tem1;indat_res1[nColRes*i+1]=tem2;indat_res1[nColRes*i+2]=tem3;
		   if(fl_feres==1)
			 {tem1=tt11*(tt11*indat_res1[nColRes*i+3]+tt21*indat_res1[nColRes*i+6]+tt31*indat_res1[nColRes*i+7])+
			   tt21*(tt11*indat_res1[nColRes*i+6]+tt21*indat_res1[nColRes*i+4]+tt31*indat_res1[nColRes*i+8])+
			   tt31*(tt11*indat_res1[nColRes*i+7]+tt21*indat_res1[nColRes*i+8]+tt31*indat_res1[nColRes*i+5]);
			  tem2=tt12*(tt12*indat_res1[nColRes*i+3]+tt22*indat_res1[nColRes*i+6]+tt32*indat_res1[nColRes*i+7])+
			   tt22*(tt12*indat_res1[nColRes*i+6]+tt22*indat_res1[nColRes*i+4]+tt32*indat_res1[nColRes*i+8])+
			   tt32*(tt12*indat_res1[nColRes*i+7]+tt22*indat_res1[nColRes*i+8]+tt32*indat_res1[nColRes*i+5]);
			  tem3=tt13*(tt13*indat_res1[nColRes*i+3]+tt23*indat_res1[nColRes*i+6]+tt33*indat_res1[nColRes*i+7])+
			   tt23*(tt13*indat_res1[nColRes*i+6]+tt23*indat_res1[nColRes*i+4]+tt33*indat_res1[nColRes*i+8])+
			   tt33*(tt13*indat_res1[nColRes*i+7]+tt23*indat_res1[nColRes*i+8]+tt33*indat_res1[nColRes*i+5]);
			  tem4=tt11*(tt12*indat_res1[nColRes*i+3]+tt22*indat_res1[nColRes*i+6]+tt32*indat_res1[nColRes*i+7])+
			   tt21*(tt12*indat_res1[nColRes*i+6]+tt22*indat_res1[nColRes*i+4]+tt32*indat_res1[nColRes*i+8])+
			   tt31*(tt12*indat_res1[nColRes*i+7]+tt22*indat_res1[nColRes*i+8]+tt32*indat_res1[nColRes*i+5]);
			  tem5=tt11*(tt13*indat_res1[nColRes*i+3]+tt23*indat_res1[nColRes*i+6]+tt33*indat_res1[nColRes*i+7])+
				   tt21*(tt13*indat_res1[nColRes*i+6]+tt23*indat_res1[nColRes*i+4]+tt33*indat_res1[nColRes*i+8])+
			   tt31*(tt13*indat_res1[nColRes*i+7]+tt23*indat_res1[nColRes*i+8]+tt33*indat_res1[nColRes*i+5]);
			  tem6=tt12*(tt13*indat_res1[nColRes*i+3]+tt23*indat_res1[nColRes*i+6]+tt33*indat_res1[nColRes*i+7])+
			   tt22*(tt13*indat_res1[nColRes*i+6]+tt23*indat_res1[nColRes*i+4]+tt33*indat_res1[nColRes*i+8])+
			   tt32*(tt13*indat_res1[nColRes*i+7]+tt23*indat_res1[nColRes*i+8]+tt33*indat_res1[nColRes*i+5]);
			  indat_res1[nColRes*i+3]=tem1;indat_res1[nColRes*i+4]=tem2;indat_res1[nColRes*i+5]=tem3;
			  indat_res1[nColRes*i+6]=tem4;indat_res1[nColRes*i+7]=tem5;indat_res1[nColRes*i+8]=tem6;
			 }
		   else if(fl_feres==4)
			 {for(is=0;is<7;is=is+6)
				{tem1=tt11*(tt11*indat_res1[nColRes*i+3+is]+tt21*indat_res1[nColRes*i+6+is]+tt31*indat_res1[nColRes*i+7+is])+
					  tt21*(tt11*indat_res1[nColRes*i+6+is]+tt21*indat_res1[nColRes*i+4+is]+tt31*indat_res1[nColRes*i+8+is])+
					  tt31*(tt11*indat_res1[nColRes*i+7+is]+tt21*indat_res1[nColRes*i+8+is]+tt31*indat_res1[nColRes*i+5+is]);
				 tem2=tt12*(tt12*indat_res1[nColRes*i+3+is]+tt22*indat_res1[nColRes*i+6+is]+tt32*indat_res1[nColRes*i+7+is])+
					  tt22*(tt12*indat_res1[nColRes*i+6+is]+tt22*indat_res1[nColRes*i+4+is]+tt32*indat_res1[nColRes*i+8+is])+
					  tt32*(tt12*indat_res1[nColRes*i+7+is]+tt22*indat_res1[nColRes*i+8+is]+tt32*indat_res1[nColRes*i+5+is]);
				 tem3=tt13*(tt13*indat_res1[nColRes*i+3+is]+tt23*indat_res1[nColRes*i+6+is]+tt33*indat_res1[nColRes*i+7+is])+
					  tt23*(tt13*indat_res1[nColRes*i+6+is]+tt23*indat_res1[nColRes*i+4+is]+tt33*indat_res1[nColRes*i+8+is])+
					  tt33*(tt13*indat_res1[nColRes*i+7+is]+tt23*indat_res1[nColRes*i+8+is]+tt33*indat_res1[nColRes*i+5+is]);
				 tem4=tt11*(tt12*indat_res1[nColRes*i+3+is]+tt22*indat_res1[nColRes*i+6+is]+tt32*indat_res1[nColRes*i+7+is])+
					  tt21*(tt12*indat_res1[nColRes*i+6+is]+tt22*indat_res1[nColRes*i+4+is]+tt32*indat_res1[nColRes*i+8+is])+
					  tt31*(tt12*indat_res1[nColRes*i+7+is]+tt22*indat_res1[nColRes*i+8+is]+tt32*indat_res1[nColRes*i+5+is]);
				 tem5=tt11*(tt13*indat_res1[nColRes*i+3+is]+tt23*indat_res1[nColRes*i+6+is]+tt33*indat_res1[nColRes*i+7+is])+
					  tt21*(tt13*indat_res1[nColRes*i+6+is]+tt23*indat_res1[nColRes*i+4+is]+tt33*indat_res1[nColRes*i+8+is])+
					  tt31*(tt13*indat_res1[nColRes*i+7+is]+tt23*indat_res1[nColRes*i+8+is]+tt33*indat_res1[nColRes*i+5+is]);
				 tem6=tt12*(tt13*indat_res1[nColRes*i+3+is]+tt23*indat_res1[nColRes*i+6+is]+tt33*indat_res1[nColRes*i+7+is])+
					  tt22*(tt13*indat_res1[nColRes*i+6+is]+tt23*indat_res1[nColRes*i+4+is]+tt33*indat_res1[nColRes*i+8+is])+
					  tt32*(tt13*indat_res1[nColRes*i+7+is]+tt23*indat_res1[nColRes*i+8+is]+tt33*indat_res1[nColRes*i+5+is]);
				 indat_res1[nColRes*i+3+is]=tem1;indat_res1[nColRes*i+4+is]=tem2;indat_res1[nColRes*i+5+is]=tem3;
				 indat_res1[nColRes*i+6+is]=tem4;indat_res1[nColRes*i+7+is]=tem5;indat_res1[nColRes*i+8+is]=tem6;
				}
			 }
		  }
	   }
   }
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Form1Paint(TObject *Sender)
// Convention: iPaintyesno=ab
//   where   a=0 ->Painted       and   b=0 ->Find all GID facets
//             1 ->Unpainted             1 ->Surface facets only
//
// iplotType=2      Use element-by-element plot authorization (base.arELEM)
//          =other  Use GID authorization                     (base.arGID, but actually arGID is not in base.XXX now)
//
// iplot_flag=other ->Banner
//    The following require  iPaintyesno=10 (ie. exterior facets known)
// iplot_flag=1     ->Margin_plot ->iCircleplot=0                                      ->Wireframe
//                                ->iCircleplot=other ->iCullyesno=0     ->Cull facets ->Paint
//                                                    ->iCullyesno=other ->Use facets  ->Paint
// iplot_flag=2     ->Scale_plot  ->iCircleplot=0                                      ->Wireframe
//                                ->iCircleplot=other ->iCullyesno=0     ->Cull facets ->Paint
//                                                    ->iCullyesno=other ->Use facets  ->Paint
{
 TPoint ptDraw[MAXPOINTS];
// int *edgFace1=NULL;
 long ntranche=8
// ,*arbFace1=NULL,*rbTem1=NULL
;
//MEMORYSTATUS ms;ms.dwLength=sizeof(MEMORYSTATUS);
// Canvas->Brush->Color=clWhite;Canvas->FillRect(Rect(0,0,ClientWidth,ClientHeight));
///////////////////////////////////////
if(iBackGroundColor==1)     {Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clBlack;
							 tBitmap->Canvas->Brush->Color=clWhite;tBitmap->Canvas->Pen->Color=clBlack;
							}
else if(iBackGroundColor==2){Canvas->Brush->Color=clRed;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Brush->Color=clRed;tBitmap->Canvas->Pen->Color=clWhite;
							}
else if(iBackGroundColor==3){Canvas->Brush->Color=clGreen;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Brush->Color=clGreen;tBitmap->Canvas->Pen->Color=clWhite;
							}
else if(iBackGroundColor==4){Canvas->Brush->Color=clBlue;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Brush->Color=clBlue;tBitmap->Canvas->Pen->Color=clWhite;
							}
else                        {Canvas->Brush->Color=clBlack;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Brush->Color=clBlack;tBitmap->Canvas->Pen->Color=clWhite;
							}
/////////
//tBitmap->Flush();
//Form1->Flush();
/////////
///////////////////////////////////////

 Canvas->FillRect(Rect(0,0,Width,Height));

 tBitmap->Width = Width;tBitmap->Height = Height;
 tBitmap->Canvas->FillRect(Rect(0,0,tBitmap->Width,tBitmap->Height));

// Form1->Canvas->Draw(0,0,tBitmap);


////Form1->Canvas->Draw(0,0,tBitmap); //This FOX Graphics idea of pre-erasing the screen had no effect on "jumpiness."
 if(iplotflag==1)
   {if(iCircleplot != 0 && iPaintyesno/10==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must paint first->View/Paint",L"Halt",MB_OK);iCircleplot=0;}
	Image1->Visible=false;

//honk<<" HeroB\n";
	FDpmargin(indat.npoin,indat.nelt,indat.nop1,indat.matno,indat.c1,nDefects,CrackCor,trans_op,prod_op);
	if(iCircleplot==0)FDwireplot(indat.nelt,indat.nop1,indat.matno,indat.c1);
	else if(iCircleplot==1)
	  {if(iCullyesno==0){
/////////////////////////////////
						 if(iplotType==2){//nFacets=FDcullfacet_arE_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM);
//										  GlobalMemoryStatus(&ms);
////honk<<ms.dwTotalPhys<<" TPhys0 "<<ms.dwAvailPhys<<" "<<ms.dwAvailPhys/4<<"\n";
////honk<<ms.dwTotalVirtual<<" TVirt0 "<<ms.dwAvailVirtual<<" "<<ms.dwAvailVirtual/4<<"\n";
//										  if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
											 arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
											 rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
											 nFacets=FDcullfacet_arEc(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet,rbTemp);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
											 FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//											}
//										  else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//											 arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//											 FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//											 delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//											}
//										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}
										  if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
										 }
						 else {
/////////////////////////////////
//						 nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
//						 GlobalMemoryStatus(&ms);
//						 if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//						   {
//							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];

honk<<" HeroC\n";
							arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
							rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);

honk<<" HeroD\n";
							nFacets=FDcullfacetc(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet,rbTemp);

honk<<" Hero0\n";
////							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
							FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);

honk<<" Hero1\n";//if(1==1)exit(0);
//						   }
//						 else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//						   {
//							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
//							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//							arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//							FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//							delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//						   }
//						 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}
						 if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;

honk<<" Hero2\n";
////////////////////////////////
							  }
////////////////////////////////
						}
	   if(ApperMetal->Checked)FDmetal(nFacets,arbFacet);
	   if(ApperShade->Checked){if(ShowFEMesh->Checked)FDshadeplot(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);else FDshadeplotnm(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);}
	   else {if(ShowFEMesh->Checked){if(section_frame)FDpaintplots(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,indat.nfsect,indat.fsect);
									 else {
honk<<" Interim2\n";
										   FDpaintplot(1,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
										  }
									}
			 else FDpaintplotnm(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,edgFacet);
			}
//	   if(nDefects && iSpecCrack==-1)FDplotdefects(nDefects,CrackCor,bCrackAng);
/////////////
//	   if(iPersistVFT)persistVFT();
//	   if(iPersistVFT)persistVFT1(0,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT-10*(iPersistVFT/10))persistVFT();
////	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(wp.nWeldPass-1,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(iPersistVFT/10 -1,iPersistVFT/10 -1); //EFP 1/21/2011

//honk<<" Hero3\n";
	   if((iPersistVFT-100*(iPersistVFT/100))/10 && wp.nWeldPass)persistVFT1a(wp.nWeldPass,wp.util_arr); //EFP 1/27/2011

//honk<<" Hero4\n";
	   if(iPersistVFT/100 && wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
//	   if(wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
/////////////
	   if(ANNOTcount)annot_render(ANNOTcount,AnnotIndex,AnnotArr0,AnnotArr1,AnnotArr2,AnnotArr3,AnnotArr4,AnnotArr5,AnnotArr6,AnnotArr7,AnnotArr8,AnnotArr9);
	   if(ANLINcount)anLIN_render(ANLINcount,AnLINIndex);
	  }
	else
	  {if(iCullyesno==0){
/////////////////////////////////
						 if(iplotType==2){//nFacets=FDcullfacet_arE_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM);
//										  GlobalMemoryStatus(&ms);
//										  if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
											 arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
											 rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
											 nFacets=FDcullfacet_arEc(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet,rbTemp);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
											 FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//											}
//										  else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//											 arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//											 FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//											 delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//											}
//										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}
										  if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
										 }
						 else {
/////////////////////////////////

//						 nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
//						 GlobalMemoryStatus(&ms);
//						 if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//						   {
//							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
							arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
							rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
							nFacets=FDcullfacetc(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet,rbTemp);
//							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
							FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//						   }
//						 else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//						   {
// 							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
//							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//							arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//							FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//							delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//						   }
//						 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}

//                         try {arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];}
//                         catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Insufficient cull dynamic memory","Halt",MB_OK);exit(0);}
//                         FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
//                         FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//                         try {arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//                              FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//                              delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//                             }
//                         catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Insufficient FDsort_low dynamic memory","Halt",MB_OK);exit(0);}

						 if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
////////////////////////////////
							  }
////////////////////////////////


						}
	   if(section_frame)FDcontourplots(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet,indat.nfsect,indat.fsect);
	   else FDcontourplot(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet);
	   FDlegend();
//	   if(nDefects && iSpecCrack==-1)FDplotdefects(nDefects,CrackCor,bCrackAng);
/////////////
//	   if(iPersistVFT)persistVFT();
//	   if(iPersistVFT)persistVFT1(0,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT-10*(iPersistVFT/10))persistVFT();
////	   if(iPersistVFT/10)persistVFT1(0,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(wp.nWeldPass-1,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(iPersistVFT/10 -1,iPersistVFT/10 -1); //EFP 1/21/2011
	   if((iPersistVFT-100*(iPersistVFT/100))/10 && wp.nWeldPass)persistVFT1a(wp.nWeldPass,wp.util_arr); //EFP 1/27/2011
	   if(iPersistVFT/100 && wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
//	   if(wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
/////////////
	   if(ANNOTcount)annot_render(ANNOTcount,AnnotIndex,AnnotArr0,AnnotArr1,AnnotArr2,AnnotArr3,AnnotArr4,AnnotArr5,AnnotArr6,AnnotArr7,AnnotArr8,AnnotArr9);
	   if(ANLINcount)anLIN_render(ANLINcount,AnLINIndex);
	  }
	axis_plotXYZ(ClientWidth,ClientHeight);
   }
 else if(iplotflag==2)
   {if(iCircleplot != 0 && iPaintyesno/10==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must paint first->View/Paint",L"Halt",MB_OK);iCircleplot=0;}
	Image1->Visible=false;
	FDpscale(indat.npoin,indat.c1,nDefects,CrackCor,prod_op);
	if(iCircleplot==0)FDwireplot(indat.nelt,indat.nop1,indat.matno,indat.c1);
	else if(iCircleplot==1)
	  {if(iCullyesno==0){
/////////////////////////////////
						 if(iplotType==2){//nFacets=FDcullfacet_arE_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM);
//										  GlobalMemoryStatus(&ms);
//										  if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
											 arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
											 rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
											 nFacets=FDcullfacet_arEc(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet,rbTemp);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
											 FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//											}
//										  else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//											 arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//											 FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//											 delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//											}
//										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}
										  if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
										 }
						 else {
/////////////////////////////////

//						 nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
//						 GlobalMemoryStatus(&ms);
//						 if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//						   {
//							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
							arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
							rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
							nFacets=FDcullfacetc(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet,rbTemp);
//							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
							FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//						   }
//						 else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//						   {
//							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
//							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//							arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//							FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//							delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//						   }
//						 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}

//                         try {arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];}
//                         catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Insufficient cull dynamic memory","Halt",MB_OK);exit(0);}
//                         FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
//                         FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//                         try {arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//                              FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//                              delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//                             }
//                         catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Insufficient FDsort_low dynamic memory","Halt",MB_OK);exit(0);}

						 if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
////////////////////////////////
							  }
////////////////////////////////


						}
	   if(ApperMetal->Checked)FDmetal(nFacets,arbFacet);
	   if(ApperShade->Checked){if(ShowFEMesh->Checked)FDshadeplot(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);else FDshadeplotnm(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);}
	   else {if(ShowFEMesh->Checked){if(section_frame)FDpaintplots(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,indat.nfsect,indat.fsect);
									 else FDpaintplot(1,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
									}
			 else FDpaintplotnm(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,edgFacet);
			}
//	   if(nDefects && iSpecCrack==-1)FDplotdefects(nDefects,CrackCor,bCrackAng);
/////////////
//	   if(iPersistVFT)persistVFT();
//	   if(iPersistVFT)persistVFT1(0,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT-10*(iPersistVFT/10))persistVFT();
////	   if(iPersistVFT/10)persistVFT1(0,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(wp.nWeldPass-1,wp.nWeldPass-1); //EFP 1/20/2011
/////	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(iPersistVFT/10 -1,iPersistVFT/10 -1); //EFP 1/21/2011
	   if((iPersistVFT-100*(iPersistVFT/100))/10 && wp.nWeldPass)persistVFT1a(wp.nWeldPass,wp.util_arr); //EFP 1/27/2011
	   if(iPersistVFT/100 && wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
//	   if(wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
/////////////
	   if(ANNOTcount)annot_render(ANNOTcount,AnnotIndex,AnnotArr0,AnnotArr1,AnnotArr2,AnnotArr3,AnnotArr4,AnnotArr5,AnnotArr6,AnnotArr7,AnnotArr8,AnnotArr9);
	   if(ANLINcount)anLIN_render(ANLINcount,AnLINIndex);
	  }
	else
	  {if(iCullyesno==0){
/////////////////////////////////
						 if(iplotType==2){//nFacets=FDcullfacet_arE_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM);
//										  GlobalMemoryStatus(&ms);
//										  if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
											 arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
											 rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
											 nFacets=FDcullfacet_arEc(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet,rbTemp);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
											 FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//											}
//										  else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//											{
//											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
//											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//											 arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//											 FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//											 delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//											}
//										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}
										  if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
										 }
						 else {
/////////////////////////////////

//						 nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
//						 GlobalMemoryStatus(&ms);
//						 if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//						   {
//							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
							arbFacet=new long[4*base.nelt]; //Use approx storage instead of computing nFacets exactly EFP 1/02/2012
							rbTemp=new long[4*base.nelt];edgFacet=new int[4*base.nelt];mutFacet=new float[4*base.nelt];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
							nFacets=FDcullfacetc(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet,rbTemp);
//							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
							FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//						   }
//						 else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
//						   {
//							arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
//							FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
//							FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//							arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//							FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//							delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//						   }
//						 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}

//                         try {arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];}
//                         catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Insufficient cull dynamic memory","Halt",MB_OK);exit(0);}
//                         FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
//                         FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//                         try {arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//                              FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//                              delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//                             }
//                         catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Insufficient FDsort_low dynamic memory","Halt",MB_OK);exit(0);}

						 if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
////////////////////////////////
							  }
////////////////////////////////


						}
	   if(section_frame)FDcontourplots(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet,indat.nfsect,indat.fsect);
	   else FDcontourplot(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet);
	   FDlegend();
//	   if(nDefects && iSpecCrack==-1)FDplotdefects(nDefects,CrackCor,bCrackAng);
/////////////
//	   if(iPersistVFT)persistVFT();
//	   if(iPersistVFT)persistVFT1(0,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT-10*(iPersistVFT/10))persistVFT();
////	   if(iPersistVFT/10)persistVFT1(0,wp.nWeldPass-1); //EFP 1/20/2011
//	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(wp.nWeldPass-1,wp.nWeldPass-1); //EFP 1/20/2011
/////	   if(iPersistVFT/10 && wp.nWeldPass)persistVFT1(iPersistVFT/10 -1,iPersistVFT/10 -1); //EFP 1/21/2011
//	   if(wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
	   if((iPersistVFT-100*(iPersistVFT/100))/10 && wp.nWeldPass)persistVFT1a(wp.nWeldPass,wp.util_arr); //EFP 1/27/2011
	   if(iPersistVFT/100 && wp.nWeldPass)persistVFT2(wp.nWeldPass,wp.util_arr);
/////////////
	   if(ANNOTcount)annot_render(ANNOTcount,AnnotIndex,AnnotArr0,AnnotArr1,AnnotArr2,AnnotArr3,AnnotArr4,AnnotArr5,AnnotArr6,AnnotArr7,AnnotArr8,AnnotArr9);
	   if(ANLINcount)anLIN_render(ANLINcount,AnLINIndex);
	  }
	axis_plotXYZ(ClientWidth,ClientHeight);
   }
 else {
//	   ran_banner();

// Start from VFTgen
	   if(!base.nop1){
Image1->Visible=true; //EFP 12/04/2009

						ptDraw[0].x=0;ptDraw[0].y=ClientHeight;
						ptDraw[1].x=(ClientWidth-Panel1->Width)/2;ptDraw[1].y=ClientHeight/2;
						ptDraw[2].x=ClientWidth-Panel1->Width;ptDraw[2].y=ClientHeight;
						tBitmap->Canvas->Brush->Color=clYellow;tBitmap->Canvas->Pen->Color=clYellow;
						tBitmap->Canvas->Polygon(ptDraw,3-1);
					 }
// End from VFTgen
	  }

//for(long ibs=0;ibs<10;ibs++){for(long ibz=0;ibz<1024*1024;ibz++){float bxx=float(ibz);if(bxx>10.)bxx=10.;float byy=cos(bxx)*exp(-bxx);}}
// Canvas->FillRect(Rect(0,0,Width,Height));

// Sleep(500);
 Form1->Canvas->Draw(0,0,tBitmap);

//// Form1->Canvas->FillRect(Rect(0,0,tBitmap->Width/2,tBitmap->Height/2));
 cxWidth0=ClientWidth;cyHeight0=ClientHeight;

//for(long ibs=0;ibs<3;ibs++){for(long ibz=0;ibz<1024*1024;ibz++){float bxx=float(ibz);if(bxx>10.)bxx=10.;float byy=cos(bxx)*exp(-bxx);}}

}
//---------------------------------------------------------------------------
void TForm1::axis_plot_init()
{int ic=0;ap.isw=0; // Select xyz or 123 (not used yet)
 ic=0;ap.x[ic]=ap.y[ic]=ap.z[ic]=0.;
 ic=1;ap.x[ic]=float(min(ClientWidth,ClientHeight))/16.;ap.y[ic]=ap.z[ic]=0.;
 ic=2;ap.x[ic]=0.;ap.y[ic]= float(min(ClientWidth,ClientHeight))/16.;ap.z[ic]=0.;
 ic=3;ap.x[ic]=ap.y[ic]=0.;ap.z[ic]= float(min(ClientWidth,ClientHeight))/16.;
 ic=4;ap.x[ic]=(float(min(ClientWidth,ClientHeight)) +float(min(ClientWidth,ClientHeight))/3.)/16.;ap.y[ic]=ap.z[ic]=0.;
 ic=5;ap.x[ic]=0.;ap.y[ic]= (float(min(ClientWidth,ClientHeight)) +float(min(ClientWidth,ClientHeight))/3.)/16.;ap.z[ic]=0.;
 ic=6;ap.x[ic]=ap.y[ic]=0.;ap.z[ic]= (float(min(ClientWidth,ClientHeight)) +float(min(ClientWidth,ClientHeight))/3.)/16.;
}
//---------------------------------------------------------------------------
void TForm1::axis_plotXYZ(int CWidth,int CHeight)
// Simple axis plot    EFP 9/17/2010
{int xloc=CWidth/16,yloc=CHeight/16;

if(iBackGroundColor==1)
//     {Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clBlack;Canvas->SetTextColor(clBlack);
							 tBitmap->Canvas->Pen->Color=clBlack;
//							 tBitmap->Canvas->SetTextColor(clBlack);}
else if(iBackGroundColor==2)
//{Canvas->Brush->Color=clRed;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Pen->Color=clWhite;
//							}
else if(iBackGroundColor==3)
//{Canvas->Brush->Color=clGreen;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Pen->Color=clWhite;
//							}
else if(iBackGroundColor==4)
//{Canvas->Brush->Color=clBlue;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Pen->Color=clWhite;
//							}
else
//                        {Canvas->Brush->Color=clBlack;Canvas->Pen->Color=clWhite;
							 tBitmap->Canvas->Pen->Color=clWhite;
//							}

 tBitmap->Canvas->Pen->Width=1;//TBD: Shift up by a small amount because Z gets lost for ZX_rot() EFP 3/22/2012
 tBitmap->Canvas->MoveTo(xloc+int(ap.x[1] +0.5),CHeight-yloc- int(ap.y[1]+0.5));
 tBitmap->Canvas->LineTo(xloc+int(ap.x[0] +0.5),CHeight-yloc- int(ap.y[0]+0.5));
 tBitmap->Canvas->LineTo(xloc+int(ap.x[2] +0.5),CHeight-yloc- int(ap.y[2]+0.5));
 tBitmap->Canvas->MoveTo(xloc+int(ap.x[0] +0.5),CHeight-yloc- int(ap.y[0]+0.5));
 tBitmap->Canvas->LineTo(xloc+int(ap.x[3] +0.5),CHeight-yloc- int(ap.y[3]+0.5));
// tBitmap->Canvas->TextOut(xloc+int(ap.x[4] +0.5),CHeight-yloc- int(ap.y[4]+0.5),"x");//Failed
 tBitmap->Canvas->MoveTo(xloc+int(ap.x[4] +0.5)-4,CHeight-yloc- int(ap.y[4]+0.5)-4);//Character x
 tBitmap->Canvas->LineTo(xloc+int(ap.x[4] +0.5)+4,CHeight-yloc- int(ap.y[4]+0.5)+4);
 tBitmap->Canvas->MoveTo(xloc+int(ap.x[4] +0.5)-4,CHeight-yloc- int(ap.y[4]+0.5)+4);
 tBitmap->Canvas->LineTo(xloc+int(ap.x[4] +0.5)+4,CHeight-yloc- int(ap.y[4]+0.5)-4);
// tBitmap->Canvas->TextOut(xloc+int(ap.x[5] +0.5),CHeight-yloc- int(ap.y[5]+0.5),"y");
 tBitmap->Canvas->MoveTo(xloc+int(ap.x[5] +0.5)-4,CHeight-yloc- int(ap.y[5]+0.5)-4);//Character y
 tBitmap->Canvas->LineTo(xloc+int(ap.x[5] +0.5),CHeight-yloc- int(ap.y[5]+0.5));
 tBitmap->Canvas->LineTo(xloc+int(ap.x[5] +0.5)+4,CHeight-yloc- int(ap.y[5]+0.5)-4);
 tBitmap->Canvas->MoveTo(xloc+int(ap.x[5] +0.5),CHeight-yloc- int(ap.y[5]+0.5));
 tBitmap->Canvas->LineTo(xloc+int(ap.x[5] +0.5),CHeight-yloc- int(ap.y[5]+0.5)+4);
// tBitmap->Canvas->TextOut(xloc+int(ap.x[6] +0.5),CHeight-yloc- int(ap.y[6]+0.5),"z");
 tBitmap->Canvas->MoveTo(xloc+int(ap.x[6] +0.5)-4,CHeight-yloc- int(ap.y[6]+0.5)-4);//Character z
 tBitmap->Canvas->LineTo(xloc+int(ap.x[6] +0.5)+4,CHeight-yloc- int(ap.y[6]+0.5)-4);
 tBitmap->Canvas->LineTo(xloc+int(ap.x[6] +0.5)-4,CHeight-yloc- int(ap.y[6]+0.5)+4);
 tBitmap->Canvas->LineTo(xloc+int(ap.x[6] +0.5)+4,CHeight-yloc- int(ap.y[6]+0.5)+4);
}
//---------------------------------------------------------------------------
void TForm1::FDpmargin(long indat_npoin,long indat_nelt,long indat_nop1[],long indat_matno[],float indat_c1[],long nDefects,float CrackCor[],float trans_op[],float prod_op[][3])
// Global NDF,MXNPEI,etc
{float xdiff=0.,ydiff=0.,gdiff=1.E38,xmax=0.,ymax=0.,zmax=0.,xmin=0.,ymin=0.,zmin=0.
//,t1=0.,t2=0.,t3=0.
;
///////////// Testing EFP 8/30/2011
// float test1=0.,test2=0.,test3=0.;
/////////////
 long in=0,i=0,eltype=0,bscode=0,node=0,tf3=1000,tf5=100000,tf7=10000000;
 xmax= -1.E28;ymax= -1.E28;zmax= -1.E28;xmin=  1.E28;ymin=  1.E28;zmin=  1.E28;
 for(i=0;i<indat_nelt;i++){
	eltype=indat_matno[i]/tf7;bscode=(indat_matno[i]-eltype*tf7)/tf5;node=(indat_matno[i]-eltype*tf7-bscode*tf5)/tf3;
	for(in=0;in<node;in++){
	   if(xmin>indat_c1[NDF*indat_nop1[MXNPEI*i+in]  ])xmin=indat_c1[NDF*indat_nop1[MXNPEI*i+in]  ];
	   if(ymin>indat_c1[NDF*indat_nop1[MXNPEI*i+in]+1])ymin=indat_c1[NDF*indat_nop1[MXNPEI*i+in]+1];
	   if(zmin>indat_c1[NDF*indat_nop1[MXNPEI*i+in]+2])zmin=indat_c1[NDF*indat_nop1[MXNPEI*i+in]+2];
	   if(xmax<indat_c1[NDF*indat_nop1[MXNPEI*i+in]  ])xmax=indat_c1[NDF*indat_nop1[MXNPEI*i+in]  ];
	   if(ymax<indat_c1[NDF*indat_nop1[MXNPEI*i+in]+1])ymax=indat_c1[NDF*indat_nop1[MXNPEI*i+in]+1];
	   if(zmax<indat_c1[NDF*indat_nop1[MXNPEI*i+in]+2])zmax=indat_c1[NDF*indat_nop1[MXNPEI*i+in]+2];
					  }
	}
//
 xdiff=float(ClientWidth)/(xmax-xmin);ydiff=float(ClientHeight)/(ymax-ymin);
 if(gdiff>xdiff)gdiff=xdiff;if(gdiff>ydiff)gdiff=ydiff;gdiff=0.95*gdiff;
glGdiff=glGdiff*gdiff;
//honk<<glGdiff<<" glGdiff in FDpmargin\n";
//honk<<xmax<<" "<<xmin<<" MMMM "<<ymax<<" "<<ymin<<" LLLL "<<zmax<<" "<<zmin<<"\n";
//honk<<xdiff<<" "<<ydiff<<" "<<gdiff<<" xyg_diff "<<ClientWidth<<" "<<ClientHeight<<"\n";
 for(i=0;i<indat_npoin;i++)
	{indat_c1[NDF*i  ]=(indat_c1[NDF*i  ]-0.5*(xmax+xmin))*gdiff +0.5*(float)ClientWidth;
	 indat_c1[NDF*i+1]=(indat_c1[NDF*i+1]-0.5*(ymax+ymin))*gdiff +0.5*(float)ClientHeight;
	 indat_c1[NDF*i+2]=(indat_c1[NDF*i+2]-0.5*(zmax+zmin))*gdiff;
	}
if(nDefects)
{for(long iq=0;iq<nDefects;iq++)
 {for(long ic=0;ic<3;ic++)
   {CrackCor[9*iq+3*ic+0]=(CrackCor[9*iq+3*ic+0]-0.5*(xmax+xmin))*gdiff +0.5*(float)ClientWidth;
	CrackCor[9*iq+3*ic+1]=(CrackCor[9*iq+3*ic+1]-0.5*(ymax+ymin))*gdiff +0.5*(float)ClientHeight;
	CrackCor[9*iq+3*ic+2]=(CrackCor[9*iq+3*ic+2]-0.5*(zmax+zmin))*gdiff;
   }
 }
}
//// t1=0.5*(xmax+xmin)+(trans_op[0]-0.5*(float)ClientWidth)/gdiff;
//// t2=0.5*(ymax+ymin)+(trans_op[1]-0.5*(float)ClientHeight)/gdiff;
//// t3=0.5*(zmax+zmin)+trans_op[2]/gdiff;
// t1=0.5*(xmax+xmin)*gdiff+(trans_op[0]-0.5*(float)ClientWidth);
// t2=0.5*(ymax+ymin)*gdiff+(trans_op[1]-0.5*(float)ClientHeight);
// t3=0.5*(zmax+zmin)*gdiff+trans_op[2];

//honk<<t1<<" "<<t2<<" "<<t3<<" t123\n";
//honk<<prod_op[0][0]<<" "<<prod_op[0][1]<<" "<<prod_op[0][2]<<" Prod00000\n";
//honk<<prod_op[1][0]<<" "<<prod_op[1][1]<<" "<<prod_op[1][2]<<" Prod11111\n";
//honk<<prod_op[2][0]<<" "<<prod_op[2][1]<<" "<<prod_op[2][2]<<" Prod22222\n";
//honk<<trans_op[0]<<" "<<trans_op[0]<<" "<<trans_op[2]<<" TRANpre\n";

// trans_op[0]=trans_op[0]+prod_op[0][0]*t1+prod_op[0][1]*t2+prod_op[0][2]*t3;
// trans_op[1]=trans_op[1]+prod_op[1][0]*t1+prod_op[1][1]*t2+prod_op[1][2]*t3;
//// trans_op[2]=trans_op[2]+prod_op[2][0]*t1+prod_op[2][1]*t2+prod_op[2][2]*t3;
// test3=prod_op[2][2]*t3;
// test2=prod_op[2][1]*t2;
// test1=prod_op[2][0]*t1;
// trans_op[2]=trans_op[2]+test1+test2+test3;

// trans_op[0]=prod_op[0][0]*t1+prod_op[0][1]*t2+prod_op[0][2]*t3;
// trans_op[1]=prod_op[1][0]*t1+prod_op[1][1]*t2+prod_op[1][2]*t3;
// trans_op[2]=prod_op[2][0]*t1+prod_op[2][1]*t2+prod_op[2][2]*t3;
 trans_op[0]=0.5*(float)ClientWidth;
 trans_op[1]=0.5*(float)ClientHeight;
 trans_op[2]=0.;
//honk<<trans_op[0]<<" "<<trans_op[0]<<" "<<trans_op[2]<<" TRANpst\n\n";

// prod_op[0][0]=prod_op[0][0]/gdiff;prod_op[0][1]=prod_op[0][1]/gdiff;prod_op[0][2]=prod_op[0][2]/gdiff;
// prod_op[1][0]=prod_op[1][0]/gdiff;prod_op[1][1]=prod_op[1][1]/gdiff;prod_op[1][2]=prod_op[1][2]/gdiff;
// prod_op[2][0]=prod_op[2][0]/gdiff;prod_op[2][1]=prod_op[2][1]/gdiff;prod_op[2][2]=prod_op[2][2]/gdiff;
 gl_indatMedian[0]=0.5*(float)ClientWidth;gl_indatMedian[1]=0.5*(float)ClientHeight;gl_indatMedian[2]=0.;
}

//---------------------------------------------------------------------------
void TForm1::FDpscale(long indat_npoin,float indat_c1[],long nDefects,float CrackCor[],float prod_op[][3])
// Global NDF,etc
{long i=0;float gdiff=0.,hscale=0.,vscale=0.;
 hscale=float(ClientWidth)/float(cxWidth0);
 vscale=float(ClientHeight)/float(cyHeight0);
 if(hscale>vscale)gdiff=vscale;else gdiff=hscale;
glGdiff=glGdiff*gdiff;
// honk<<hscale<<" "<<vscale<<" FDpscale "<<gdiff<<"\n";
//honk<<glGdiff<<" glGdiff in FDpscale\n";

 for(i=0;i<NDF*indat_npoin;i++)indat_c1[i]=indat_c1[i]*gdiff;
if(nDefects)
{for(long iq=0;iq<nDefects;iq++)
 {for(long ic=0;ic<3;ic++)
   {CrackCor[9*iq+3*ic+0]=CrackCor[9*iq+3*ic+0]*gdiff;
	CrackCor[9*iq+3*ic+1]=CrackCor[9*iq+3*ic+1]*gdiff;
	CrackCor[9*iq+3*ic+2]=CrackCor[9*iq+3*ic+2]*gdiff;
   }
 }
}
 for(int k=0;k<NDF;k++){for(int j=0;j<NDF;j++)prod_op[k][j]=prod_op[k][j]/gdiff;}
//gl_indatMedian UNCHANGED
}
//---------------------------------------------------------------------------
void TForm1::FDwireplot(long indat_nelt,long indat_nop1[],long indat_matno[],float indat_c1[]) //tBitmap->
// Global MAXPOINTS,NDF,MXNPEI,etc
{long ie=0,eltype=0,t7=10000000;TPoint ptDraw[MAXPOINTS];
 tBitmap->Canvas->Pen->Width=1;
 for(ie=0;ie<indat_nelt;ie++)
   {eltype=indat_matno[ie]/t7;
	if(eltype==5)
	  {for(int jp=0;jp<3;jp++){ptDraw[jp].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+jp]  ]+0.5);ptDraw[jp].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+jp]+1]+0.5);}
	   ptDraw[3].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+0]]+0.5);ptDraw[3].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+0]+1]+0.5);
	   ptDraw[4].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]]+0.5);ptDraw[4].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]+1]+0.5);
	   ptDraw[5].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+1]]+0.5);ptDraw[5].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+1]+1]+0.5);
	   ptDraw[6].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]]+0.5);ptDraw[6].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]+1]+0.5);
	   ptDraw[7].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+2]]+0.5);ptDraw[7].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+2]+1]+0.5);
	   tBitmap->Canvas->Polyline(ptDraw,7);
      }
	else if(eltype==7)
      {for(int jp=0;jp<3;jp++){ptDraw[jp].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+jp]  ]+0.5);ptDraw[jp].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+jp]+1]+0.5);}
       ptDraw[ 3].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+0]]+0.5);ptDraw[ 3].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+0]+1]+0.5);
	   ptDraw[ 4].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]]+0.5);ptDraw[ 4].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]+1]+0.5);
       ptDraw[ 5].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]]+0.5);ptDraw[ 5].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]+1]+0.5);
       ptDraw[ 6].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+1]]+0.5);ptDraw[ 6].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+1]+1]+0.5);
       ptDraw[ 7].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]]+0.5);ptDraw[ 7].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]+1]+0.5);
	   ptDraw[ 8].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]]+0.5);ptDraw[ 8].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]+1]+0.5);
	   ptDraw[ 9].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+2]]+0.5);ptDraw[ 9].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+2]+1]+0.5);
	   ptDraw[10].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]]+0.5);ptDraw[10].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]+1]+0.5);
       ptDraw[11].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]]+0.5);ptDraw[11].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]+1]+0.5);
	   tBitmap->Canvas->Polyline(ptDraw,11);
      }
    else
      {for(int jp=0;jp<4;jp++){ptDraw[jp].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+jp]  ]+0.5);ptDraw[jp].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+jp]+1]+0.5);}
	   ptDraw[ 4].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+0]]+0.5);ptDraw[ 4].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+0]+1]+0.5);
	   ptDraw[ 5].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]]+0.5);ptDraw[ 5].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]+1]+0.5);
       ptDraw[ 6].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]]+0.5);ptDraw[ 6].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]+1]+0.5);
       ptDraw[ 7].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+1]]+0.5);ptDraw[ 7].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+1]+1]+0.5);
       ptDraw[ 8].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]]+0.5);ptDraw[ 8].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+5]+1]+0.5);
	   ptDraw[ 9].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+6]]+0.5);ptDraw[ 9].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+6]+1]+0.5);
       ptDraw[10].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+2]]+0.5);ptDraw[10].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+2]+1]+0.5);
       ptDraw[11].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+6]]+0.5);ptDraw[11].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+6]+1]+0.5);
       ptDraw[12].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+7]]+0.5);ptDraw[12].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+7]+1]+0.5);
	   ptDraw[13].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]]+0.5);ptDraw[13].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+3]+1]+0.5);
	   ptDraw[14].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+7]]+0.5);ptDraw[14].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+7]+1]+0.5);
       ptDraw[15].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]]+0.5);ptDraw[15].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+4]+1]+0.5);
	   tBitmap->Canvas->Polyline(ptDraw,15);
      }
    }
}

//---------------------------------------------------------------------------
void TForm1::FDcomp_nGID(long indat_nelt,long indat_matno[],int *nGID,long arGID[])
// Global MAX_GID
{long i=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 for(i=0;i<MAX_GID;i++)arGID[i]=0;
// for(i=0;i<indat_nelt;i++)arGID[i]=0;// NOT for use in shell analysis
 for(i=0;i<indat_nelt;i++)
	{
////	eltype=indat_matno[i]/t7;bscode=(indat_matno[i]-eltype*t7)/t5;node=(indat_matno[i]-eltype*t7-bscode*t5)/t3;
////	 ieGID=indat_matno[i]-eltype*t7-bscode*t5-node*t3;

//	 if(indat.trackELSET[i+1]-indat.trackELSET[i]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[i+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[i+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[i]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[i+1]-1 ];                      //Prioritize WP
//		  }

ieGID=indat.arrELSET[i];

////	 if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
////	 else if(base.arrELSET[base.trackELSET[i+1]-1 ]<0)ieGID=base.arrELSET[base.trackELSET[i+1]-2 ];
////	 else {if(base.GIDcol==1)ieGID=base.arrELSET[base.trackELSET[i]+base.GIDcol ]; //Prioritize WG
////		   else ieGID=base.arrELSET[base.trackELSET[i+1]-1 ];                      //Prioritize WP
////		  }


	 if(ieGID<0 || ieGID>MAX_GID){
//                                      extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Zero geometry ID input","Exit",MB_OK);
honk<<i+1<<" ieGID input check "<<eltype<<" "<<node<<" "<<ieGID+1<<"\n";
//                                      exit(0);
								 }
	 arGID[ieGID]=1;
//honk<<i<<" "<<ieGID<<" voedugA\n";
	}

//if(1==1)exit(0);

 *nGID=0;for(i=0;i<MAX_GID;i++)if(arGID[i]>0) *nGID= *nGID+1;
}
//---------------------------------------------------------------------------
void TForm1::FDelemfacets3(long npoin,long nelt,long nop1[],long matno[],long arGID[])
// Version using huge memory for speed (Code allows for quadratic elements)  Global LONG_INT,MXNPEI,MAX_GID,nGIDmax
// Corrcted 2008/08/15 for several erroneous "isw=1;break;".
// Version with log search throughout
{int isw=0,side_arr8[26]={16,0,0,0,0,16,1,1,0,0,8,2,2,8,0,0,4,4,0,0,32,0,0,0,0,32},
	 side_arr6[10]={8,1,4,2,0,0,0,0,0,16},side_arr4[4]={1,8,4,2};
 long ie=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,
	  ip=0,in=0,iv=0,ivp=0,nside=0,in0=0,in0p=0,in0pp=0,inx=0,inxp=0,inxpp=0,oppn0=0,oppn1=0,oppn3=0,prod=0,
	  iex=0,eltypex=0,bscodex=0,nodex=0,ieGIDx=0,mxnelvertex=0,accum=0,
	  lows=0,mids=0,tops=0,istx=0,lowsp=0,midsp=0,topsp=0,istxp=0,corruptf[4],*arr1=NULL,*arr3=NULL;
// Note: matno[i]=8*10000000+nodes*1000+ipid -1; Also bscodex=1+2+4+8+16+32......
// corruptf[0]=counter for corrupt hex-wedge, [1] wedge-wedge, [2] tetra-wedge, [3] unsupported elements
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 arr1=new long[npoin+1];for(ip=0;ip<npoin+1;ip++) *(arr1+ip)=0;
 for(ip=0;ip<4;ip++)corruptf[ip]=0; //EFP 8/01/2014
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
//						ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
// 							 }
ieGID=indat.arrELSET[ie];
//////////////
						if(arGID[ieGID]){if(eltype==8){bscodex=63;nodex=8;}
										 else if(eltype==7){bscodex=31;nodex=6;}
										 else {bscodex=15;nodex=4;}
										 for(in=0;in<nodex;in++) *(arr1+nop1[MXNPEI*ie+in])= *(arr1+nop1[MXNPEI*ie+in])+1;
										}
						else bscodex=0;
						matno[ie]=matno[ie]-(bscode-bscodex)*t5;
					   }
 mxnelvertex=accum=0;for(ip=0;ip<npoin;ip++){if(mxnelvertex< *(arr1+ip))mxnelvertex= *(arr1+ip);accum=accum+ *(arr1+ip); *(arr1+ip)=accum;}
 for(ip=npoin;ip>0;ip--) *(arr1+ip)= *(arr1+ip-1); *arr1=0;
 try {
	  arr3=new long[accum];
	  }catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient facet dynamic memory",L"Exit",MB_OK);exit(0);}
// honk<<mxnelvertex<<" MxNelVert "<<accum<<" "<<npoin<<"\n";
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
//						ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[ie];
//////////////
						if(arGID[ieGID]){if(eltype==8)nodex=8;else if(eltype==7)nodex=6;else nodex=4;
										 for(in=0;in<nodex;in++){ip=nop1[MXNPEI*ie+in]; *(arr3+ *(arr1+ip))=10*ie+in; *(arr1+ip)= *(arr1+ip)+1;}
										}
					   }
 for(ip=npoin;ip>0;ip--) *(arr1+ip)= *(arr1+ip-1); *arr1=0;
//
 for(ie=0;ie<nelt-1;ie++)
   {eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
//	ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[ie];
//////////////
	if(arGID[ieGID])
	  {if(eltype==8)
		 {nside=6;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0)     {oppn0=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+5];}
				else if(iv==1){oppn0=nop1[MXNPEI*ie+1];oppn3=nop1[MXNPEI*ie+6];}
				else if(iv==2){oppn0=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+7];}
				else if(iv==3){oppn0=nop1[MXNPEI*ie+3];oppn3=nop1[MXNPEI*ie+4];}
				else if(iv==4){oppn0=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+2];}
				else          {oppn0=nop1[MXNPEI*ie+4];oppn3=nop1[MXNPEI*ie+6];}
				isw=0;istx= *(arr1+oppn3);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
//							  ieGIDx=matno[iex]-eltypex*t7-bscodex*t5-nodex*t3;
////////////// EFP 2/20/2012
//						if(indat.trackELSET[iex+1]-indat.trackELSET[iex]==1)ieGIDx=0;
//						else if(indat.arrELSET[ indat.trackELSET[iex+1]-1 ]<0)ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-2 ];
//						else {if(indat.GIDcol==1)ieGIDx=indat.arrELSET[ indat.trackELSET[iex]+indat.GIDcol ]; //Prioritize WG
//							  else ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[iex];
//////////////
							  if(ieGIDx==ieGID)
								{lows=istx;tops= *(arr1+oppn3+1) -1;
								 if(eltypex==8)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {matno[ie]=matno[ie]-prod*t5;in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;
										  ivp=side_arr8[3*min(in0,in0p)+2*max(in0,in0p)-4];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 else if(eltypex==7)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {matno[ie]=matno[ie]-prod*t5;
										  in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;ivp=side_arr6[in0+in0p-3];
//										  if(ivp>0 && ivp<8){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//										  else {extern PACKAGE void __fastcall Beep(void);
////												Application->MessageBox(L"Corrupt hex-wedge mesh",L"Terminate",MB_OK);
//												Application->MessageBox(L"Ignoring corrupt hex-wedge mesh",L"Warning",MB_OK);
////												exit(0);
//												break;
//											   }
										  if(ivp>0 && ivp<8)matno[iex]=matno[iex]-ivp*t5;
										  else corruptf[0]=corruptf[0]+1;
										  isw=1;break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 if(isw)break;
								}
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
//
	   else if(eltype==7)
		 {nside=5;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0){oppn0=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+4];}
				else if(iv==1){oppn0=nop1[MXNPEI*ie+1];oppn3=nop1[MXNPEI*ie+5];}
				else if(iv==2){oppn0=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+3];}
				else if(iv==3){oppn0=nop1[MXNPEI*ie+0];oppn1=nop1[MXNPEI*ie+1];oppn3=nop1[MXNPEI*ie+2];istxp= *(arr1+oppn1);}
				else {oppn0=nop1[MXNPEI*ie+3];oppn1=nop1[MXNPEI*ie+4];oppn3=nop1[MXNPEI*ie+5];istxp= *(arr1+oppn1);}
				isw=0;istx= *(arr1+oppn3);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
//							  ieGIDx=matno[iex]-eltypex*t7-bscodex*t5-nodex*t3;
////////////// EFP 2/20/2012
//						if(indat.trackELSET[iex+1]-indat.trackELSET[iex]==1)ieGIDx=0;
//						else if(indat.arrELSET[ indat.trackELSET[iex+1]-1 ]<0)ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-2 ];
//						else {if(indat.GIDcol==1)ieGIDx=indat.arrELSET[ indat.trackELSET[iex]+indat.GIDcol ]; //Prioritize WG
//							  else ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[iex];
//////////////
							  if(ieGIDx==ieGID)
								{
//MMMMMMMMMMMMMMM Correction 5/18/2009
								 lows=istx;tops= *(arr1+oppn3+1) -1;
//MMMMMMMMMMMMMMMMMMMMMMMMMM
								 if(iv<3)
								   {
//                                    lows=istx;tops= *(arr1+oppn3+1) -1;
									if(eltypex==8)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{matno[ie]=matno[ie]-prod*t5;in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;
											 ivp=side_arr8[3*min(in0,in0p)+2*max(in0,in0p)-4];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
									else if(eltypex==7)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{matno[ie]=matno[ie]-prod*t5;
											 in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;ivp=side_arr6[in0+in0p-3];
//											 if(ivp>0 && ivp<8){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//											 else {extern PACKAGE void __fastcall Beep(void);
////												   Application->MessageBox(L"Corrupt hex-wedge mesh",L"Terminate",MB_OK);
//												   Application->MessageBox(L"Ignoring corrupt hex-wedge mesh",L"Warning",MB_OK);
////												   exit(0);
//												   break;
//												  }
											 if(ivp>0 && ivp<8)matno[iex]=matno[iex]-ivp*t5;
											 else corruptf[0]=corruptf[0]+1;
											 isw=1;break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
								   }
								 else
								   {if(eltypex==7)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
											 for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											   {midsp=(lowsp+topsp)/2;
												if( *(arr3+midsp)/10==iex)
												  {matno[ie]=matno[ie]-prod*t5;
												   in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												   ivp=side_arr6[in0+in0p+in0pp-3];
//												   if(ivp>4){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//												   else {
///////////////////
////extern PACKAGE void __fastcall Beep(void);Application->MessageBox("Corrupt wedge-wedge mesh","Terminate",MB_OK);exit(0);
//honk<<ie+1<<" "<<iex+1<<" FDelemfacets3:Corrupt wedge-wedge mesh\n";isw=1;break;
///////////////////
//														}
												   if(ivp>4)matno[iex]=matno[iex]-ivp*t5;
												   else corruptf[1]=corruptf[1]+1;
												   isw=1;break;
												  }
												else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
												else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											   }
/////////////////////
//if(iv==3){in0=in0p=0;for(inxpp=0;inxpp<3;inxpp++){if(nop1[MXNPEL*ie+inxpp]==nop1[MXNPEL*iex+inxpp  ])in0++;
//                                                  if(nop1[MXNPEL*ie+inxpp]==nop1[MXNPEL*iex+inxpp+3])in0p++;
//                                                 }
//          if(in0==3){matno[ie]=matno[ie]-prod*t5;matno[iex]=matno[iex]-8*t5;}
//          else if(in0p==3){matno[ie]=matno[ie]-prod*t5;matno[iex]=matno[iex]-16*t5;}
//          isw=1;
//         }
//else {    in0=in0p=0;for(inxpp=3;inxpp<6;inxpp++){if(nop1[MXNPEL*ie+inxpp]==nop1[MXNPEL*iex+inxpp-3])in0++;
//                                                  if(nop1[MXNPEL*ie+inxpp]==nop1[MXNPEL*iex+inxpp  ])in0p++;
//                                                 }
//          if(in0==3){matno[ie]=matno[ie]-prod*t5;matno[iex]=matno[iex]-8*t5;}
//          else if(in0p==3){matno[ie]=matno[ie]-prod*t5;matno[iex]=matno[iex]-16*t5;}
//          isw=1;
//     }
/////////////////////
											 break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
									else if(eltypex==5)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
											 for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											   {midsp=(lowsp+topsp)/2;
												if( *(arr3+midsp)/10==iex)
												  {matno[ie]=matno[ie]-prod*t5;
												   in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												   ivp=side_arr4[in0+in0p+in0pp-3];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
												  }
												else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
												else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											   }
											 break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
								   }
								 if(isw)break;
								}
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
//
	   else if(eltype==5)
		 {nside=4;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0){oppn0=nop1[MXNPEI*ie+0];oppn1=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+1];}
				else if(iv==1){oppn0=nop1[MXNPEI*ie+1];oppn1=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+3];}
				else if(iv==2){oppn0=nop1[MXNPEI*ie+2];oppn1=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+3];}
				else {oppn0=nop1[MXNPEI*ie+3];oppn1=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+1];}
				isw=0;istx= *(arr1+oppn3);istxp= *(arr1+oppn1);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
//							  ieGIDx=matno[iex]-eltypex*t7-bscodex*t5-nodex*t3;
////////////// EFP 2/20/2012
//						if(indat.trackELSET[iex+1]-indat.trackELSET[iex]==1)ieGIDx=0;
//						else if(indat.arrELSET[ indat.trackELSET[iex+1]-1 ]<0)ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-2 ];
//						else {if(indat.GIDcol==1)ieGIDx=indat.arrELSET[ indat.trackELSET[iex]+indat.GIDcol ]; //Prioritize WG
//							  else ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[iex];
//////////////
							  if(ieGIDx==ieGID)
								{
//MMMMMMMMMMMMMMM Correction 5/18/2009
								 lows=istx;tops= *(arr1+oppn3+1) -1;
//MMMMMMMMMMMMMMMMMMMMMMMMMM
								 if(eltypex==7)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
										  for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											{midsp=(lowsp+topsp)/2;
											 if( *(arr3+midsp)/10==iex)
											   {matno[ie]=matno[ie]-prod*t5;
												in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												ivp=side_arr6[in0+in0p+in0pp-3];
//												if(ivp>4){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//												else {extern PACKAGE void __fastcall Beep(void);
////													  Application->MessageBox(L"Corrupt tetra-wedge mesh",L"Terminate",MB_OK);
//													  Application->MessageBox(L"Ignoring corrupt tetra-wedge mesh",L"Warning",MB_OK);
////													  exit(0);
//													  break;
//													 }
												if(ivp>4)matno[iex]=matno[iex]-ivp*t5;
												else corruptf[2]=corruptf[2]+1;
												isw=1;break;
											   }
											 else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
											 else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											}
										  break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 else if(eltypex==5)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
										  for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											{midsp=(lowsp+topsp)/2;
											 if( *(arr3+midsp)/10==iex)
											   {matno[ie]=matno[ie]-prod*t5;
												in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												ivp=side_arr4[in0+in0p+in0pp-3];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
											   }
											 else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
											 else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											}
										  break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 if(isw)break;
								}
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
	   else {
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
honk<<ie<<" "<<eltype<<" "<<bscode<<" "<<node<<" "<<ieGID<<" "<<" FDelemfacets3()\n";
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
//			 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elements found in FDelemfacets3()",L"Warning",MB_OK);
//	         exit(0); //Speculative intervention EFP 7/31/2014
			 corruptf[3]=corruptf[3]+1;
			}
	  }
   }
 delete [] arr1;delete [] arr3;
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
 if(corruptf[3]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elements found in FDelemfacets3()",L"Warning",MB_OK);}
 if     (corruptf[0] && corruptf[1] && corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/wedge/hex found in FDelemfacets3()",L"Warning",MB_OK);}
 else if(corruptf[0] && corruptf[1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge/hex found in FDelemfacets3()",L"Warning",MB_OK);}
 else if(corruptf[1] && corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/wedge found in FDelemfacets3()",L"Warning",MB_OK);}
 else if(corruptf[2] && corruptf[0]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/hex found in FDelemfacets3()",L"Warning",MB_OK);}
 else if(corruptf[0]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge-hex found in FDelemfacets3()",L"Warning",MB_OK);}
 else if(corruptf[1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge-wedge found in FDelemfacets3()",L"Warning",MB_OK);}
 else if(corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet-wedge found in FDelemfacets3()",L"Warning",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::FDelemfacets3a(long npoin,long nelt,long nop1[],long matno[])
// Version using huge memory for speed (Code allows for quadratic elements)  Global LONG_INT,MXNPEI,MAX_GID,nGIDmax
// Corrcted 2008/08/15 for several erroneous "isw=1;break;".
// Version with log search throughout
{int isw=0,side_arr8[26]={16,0,0,0,0,16,1,1,0,0,8,2,2,8,0,0,4,4,0,0,32,0,0,0,0,32},
	 side_arr6[10]={8,1,4,2,0,0,0,0,0,16},side_arr4[4]={1,8,4,2};
 long ie=0,eltype=0,bscode=0,t3=1000,t5=100000,t7=10000000,
	  ip=0,in=0,iv=0,ivp=0,nside=0,in0=0,in0p=0,in0pp=0,inx=0,inxp=0,inxpp=0,oppn0=0,oppn1=0,oppn3=0,prod=0,
	  iex=0,eltypex=0,bscodex=0,nodex=0,mxnelvertex=0,accum=0,
	  lows=0,mids=0,tops=0,istx=0,lowsp=0,midsp=0,topsp=0,istxp=0,corruptf[4],*arr1=NULL,*arr3=NULL;
// Note: matno[i]=8*10000000+nodes*1000+ipid -1; Also bscodex=1+2+4+8+16+32......
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 arr1=new long[npoin+1];for(ip=0;ip<npoin+1;ip++) *(arr1+ip)=0;
 for(ip=0;ip<4;ip++)corruptf[ip]=0; //EFP 8/01/2014
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;
						if(eltype==8){bscodex=63;nodex=8;}
						else if(eltype==7){bscodex=31;nodex=6;}
						else if(eltype==5){bscodex=15;nodex=4;}

//else {honk<<ie<<" "<<eltype<<" "<<bscode<<" earlyFDelemfacets3a()\n";
//	 }

						for(in=0;in<nodex;in++) *(arr1+nop1[MXNPEI*ie+in])= *(arr1+nop1[MXNPEI*ie+in])+1;
						matno[ie]=matno[ie]-(bscode-bscodex)*t5;
					   }
 mxnelvertex=accum=0;for(ip=0;ip<npoin;ip++){if(mxnelvertex< *(arr1+ip))mxnelvertex= *(arr1+ip);accum=accum+ *(arr1+ip); *(arr1+ip)=accum;}
 for(ip=npoin;ip>0;ip--) *(arr1+ip)= *(arr1+ip-1); *arr1=0;
// try {arr3=new long[accum];}catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient facet dynamic memory",L"Exit",MB_OK);exit(0);}
 arr3=new long[accum];if(arr3==NULL){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient facet dynamic memory",L"Exit",MB_OK);exit(0);}
// honk<<mxnelvertex<<" MxNelVert "<<accum<<" "<<npoin<<"\n";
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;
						if(eltype==8)nodex=8;else if(eltype==7)nodex=6;else nodex=4;
						for(in=0;in<nodex;in++){ip=nop1[MXNPEI*ie+in]; *(arr3+ *(arr1+ip))=10*ie+in; *(arr1+ip)= *(arr1+ip)+1;}
					   }
 for(ip=npoin;ip>0;ip--) *(arr1+ip)= *(arr1+ip-1); *arr1=0;
//
 for(ie=0;ie<nelt-1;ie++)
   {eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;
//    if(arGID[ieGID])
//      {
//
	   if(eltype==8)
		 {nside=6;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0)     {oppn0=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+5];}
				else if(iv==1){oppn0=nop1[MXNPEI*ie+1];oppn3=nop1[MXNPEI*ie+6];}
				else if(iv==2){oppn0=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+7];}
				else if(iv==3){oppn0=nop1[MXNPEI*ie+3];oppn3=nop1[MXNPEI*ie+4];}
				else if(iv==4){oppn0=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+2];}
				else          {oppn0=nop1[MXNPEI*ie+4];oppn3=nop1[MXNPEI*ie+6];}
				isw=0;istx= *(arr1+oppn3);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
//                              if(ieGIDx==ieGID)
//                                {
								 lows=istx;tops= *(arr1+oppn3+1) -1;
								 if(eltypex==8)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {matno[ie]=matno[ie]-prod*t5;in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;
										  ivp=side_arr8[3*min(in0,in0p)+2*max(in0,in0p)-4];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 else if(eltypex==7)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {matno[ie]=matno[ie]-prod*t5;
										  in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;ivp=side_arr6[in0+in0p-3];
//										  if(ivp>0 && ivp<8){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//										  else {extern PACKAGE void __fastcall Beep(void);
////												Application->MessageBox(L"Corrupt hex-wedge mesh",L"Terminate",MB_OK);
//												Application->MessageBox(L"Ignoring corrupt hex-wedge mesh",L"Warning",MB_OK);
////												exit(0);
//												break;
//											   }
										  if(ivp>0 && ivp<8)matno[iex]=matno[iex]-ivp*t5;
										  else corruptf[0]=corruptf[0]+1;
										  isw=1;break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 if(isw)break;
//                                }
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
//
	   else if(eltype==7)
		 {nside=5;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0)     {oppn0=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+4];}
				else if(iv==1){oppn0=nop1[MXNPEI*ie+1];oppn3=nop1[MXNPEI*ie+5];}
				else if(iv==2){oppn0=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+3];}
				else if(iv==3){oppn0=nop1[MXNPEI*ie+0];oppn1=nop1[MXNPEI*ie+1];oppn3=nop1[MXNPEI*ie+2];istxp= *(arr1+oppn1);}
				else          {oppn0=nop1[MXNPEI*ie+3];oppn1=nop1[MXNPEI*ie+4];oppn3=nop1[MXNPEI*ie+5];istxp= *(arr1+oppn1);}
				isw=0;istx= *(arr1+oppn3);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
//                              if(ieGIDx==ieGID)
//                                {
								 lows=istx;tops= *(arr1+oppn3+1) -1; //Correction??? Moved to here... EFP 4/14/2011
								 if(iv<3)
								   {
//								    lows=istx;tops= *(arr1+oppn3+1) -1; //Correction??? Moved above... EFP 4/14/2011
									if(eltypex==8)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{matno[ie]=matno[ie]-prod*t5;in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;
											 ivp=side_arr8[3*min(in0,in0p)+2*max(in0,in0p)-4];matno[iex]=matno[iex]-ivp*t5;isw=1;

//if(ie==800-1)honk<<ie<<" "<<eltype<<" "<<iv<<" "<<prod<<" Jericho0 "<<inx<<" "<<iex<<" "<<eltypex<<" "<<inxp<<" "<<ivp<<"\n";
											 break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
									else if(eltypex==7)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{matno[ie]=matno[ie]-prod*t5;
											 in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;
											 ivp=side_arr6[in0+in0p-3];
////if(ie==800-1)honk<<ie<<" "<<eltype<<" "<<iv<<" "<<prod<<" Allenby0 "<<inx<<" "<<iex<<" "<<inxp<<" "<<mids<<" bridge "<<in0<<" "<<in0p<<" "<<ivp<<"\n";
//											 if(ivp>0 && ivp<8){matno[iex]=matno[iex]-ivp*t5;isw=1;
////if(ie==800-1)honk<<ie<<" "<<eltype<<" "<<iv<<" "<<prod<<" Bersheeba0 "<<inxp<<" "<<iex<<" "<<eltypex<<" "<<ivp<<"\n";
//																break;
//															   }
////											 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt hex-wedge mesh",L"Terminate",MB_OK);exit(0);}
//											 else {extern PACKAGE void __fastcall Beep(void);
//												   Application->MessageBox(L"Ignoring corrupt hex-wedge mesh",L"Warning",MB_OK);
////												   exit(0); //EFP 8/01/2014
//												   break;
//												  }
											 if(ivp>0 && ivp<8)matno[iex]=matno[iex]-ivp*t5;
											 else corruptf[0]=corruptf[0]+1;
											 isw=1;break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
								   }
								 else
								   {if(eltypex==7)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
											 for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											   {midsp=(lowsp+topsp)/2;
												if( *(arr3+midsp)/10==iex)
												  {matno[ie]=matno[ie]-prod*t5;
												   in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
//if(ie==800-1)honk<<ie<<" "<<eltype<<" "<<iv<<" "<<prod<<" Index Meggido0 "<<inx<<" "<<iex<<" "<<eltypex<<" "<<inxp<<" "<<inxpp<<" boom "<<in0<<" "<<in0p<<" "<<in0pp<<"\n";
												   ivp=side_arr6[in0+in0p+in0pp-3];
//												   if(ivp>4){
////if(ie==800-1)honk<<ie<<" "<<eltype<<" "<<iv<<" "<<prod<<" Not Meggido0 "<<iex<<" "<<eltypex<<" "<<inxp<<" "<<inxpp<<" "<<ivp<<"\n";
//															 matno[iex]=matno[iex]-ivp*t5;isw=1;break;
//															}
//												   else {
////if(ie==800-1)honk<<ie<<" "<<eltype<<" "<<iv<<" "<<prod<<" Har Meggido0 "<<iex<<" "<<eltypex<<" "<<inxp<<" "<<inxpp<<" "<<ivp<<"\n";
////														 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge-wedge mesh",L"Terminate",MB_OK);
//														 extern PACKAGE void __fastcall Beep(void);
//														 Application->MessageBox(L"Ignoring corrupt wedge-wedge mesh",L"Warning",MB_OK);
////														 exit(0); //EFP 8/01/2014
//														 break;
//														}
												   if(ivp>4)matno[iex]=matno[iex]-ivp*t5;
												   else corruptf[1]=corruptf[1]+1;
												   isw=1;break;
												  }
												else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
												else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											   }
											 break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
									else if(eltypex==5)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
											 for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											   {midsp=(lowsp+topsp)/2;
												if( *(arr3+midsp)/10==iex)
												  {matno[ie]=matno[ie]-prod*t5;
												   in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												   ivp=side_arr4[in0+in0p+in0pp-3];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
												  }
												else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
												else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											   }
											 break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
								   }
								 if(isw)break;
//                                }
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
//
	   else if(eltype==5)
		 {nside=4;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0)     {oppn0=nop1[MXNPEI*ie+0];oppn1=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+1];}
				else if(iv==1){oppn0=nop1[MXNPEI*ie+1];oppn1=nop1[MXNPEI*ie+2];oppn3=nop1[MXNPEI*ie+3];}
				else if(iv==2){oppn0=nop1[MXNPEI*ie+2];oppn1=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+3];}
				else          {oppn0=nop1[MXNPEI*ie+3];oppn1=nop1[MXNPEI*ie+0];oppn3=nop1[MXNPEI*ie+1];}
				isw=0;istx= *(arr1+oppn3);istxp= *(arr1+oppn1);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
//                              if(ieGIDx==ieGID)
//                                {
								 lows=istx;tops= *(arr1+oppn3+1) -1; //Correction??? Added to here... EFP 4/14/2011
								 if(eltypex==7)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
										  for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											{midsp=(lowsp+topsp)/2;
											 if( *(arr3+midsp)/10==iex)
											   {matno[ie]=matno[ie]-prod*t5;
												in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												ivp=side_arr6[in0+in0p+in0pp-3];
//												if(ivp>4){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
////												else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tetra-wedge mesh",L"Terminate",MB_OK);exit(0);}
//												else {extern PACKAGE void __fastcall Beep(void);
// 													  Application->MessageBox(L"Ignoring corrupt tetra-wedge mesh",L"Terminate",MB_OK);
////													  exit(0);
//													  break;
//													 }
												if(ivp>4)matno[iex]=matno[iex]-ivp*t5;
												else corruptf[2]=corruptf[2]+1;
												isw=1;break;
											   }
											 else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
											 else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											}
										  break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 else if(eltypex==5)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
										  for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											{midsp=(lowsp+topsp)/2;
											 if( *(arr3+midsp)/10==iex)
											   {matno[ie]=matno[ie]-prod*t5;
												in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												ivp=side_arr4[in0+in0p+in0pp-3];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
											   }
											 else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
											 else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											}
										  break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 if(isw)break;
//                                }
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
	   else {
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
honk<<ie<<" "<<eltype<<" "<<bscode<<" FDelemfacets3a()\n";
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////

//			 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elements found",L"Terminate",MB_OK);exit(0);
//			 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elements found in FDelemfacets3a()",L"Warning",MB_OK);
			 corruptf[3]=corruptf[3]+1;
			}
//      }
//
   }
 delete [] arr1;delete [] arr3;
///////////
//exit(0);
///////////
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
 if(corruptf[3]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elements found in FDelemfacets3a()",L"Warning",MB_OK);}
 if     (corruptf[0] && corruptf[1] && corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/wedge/hex found in FDelemfacets3a()",L"Warning",MB_OK);}
 else if(corruptf[0] && corruptf[1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge/hex found in FDelemfacets3a()",L"Warning",MB_OK);}
 else if(corruptf[1] && corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/wedge found in FDelemfacets3a()",L"Warning",MB_OK);}
 else if(corruptf[2] && corruptf[0]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/hex found in FDelemfacets3a()",L"Warning",MB_OK);}
 else if(corruptf[0]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge-hex found in FDelemfacets3a()",L"Warning",MB_OK);}
 else if(corruptf[1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge-wedge found in FDelemfacets3a()",L"Warning",MB_OK);}
 else if(corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet-wedge found in FDelemfacets3a()",L"Warning",MB_OK);}
}
//---------------------------------------------------------------------------
long TForm1::FDcullfacet_mem(long indat_nelt,long indat_nop1[],long indat_matno[],float indat_c1[],long arGID[])
// Global MXNPEI
{long ies=0,eltypes=0,bscodes=0,nodes=0,ieGIDs=0,t3=1000,t5=100000,t7=10000000,nFace=0;float CENT=1./3.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
 for(ies=0;ies<indat_nelt;ies++)
   {eltypes=indat_matno[ies]/t7;bscodes=(indat_matno[ies]-eltypes*t7)/t5;nodes=(indat_matno[ies]-eltypes*t7-bscodes*t5)/t3;
//	ieGIDs=indat_matno[ies]-eltypes*t7-bscodes*t5-nodes*t3;
////////////// EFP 2/20/2012
//						if(indat.trackELSET[ies+1]-indat.trackELSET[ies]==1)ieGIDs=0;
//						else if(indat.arrELSET[ indat.trackELSET[ies+1]-1 ]<0)ieGIDs=indat.arrELSET[ indat.trackELSET[ies+1]-2 ];
//						else {if(indat.GIDcol==1)ieGIDs=indat.arrELSET[ indat.trackELSET[ies]+indat.GIDcol ]; //Prioritize WG
//							  else ieGIDs=indat.arrELSET[ indat.trackELSET[ies+1]-1 ];                      //Prioritize WP
//							 }
ieGIDs=indat.arrELSET[ies];
////////////// but this does not use indat.xxx ?
	if(arGID[ieGIDs] && bscodes>0)
	  {if(bscodes >= 32){bscodes=bscodes-32;STFISO8(3,  0.,  0.,  1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.)nFace++;
						}
	   if(bscodes >= 16){bscodes=bscodes-16;
						 if(eltypes==7)STFISO6(3,CENT,CENT, 1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else          STFISO8(3,  0.,  0., -1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.)nFace++;
						}
	   if(bscodes >=  8){bscodes=bscodes-8;
						 if(eltypes==5)     STFISO4(3,CENT,CENT,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,CENT,CENT, -1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3, -1.,  0.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.)nFace++;
						}
	   if(bscodes >=  4){bscodes=bscodes-4;
						 if(eltypes==5)     STFISO4(3,CENT,  0.,CENT,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,0.5,0.,0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3,  0.,  1.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.)nFace++;
						}
	   if(bscodes >=  2){bscodes=bscodes-2;
						 if(eltypes==5)     STFISO4(3,  0.,CENT,CENT,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,0.,0.5,0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3,  1.,  0.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.)nFace++;
						}
	   if(bscodes >=  1){if(eltypes==5)     STFISO4(3,CENT,CENT,CENT,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,0.5,0.5,0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3,  0., -1.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.)nFace++;
						}
	  }
   }
 return nFace;
}
//---------------------------------------------------------------------------
void TForm1::FDcullfacet(long indat_nelt,long indat_nop1[],long indat_matno[],float indat_c1[],long arGID[],long arbFace[])
// Global MXNPEI
{long ies=0,eltypes=0,bscodes=0,nodes=0,ieGIDs=0,fType=0,t3=1000,t5=100000,t7=10000000,nFace=0;
 float CENT=1./3.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],oopv0=0.,oopv1=0.,oopv2=0.,tanv0=0.,tanv1=0.,tanv2=0.,zcomp_r=0.,onorm=0.,tnorm=0.;
 for(ies=0;ies<indat_nelt;ies++)
   {eltypes=indat_matno[ies]/t7;bscodes=(indat_matno[ies]-eltypes*t7)/t5;nodes=(indat_matno[ies]-eltypes*t7-bscodes*t5)/t3;
//	ieGIDs=indat_matno[ies]-eltypes*t7-bscodes*t5-nodes*t3;
////////////// EFP 2/20/2012
//						if(base.trackELSET[ies+1]-base.trackELSET[ies]==1)ieGIDs=0;
//						else if(base.arrELSET[ base.trackELSET[ies+1]-1 ]<0)ieGIDs=base.arrELSET[ base.trackELSET[ies+1]-2 ];
//						else {if(base.GIDcol==1)ieGIDs=base.arrELSET[ base.trackELSET[ies]+base.GIDcol ]; //Prioritize WG
//							  else ieGIDs=base.arrELSET[ base.trackELSET[ies+1]-1 ];                      //Prioritize WP
//							 }
ieGIDs=base.arrELSET[ies];
////////////// but this does not use indat.xxx ?
	if(arGID[ieGIDs] && bscodes>0)
	  {if(bscodes >= 32){bscodes=bscodes-32;
						 STFISO8(3,  0.,  0.,  1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.){
// Shade
oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
			   }
else zcomp_r=HN[2];
if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  arbFace[nFace]=ies*t3+fType*10+5;nFace++;
									 }
						}
	   if(bscodes >= 16){bscodes=bscodes-16;
						 if(eltypes==7)STFISO6(3,CENT,CENT, 1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else          STFISO8(3,  0.,  0., -1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.){
// Shade
oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
			   }
else zcomp_r=HN[2];
if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  arbFace[nFace]=ies*t3+fType*10+4;nFace++;
									 }
						}
	   if(bscodes >=  8){bscodes=bscodes-8;
						 if(eltypes==5)     STFISO4(3,CENT,CENT,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,CENT,CENT, -1.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3, -1.,  0.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.){
// Shade
oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
			   }
else zcomp_r=HN[2];
if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  arbFace[nFace]=ies*t3+fType*10+3;nFace++;
									 }
						}
	   if(bscodes >=  4){bscodes=bscodes-4;
						 if(eltypes==5)     STFISO4(3,CENT,  0.,CENT,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,0.5,0.,0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3,  0.,  1.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.){
// Shade
oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
			   }
else zcomp_r=HN[2];
if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  arbFace[nFace]=ies*t3+fType*10+2;nFace++;
									 }
						}
	   if(bscodes >=  2){bscodes=bscodes-2;
						 if(eltypes==5)     STFISO4(3,  0.,CENT,CENT,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,0.,0.5,0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3,  1.,  0.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.){
// Shade
oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
			   }
else zcomp_r=HN[2];
if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  arbFace[nFace]=ies*t3+fType*10+1;nFace++;
									 }
						}
	   if(bscodes >=  1){if(eltypes==5)     STFISO4(3,CENT,CENT,CENT,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else if(eltypes==7)STFISO6(3,0.5,0.5,0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 else               STFISO8(3,  0., -1.,  0.,&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ies,indat_c1);
						 if(HN[2]>0.){
// Shade
oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
			   }
else zcomp_r=HN[2];
if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  arbFace[nFace]=ies*t3+fType*10;nFace++;
									 }
						}
	  }
   }
}
//---------------------------------------------------------------------------
long TForm1::FDcullfacetc(long nelt,long nop1[],long matno[],float c1[],long arGID[],long arbFace[],long rbTem[])
// Global MXNPEI.  Shade coding removed for speed  EFP 1/02/2012
{long ies=0,eltypes=0,bscodes=0,nodes=0,ieGIDs=0,fType=0,t3=1000,t5=100000,t7=10000000,nFace=0,ip=0,ipr=0;
 float CENT=1./3.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9]
// ,oopv0=0.,oopv1=0.,oopv2=0.,tanv0=0.,tanv1=0.,tanv2=0.,zcomp_r=0.,onorm=0.,tnorm=0.
,proximi=0.,distant=0.;
 float testcor[4*2]= { -0.9,-0.9,
						0.9,-0.9,
						0.9, 0.9,
					   -0.9, 0.9};
 int is=0,iprox=0,idist=0,npts=0,iside=0;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 nFace=0;
 for(ies=0;ies<nelt;ies++)
   {eltypes=matno[ies]/t7;bscodes=(matno[ies]-eltypes*t7)/t5;nodes=(matno[ies]-eltypes*t7-bscodes*t5)/t3;
////	ieGIDs=matno[ies]-eltypes*t7-bscodes*t5-nodes*t3;
//	 if(indat.trackELSET[ies+1]-indat.trackELSET[ies]==1)ieGIDs=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ies+1]-1 ]<0)ieGIDs=indat.arrELSET[ indat.trackELSET[ies+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGIDs=indat.arrELSET[ indat.trackELSET[ies]+indat.GIDcol ]; //Prioritize WG
//		   else ieGIDs=indat.arrELSET[ indat.trackELSET[ies+1]-1 ];                      //Prioritize WP
//		  }
ieGIDs=indat.arrELSET[ies];

	if(arGID[ieGIDs] && bscodes>0)
	  {if(bscodes >= 32){bscodes=bscodes-32;
						 STFISO8(3,  0.,  0.,  1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 if(HN[2]>0.){
//// Shade
//oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
//oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
//if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
//				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
//				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
//						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
//			   }
//else zcomp_r=HN[2];
//if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
//else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
//else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
//else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
//else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  iside=5;arbFace[nFace]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTem[nFace]=iprox*100+idist;
//////////////////
									  nFace++;
									 }
						}
	   if(bscodes >= 16){bscodes=bscodes-16;
						 if(eltypes==7)STFISO6(3,CENT,CENT, 1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else          STFISO8(3,  0.,  0., -1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 if(HN[2]>0.){
//// Shade
//oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
//oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
//if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
//				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
//				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
//						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
//			   }
//else zcomp_r=HN[2];
//if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
//else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
//else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
//else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
//else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  iside=4;arbFace[nFace]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTem[nFace]=iprox*100+idist;
//////////////////
									  nFace++;
									 }
						}
	   if(bscodes >=  8){bscodes=bscodes-8;
						 if(eltypes==5)     STFISO4(3,CENT,CENT,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else if(eltypes==7)STFISO6(3,CENT,CENT, -1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else               STFISO8(3, -1.,  0.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 if(HN[2]>0.){
//// Shade
//oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
//oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
//if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
//				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
//				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
//						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
//			   }
//else zcomp_r=HN[2];
//if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
//else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
//else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
//else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
//else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  iside=3;arbFace[nFace]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTem[nFace]=iprox*100+idist;
//////////////////
									  nFace++;
									 }
						}
	   if(bscodes >=  4){bscodes=bscodes-4;
						 if(eltypes==5)     STFISO4(3,CENT,  0.,CENT,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else if(eltypes==7)STFISO6(3,0.5,0.,0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else               STFISO8(3,  0.,  1.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 if(HN[2]>0.){
//// Shade
//oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
//oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
//if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
//				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
//				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
//						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
//			   }
//else zcomp_r=HN[2];
//if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
//else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
//else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
//else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
//else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  iside=2;arbFace[nFace]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTem[nFace]=iprox*100+idist;
//////////////////
									  nFace++;
									 }
						}
	   if(bscodes >=  2){bscodes=bscodes-2;
						 if(eltypes==5)     STFISO4(3,  0.,CENT,CENT,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else if(eltypes==7)STFISO6(3,0.,0.5,0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else               STFISO8(3,  1.,  0.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 if(HN[2]>0.){
//// Shade
//oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
//oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
//if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
//				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
//				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
//						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
//			   }
//else zcomp_r=HN[2];
//if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
//else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
//else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
//else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
//else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  iside=1;arbFace[nFace]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTem[nFace]=iprox*100+idist;
//////////////////
									  nFace++;
									 }
						}
	   if(bscodes >=  1){if(eltypes==5)     STFISO4(3,CENT,CENT,CENT,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else if(eltypes==7)STFISO6(3,0.5,0.5,0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 else               STFISO8(3,  0., -1.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 if(HN[2]>0.){
//// Shade
//oopv0=HN[1]*illumDirect[2]-HN[2]*illumDirect[1];oopv1=HN[2]*illumDirect[0]-HN[0]*illumDirect[2];
//oopv2=HN[0]*illumDirect[1]-HN[1]*illumDirect[0];onorm=sqrt(oopv0*oopv0+oopv1*oopv1+oopv2*oopv2);
//if(onorm>0.001){oopv0=oopv0/onorm;oopv1=oopv1/onorm;oopv2=oopv2/onorm;tanv0=HN[2]*oopv1-HN[1]*oopv2;tanv1=HN[0]*oopv2-HN[2]*oopv0;
//				tanv2=HN[1]*oopv0-HN[0]*oopv1;tnorm=sqrt(tanv0*tanv0+tanv1*tanv1+tanv2*tanv2);tanv0=tanv0/tnorm;tanv1=tanv1/tnorm;tanv2=tanv2/tnorm;
//				zcomp_r=HN[2]*(illumDirect[0]*HN[0]+illumDirect[1]*HN[1]+illumDirect[2]*HN[2])-
//						tanv2*(illumDirect[0]*tanv0+illumDirect[1]*tanv1+illumDirect[2]*tanv2);
//			   }
//else zcomp_r=HN[2];
//if(zcomp_r> 0.9781476)fType=11;else if(zcomp_r> 0.9135455)fType=12;else if(zcomp_r> 0.809017)fType=13;
//else if(zcomp_r> 0.6691306)fType=14;else if(zcomp_r> 0.5)fType=15;else if(zcomp_r> 0.309017)fType=16;
//else if(zcomp_r> 0.1045285)fType=17;else if(zcomp_r> -0.1045285)fType=18;else if(zcomp_r> -0.309017)fType=19;
//else if(zcomp_r> -0.5)fType=20;else if(zcomp_r> -0.6691306)fType=21;else if(zcomp_r> -0.809017)fType=22;
//else if(zcomp_r> -0.9135455)fType=23;else if(zcomp_r> -0.9781476)fType=24;else fType=25;
									  iside=0;arbFace[nFace]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTem[nFace]=iprox*100+idist;
//////////////////
									  nFace++;
									 }
						}
	  }
   }
 return nFace;
}
//---------------------------------------------------------------------------
void TForm1::FDculledge(long indat_nop1[],long indat_matno[],float indat_bc1[],long nFace,long arbFace[],int edgFace[])
// Global NDF,MXNPEL,MAX_GID
{int ibw=0,ival=0,jval=0,iloc=0,jloc=0,ilocp=0,jlocp=0;float x1=0.,y1=0.,z1=0.,x2=0.,y2=0.,z2=0.;
 long ic=0,jc=0,iedg=0,jedg=0,ie=0,je=0,ig=0,jg=0,igp=0,jgp=0,eltype=0,eltypj=0,bscode=0,bscodj=0,node=0,nodj=0,ieGID=0,jeGID=0,
   fType=0,jType=0,iside=0,jside=0,inlo=0,jnlo=0,inup=0,jnup=0,t3=1000,t5=100000,t7=10000000;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 for(ic=0;ic<nFace;ic++)edgFace[ic]=1111;
 for(ic=0;ic<nFace-1;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;eltype=indat_matno[ie]/t7;
	bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	if(eltype==5)iedg=3;else if(eltype==7){if(iside>2)iedg=3;else iedg=4;}else iedg=4;
	iloc=1;ilocp=10;
	for(ig=0;ig<iedg;ig++)
	  {ival=(edgFace[ic]-ilocp*(edgFace[ic]/ilocp))/iloc;
	   if(ival)
		 {ibw=0;igp=ig+1;if(igp>=iedg)igp=0;
		  if(eltype==5){inlo=min(indat_nop1[MXNPEL*ie+gdata4[3*iside+ig]],indat_nop1[MXNPEL*ie+gdata4[3*iside+igp]]);
						inup=max(indat_nop1[MXNPEL*ie+gdata4[3*iside+ig]],indat_nop1[MXNPEL*ie+gdata4[3*iside+igp]]);
					   }
		  else if(eltype==7){inlo=min(indat_nop1[MXNPEL*ie+gdata6[4*iside+ig]],indat_nop1[MXNPEL*ie+gdata6[4*iside+igp]]);
							 inup=max(indat_nop1[MXNPEL*ie+gdata6[4*iside+ig]],indat_nop1[MXNPEL*ie+gdata6[4*iside+igp]]);
							}
		  else {inlo=min(indat_nop1[MXNPEL*ie+gdata8[4*iside+ig]],indat_nop1[MXNPEL*ie+gdata8[4*iside+igp]]);
				inup=max(indat_nop1[MXNPEL*ie+gdata8[4*iside+ig]],indat_nop1[MXNPEL*ie+gdata8[4*iside+igp]]);
			   }
//
x1=(indat_bc1[NDF*inlo  ]+indat_bc1[NDF*inup  ])/2.;y1=(indat_bc1[NDF*inlo+1]+indat_bc1[NDF*inup+1])/2.;z1=(indat_bc1[NDF*inlo+2]+indat_bc1[NDF*inup+2])/2.;
//
		  for(jc=ic+1;jc<nFace;jc++)
			{je=arbFace[jc]/t3;
			 if(ie!=je)
			   {jType=(arbFace[jc]-je*t3)/10;jside=arbFace[jc]-je*t3-jType*10;eltypj=indat_matno[je]/t7;
				bscodj=(indat_matno[je]-eltypj*t7)/t5;nodj=(indat_matno[je]-eltypj*t7-bscodj*t5)/t3;
//				jeGID=indat_matno[je]-eltypj*t7-bscodj*t5-nodj*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[je+1]-indat.trackELSET[je]==1)jeGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[je+1]-1 ]<0)jeGID=indat.arrELSET[ indat.trackELSET[je+1]-2 ];
//	 else {if(indat.GIDcol==1)jeGID=indat.arrELSET[ indat.trackELSET[je]+indat.GIDcol ]; //Prioritize WG
//		   else jeGID=indat.arrELSET[ indat.trackELSET[je+1]-1 ];                      //Prioritize WP
//		  }
jeGID=indat.arrELSET[je];
//////////////////
				if((ieGID==MAX_GID-1 && jeGID==MAX_GID-1) || (ieGID!=MAX_GID-1 && jeGID!=MAX_GID-1))
				  {if(eltypj==5)jedg=3;else if(eltypj==7){if(jside>2)jedg=3;else jedg=4;}else jedg=4;
				   jloc=1;jlocp=10;
				   for(jg=0;jg<jedg;jg++)
					 {jval=(edgFace[jc]-jlocp*(edgFace[jc]/jlocp))/jloc;
					  if(jval)
						{jgp=jg+1;if(jgp>=jedg)jgp=0;
						 if(eltypj==5){jnlo=min(indat_nop1[MXNPEL*je+gdata4[3*jside+jg]],indat_nop1[MXNPEL*je+gdata4[3*jside+jgp]]);
									   jnup=max(indat_nop1[MXNPEL*je+gdata4[3*jside+jg]],indat_nop1[MXNPEL*je+gdata4[3*jside+jgp]]);
									  }
						 else if(eltypj==7){jnlo=min(indat_nop1[MXNPEL*je+gdata6[4*jside+jg]],indat_nop1[MXNPEL*je+gdata6[4*jside+jgp]]);
											jnup=max(indat_nop1[MXNPEL*je+gdata6[4*jside+jg]],indat_nop1[MXNPEL*je+gdata6[4*jside+jgp]]);
										   }
						 else {jnlo=min(indat_nop1[MXNPEL*je+gdata8[4*jside+jg]],indat_nop1[MXNPEL*je+gdata8[4*jside+jgp]]);
							   jnup=max(indat_nop1[MXNPEL*je+gdata8[4*jside+jg]],indat_nop1[MXNPEL*je+gdata8[4*jside+jgp]]);
							  }
//                         if(inlo==jnlo && inup==jnup){edgFace[ic]=edgFace[ic]-ival*iloc;
//                                                      edgFace[jc]=edgFace[jc]-jval*jloc;
//                                                      ibw=1;break;
//                                                     }
//
x2=(indat_bc1[NDF*jnlo  ]+indat_bc1[NDF*jnup  ])/2.;y2=(indat_bc1[NDF*jnlo+1]+indat_bc1[NDF*jnup+1])/2.;z2=(indat_bc1[NDF*jnlo+2]+indat_bc1[NDF*jnup+2])/2.;
//

						 if((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2)<1.E-4)
						   {edgFace[ic]=edgFace[ic]-ival*iloc;edgFace[jc]=edgFace[jc]-jval*jloc;ibw=1;break;
						   }
						}
					  jloc=jloc*10;jlocp=jlocp*10;
					 }
				   if(ibw)break;
				  }
			   }
			}
		 }
	   iloc=iloc*10;ilocp=ilocp*10;
	  }
   }
}
//---------------------------------------------------------------------------
void TForm1::STFISO20(int ISL,float G,float E,float T,float *DJD,float HN[],float SN[],float SG[],float DJR[],long ind_nop1[],float ind_c1[])
//  See User Manual for element surface coord.frame.
//  On positive sides: n x t1=t2; on negative HN()= -HN(positive side)
//  so n x t1 = -t2 on negative sides (ie. NOT corkscrew).
//  Normal=HN(1 to 3), t1=HN(4 to 6), t2=HN(7 to 9) so      x = HN.x'
//  CAUTION: do NOT evaluate normals at edges/nodes due to ambiguity!!
{int I=0,IM=0,IP=0,J=0;
//      DIMENSION HN(3),SN(1),SG(3,8),CORD(NDF,1),DJR(3,3),NOP(MXNPEL)
 float PRMT=1.E-10,GP=0.,GM=0.,EP=0.,EM=0.,TP=0.,TM=0.,GPP=0.,GMM=0.,EPP=0.,EMM=0.,TPP=0.,TMM=0.,
		SL1 =0.,SL2 =0.,SL3 =0.,SL4 =0.,SL5 =0.,SL6 =0.,SL7 =0.,SL8 =0.,SL9 =0.,SL10=0.,SL11=0.,SL12=0.,SL13=0.,SL14=0.,SL15=0.,SL16=0.,SL17=0.,SL18=0.,SL19=0.,SL20=0.,
		SL21=0.,SL22=0.,SL23=0.,SL24=0.,SL25=0.,SL26=0.,SL27=0.,SL28=0.,SL29=0.,SL30=0.,SL31=0.,SL32=0.,SL33=0.,SL34=0.,SL35=0.,SL36=0.,SL37=0.,SL38=0.,SL39=0.,SL40=0.,
		SL41=0.,SL42=0.,SL43=0.,SL44=0.,SL45=0.,SL46=0.,SL47=0.,SL48=0.,SL49=0.,SL50=0.,SL51=0.,SL52=0.,SL53=0.,SL54=0.,SL55=0.,SL56=0.,SL57=0.,SL58=0.,SL59=0.,SL60=0.,
		DJI1=0.,DJI4=0.,DJI7=0.,DJI2=0.,DJI5=0.,DJI8=0.,DJI3=0.,DJI6=0.,DJI9=0.,GG11=0.,GG22=0.,GG12=0.,GGSQ=0.,FPROD=0.;
 GP=1.+G;GM=1.-G;EP=1.+E;EM=1.-E;TP=1.+T;TM=1.-T;
 GPP=GP+G;GMM=GM-G;EPP=EP+E;EMM=EM-E;TPP=TP+T;TMM=TM-T;
 if(ISL==1)
	{*DJD=0.;
	SN[ 0]=GM*EM*TM*(-G-EP-TP)*0.125;SN[ 1]=GP*EM*TM*(G-EP-TP)*0.125;SN[ 2]=GP*EP*TM*(G-EM-TP)*0.125; SN[ 3]=GM*EP*TM*(-G-EM-TP)*0.125;
	SN[ 4]=GM*EM*TP*(-G-EP-TM)*0.125;SN[ 5]=GP*EM*TP*(G-EP-TM)*0.125;SN[ 6]=GP*EP*TP*(G-EM-TM)*0.125; SN[ 7]=GM*EP*TP*(-G-EM-TM)*0.125;
	SN[ 8]=EM*TM*GP*GM*0.25;SN[ 9]=GP*TM*EP*EM*0.25;SN[10]=EP*TM*GP*GM*0.25;SN[11]=GM*TM*EP*EM*0.25;
	SN[12]=GM*EM*TP*TM*0.25;SN[13]=GP*EM*TP*TM*0.25;SN[14]=GP*EP*TP*TM*0.25;SN[15]=GM*EP*TP*TM*0.25;
		SN[16]=EM*TP*GP*GM*0.25;SN[17]=GP*TP*EP*EM*0.25;SN[18]=EP*TP*GP*GM*0.25;SN[19]=GM*TP*EP*EM*0.25;
	}
 else if(ISL==2 || ISL==3)
	{SL1 =-EM*TM*(GMM-EP-TP)*0.125;SL2 =-GM*TM*(EMM-GP-TP)*0.125;SL3 =-GM*EM*(TMM-GP-EP)*0.125;SL4 = EM*TM*(GPP-EP-TP)*0.125;
	SL5 =-GP*TM*(EMM-GM-TP)*0.125;SL6 =-GP*EM*(TMM-GM-EP)*0.125;SL7 = EP*TM*(GPP-EM-TP)*0.125;SL8 = GP*TM*(EPP-GM-TP)*0.125;
	SL9 =-GP*EP*(TMM-GM-EM)*0.125;SL10=-EP*TM*(GMM-EM-TP)*0.125;SL11= GM*TM*(EPP-GP-TP)*0.125;SL12=-GM*EP*(TMM-GP-EM)*0.125;
	SL13=-EM*TP*(GMM-EP-TM)*0.125;SL14=-GM*TP*(EMM-GP-TM)*0.125;SL15= GM*EM*(TPP-GP-EP)*0.125;SL16= EM*TP*(GPP-EP-TM)*0.125;
	SL17=-GP*TP*(EMM-GM-TM)*0.125;SL18= GP*EM*(TPP-GM-EP)*0.125;SL19= EP*TP*(GPP-EM-TM)*0.125;SL20= GP*TP*(EPP-GM-TM)*0.125;
	SL21= GP*EP*(TPP-GM-EM)*0.125;SL22=-EP*TP*(GMM-EM-TM)*0.125;SL23= GM*TP*(EPP-GP-TM)*0.125;SL24= GM*EP*(TPP-GP-EM)*0.125;
	SL25=-EM*TM*G*0.5;SL26=-TM*GP*GM*0.25;SL27=-EM*GP*GM*0.25;SL28= TM*EP*EM*0.25;SL29=-GP*TM*E*0.5;SL30=-GP*EP*EM*0.25;SL31=-EP*TM*G*0.5;SL32= TM*GP*GM*0.25;
	SL33=-EP*GP*GM*0.25;SL34=-TM*EP*EM*0.25;SL35=-GM*TM*E*0.5;SL36=-GM*EP*EM*0.25;SL37=-EM*TP*TM*0.25;SL38=-GM*TP*TM*0.25;SL39=-GM*EM*T*0.5;SL40= EM*TP*TM*0.25;
	SL41=-GP*TP*TM*0.25;SL42=-GP*EM*T*0.5;SL43= EP*TP*TM*0.25;SL44= GP*TP*TM*0.25;SL45=-GP*EP*T*0.5;SL46=-EP*TP*TM*0.25;SL47= GM*TP*TM*0.25;SL48=-GM*EP*T*0.5;
	SL49=-EM*TP*G*0.5;SL50=-TP*GP*GM*0.25;SL51= EM*GP*GM*0.25;SL52= TP*EP*EM*0.25;SL53=-GP*TP*E*0.5;SL54= GP*EP*EM*0.25;SL55=-EP*TP*G*0.5;SL56= TP*GP*GM*0.25;
	SL57= EP*GP*GM*0.25;SL58=-TP*EP*EM*0.25;SL59=-GM*TP*E*0.5;SL60= GM*EP*EM*0.25;
	J= -2;
		DJR[3*J+7]=
SL1 *ind_c1[NDF*ind_nop1[ 0]  ]+SL4 *ind_c1[NDF*ind_nop1[ 1]  ]+SL7 *ind_c1[NDF*ind_nop1[ 2]  ]+SL10*ind_c1[NDF*ind_nop1[ 3]  ]+
SL13*ind_c1[NDF*ind_nop1[ 4]  ]+SL16*ind_c1[NDF*ind_nop1[ 5]  ]+SL19*ind_c1[NDF*ind_nop1[ 6]  ]+SL22*ind_c1[NDF*ind_nop1[ 7]  ]+
SL25*ind_c1[NDF*ind_nop1[ 8]  ]+SL28*ind_c1[NDF*ind_nop1[ 9]  ]+SL31*ind_c1[NDF*ind_nop1[10]  ]+SL34*ind_c1[NDF*ind_nop1[11]  ]+
SL37*ind_c1[NDF*ind_nop1[12]  ]+SL40*ind_c1[NDF*ind_nop1[13]  ]+SL43*ind_c1[NDF*ind_nop1[14]  ]+SL46*ind_c1[NDF*ind_nop1[15]  ]+
SL49*ind_c1[NDF*ind_nop1[16]  ]+SL52*ind_c1[NDF*ind_nop1[17]  ]+SL55*ind_c1[NDF*ind_nop1[18]  ]+SL58*ind_c1[NDF*ind_nop1[19]  ];
		DJR[3*J+8]=
SL2 *ind_c1[NDF*ind_nop1[ 0]  ]+SL5 *ind_c1[NDF*ind_nop1[ 1]  ]+SL8 *ind_c1[NDF*ind_nop1[ 2]  ]+SL11*ind_c1[NDF*ind_nop1[ 3]  ]+
SL14*ind_c1[NDF*ind_nop1[ 4]  ]+SL17*ind_c1[NDF*ind_nop1[ 5]  ]+SL20*ind_c1[NDF*ind_nop1[ 6]  ]+SL23*ind_c1[NDF*ind_nop1[ 7]  ]+
SL26*ind_c1[NDF*ind_nop1[ 8]  ]+SL29*ind_c1[NDF*ind_nop1[ 9]  ]+SL32*ind_c1[NDF*ind_nop1[10]  ]+SL35*ind_c1[NDF*ind_nop1[11]  ]+
SL38*ind_c1[NDF*ind_nop1[12]  ]+SL41*ind_c1[NDF*ind_nop1[13]  ]+SL44*ind_c1[NDF*ind_nop1[14]  ]+SL47*ind_c1[NDF*ind_nop1[15]  ]+
SL50*ind_c1[NDF*ind_nop1[16]  ]+SL53*ind_c1[NDF*ind_nop1[17]  ]+SL56*ind_c1[NDF*ind_nop1[18]  ]+SL59*ind_c1[NDF*ind_nop1[19]  ];
		DJR[3*J+9]=
SL3 *ind_c1[NDF*ind_nop1[ 0]  ]+SL6 *ind_c1[NDF*ind_nop1[ 1]  ]+SL9 *ind_c1[NDF*ind_nop1[ 2]  ]+SL12*ind_c1[NDF*ind_nop1[ 3]  ]+
SL15*ind_c1[NDF*ind_nop1[ 4]  ]+SL18*ind_c1[NDF*ind_nop1[ 5]  ]+SL21*ind_c1[NDF*ind_nop1[ 6]  ]+SL24*ind_c1[NDF*ind_nop1[ 7]  ]+
SL27*ind_c1[NDF*ind_nop1[ 8]  ]+SL30*ind_c1[NDF*ind_nop1[ 9]  ]+SL33*ind_c1[NDF*ind_nop1[10]  ]+SL36*ind_c1[NDF*ind_nop1[11]  ]+
SL39*ind_c1[NDF*ind_nop1[12]  ]+SL42*ind_c1[NDF*ind_nop1[13]  ]+SL45*ind_c1[NDF*ind_nop1[14]  ]+SL48*ind_c1[NDF*ind_nop1[15]  ]+
SL51*ind_c1[NDF*ind_nop1[16]  ]+SL54*ind_c1[NDF*ind_nop1[17]  ]+SL57*ind_c1[NDF*ind_nop1[18]  ]+SL60*ind_c1[NDF*ind_nop1[19]  ];
	J= -1;
		DJR[3*J+7]=
SL1 *ind_c1[NDF*ind_nop1[ 0]+1]+SL4 *ind_c1[NDF*ind_nop1[ 1]+1]+SL7 *ind_c1[NDF*ind_nop1[ 2]+1]+SL10*ind_c1[NDF*ind_nop1[ 3]+1]+
SL13*ind_c1[NDF*ind_nop1[ 4]+1]+SL16*ind_c1[NDF*ind_nop1[ 5]+1]+SL19*ind_c1[NDF*ind_nop1[ 6]+1]+SL22*ind_c1[NDF*ind_nop1[ 7]+1]+
SL25*ind_c1[NDF*ind_nop1[ 8]+1]+SL28*ind_c1[NDF*ind_nop1[ 9]+1]+SL31*ind_c1[NDF*ind_nop1[10]+1]+SL34*ind_c1[NDF*ind_nop1[11]+1]+
SL37*ind_c1[NDF*ind_nop1[12]+1]+SL40*ind_c1[NDF*ind_nop1[13]+1]+SL43*ind_c1[NDF*ind_nop1[14]+1]+SL46*ind_c1[NDF*ind_nop1[15]+1]+
SL49*ind_c1[NDF*ind_nop1[16]+1]+SL52*ind_c1[NDF*ind_nop1[17]+1]+SL55*ind_c1[NDF*ind_nop1[18]+1]+SL58*ind_c1[NDF*ind_nop1[19]+1];
		DJR[3*J+8]=
SL2 *ind_c1[NDF*ind_nop1[ 0]+1]+SL5 *ind_c1[NDF*ind_nop1[ 1]+1]+SL8 *ind_c1[NDF*ind_nop1[ 2]+1]+SL11*ind_c1[NDF*ind_nop1[ 3]+1]+
SL14*ind_c1[NDF*ind_nop1[ 4]+1]+SL17*ind_c1[NDF*ind_nop1[ 5]+1]+SL20*ind_c1[NDF*ind_nop1[ 6]+1]+SL23*ind_c1[NDF*ind_nop1[ 7]+1]+
SL26*ind_c1[NDF*ind_nop1[ 8]+1]+SL29*ind_c1[NDF*ind_nop1[ 9]+1]+SL32*ind_c1[NDF*ind_nop1[10]+1]+SL35*ind_c1[NDF*ind_nop1[11]+1]+
SL38*ind_c1[NDF*ind_nop1[12]+1]+SL41*ind_c1[NDF*ind_nop1[13]+1]+SL44*ind_c1[NDF*ind_nop1[14]+1]+SL47*ind_c1[NDF*ind_nop1[15]+1]+
SL50*ind_c1[NDF*ind_nop1[16]+1]+SL53*ind_c1[NDF*ind_nop1[17]+1]+SL56*ind_c1[NDF*ind_nop1[18]+1]+SL59*ind_c1[NDF*ind_nop1[19]+1];
		DJR[3*J+9]=
SL3 *ind_c1[NDF*ind_nop1[ 0]+1]+SL6 *ind_c1[NDF*ind_nop1[ 1]+1]+SL9 *ind_c1[NDF*ind_nop1[ 2]+1]+SL12*ind_c1[NDF*ind_nop1[ 3]+1]+
SL15*ind_c1[NDF*ind_nop1[ 4]+1]+SL18*ind_c1[NDF*ind_nop1[ 5]+1]+SL21*ind_c1[NDF*ind_nop1[ 6]+1]+SL24*ind_c1[NDF*ind_nop1[ 7]+1]+
SL27*ind_c1[NDF*ind_nop1[ 8]+1]+SL30*ind_c1[NDF*ind_nop1[ 9]+1]+SL33*ind_c1[NDF*ind_nop1[10]+1]+SL36*ind_c1[NDF*ind_nop1[11]+1]+
SL39*ind_c1[NDF*ind_nop1[12]+1]+SL42*ind_c1[NDF*ind_nop1[13]+1]+SL45*ind_c1[NDF*ind_nop1[14]+1]+SL48*ind_c1[NDF*ind_nop1[15]+1]+
SL51*ind_c1[NDF*ind_nop1[16]+1]+SL54*ind_c1[NDF*ind_nop1[17]+1]+SL57*ind_c1[NDF*ind_nop1[18]+1]+SL60*ind_c1[NDF*ind_nop1[19]+1];
	J=0;
		DJR[3*J+7]=
SL1 *ind_c1[NDF*ind_nop1[ 0]+2]+SL4 *ind_c1[NDF*ind_nop1[ 1]+2]+SL7 *ind_c1[NDF*ind_nop1[ 2]+2]+SL10*ind_c1[NDF*ind_nop1[ 3]+2]+
SL13*ind_c1[NDF*ind_nop1[ 4]+2]+SL16*ind_c1[NDF*ind_nop1[ 5]+2]+SL19*ind_c1[NDF*ind_nop1[ 6]+2]+SL22*ind_c1[NDF*ind_nop1[ 7]+2]+
SL25*ind_c1[NDF*ind_nop1[ 8]+2]+SL28*ind_c1[NDF*ind_nop1[ 9]+2]+SL31*ind_c1[NDF*ind_nop1[10]+2]+SL34*ind_c1[NDF*ind_nop1[11]+2]+
SL37*ind_c1[NDF*ind_nop1[12]+2]+SL40*ind_c1[NDF*ind_nop1[13]+2]+SL43*ind_c1[NDF*ind_nop1[14]+2]+SL46*ind_c1[NDF*ind_nop1[15]+2]+
SL49*ind_c1[NDF*ind_nop1[16]+2]+SL52*ind_c1[NDF*ind_nop1[17]+2]+SL55*ind_c1[NDF*ind_nop1[18]+2]+SL58*ind_c1[NDF*ind_nop1[19]+2];
		DJR[3*J+8]=
SL2 *ind_c1[NDF*ind_nop1[ 0]+2]+SL5 *ind_c1[NDF*ind_nop1[ 1]+2]+SL8 *ind_c1[NDF*ind_nop1[ 2]+2]+SL11*ind_c1[NDF*ind_nop1[ 3]+2]+
SL14*ind_c1[NDF*ind_nop1[ 4]+2]+SL17*ind_c1[NDF*ind_nop1[ 5]+2]+SL20*ind_c1[NDF*ind_nop1[ 6]+2]+SL23*ind_c1[NDF*ind_nop1[ 7]+2]+
SL26*ind_c1[NDF*ind_nop1[ 8]+2]+SL29*ind_c1[NDF*ind_nop1[ 9]+2]+SL32*ind_c1[NDF*ind_nop1[10]+2]+SL35*ind_c1[NDF*ind_nop1[11]+2]+
SL38*ind_c1[NDF*ind_nop1[12]+2]+SL41*ind_c1[NDF*ind_nop1[13]+2]+SL44*ind_c1[NDF*ind_nop1[14]+2]+SL47*ind_c1[NDF*ind_nop1[15]+2]+
SL50*ind_c1[NDF*ind_nop1[16]+2]+SL53*ind_c1[NDF*ind_nop1[17]+2]+SL56*ind_c1[NDF*ind_nop1[18]+2]+SL59*ind_c1[NDF*ind_nop1[19]+2];
		DJR[3*J+9]=
SL3 *ind_c1[NDF*ind_nop1[ 0]+2]+SL6 *ind_c1[NDF*ind_nop1[ 1]+2]+SL9 *ind_c1[NDF*ind_nop1[ 2]+2]+SL12*ind_c1[NDF*ind_nop1[ 3]+2]+
SL15*ind_c1[NDF*ind_nop1[ 4]+2]+SL18*ind_c1[NDF*ind_nop1[ 5]+2]+SL21*ind_c1[NDF*ind_nop1[ 6]+2]+SL24*ind_c1[NDF*ind_nop1[ 7]+2]+
SL27*ind_c1[NDF*ind_nop1[ 8]+2]+SL30*ind_c1[NDF*ind_nop1[ 9]+2]+SL33*ind_c1[NDF*ind_nop1[10]+2]+SL36*ind_c1[NDF*ind_nop1[11]+2]+
SL39*ind_c1[NDF*ind_nop1[12]+2]+SL42*ind_c1[NDF*ind_nop1[13]+2]+SL45*ind_c1[NDF*ind_nop1[14]+2]+SL48*ind_c1[NDF*ind_nop1[15]+2]+
SL51*ind_c1[NDF*ind_nop1[16]+2]+SL54*ind_c1[NDF*ind_nop1[17]+2]+SL57*ind_c1[NDF*ind_nop1[18]+2]+SL60*ind_c1[NDF*ind_nop1[19]+2];
	if(ISL==2)
	  {*DJD=DJR[1]*(DJR[5]*DJR[9]-DJR[6]*DJR[8])+DJR[2]*(DJR[6]*DJR[7]-DJR[4]*DJR[9])+DJR[3]*(DJR[4]*DJR[8]-DJR[5]*DJR[7]);
/////////////////////
//honk<< *DJD<<" DJD\n";
//honk<<DJR[1]<<" "<<DJR[2]<<" "<<DJR[3]<<" "<<DJR[4]<<" "<<DJR[5]<<" "<<DJR[6]<<" "<<DJR[7]<<" "<<DJR[8]<<" "<<DJR[9]<<" DJR\n";
/////////////////////
	  if(sqrt(*DJD * *DJD)<1.E-30){
// ::MessageBeep(-1);MessageBox("STFISO8 zero det.");
									   *DJD=1.E-6;
									  }
	  DJI1=(DJR[5]*DJR[9]-DJR[6]*DJR[8])/ *DJD;DJI4=(DJR[6]*DJR[7]-DJR[4]*DJR[9])/ *DJD;
	  DJI7=(DJR[4]*DJR[8]-DJR[5]*DJR[7])/ *DJD;DJI2=(DJR[3]*DJR[8]-DJR[2]*DJR[9])/ *DJD;
	  DJI5=(DJR[1]*DJR[9]-DJR[3]*DJR[7])/ *DJD;DJI8=(DJR[2]*DJR[7]-DJR[1]*DJR[8])/ *DJD;
	  DJI3=(DJR[2]*DJR[6]-DJR[3]*DJR[5])/ *DJD;DJI6=(DJR[3]*DJR[4]-DJR[1]*DJR[6])/ *DJD;
	  DJI9=(DJR[1]*DJR[5]-DJR[2]*DJR[4])/ *DJD;
	  SG[0]=DJI1*SL1+DJI4*SL2+DJI7*SL3;SG[1]=DJI2*SL1+DJI5*SL2+DJI8*SL3;
	  SG[2]=DJI3*SL1+DJI6*SL2+DJI9*SL3;SG[3]=DJI1*SL4+DJI4*SL5+DJI7*SL6;
	  SG[4]=DJI2*SL4+DJI5*SL5+DJI8*SL6;SG[5]=DJI3*SL4+DJI6*SL5+DJI9*SL6;
	  SG[6]=DJI1*SL7+DJI4*SL8+DJI7*SL9;SG[7]=DJI2*SL7+DJI5*SL8+DJI8*SL9;
	  SG[8]=DJI3*SL7+DJI6*SL8+DJI9*SL9;SG[9]=DJI1*SL10+DJI4*SL11+DJI7*SL12;
	  SG[10]=DJI2*SL10+DJI5*SL11+DJI8*SL12;SG[11]=DJI3*SL10+DJI6*SL11+DJI9*SL12;
	  SG[12]=DJI1*SL13+DJI4*SL14+DJI7*SL15;SG[13]=DJI2*SL13+DJI5*SL14+DJI8*SL15;
	  SG[14]=DJI3*SL13+DJI6*SL14+DJI9*SL15;SG[15]=DJI1*SL16+DJI4*SL17+DJI7*SL18;
	  SG[16]=DJI2*SL16+DJI5*SL17+DJI8*SL18;SG[17]=DJI3*SL16+DJI6*SL17+DJI9*SL18;
	  SG[18]=DJI1*SL19+DJI4*SL20+DJI7*SL21;SG[19]=DJI2*SL19+DJI5*SL20+DJI8*SL21;
	  SG[20]=DJI3*SL19+DJI6*SL20+DJI9*SL21;SG[21]=DJI1*SL22+DJI4*SL23+DJI7*SL24;
	  SG[22]=DJI2*SL22+DJI5*SL23+DJI8*SL24;SG[23]=DJI3*SL22+DJI6*SL23+DJI9*SL24;
//
	  SG[24]=DJI1*SL25+DJI4*SL26+DJI7*SL27;SG[25]=DJI2*SL25+DJI5*SL26+DJI8*SL27;
	  SG[26]=DJI3*SL25+DJI6*SL26+DJI9*SL27;SG[27]=DJI1*SL28+DJI4*SL29+DJI7*SL30;
	  SG[28]=DJI2*SL28+DJI5*SL29+DJI8*SL30;SG[29]=DJI3*SL28+DJI6*SL29+DJI9*SL30;
	  SG[30]=DJI1*SL31+DJI4*SL32+DJI7*SL33;SG[31]=DJI2*SL31+DJI5*SL32+DJI8*SL33;
	  SG[32]=DJI3*SL31+DJI6*SL32+DJI9*SL33;SG[33]=DJI1*SL34+DJI4*SL35+DJI7*SL36;
	  SG[34]=DJI2*SL34+DJI5*SL35+DJI8*SL36;SG[35]=DJI3*SL34+DJI6*SL35+DJI9*SL36;
	  SG[36]=DJI1*SL37+DJI4*SL38+DJI7*SL39;SG[37]=DJI2*SL37+DJI5*SL38+DJI8*SL39;
	  SG[38]=DJI3*SL37+DJI6*SL38+DJI9*SL39;SG[39]=DJI1*SL40+DJI4*SL41+DJI7*SL42;
	  SG[40]=DJI2*SL40+DJI5*SL41+DJI8*SL42;SG[41]=DJI3*SL40+DJI6*SL41+DJI9*SL42;
	  SG[42]=DJI1*SL43+DJI4*SL44+DJI7*SL45;SG[43]=DJI2*SL43+DJI5*SL44+DJI8*SL45;
	  SG[44]=DJI3*SL43+DJI6*SL44+DJI9*SL45;SG[45]=DJI1*SL46+DJI4*SL47+DJI7*SL48;
	  SG[46]=DJI2*SL46+DJI5*SL47+DJI8*SL48;SG[47]=DJI3*SL46+DJI6*SL47+DJI9*SL48;
	  SG[48]=DJI1*SL49+DJI4*SL50+DJI7*SL51;SG[49]=DJI2*SL49+DJI5*SL50+DJI8*SL51;
	  SG[50]=DJI3*SL49+DJI6*SL50+DJI9*SL51;SG[51]=DJI1*SL52+DJI4*SL53+DJI7*SL54;
	  SG[52]=DJI2*SL52+DJI5*SL53+DJI8*SL54;SG[53]=DJI3*SL52+DJI6*SL53+DJI9*SL54;
	  SG[54]=DJI1*SL55+DJI4*SL56+DJI7*SL57;SG[55]=DJI2*SL55+DJI5*SL56+DJI8*SL57;
	  SG[56]=DJI3*SL55+DJI6*SL56+DJI9*SL57;SG[57]=DJI1*SL58+DJI4*SL59+DJI7*SL60;
	  SG[58]=DJI2*SL58+DJI5*SL59+DJI8*SL60;SG[59]=DJI3*SL58+DJI6*SL59+DJI9*SL60;
	  }
	else
	  {FPROD=1.;
		if     (sqrt((G*G-1.)*(G*G-1.)) < PRMT){I=1;if(G<0)FPROD= -1.;}
		else if(sqrt((E*E-1.)*(E*E-1.)) < PRMT){I=2;if(E<0)FPROD= -1.;}
		else if(sqrt((T*T-1.)*(T*T-1.)) < PRMT){I=3;if(T<0)FPROD= -1.;}
		else{
//  ::MessageBeep(-1);MessageBox("STFISO8 invalid surface pt.");
			  exit(0);
			 }
		IP= -2+I*(11-3*I)/2;IM=6-I-IP;
		GG11=DJR[IP]*DJR[IP]+DJR[IP+3]*DJR[IP+3]+DJR[IP+6]*DJR[IP+6];
		GG22=DJR[IM]*DJR[IM]+DJR[IM+3]*DJR[IM+3]+DJR[IM+6]*DJR[IM+6];
		GG12=DJR[IP]*DJR[IM]+DJR[IP+3]*DJR[IM+3]+DJR[IP+6]*DJR[IM+6];
		*DJD=GG11*GG22-GG12*GG12;
	  if(sqrt(*DJD * *DJD)<1.E-30){
//  ::MessageBeep(-1);MessageBox("STFISO8 zero surf.det.");
									   *DJD=1.E-6;
									  }
	  else *DJD=sqrt(*DJD);
	  GGSQ=1./sqrt(GG11);
	  HN[0]=(DJR[IP+3]*DJR[IM+6]-DJR[IP+6]*DJR[IM+3])/ *DJD;
	  HN[1]=(DJR[IP+6]*DJR[IM  ]-DJR[IP  ]*DJR[IM+6])/ *DJD;
	  HN[2]=(DJR[IP  ]*DJR[IM+3]-DJR[IP+3]*DJR[IM  ])/ *DJD;
	  HN[3]=GGSQ*DJR[IP  ];HN[4]=GGSQ*DJR[IP+3];HN[5]=GGSQ*DJR[IP+6];
	  HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
	  HN[8]=HN[0]*HN[4]-HN[1]*HN[3];
	  for(int IC=0;IC<9;IC++)HN[IC]=FPROD*HN[IC];
	}
	 }
		else{
//  ::MessageBeep(-1);MessageBox("STFISO8 unsupported ISL");
			  exit(0);
			 }
}
//---------------------------------------------------------------------------
void TForm1::STFISO15(int ISL,float G,float E,float T,float *DJD,float HN[],float SN[],float SG[],float DJR[],long ind_nop1[],float ind_c1[])
//CCCCC Note: G==L1, E==L2, T==natural z coord (=t), L3=1.-L1-L2
//
//   DJR(I,J)= dx/dL1  dy/dL1  dz/dL1  based on L1/L2/1-L1-L2 coords
//             dx/dL2  dy/dL2  dz/dL2  based on L1/L2/1-L1-L2 coords
//             dx/dt   dy/dt   dz/dt   based on L1/L2/1-L1-L2 coords
//
//   However, to compute surface normals it is necessary to use the
//   appropriate basis system on each side (ie. L1/L2 on side L1=0,
//   L1/L2 on side L2=0, L1/L3 on side L3=0)
//
//   Hence the array SLP(I)= dN(L1,L3)/dL1 and DJR6(I,J) thus:
//
//  DJR6(I,J)= dx/dL1  dy/dL1  dz/dL1  based on L1/1-L1-L3/L3 coords
//             dx/dL1  dy/dL1  dz/dL1  based on L1/L2/1-L1-L2 coords
//             dx/dL2  dy/dL2  dz/dL2  based on L1/L2/1-L1-L2 coords
//  	       dx/dt   dy/dt   dz/dt   based on L1/L2/1-L1-L2 coords
//
//  Note that DJD/DJD are RECTANGULAR areas/volumes ...NOT triangular.
//  See User Manual for element surface coord.frame & note that this
//  frame varies drastically on triangular sides....
{int I=0,IM=0,IP=0,J=0,K=0,NODE=15;
//      DIMENSION HN(3),SN(1),SG(3,8),CORD(NDF,1),DJR(3,3),NOP(MXNPEL)
 float PRMT=1.E-10,GG11=0.,GG22=0.,GG12=0.,WSGN=0.,FPROD=0.,S=0.,SUM=0.,
		SL[45],DJI[9],SLP[15],DJR6[12];
 S=1.-G-E;
 if(ISL==1)
	{*DJD=0.;
	SN[0]=G*(2.*G-T-2.)*(1.-T)*0.5;
	SN[1]=E*(2.*E-T-2.)*(1.-T)*0.5;
	SN[2]=S*(2.*S-T-2.)*(1.-T)*0.5;
	SN[3]=G*(2.*G+T-2.)*(1.+T)*0.5;
	SN[4]=E*(2.*E+T-2.)*(1.+T)*0.5;
	SN[5]=S*(2.*S+T-2.)*(1.+T)*0.5;
	SN[6]=2.*G*E*(1.-T);
	SN[7]=2.*E*S*(1.-T);
	SN[8]=2.*G*S*(1.-T);
	SN[9]=G*(1.-T*T);
	SN[10]=E*(1.-T*T);
	SN[11]=S*(1.-T*T);
	SN[12]=2.*G*E*(1.+T);
	SN[13]=2.*E*S*(1.+T);
	SN[14]=2.*G*S*(1.+T);
	}
 else if(ISL==2 || ISL==3)
	{
	SL[0]=(4.*G-T-2.)*(1.-T)/2.;
	SL[1]=0.;
	SL[2]=G*(1.-2.*G+2.*T)/2.;
	SL[3]=0.;
	SL[4]=(4.*E-T-2.)*(1.-T)/2.;
	SL[5]=E*(1.-2.*E+2.*T)/2.;
	SL[6]=(2.-4.*S+T)*(1.-T)/2.;
	SL[7]=(2.-4.*S+T)*(1.-T)/2.;
	SL[8]=S*(1.-2.*S+2.*T)/2.;
	SL[9]=(4.*G+T-2.)*(1.+T)/2.;
	SL[10]=0.;
	SL[11]=G*(-1.+2.*G+2.*T)/2.;
	SL[12]=0.;
	SL[13]=(4.*E+T-2.)*(1.+T)/2.;
	SL[14]=E*(-1.+2.*E+2.*T)/2.;
	SL[15]=(2.-4.*S-T)*(1.+T)/2.;
	SL[16]=(2.-4.*S-T)*(1.+T)/2.;
	SL[17]=S*(-1.+2.*S+2.*T)/2.;
	SL[18]=2.*E*(1.-T);
	SL[19]=2.*G*(1.-T);
	SL[20]= -2.*G*E;
	SL[21]= -2.*E*(1.-T);
	SL[22]=2.*(S-E)*(1.-T);
	SL[23]= -2.*E*S;
	SL[24]=2.*(S-G)*(1.-T);
	SL[25]= -2.*G*(1.-T);
	SL[26]= -2.*G*S;
	SL[27]=1.-T*T;
	SL[28]=0.;
	SL[29]= -2.*G*T;
	SL[30]=0.;
	SL[31]=1.-T*T;
	SL[32]= -2.*E*T;
	SL[33]= -(1.-T*T);
	SL[34]= -(1.-T*T);
	SL[35]= -2.*S*T;
	SL[36]=2.*E*(1.+T);
	SL[37]=2.*G*(1.+T);
	SL[38]=2.*G*E;
	SL[39]= -2.*E*(1.+T);
	SL[40]=2.*(S-E)*(1.+T);
	SL[41]=2.*E*S;
	SL[42]=2.*(S-G)*(1.+T);
	SL[43]= -2.*G*(1.+T);
	SL[44]=2.*G*S;
// NOTE NOTE NOTE DJR[1 to 9]  !!!!!!!!!!!!!!
        for(J=0;J<3;J++){for(I=0;I<3;I++){SUM=0.;
										  for(K=0;K<NODE;K++)SUM=SUM+SL[I+3*K]*ind_c1[NDF*ind_nop1[K]+J];
                                          DJR[I+3*J+1]=SUM;
										 }
						}
	if(ISL==2)
	  {*DJD=DJR[1]*(DJR[5]*DJR[9]-DJR[6]*DJR[8])+DJR[2]*(DJR[6]*DJR[7]-DJR[4]*DJR[9])
			+DJR[3]*(DJR[4]*DJR[8]-DJR[5]*DJR[7]);
	  if(sqrt(*DJD * *DJD)<1.E-30){
// ::MessageBeep(-1);MessageBox("STFISO8 zero det.");
									   *DJD=1.E-6;
									  }
	  DJI[0]=(DJR[5]*DJR[9]-DJR[6]*DJR[8])/ *DJD;
	  DJI[3]=(DJR[6]*DJR[7]-DJR[4]*DJR[9])/ *DJD;
	  DJI[6]=(DJR[4]*DJR[8]-DJR[5]*DJR[7])/ *DJD;
	  DJI[1]=(DJR[3]*DJR[8]-DJR[2]*DJR[9])/ *DJD;
	  DJI[4]=(DJR[1]*DJR[9]-DJR[3]*DJR[7])/ *DJD;
	  DJI[7]=(DJR[2]*DJR[7]-DJR[1]*DJR[8])/ *DJD;
	  DJI[2]=(DJR[2]*DJR[6]-DJR[3]*DJR[5])/ *DJD;
	  DJI[5]=(DJR[3]*DJR[4]-DJR[1]*DJR[6])/ *DJD;
	  DJI[8]=(DJR[1]*DJR[5]-DJR[2]*DJR[4])/ *DJD;
          for(J=3;J<3*NODE+1;J=J+3){for(I=0;I<3;I++)SG[I+J-3]=DJI[I]*SL[J-3]+DJI[I+3]*SL[J-2]+DJI[I+6]*SL[J-1];}
	  }
	else
	  {
	  SLP[0]=(4.*G-T-2.)*(1.-T)/2.;
	  SLP[1]=(2.-4.*E+T)*(1.-T)/2.;
	  SLP[2]=0.;
	  SLP[3]=(4.*G+T-2.)*(1.+T)/2.;
	  SLP[4]=(2.-4.*E-T)*(1.+T)/2.;
	  SLP[5]=0.;
	  SLP[6]=2.*(E-G)*(1.-T);
	  SLP[7]= -2.*S*(1.-T);
	  SLP[8]=2.*S*(1.-T);
	  SLP[9]=1.-T*T;
	  SLP[10]= -(1.-T*T);
	  SLP[11]=0.;
	  SLP[12]=2.*(E-G)*(1.+T);
	  SLP[13]= -2.*S*(1.+T);
	  SLP[14]=2.*S*(1.+T);
          for(J=1;J<3+1;J++){for(I=1;I<3+1;I++)DJR6[1-I+4*J  -1]=DJR[1-I+3*J];}
		  for(J=1;J<3+1;J++){SUM=0.;
                             for(K=0;K<NODE;K++)SUM=SUM+SLP[K]*ind_c1[NDF*ind_nop1[K]+J-1];
                             DJR6[4*J-3  -1]=SUM;
							}
	  WSGN=1.;
           FPROD=1.;
	  if(fabs(T*T-1.)>PRMT){IP=2;IM=3;if(T<0.)FPROD= -1.;}
	  else {IM=4;
   	        if(fabs(G)<PRMT){IP=3;WSGN= -1.;}
			else if(fabs(E)<PRMT)IP=2;
	        else if(fabs(1.-G-E)<PRMT){IP=1;WSGN= -1.;}
  	        else{
//  ::MessageBeep(-1);MessageBox("STFISO8 invalid surface pt.");
			  exit(0);
	            }
		   }
      GG11=DJR6[IP-1]*DJR6[IP-1]+DJR6[IP+4-1]*DJR6[IP+4-1]+DJR6[IP+8-1]*DJR6[IP+8-1];
	  GG22=DJR6[IM-1]*DJR6[IM-1]+DJR6[IM+4-1]*DJR6[IM+4-1]+DJR6[IM+8-1]*DJR6[IM+8-1];
      GG12=DJR6[IP-1]*DJR6[IM-1]+DJR6[IP+4-1]*DJR6[IM+4-1]+DJR6[IP+8-1]*DJR6[IM+8-1];
	  *DJD=GG11*GG22-GG12*GG12;
	  if(sqrt(*DJD * *DJD)<1.E-30){
//  ::MessageBeep(-1);MessageBox("STFISO8 zero surf.det.");
                                       *DJD=1.E-6;
                                      }
	  else *DJD=sqrt(*DJD);
	  HN[0]=WSGN*(DJR6[IP+4-1]*DJR6[IM+8-1]-DJR6[IP+8-1]*DJR6[IM+4-1])/ *DJD;
	  HN[1]=WSGN*(DJR6[IP+8-1]*DJR6[IM  -1]-DJR6[IP  -1]*DJR6[IM+8-1])/ *DJD;
	  HN[2]=WSGN*(DJR6[IP  -1]*DJR6[IM+4-1]-DJR6[IP+4-1]*DJR6[IM  -1])/ *DJD;
	  HN[3]=WSGN*DJR6[IP  -1]/sqrt(GG11);
	  HN[4]=WSGN*DJR6[IP+4-1]/sqrt(GG11);
	  HN[5]=WSGN*DJR6[IP+8-1]/sqrt(GG11);
	  HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
	  HN[8]=HN[0]*HN[4]-HN[1]*HN[3];
	  for(int IC=0;IC<9;IC++)HN[IC]=FPROD*HN[IC];
	}
	 }
		else{
//  ::MessageBeep(-1);MessageBox("STFISO8 unsupported ISL");
			  exit(0);
			 }
}
//---------------------------------------------------------------------------
void TForm1::STFISO10(int ISL,float G,float E,float T,float *DJD,float HN[],float SN[],float SG[],float DJR[],long ind_nop1[],float ind_c1[])
//  See User Manual for element surface coord.frame.
//  On positive sides: n x t1=t2; on negative HN()= -HN(positive side)
//  so n x t1 = -t2 on negative sides (ie. NOT corkscrew).
//  Normal=HN(1 to 3), t1=HN(4 to 6), t2=HN(7 to 9) so      x = HN.x'
//  CAUTION: do NOT evaluate normals at edges/nodes due to ambiguity!!
//CCCCCC Note: G==L1, E==L2, T==natural z coord (=t), L3=1.-L1-L2
//C
//C   DJR(I,J)= dx/dL2  dy/dL2  dz/dL2  based on L1/L2/L3/1-L1-L2-L3 coords
//C             dx/dL3  dy/dL3  dz/dL3  based on L1/L2/L3/1-L1-L2-L3 coords
//C             dx/dL4  dy/dL4  dz/dL4  based on L1/L2/L3/1-L1-L2-L3 coords
//C
//C   However, to compute surface normals it is necessary to use the
//C   appropriate basis system on each side (ie. L1/L2 on side L1=0,
//C   L1/L2 on side L2=0, L1/L3 on side L3=0)
//C
//C  Note that DJD/DJD are true TETRA areas/volumes ...NOT rectangular.
{int I=0,IM=0,IP=0,J=0,K=0,NODE=10;
//      DIMENSION HN(3),SN(1),SG(3,8),CORD(NDF,1),DJR(3,3),NOP(MXNPEL)
 float PRMT=1.E-10,PMSURF=1.E-8,GG11=0.,GG22=0.,GG12=0.,GGSQ=0.,S=0.,SUM=0.,SL[30],DJI[9];
 S=1.-G-E-T;
 if(ISL==1)
	{*DJD=0.;
	SN[0]=G*(2.*G-1.);
	SN[1]=E*(2.*E-1.);
	SN[2]=T*(2.*T-1.);
	SN[3]=S*(2.*S-1.);
	SN[4]=4.*G*E;
	SN[5]=4.*E*T;
	SN[6]=4.*G*T;
	SN[7]=4.*G*S;
	SN[8]=4.*E*S;
	SN[9]=4.*T*S;
	}
 else if(ISL==2 || ISL==3)
	{
	SL[0]=1.-4.*G;
	SL[1]=1.-4.*G;
	SL[2]=1.-4.*G;
	SL[3]=4.*E-1.;
	SL[4]=0.;
	SL[5]=0.;
	SL[6]=0.;
	SL[7]=4.*T-1.;
	SL[8]=0.;
	SL[9]=0.;
	SL[10]=0.;
	SL[11]=4.*S-1.;
	SL[12]=4.*(G-E);
	SL[13]= -4.*E;
	SL[14]= -4.*E;
	SL[15]=4.*T;
	SL[16]=4.*E;
	SL[17]=0.;
	SL[18]= -4.*T;
	SL[19]=4.*(G-T);
	SL[20]= -4.*T;
	SL[21]= -4.*S;
	SL[22]= -4.*S;
	SL[23]=4.*(G-S);
	SL[24]=4.*S;
	SL[25]=0.;
	SL[26]=4.*E;
	SL[27]=0.;
	SL[28]=4.*S;
	SL[29]=4.*T;
// NOTE NOTE NOTE DJR[1 to 9]  !!!!!!!!!!!!!!
        for(J=0;J<3;J++){for(I=0;I<3;I++){SUM=0.;
                                          for(K=0;K<NODE;K++)SUM=SUM+SL[I+3*K]*ind_c1[NDF*ind_nop1[K]+J];
										  DJR[I+3*J+1]=SUM;
                                         }
                        }
	if(ISL==2)
	  {*DJD=DJR[1]*(DJR[5]*DJR[9]-DJR[6]*DJR[8])+DJR[2]*(DJR[6]*DJR[7]-DJR[4]*DJR[9])
			+DJR[3]*(DJR[4]*DJR[8]-DJR[5]*DJR[7]);
	  if(sqrt(*DJD * *DJD)<1.E-30){
// ::MessageBeep(-1);MessageBox("STFISO8 zero det.");
									   *DJD=1.E-6;
									  }
	  DJI[0]=(DJR[5]*DJR[9]-DJR[6]*DJR[8])/ *DJD;
	  DJI[3]=(DJR[6]*DJR[7]-DJR[4]*DJR[9])/ *DJD;
	  DJI[6]=(DJR[4]*DJR[8]-DJR[5]*DJR[7])/ *DJD;
	  DJI[1]=(DJR[3]*DJR[8]-DJR[2]*DJR[9])/ *DJD;
	  DJI[4]=(DJR[1]*DJR[9]-DJR[3]*DJR[7])/ *DJD;
	  DJI[7]=(DJR[2]*DJR[7]-DJR[1]*DJR[8])/ *DJD;
	  DJI[2]=(DJR[2]*DJR[6]-DJR[3]*DJR[5])/ *DJD;
	  DJI[5]=(DJR[3]*DJR[4]-DJR[1]*DJR[6])/ *DJD;
	  DJI[8]=(DJR[1]*DJR[5]-DJR[2]*DJR[4])/ *DJD;
          for(J=3;J<3*NODE+1;J=J+3){for(I=0;I<3;I++)SG[I+J-3]=DJI[I]*SL[J-3]+DJI[I+3]*SL[J-2]+DJI[I+6]*SL[J-1];}
	  *DJD= *DJD/6.;
	  }
	  else
		 {if(fabs(S)<PRMT)
			 {IP=2;IM=3;HN[0]= -DJR[IP+3]*DJR[IM+6]+DJR[IP+6]*DJR[IM+3];
			  HN[1]= -DJR[IP+6]*DJR[IM  ]+DJR[IP  ]*DJR[IM+6];
			  HN[2]= -DJR[IP  ]*DJR[IM+3]+DJR[IP+3]*DJR[IM  ];
			  IP=3;IM=1;HN[0]=HN[0]-DJR[IP+3]*DJR[IM+6]+DJR[IP+6]*DJR[IM+3];
			  HN[1]=HN[1]-DJR[IP+6]*DJR[IM  ]+DJR[IP  ]*DJR[IM+6];
			  HN[2]=HN[2]-DJR[IP  ]*DJR[IM+3]+DJR[IP+3]*DJR[IM  ];
			  IP=1;IM=2;HN[0]=HN[0]-DJR[IP+3]*DJR[IM+6]+DJR[IP+6]*DJR[IM+3];
			  HN[1]=HN[1]-DJR[IP+6]*DJR[IM  ]+DJR[IP  ]*DJR[IM+6];
			  HN[2]=HN[2]-DJR[IP  ]*DJR[IM+3]+DJR[IP+3]*DJR[IM  ];
			  *DJD=HN[0]*HN[0]+HN[1]*HN[1]+HN[2]*HN[2];
			  if(*DJD<PMSURF*PMSURF){
//  ::MessageBeep(-1);MessageBox("STFISO10 zero surf.det.");
                                                 *DJD=1.E-6;
												}
			  else *DJD=sqrt(*DJD);
			  HN[0]=HN[0]/ *DJD;HN[1]=HN[1]/ *DJD;HN[2]=HN[2]/ *DJD;
			  HN[3]=DJR[3]-DJR[1];HN[4]=DJR[6]-DJR[4];HN[5]=DJR[9]-DJR[7];
			  GGSQ=1./sqrt(HN[3]*HN[3]+HN[4]*HN[4]+HN[5]*HN[5]);
			  HN[3]=GGSQ*HN[3];HN[4]=GGSQ*HN[4];HN[5]=GGSQ*HN[5];
			  HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
			  HN[8]=HN[0]*HN[4]-HN[1]*HN[3]; *DJD= *DJD/2.;
			 }
		  else
			 {if(fabs(G)<PRMT){IP=2;IM=3;}
			  else if(fabs(E)<PRMT){IP=3;IM=1;}
			  else if(fabs(T)<PRMT){IP=1;IM=2;}
			  else{
//  ::MessageBeep(-1);MessageBox("STFISO10 invalid surface pt.");
					 exit(0);
					}
			  GG11=DJR[IP]*DJR[IP]+DJR[IP+3]*DJR[IP+3]+DJR[IP+6]*DJR[IP+6];
			  GG22=DJR[IM]*DJR[IM]+DJR[IM+3]*DJR[IM+3]+DJR[IM+6]*DJR[IM+6];
			  GG12=DJR[IP]*DJR[IM]+DJR[IP+3]*DJR[IM+3]+DJR[IP+6]*DJR[IM+6];
			  *DJD=GG11*GG22-GG12*GG12;
			  if(*DJD<PMSURF*PMSURF){
//  ::MessageBeep(-1);MessageBox("STFISO10 zero surf.det.");
                                                 *DJD=1.E-6;
                                                }
			  else *DJD=sqrt(*DJD);
			  GGSQ=1./sqrt(GG11);
			  HN[0]=(DJR[IP+3]*DJR[IM+6]-DJR[IP+6]*DJR[IM+3])/ *DJD;
			  HN[1]=(DJR[IP+6]*DJR[IM  ]-DJR[IP  ]*DJR[IM+6])/ *DJD;
			  HN[2]=(DJR[IP  ]*DJR[IM+3]-DJR[IP+3]*DJR[IM  ])/ *DJD;
			  HN[3]=GGSQ*DJR[IP  ];HN[4]=GGSQ*DJR[IP+3];HN[5]=GGSQ*DJR[IP+6];
			  HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
			  HN[8]=HN[0]*HN[4]-HN[1]*HN[3]; *DJD= *DJD/2.;
			 }
		 }
	 }
  else{
//  ::MessageBeep(-1);MessageBox("STFISO10 unsupported ISL");
		 exit(0);
		}
}
//---------------------------------------------------------------------------
void TForm1::STFISO8_ncalc(long ie,long iside,float HN[],long ind_nop1[],float ind_c1[])
{long n0=0,n1=0,n2=0,n3=0;float a0=0.,a1=0.,a2=0.,b0=0.,b1=0.,b2=0.,c0=0.,c1=0.,c2=0.,mag=0.;
 if(iside==0)     {n0=4;n2=1;n1=0;n3=5;}//OK
 else if(iside==1){n0=5;n2=2;n1=1;n3=6;}//OK
 else if(iside==2){n0=6;n2=3;n1=2;n3=7;}//OK
 else if(iside==3){n0=7;n2=0;n1=3;n3=4;}//OK
 else if(iside==4){n0=0;n2=2;n1=3;n3=1;}//OK
 else             {n0=7;n2=5;n1=4;n3=6;}//OK
 a0=ind_c1[NDF*ind_nop1[MXNPEL*ie+n2]+0] -ind_c1[NDF*ind_nop1[MXNPEL*ie+n0]+0];
 a1=ind_c1[NDF*ind_nop1[MXNPEL*ie+n2]+1] -ind_c1[NDF*ind_nop1[MXNPEL*ie+n0]+1];
 a2=ind_c1[NDF*ind_nop1[MXNPEL*ie+n2]+2] -ind_c1[NDF*ind_nop1[MXNPEL*ie+n0]+2];
 mag=sqrt(a0*a0+a1*a1+a2*a2);a0=a0/mag;a1=a1/mag;a2=a2/mag;
 b0=ind_c1[NDF*ind_nop1[MXNPEL*ie+n3]+0] -ind_c1[NDF*ind_nop1[MXNPEL*ie+n1]+0];
 b1=ind_c1[NDF*ind_nop1[MXNPEL*ie+n3]+1] -ind_c1[NDF*ind_nop1[MXNPEL*ie+n1]+1];
 b2=ind_c1[NDF*ind_nop1[MXNPEL*ie+n3]+2] -ind_c1[NDF*ind_nop1[MXNPEL*ie+n1]+2];
 mag=sqrt(b0*b0+b1*b1+b2*b2);b0=b0/mag;b1=b1/mag;b2=b2/mag;

//honk<<a0<<" "<<a1<<" "<<a2<<" Protagonists "<<b0<<" "<<b1<<" "<<b2<<"\n";

 c0=a1*b2-a2*b1;c1=a2*b0-a0*b2;c2=a0*b1-a1*b0;
 mag=sqrt(c0*c0+c1*c1+c2*c2);HN[0]=c0/mag;HN[1]=c1/mag;HN[2]=c2/mag;
}
//---------------------------------------------------------------------------
void TForm1::STFISO8(int ISL,float G,float E,float T,float *DJD,float HN[],float SN[],float SG[],float DJR[],long ind_nop1[],float ind_c1[])
//  See User Manual for element surface coord.frame.
//  On positive sides: n x t1=t2; on negative HN()= -HN(positive side)
//  so n x t1 = -t2 on negative sides (ie. NOT corkscrew).
//  Normal=HN(1 to 3), t1=HN(4 to 6), t2=HN(7 to 9) so      x = HN.x'
//  CAUTION: do NOT evaluate normals at edges/nodes due to ambiguity!!
// CAUTION: a surface point MUST be exactly on surface (i.e. one natural coord = +/-1.)
{int I=0,IM=0,IP=0,J=0;
//      DIMENSION HN(3),SN(1),SG(3,8),CORD(NDF,1),DJR(3,3),NOP(MXNPEL)
 float PRMT=1.E-5,GP=0.,GM=0.,EP=0.,EM=0.,TP=0.,TM=0.,
   SL1=0.,SL4=0.,SL7=0.,SL10=0.,SL13=0.,SL16=0.,SL19=0.,SL22=0.,SL2=0.,SL5=0.,SL8=0.,SL11=0.,
   SL14=0.,SL17=0.,SL20=0.,SL23=0.,SL3=0.,SL6=0.,SL9=0.,SL12=0.,SL15=0.,SL18=0.,SL21=0.,SL24=0.,
   DJI1=0.,DJI4=0.,DJI7=0.,DJI2=0.,DJI5=0.,DJI8=0.,DJI3=0.,DJI6=0.,DJI9=0.,GG11=0.,GG22=0.,GG12=0.,GGSQ=0.,FPROD=0.;
 GP=0.5*(1.+G);GM=0.5*(1.-G);EP=0.5*(1.+E);EM=0.5*(1.-E);TP=0.5*(1.+T);TM=0.5*(1.-T);
 if(ISL==1){*DJD=0.;SN[0]=GM*EM*TM;SN[1]=GP*EM*TM;SN[2]=GP*EP*TM;SN[3]=GM*EP*TM;
				SN[4]=GM*EM*TP;SN[5]=GP*EM*TP;SN[6]=GP*EP*TP;SN[7]=GM*EP*TP;
	   }
 else if(ISL==2 || ISL==3)
	{SL1=-EM*TM;SL4= EM*TM;SL7= EP*TM;SL10=-EP*TM;SL13=-EM*TP;SL16= EM*TP;
	SL19= EP*TP;SL22=-EP*TP;SL2=-GM*TM;SL5=-GP*TM;SL8= GP*TM;SL11= GM*TM;
	SL14=-GM*TP;SL17=-GP*TP;SL20= GP*TP;SL23= GM*TP;SL3=-GM*EM;SL6=-GP*EM;
	SL9=-GP*EP;SL12=-GM*EP;SL15= GM*EM;SL18= GP*EM;SL21= GP*EP;SL24= GM*EP;
	J= -2;  DJR[3*J+6]=0.5*(
SL1 *ind_c1[NDF*ind_nop1[0]  ]+SL4 *ind_c1[NDF*ind_nop1[1]  ]+
SL7 *ind_c1[NDF*ind_nop1[2]  ]+SL10*ind_c1[NDF*ind_nop1[3]  ]+
SL13*ind_c1[NDF*ind_nop1[4]  ]+SL16*ind_c1[NDF*ind_nop1[5]  ]+
SL19*ind_c1[NDF*ind_nop1[6]  ]+SL22*ind_c1[NDF*ind_nop1[7]  ]);
		DJR[3*J+7]=0.5*(
SL2 *ind_c1[NDF*ind_nop1[0]  ]+SL5 *ind_c1[NDF*ind_nop1[1]  ]+
SL8 *ind_c1[NDF*ind_nop1[2]  ]+SL11*ind_c1[NDF*ind_nop1[3]  ]+
SL14*ind_c1[NDF*ind_nop1[4]  ]+SL17*ind_c1[NDF*ind_nop1[5]  ]+
SL20*ind_c1[NDF*ind_nop1[6]  ]+SL23*ind_c1[NDF*ind_nop1[7]  ]);
		DJR[3*J+8]=0.5*(
SL3 *ind_c1[NDF*ind_nop1[0]  ]+SL6 *ind_c1[NDF*ind_nop1[1]  ]+
SL9 *ind_c1[NDF*ind_nop1[2]  ]+SL12*ind_c1[NDF*ind_nop1[3]  ]+
SL15*ind_c1[NDF*ind_nop1[4]  ]+SL18*ind_c1[NDF*ind_nop1[5]  ]+
SL21*ind_c1[NDF*ind_nop1[6]  ]+SL24*ind_c1[NDF*ind_nop1[7]  ]);
	J= -1;  DJR[3*J+6]=0.5*(
SL1 *ind_c1[NDF*ind_nop1[0]+1]+SL4 *ind_c1[NDF*ind_nop1[1]+1]+
SL7 *ind_c1[NDF*ind_nop1[2]+1]+SL10*ind_c1[NDF*ind_nop1[3]+1]+
SL13*ind_c1[NDF*ind_nop1[4]+1]+SL16*ind_c1[NDF*ind_nop1[5]+1]+
SL19*ind_c1[NDF*ind_nop1[6]+1]+SL22*ind_c1[NDF*ind_nop1[7]+1]);
		DJR[3*J+7]=0.5*(
SL2 *ind_c1[NDF*ind_nop1[0]+1]+SL5 *ind_c1[NDF*ind_nop1[1]+1]+
SL8 *ind_c1[NDF*ind_nop1[2]+1]+SL11*ind_c1[NDF*ind_nop1[3]+1]+
SL14*ind_c1[NDF*ind_nop1[4]+1]+SL17*ind_c1[NDF*ind_nop1[5]+1]+
SL20*ind_c1[NDF*ind_nop1[6]+1]+SL23*ind_c1[NDF*ind_nop1[7]+1]);
		DJR[3*J+8]=0.5*(
SL3 *ind_c1[NDF*ind_nop1[0]+1]+SL6 *ind_c1[NDF*ind_nop1[1]+1]+
SL9 *ind_c1[NDF*ind_nop1[2]+1]+SL12*ind_c1[NDF*ind_nop1[3]+1]+
SL15*ind_c1[NDF*ind_nop1[4]+1]+SL18*ind_c1[NDF*ind_nop1[5]+1]+
SL21*ind_c1[NDF*ind_nop1[6]+1]+SL24*ind_c1[NDF*ind_nop1[7]+1]);
	J=0;    DJR[3*J+6]=0.5*(
SL1 *ind_c1[NDF*ind_nop1[0]+2]+SL4 *ind_c1[NDF*ind_nop1[1]+2]+
SL7 *ind_c1[NDF*ind_nop1[2]+2]+SL10*ind_c1[NDF*ind_nop1[3]+2]+
SL13*ind_c1[NDF*ind_nop1[4]+2]+SL16*ind_c1[NDF*ind_nop1[5]+2]+
SL19*ind_c1[NDF*ind_nop1[6]+2]+SL22*ind_c1[NDF*ind_nop1[7]+2]);
		DJR[3*J+7]=0.5*(
SL2 *ind_c1[NDF*ind_nop1[0]+2]+SL5 *ind_c1[NDF*ind_nop1[1]+2]+
SL8 *ind_c1[NDF*ind_nop1[2]+2]+SL11*ind_c1[NDF*ind_nop1[3]+2]+
SL14*ind_c1[NDF*ind_nop1[4]+2]+SL17*ind_c1[NDF*ind_nop1[5]+2]+
SL20*ind_c1[NDF*ind_nop1[6]+2]+SL23*ind_c1[NDF*ind_nop1[7]+2]);
		DJR[3*J+8]=0.5*(
SL3 *ind_c1[NDF*ind_nop1[0]+2]+SL6 *ind_c1[NDF*ind_nop1[1]+2]+
SL9 *ind_c1[NDF*ind_nop1[2]+2]+SL12*ind_c1[NDF*ind_nop1[3]+2]+
SL15*ind_c1[NDF*ind_nop1[4]+2]+SL18*ind_c1[NDF*ind_nop1[5]+2]+
SL21*ind_c1[NDF*ind_nop1[6]+2]+SL24*ind_c1[NDF*ind_nop1[7]+2]);
	if(ISL==2)
	  {*DJD=DJR[0]*(DJR[4]*DJR[8]-DJR[5]*DJR[7])+DJR[1]*(DJR[5]*DJR[6]-DJR[3]*DJR[8])+DJR[2]*(DJR[3]*DJR[7]-DJR[4]*DJR[6]);
	  if(sqrt(*DJD * *DJD)<1.E-6){
// ::MessageBeep(-1);MessageBox("STFISO8 zero det.");
									   *DJD=1.E-6;
									  }
	  DJI1=(DJR[4]*DJR[8]-DJR[5]*DJR[7])/ *DJD;DJI4=(DJR[5]*DJR[6]-DJR[3]*DJR[8])/ *DJD;
	  DJI7=(DJR[3]*DJR[7]-DJR[4]*DJR[6])/ *DJD;DJI2=(DJR[2]*DJR[7]-DJR[1]*DJR[8])/ *DJD;
	  DJI5=(DJR[0]*DJR[8]-DJR[2]*DJR[6])/ *DJD;DJI8=(DJR[1]*DJR[6]-DJR[0]*DJR[7])/ *DJD;
	  DJI3=(DJR[1]*DJR[5]-DJR[2]*DJR[4])/ *DJD;DJI6=(DJR[2]*DJR[3]-DJR[0]*DJR[5])/ *DJD;
	  DJI9=(DJR[0]*DJR[4]-DJR[1]*DJR[3])/ *DJD;
	  SG[0]=0.5*(DJI1*SL1+DJI4*SL2+DJI7*SL3);SG[1]=0.5*(DJI2*SL1+DJI5*SL2+DJI8*SL3);
	  SG[2]=0.5*(DJI3*SL1+DJI6*SL2+DJI9*SL3);SG[3]=0.5*(DJI1*SL4+DJI4*SL5+DJI7*SL6);
	  SG[4]=0.5*(DJI2*SL4+DJI5*SL5+DJI8*SL6);SG[5]=0.5*(DJI3*SL4+DJI6*SL5+DJI9*SL6);
	  SG[6]=0.5*(DJI1*SL7+DJI4*SL8+DJI7*SL9);SG[7]=0.5*(DJI2*SL7+DJI5*SL8+DJI8*SL9);
	  SG[8]=0.5*(DJI3*SL7+DJI6*SL8+DJI9*SL9);SG[9]=0.5*(DJI1*SL10+DJI4*SL11+DJI7*SL12);
	  SG[10]=0.5*(DJI2*SL10+DJI5*SL11+DJI8*SL12);SG[11]=0.5*(DJI3*SL10+DJI6*SL11+DJI9*SL12);
	  SG[12]=0.5*(DJI1*SL13+DJI4*SL14+DJI7*SL15);SG[13]=0.5*(DJI2*SL13+DJI5*SL14+DJI8*SL15);
	  SG[14]=0.5*(DJI3*SL13+DJI6*SL14+DJI9*SL15);SG[15]=0.5*(DJI1*SL16+DJI4*SL17+DJI7*SL18);
	  SG[16]=0.5*(DJI2*SL16+DJI5*SL17+DJI8*SL18);SG[17]=0.5*(DJI3*SL16+DJI6*SL17+DJI9*SL18);
	  SG[18]=0.5*(DJI1*SL19+DJI4*SL20+DJI7*SL21);SG[19]=0.5*(DJI2*SL19+DJI5*SL20+DJI8*SL21);
	  SG[20]=0.5*(DJI3*SL19+DJI6*SL20+DJI9*SL21);SG[21]=0.5*(DJI1*SL22+DJI4*SL23+DJI7*SL24);
	  SG[22]=0.5*(DJI2*SL22+DJI5*SL23+DJI8*SL24);SG[23]=0.5*(DJI3*SL22+DJI6*SL23+DJI9*SL24);
	  }
	else
	  {FPROD=1.;
		if     (sqrt((G*G-1.)*(G*G-1.)) < PRMT){I=1;if(G<0)FPROD= -1.;}
		else if(sqrt((E*E-1.)*(E*E-1.)) < PRMT){I=2;if(E<0)FPROD= -1.;}
		else if(sqrt((T*T-1.)*(T*T-1.)) < PRMT){I=3;if(T<0)FPROD= -1.;}
		else{
//  ::MessageBeep(-1);MessageBox("STFISO8 invalid surface pt.");
honk<<G<<" "<<E<<" "<<T<<" STFISO8:Invalid SP\n";
			  exit(0);
			 }
		IP= -2+I*(11-3*I)/2;IM=6-I-IP;
		GG11=DJR[IP-1]*DJR[IP-1]+DJR[IP+2]*DJR[IP+2]+DJR[IP+5]*DJR[IP+5];
		GG22=DJR[IM-1]*DJR[IM-1]+DJR[IM+2]*DJR[IM+2]+DJR[IM+5]*DJR[IM+5];
		GG12=DJR[IP-1]*DJR[IM-1]+DJR[IP+2]*DJR[IM+2]+DJR[IP+5]*DJR[IM+5];
		*DJD=GG11*GG22-GG12*GG12;
	  if(sqrt(*DJD * *DJD)<1.E-6){
//Application->MessageBox(L"DJD",L"Rotten",MB_OK);
									   *DJD=1.E-6;
									  }
	  else *DJD=sqrt(*DJD);
//////////////////////
////////////////////////
////////////////////////// start trash
if(fabs(GG11)<1.e-10){//honk<<ISL<<" "<<GG11<<" GG11 "<<G<<" "<<E<<" "<<T<<"\n";
					  for(J=0;J<8;J++)honk<<ind_nop1[J]+1<<" 8-n hex STFISOsurf fail "<<ind_c1[NDF*ind_nop1[J]  ]<<" "<<ind_c1[NDF*ind_nop1[J]+1]<<" "<<ind_c1[NDF*ind_nop1[J]+2]<<"\n";
//					  exit(0);
                      GG11=1.e-4;
					 }
////////////////////////// end trash
////////////////////////
//////////////////////
	  GGSQ=1./sqrt(GG11);
	  HN[0]=(DJR[IP+2]*DJR[IM+5]-DJR[IP+5]*DJR[IM+2])/ *DJD;
	  HN[1]=(DJR[IP+5]*DJR[IM-1]-DJR[IP-1]*DJR[IM+5])/ *DJD;
	  HN[2]=(DJR[IP-1]*DJR[IM+2]-DJR[IP+2]*DJR[IM-1])/ *DJD;
	  HN[3]=GGSQ*DJR[IP-1];HN[4]=GGSQ*DJR[IP+2];HN[5]=GGSQ*DJR[IP+5];
	  HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
	  HN[8]=HN[0]*HN[4]-HN[1]*HN[3];for(int IC=0;IC<9;IC++)HN[IC]=FPROD*HN[IC];
	}
	 }
		else{
//  ::MessageBeep(-1);MessageBox("STFISO8 unsupported ISL");
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory",L"Halt",MB_OK);exit(0);
					}
}
//---------------------------------------------------------------------------
void TForm1::STFISO6(int ISL,float G,float E,float T,float *DJD,float HN[],float SN[],float SG[],float DJR[],long ind_nop1[],float ind_c1[])
//		SUBROUTINE STFISO6(ISL,HN,SN,SG,DJD,G,E,T,NOP,DJR,CORD)
//      PARAMETER (MXNPEL=8,PRMT=1.E-2,PMSURF=1.E-8)
//      DIMENSION HN(9),SN(6),SG(18),CORD(1),DJR(9),NOP(MXNPEL),DJR6(12)
//      DIMENSION HN(3),SN(6),SG(3,6),CORD(NDF,1),DJR(3,3),
//     . NOP(MXNPEL,1),DJR6(4,3)
//CCCCC Note: G==L1, E==L2, T==natural z coord (=t), L3=1.-L1-L2
//
//   DJR(I,J)= dx/dL1  dy/dL1  dz/dL1  based on L1/L2/1-L1-L2 coords
//             dx/dL2  dy/dL2  dz/dL2  based on L1/L2/1-L1-L2 coords
//             dx/dt   dy/dt   dz/dt   based on L1/L2/1-L1-L2 coords
//
//   However, to compute surface normals it is necessary to use the
//   appropriate basis system on each side (ie. L1/L2 on side L1=0,
//   L1/L2 on side L2=0, L1/L3 on side L3=0)
//
//   Hence the array SLP(I)= dN(L1,L3)/dL1 and DJR6(I,J) thus:
//
//  DJR6(I,J)= dx/dL1  dy/dL1  dz/dL1  based on L1/1-L1-L3/L3 coords
//             dx/dL1  dy/dL1  dz/dL1  based on L1/L2/1-L1-L2 coords
//             dx/dL2  dy/dL2  dz/dL2  based on L1/L2/1-L1-L2 coords
//  	       dx/dt   dy/dt   dz/dt   based on L1/L2/1-L1-L2 coords
//
//  Note that DJD/DJD are RECTANGULAR areas/volumes ...NOT triangular.
//  See User Manual for element surface coord.frame & note that this
//  frame varies drastically on triangular sides....
{int I=0,J=0,IM=0,IP=0,IC=0;
 float PRMT=1.E-5,PMSURF=1.E-8,TP=0.,TM=0.,DJR6[12+1],SL3=0.,SL6=0.,SL9=0.,WSGN=0.,
       DJI1=0.,DJI4=0.,DJI7=0.,DJI2=0.,DJI5=0.,DJI8=0.,DJI3=0.,DJI6=0.,DJI9=0.,GG11=0.,GG22=0.,GG12=0.,GGSQ=0.,FPROD=0.;
 TP=(1.+T)*0.5;TM=(1.-T)*0.5;
 if(ISL==1){*DJD=0.;SN[0]=G*TM;SN[1]=E*TM;SN[2]=(1.-G-E)*TM;SN[3]=G*TP;SN[4]=E*TP;SN[5]=(1.-G-E)*TP;}
 else if(ISL==2 || ISL==3)
	{SL3= -G*0.5;SL6= -E*0.5;SL9=-0.5-SL3-SL6;
	 J= -2;DJR[3*J+6]=TM*(ind_c1[NDF*ind_nop1[0]  ]-ind_c1[NDF*ind_nop1[2]  ])+TP*(ind_c1[NDF*ind_nop1[3]  ]-ind_c1[NDF*ind_nop1[5]  ]);
		DJR[3*J+7]=TM*(ind_c1[NDF*ind_nop1[1]  ]-ind_c1[NDF*ind_nop1[2]  ])+TP*(ind_c1[NDF*ind_nop1[4]  ]-ind_c1[NDF*ind_nop1[5]  ]);
		DJR[3*J+8]=SL3*(ind_c1[NDF*ind_nop1[0]  ]-ind_c1[NDF*ind_nop1[3]  ])+
SL6*(ind_c1[NDF*ind_nop1[1]  ]-ind_c1[NDF*ind_nop1[4]  ])+SL9*(ind_c1[NDF*ind_nop1[2]  ]-ind_c1[NDF*ind_nop1[5]  ]);
	 J= -1;DJR[3*J+6]=TM*(ind_c1[NDF*ind_nop1[0]+1]-ind_c1[NDF*ind_nop1[2]+1])+TP*(ind_c1[NDF*ind_nop1[3]+1]-ind_c1[NDF*ind_nop1[5]+1]);
		DJR[3*J+7]=TM*(ind_c1[NDF*ind_nop1[1]+1]-ind_c1[NDF*ind_nop1[2]+1])+TP*(ind_c1[NDF*ind_nop1[4]+1]-ind_c1[NDF*ind_nop1[5]+1]);
		DJR[3*J+8]=SL3*(ind_c1[NDF*ind_nop1[0]+1]-ind_c1[NDF*ind_nop1[3]+1])+
SL6*(ind_c1[NDF*ind_nop1[1]+1]-ind_c1[NDF*ind_nop1[4]+1])+SL9*(ind_c1[NDF*ind_nop1[2]+1]-ind_c1[NDF*ind_nop1[5]+1]);
	 J=0;DJR[3*J+6]=TM*(ind_c1[NDF*ind_nop1[0]+2]-ind_c1[NDF*ind_nop1[2]+2])+TP*(ind_c1[NDF*ind_nop1[3]+2]-ind_c1[NDF*ind_nop1[5]+2]);
		DJR[3*J+7]=TM*(ind_c1[NDF*ind_nop1[1]+2]-ind_c1[NDF*ind_nop1[2]+2])+TP*(ind_c1[NDF*ind_nop1[4]+2]-ind_c1[NDF*ind_nop1[5]+2]);
		DJR[3*J+8]=SL3*(ind_c1[NDF*ind_nop1[0]+2]-ind_c1[NDF*ind_nop1[3]+2])+
SL6*(ind_c1[NDF*ind_nop1[1]+2]-ind_c1[NDF*ind_nop1[4]+2])+SL9*(ind_c1[NDF*ind_nop1[2]+2]-ind_c1[NDF*ind_nop1[5]+2]);
	if(ISL==2)
	  {*DJD=DJR[0]*(DJR[4]*DJR[8]-DJR[5]*DJR[7])+DJR[1]*(DJR[5]*DJR[6]-DJR[3]*DJR[8])+DJR[2]*(DJR[3]*DJR[7]-DJR[4]*DJR[6]);
	  if(sqrt(*DJD * *DJD)<1.E-6){
//  ::MessageBeep(-1);MessageBox("STFISO6 zero det.");
                                       *DJD=1.E-6;
									  }
	  DJI1=(DJR[4]*DJR[8]-DJR[5]*DJR[7])/ *DJD;DJI4=(DJR[5]*DJR[6]-DJR[3]*DJR[8])/ *DJD;
	  DJI7=(DJR[3]*DJR[7]-DJR[4]*DJR[6])/ *DJD;DJI2=(DJR[2]*DJR[7]-DJR[1]*DJR[8])/ *DJD;
	  DJI5=(DJR[0]*DJR[8]-DJR[2]*DJR[6])/ *DJD;DJI8=(DJR[1]*DJR[6]-DJR[0]*DJR[7])/ *DJD;
	  DJI3=(DJR[1]*DJR[5]-DJR[2]*DJR[4])/ *DJD;DJI6=(DJR[2]*DJR[3]-DJR[0]*DJR[5])/ *DJD;
	  DJI9=(DJR[0]*DJR[4]-DJR[1]*DJR[3])/ *DJD;
	  SG[0]=DJI1*TM+DJI7*SL3;SG[1]=DJI2*TM+DJI8*SL3;SG[2]=DJI3*TM+DJI9*SL3;
	  SG[3]=DJI4*TM+DJI7*SL6;SG[4]=DJI5*TM+DJI8*SL6;SG[5]=DJI6*TM+DJI9*SL6;
	  SG[6]= -TM*(DJI1+DJI4)+DJI7*SL9;SG[7]= -TM*(DJI2+DJI5)+DJI8*SL9;SG[8]= -TM*(DJI3+DJI6)+DJI9*SL9;
	  SG[9]=DJI1*TP-DJI7*SL3;SG[10]=DJI2*TP-DJI8*SL3;SG[11]=DJI3*TP-DJI9*SL3;
	  SG[12]=DJI4*TP-DJI7*SL6;SG[13]=DJI5*TP-DJI8*SL6;SG[14]=DJI6*TP-DJI9*SL6;
	  SG[15]= -TP*(DJI1+DJI4)-DJI7*SL9;SG[16]= -TP*(DJI2+DJI5)-DJI8*SL9;SG[17]= -TP*(DJI3+DJI6)-DJI9*SL9;
	  }
	else
	  {for(J=1;J<=3;J++){for(I=1;I<=3;I++)DJR6[1-I+4*J]=DJR[-I+3*J];}
		J= -2;DJR6[4*J+9]=TM*(ind_c1[NDF*ind_nop1[0]  ]-ind_c1[NDF*ind_nop1[1]  ])+TP*(ind_c1[NDF*ind_nop1[3]  ]-ind_c1[NDF*ind_nop1[4]  ]);
		J= -1;DJR6[4*J+9]=TM*(ind_c1[NDF*ind_nop1[0]+1]-ind_c1[NDF*ind_nop1[1]+1])+TP*(ind_c1[NDF*ind_nop1[3]+1]-ind_c1[NDF*ind_nop1[4]+1]);
		J=0;DJR6[4*J+9]=TM*(ind_c1[NDF*ind_nop1[0]+2]-ind_c1[NDF*ind_nop1[1]+2])+TP*(ind_c1[NDF*ind_nop1[3]+2]-ind_c1[NDF*ind_nop1[4]+2]);
		WSGN=1.;FPROD=1.;
		if(fabs(T*T-1.)<PRMT){IP=2;IM=3;if(T<0.)FPROD= -1.;}
		else{IM=4;if(fabs(G)<PRMT){IP=3;WSGN= -1.;}
			  else if(fabs(E)<PRMT)IP=2;
			  else if(fabs(1.-G-E)<PRMT){IP=1;WSGN= -1.;}
			  else{
//  ::MessageBeep(-1);MessageBox("STFISO6 invalid surface pt.");
					 exit(0);
					}
			 }
		GG11=DJR6[IP]*DJR6[IP]+DJR6[IP+4]*DJR6[IP+4]+DJR6[IP+8]*DJR6[IP+8];
		GG22=DJR6[IM]*DJR6[IM]+DJR6[IM+4]*DJR6[IM+4]+DJR6[IM+8]*DJR6[IM+8];
		GG12=DJR6[IP]*DJR6[IM]+DJR6[IP+4]*DJR6[IM+4]+DJR6[IP+8]*DJR6[IM+8];
		*DJD=GG11*GG22-GG12*GG12;
		if(*DJD<PMSURF*PMSURF){
//  ::MessageBeep(-1);MessageBox("STFISO6 zero surf.det.");
									   *DJD=1.E-6;
                                      }
		else *DJD=sqrt(*DJD);
		GGSQ=WSGN/sqrt(GG11);
		HN[0]=WSGN*(DJR6[IP+4]*DJR6[IM+8]-DJR6[IP+8]*DJR6[IM+4])/ *DJD;
		HN[1]=WSGN*(DJR6[IP+8]*DJR6[IM  ]-DJR6[IP  ]*DJR6[IM+8])/ *DJD;
		HN[2]=WSGN*(DJR6[IP  ]*DJR6[IM+4]-DJR6[IP+4]*DJR6[IM  ])/ *DJD;
		HN[3]=GGSQ*DJR6[IP  ];HN[4]=GGSQ*DJR6[IP+4];HN[5]=GGSQ*DJR6[IP+8];
		HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
		HN[8]=HN[0]*HN[4]-HN[1]*HN[3];for(IC=0;IC<9;IC++)HN[IC]=FPROD*HN[IC];
	  }
	}
 else{
//  ::MessageBeep(-1);MessageBox("STFISO6 unsupported ISL");
		exit(0);
	  }
}
//---------------------------------------------------------------------------
void TForm1::STFISO4(int ISL,float G,float E,float T,float *DJD,float HN[],float SN[],float SG[],float DJR[],long ind_nop1[],float ind_c1[])
//  See User Manual for element surface coord.frame.
//  On positive sides: n x t1=t2; on negative HN()= -HN(positive side)
//  so n x t1 = -t2 on negative sides (ie. NOT corkscrew).
//  Normal=HN(1 to 3), t1=HN(4 to 6), t2=HN(7 to 9) so      x = HN.x'
//  CAUTION: do NOT evaluate normals at edges/nodes due to ambiguity!!
{int J=0,IM=0,IP=0;
//      DIMENSION HN(3),SN(1),SG(3,8),CORD(NDF,1),DJR(3,3),NOP(MXNPEL)
 float PRMT=1.E-5,PMSURF=1.E-8,S,DJI1=0.,DJI4=0.,DJI7=0.,DJI2=0.,DJI5=0.,DJI8=0.,DJI3=0.,DJI6=0.,DJI9=0.,GG11=0.,GG22=0.,GG12=0.,GGSQ=0.;
//      DIMENSION HN(3),SN(4),SG(3,4),CORD(NDF,1),DJR(3,3),NOP(MXNPEL,1)
//CCCCC Note: G==L1, E==L2, T==natural z coord (=t), L3=1.-L1-L2
//
//   DJR(I,J)= dx/dL1  dy/dL1  dz/dL1  based on L1/L2/L3/1-L1-L2-L3 coords
//             dx/dL2  dy/dL2  dz/dL2  based on L1/L2/L3/1-L1-L2-L3 coords
//             dx/dL3  dy/dL3  dz/dL3  based on L1/L2/L3/1-L1-L2-L3 coords
//
//   However, to compute surface normals it is necessary to use the
//   appropriate basis system on each side (ie. L1/L2 on side L1=0,
//   L1/L2 on side L2=0, L1/L3 on side L3=0)
//
//  Note that DJD/DJD are true TETRA areas/volumes ...NOT rectangular.
//  See User Manual for element surface coord.frame.
  S=1.-G-E-T;
  if(ISL==1){*DJD=0.;SN[0]=G;SN[1]=E;SN[2]=T;SN[3]=S;}
  else if(ISL==2 || ISL==3)
	 {J= -2;DJR[3*J+6]= -ind_c1[NDF*ind_nop1[3]  ]+ind_c1[NDF*ind_nop1[0]  ];
		  DJR[3*J+7]= -ind_c1[NDF*ind_nop1[3]  ]+ind_c1[NDF*ind_nop1[1]  ];
		  DJR[3*J+8]= -ind_c1[NDF*ind_nop1[3]  ]+ind_c1[NDF*ind_nop1[2]  ];
	  J= -1;DJR[3*J+6]= -ind_c1[NDF*ind_nop1[3]+1]+ind_c1[NDF*ind_nop1[0]+1];
		  DJR[3*J+7]= -ind_c1[NDF*ind_nop1[3]+1]+ind_c1[NDF*ind_nop1[1]+1];
		  DJR[3*J+8]= -ind_c1[NDF*ind_nop1[3]+1]+ind_c1[NDF*ind_nop1[2]+1];
	  J=0;DJR[3*J+6]= -ind_c1[NDF*ind_nop1[3]+2]+ind_c1[NDF*ind_nop1[0]+2];
		  DJR[3*J+7]= -ind_c1[NDF*ind_nop1[3]+2]+ind_c1[NDF*ind_nop1[1]+2];
		  DJR[3*J+8]= -ind_c1[NDF*ind_nop1[3]+2]+ind_c1[NDF*ind_nop1[2]+2];
	  if(ISL==2)
		 {*DJD=DJR[0]*(DJR[4]*DJR[8]-DJR[5]*DJR[7])+DJR[1]*(DJR[5]*DJR[6]-DJR[3]*DJR[8])+DJR[2]*(DJR[3]*DJR[7]-DJR[4]*DJR[6]);
		  if(sqrt(*DJD * *DJD)<1.E-6){
//  ::MessageBeep(-1);MessageBox("STFISO4 zero det.");
											   *DJD=1.E-6;
											  }
		  DJI1=(DJR[4]*DJR[8]-DJR[5]*DJR[7])/ *DJD;DJI4=(DJR[5]*DJR[6]-DJR[3]*DJR[8])/ *DJD;
		  DJI7=(DJR[3]*DJR[7]-DJR[4]*DJR[6])/ *DJD;DJI2=(DJR[2]*DJR[7]-DJR[1]*DJR[8])/ *DJD;
		  DJI5=(DJR[0]*DJR[8]-DJR[2]*DJR[6])/ *DJD;DJI8=(DJR[1]*DJR[6]-DJR[0]*DJR[7])/ *DJD;
		  DJI3=(DJR[1]*DJR[5]-DJR[2]*DJR[4])/ *DJD;DJI6=(DJR[2]*DJR[3]-DJR[0]*DJR[5])/ *DJD;
		  DJI9=(DJR[0]*DJR[4]-DJR[1]*DJR[3])/ *DJD;
		  SG[0]=-DJI1-DJI4-DJI7;SG[1]=-DJI2-DJI5-DJI8;SG[2]=-DJI3-DJI6-DJI9;
		  SG[3]=DJI1;SG[4]=DJI2;SG[5]=DJI3;SG[6]=DJI4;SG[7]=DJI5;
		  SG[8]=DJI6;SG[9]=DJI7;SG[10]=DJI8;SG[11]=DJI9; *DJD= *DJD/6.;
		 }
	  else
		 {if(fabs(S)<PRMT)
			 {IP=2;IM=3;HN[0]= -DJR[IP+2]*DJR[IM+5]+DJR[IP+5]*DJR[IM+2];
			  HN[1]= -DJR[IP+5]*DJR[IM-1]+DJR[IP-1]*DJR[IM+5];HN[2]= -DJR[IP-1]*DJR[IM+2]+DJR[IP+2]*DJR[IM-1];
			  IP=3;IM=1;HN[0]=HN[0]-DJR[IP+2]*DJR[IM+5]+DJR[IP+5]*DJR[IM+2];
			  HN[1]=HN[1]-DJR[IP+5]*DJR[IM-1]+DJR[IP-1]*DJR[IM+5];HN[2]=HN[2]-DJR[IP-1]*DJR[IM+2]+DJR[IP+2]*DJR[IM-1];
			  IP=1;IM=2;HN[0]=HN[0]-DJR[IP+2]*DJR[IM+5]+DJR[IP+5]*DJR[IM+2];
			  HN[1]=HN[1]-DJR[IP+5]*DJR[IM-1]+DJR[IP-1]*DJR[IM+5];HN[2]=HN[2]-DJR[IP-1]*DJR[IM+2]+DJR[IP+2]*DJR[IM-1];
			  *DJD=HN[0]*HN[0]+HN[1]*HN[1]+HN[2]*HN[2];
			  if(*DJD<PMSURF*PMSURF){
//  ::MessageBeep(-1);MessageBox("STFISO4 zero surf.det.");
												 *DJD=1.E-6;
												}
			  else *DJD=sqrt(*DJD);
			  HN[0]=HN[0]/ *DJD;HN[1]=HN[1]/ *DJD;HN[2]=HN[2]/ *DJD;
			  HN[3]=DJR[2]-DJR[0];HN[4]=DJR[5]-DJR[3];HN[5]=DJR[8]-DJR[6];
			  GGSQ=1./sqrt(HN[3]*HN[3]+HN[4]*HN[4]+HN[5]*HN[5]);
			  HN[3]=GGSQ*HN[3];HN[4]=GGSQ*HN[4];HN[5]=GGSQ*HN[5];
			  HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
			  HN[8]=HN[0]*HN[4]-HN[1]*HN[3]; *DJD= *DJD/2.;
			 }
		  else
			 {if(fabs(G)<PRMT){IP=2;IM=3;}
			  else if(fabs(E)<PRMT){IP=3;IM=1;}
			  else if(fabs(T)<PRMT){IP=1;IM=2;}
			  else{exit(0);}
			  GG11=DJR[IP-1]*DJR[IP-1]+DJR[IP+2]*DJR[IP+2]+DJR[IP+5]*DJR[IP+5];
			  GG22=DJR[IM-1]*DJR[IM-1]+DJR[IM+2]*DJR[IM+2]+DJR[IM+5]*DJR[IM+5];
			  GG12=DJR[IP-1]*DJR[IM-1]+DJR[IP+2]*DJR[IM+2]+DJR[IP+5]*DJR[IM+5];
			  *DJD=GG11*GG22-GG12*GG12;
			  if(*DJD<PMSURF*PMSURF){
//  ::MessageBeep(-1);MessageBox("STFISO4 zero surf.det.");
												 *DJD=1.E-6;
												}
			  else *DJD=sqrt(*DJD);
			  GGSQ=1./sqrt(GG11);
			  HN[0]=(DJR[IP+2]*DJR[IM+5]-DJR[IP+5]*DJR[IM+2])/ *DJD;
			  HN[1]=(DJR[IP+5]*DJR[IM-1]-DJR[IP-1]*DJR[IM+5])/ *DJD;
			  HN[2]=(DJR[IP-1]*DJR[IM+2]-DJR[IP+2]*DJR[IM-1])/ *DJD;
			  HN[3]=GGSQ*DJR[IP-1];HN[4]=GGSQ*DJR[IP+2];HN[5]=GGSQ*DJR[IP+5];
			  HN[6]=HN[1]*HN[5]-HN[2]*HN[4];HN[7]=HN[2]*HN[3]-HN[0]*HN[5];
			  HN[8]=HN[0]*HN[4]-HN[1]*HN[3]; *DJD= *DJD/2.;
			 }
		 }
	 }
  else{
//  ::MessageBeep(-1);MessageBox("STFISO4 unsupported ISL");
		 exit(0);
		}
}
//---------------------------------------------------------------------------
void TForm1::FDmetal(long nFace,long arbFace[]){long ic=0,ie=0,fType=0,t3=1000;for(ic=0;ic<nFace;ic++){ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;arbFace[ic]=arbFace[ic]+10-fType*10;}}
//---------------------------------------------------------------------------
void TForm1::FDorderfacet(long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[],long rbTem[])
// Global NDF,MXNPEI
{int is=0,iprox=0,idist=0,npts=0;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 long ic=0,ie=0,fType=0,iside=0,eltype=0,t3=1000,t7=10000000;float proximity=0.,distant=0.;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 for(ic=0;ic<nFace;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;eltype=indat_matno[ie]/t7;proximity= -1.e28;distant= 1.e28;
	if(eltype==5)
	  {for(is=0;is<3;is++)
		 {if(proximity<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+2]){proximity=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
		  if(distant>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+2]){distant=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
		 }
	  }
	else if(eltype==7)
	  {if(iside>2)npts=3;else npts=4;
	   for(is=0;is<npts;is++)
		 {if(proximity<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+2]){proximity=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
		  if(distant>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+2]){distant=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
		 }
	  }
	else
	  {for(is=0;is<4;is++)
		 {if(proximity<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+2]){proximity=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
		  if(distant>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+2]){distant=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
		 }
	  }
	rbTem[ic]=iprox*100+idist;
   }
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::FDsort_low1(long *indat_nop1,float *indat_c1,long nFace,long *arbFace,long *rbTem,int *edgFace,long ntranche)
// Version with status[nFace]. Note that constant ntranche=8 (throughout) was found to be fastest....
// Sort in increasing order (Buckets & efficient partition/stride sort used)  Global NDF,MXNPEI
{int isw=0,procsw=0;long ic=0,ip=0,is=0,ie=0,t3=1000,curstat=1,statct=0,outct=0,outct0=nFace,loopct=0,sval=0,irec0=0,irec1=0,*facetmap=NULL,*facettrash=NULL,*facetloc=NULL,*status=NULL;
//// float lolim=0.,upmax=0.,disTOL=0.01,*partition=NULL;
 float lolim=0.,upmax=0.,disTOL=0.1,*partition=NULL;
// float lolim=0.,upmax=0.,disTOL=0.5,*partition=NULL;
 if(nFace<2){honk<<nFace<<" nFacets\n";extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsort_low insufficient nFacets",L"Terminate",MB_OK);exit(0);}
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 facetmap=new long[nFace];status=new long[nFace];facettrash=new long[ntranche*nFace];facetloc=new long[2*ntranche+1];partition=new float[ntranche+1];
 for(ic=0;ic<nFace;ic++) *(facetmap+ic)=ic;for(ic=0;ic<nFace;ic++) *(status+ic)=1;isw=1;loopct=0;

honk<<ntranche*nFace<<" FDsort_low1\n";//if(1==1)exit(0);

 while (isw)
   {irec0=0;sval= *(status+0);
	for(ic=0;ic<nFace;ic++)
	  {if( *(status+ic)==sval)irec1=ic;
	   else {if(sval){if(irec1-irec0==0) *(status+irec0)=0;
					  else if(irec1-irec0+1<9){sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
											   for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
											  }
					  else if(irec1-irec0+1<17){sort_by_stride(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
												sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
												for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
											   }
					  else {if(procsw){sort_by_stride(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
									   sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
									   for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
									  }
							else {lolim=1.e30;upmax= -1.e30;
								  for(ip=irec0;ip<irec1+1;ip++)
									{is= *(facetmap+ip);ie= *(arbFace+is)/t3;
									 if(lolim> *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2))lolim= *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2);
									 if(upmax< *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2))upmax= *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2);
									}
								  if(upmax-lolim>disTOL)sort_by_partition(indat_nop1,indat_c1,irec1-irec0+1,arbFace,rbTem,facetmap,facettrash,facetloc,status,partition,ntranche,irec0,irec1,lolim,upmax,&curstat);
								  else {if(irec1-irec0+1>8)sort_by_stride(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                                        sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                                        for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
                                       }
								 }
						   }
                     }
			 irec0=irec1=ic;sval= *(status+ic);
			}
      }
    if(sval){irec1=nFace-1;
			 if(irec1-irec0==0) *(status+irec0)=0;
             else if(irec1-irec0+1<9){sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
									  for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
                                     }
			 else if(irec1-irec0+1<17){sort_by_stride(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                                       sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                                       for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
                                      }
             else {if(procsw){sort_by_stride(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                              sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                              for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
							 }
                   else {lolim=1.e30;upmax= -1.e30;
						 for(ip=irec0;ip<irec1+1;ip++)
                           {is= *(facetmap+ip);ie= *(arbFace+is)/t3;
							if(lolim> *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2))lolim= *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2);
							if(upmax< *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2))upmax= *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2);
                           }
                         if(upmax-lolim>disTOL)sort_by_partition(indat_nop1,indat_c1,irec1-irec0+1,arbFace,rbTem,facetmap,facettrash,facetloc,status,partition,ntranche,irec0,irec1,lolim,upmax,&curstat);
                         else {if(irec1-irec0+1>8)sort_by_stride(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                               sort_by_bubble(indat_nop1,indat_c1,arbFace,rbTem,facetmap,irec0,irec1);
                               for(ip=irec0;ip<irec1+1;ip++) *(status+ip)=0;
							  }
						}
                  }
            }
    loopct++;statct=0;for(ic=0;ic<nFace;ic++)statct=statct+ *(status+ic);
	if(!statct)isw=0;
	else {outct=0;for(ic=0;ic<nFace;ic++)if( *(status+ic))outct=outct+ *(status+ic);
		  if(outct==outct0 && loopct>3)procsw=1;
		  outct0=outct;
		 }
   }
 delete [] facettrash;delete [] facetloc;delete [] partition;
 for(ic=0;ic<nFace;ic++) *(status+ic)= *(arbFace+ *(facetmap+ic));for(ic=0;ic<nFace;ic++) *(arbFace+ic)= *(status+ic);
 for(ic=0;ic<nFace;ic++) *(status+ic)= *(rbTem+ *(facetmap+ic));for(ic=0;ic<nFace;ic++) *(rbTem+ic)= *(status+ic);
 for(ic=0;ic<nFace;ic++) *(status+ic)= *(edgFace+ *(facetmap+ic));for(ic=0;ic<nFace;ic++) *(edgFace+ic)=int( *(status+ic));
 delete [] facetmap;delete [] status;
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::sort_by_partition(long *indat_nop1,float *indat_c1,long cFace,long *arbFace,long *rbTem,
   long *facetmap,long *facettrash,long *facetloc,long *status,float *partition,long ctranche,long lwFace,long upFace,float lolim,float upmax,long *curstat)
// Version with status[nFace]
{long pval=0,ic=0,ip=0,is=0,ist=0,ie=0,t3=1000,accum=0,accum0=0,purtranche=0,lows=0,mids=0,tops=0,procd=0,shift=0,ism=0,istart=0,iend=0,itf=0,itr=0;
 float cval=float(cFace)/float(ctranche),deltranche=(upmax-lolim)/(float(ctranche*cFace-1)),dmargin=(deltranche*float(ctranche*cFace)-upmax+lolim)/2.,zcor=0.;
 for(ic=0;ic<ctranche*cFace;ic++)*(facettrash+ic)=0;
 for(ic=lwFace;ic<upFace+1;ic++){is=facetmap[ic];ie= *(arbFace+is)/t3;
								 (*(facettrash+long((*(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2)-lolim+dmargin)/deltranche)))++;
								}
 *(partition+0)=lolim-deltranche;accum=accum0=0;purtranche=1;
 for(ip=0;ip<ctranche*cFace;ip++){accum=accum+ *(facettrash+ip);pval=long(float(purtranche)*cval);
								  while (pval<=accum)
									{*(partition+purtranche)=deltranche*(float(ip)+float(pval-accum0)/float(accum-accum0))+lolim-dmargin;
									 purtranche++;pval=long(float(purtranche)*cval);
									}
								  accum0=accum;
								 }
 *(partition+ctranche)=upmax+deltranche;for(ip=0;ip<ctranche;ip++) *(facetloc+2*ip)= *(facetloc+2*ip+1)=ip*cFace; *(facetloc+2*ctranche)=ctranche*cFace;
 for(ic=lwFace;ic<upFace+1;ic++)
   {is= *(facetmap+ic);ie= *(arbFace+is)/t3;zcor=*(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2);lows=0;tops=ctranche-1;
	for(ip=0;ip<ctranche;ip++)
	  {mids=(lows+tops)/2;if(zcor>= *(partition+mids) && zcor< *(partition+mids+1))
							{
/////////////// Code to shift overpopulated regions of facettrash[]
if( *(facetloc+2*mids+1)>= *(facetloc+2*mids+2))
  {procd=0;for(ism=0;ism<ctranche;ism++)procd=procd+ *(facetloc+2*ism+1)- *(facetloc+2*ism);shift=min(cFace-procd,(ctranche*cFace-procd)/ctranche);
   for(itf=1;itf<ctranche;itf++){istart= *(facetloc+2*itf-1)+shift;
								 if(istart< *(facetloc+2*itf)){for(ism= *(facetloc+2*itf);ism< *(facetloc+2*itf+1);ism++) *(facettrash+ism- *(facetloc+2*itf)+istart)= *(facettrash+ism);
															   *(facetloc+2*itf+1)= *(facetloc+2*itf+1)- *(facetloc+2*itf)+istart; *(facetloc+2*itf)=istart;
															  }
								 else if(istart== *(facetloc+2*itf));
								 else {if(ctranche>itf)
                                         {for(itr=ctranche-1;itr>=itf;itr++)
                                            {iend= *(facetloc+2*itr+2)-shift;
                                             if(iend> *(facetloc+2*itr+1)){for(ism= *(facetloc+2*itr+1)-1;ism>= *(facetloc+2*itr);ism--) *(facettrash+ism- *(facetloc+2*itr+1)+iend)= *(facettrash+ism);
                                                                           *(facetloc+2*itr)= *(facetloc+2*itr)- *(facetloc+2*itr+1)+iend; *(facetloc+2*itr+1)=iend;
                                                                          }
											 else break;
                                            }
                                         }
                                       break;
                                      }
								}
  }
///////////////
                             *(facettrash+ *(facetloc+2*mids+1))=is;(*(facetloc+2*mids+1))++;break;
                            }
                          else if(zcor< *(partition+mids))tops=mids-1;
						  else lows=mids+1;
	  }
   }
 accum=lwFace;for(ip=0;ip<ctranche;ip++)
				{ist= *(facetloc+2*ip+1)- *(facetloc+2*ip);
                 if(ist==1){ *(facetmap+accum)= *(facettrash+ *(facetloc+2*ip)); *(status+accum)=0;accum++;}
                 else if(ist>1){for(ic= *(facetloc+2*ip);ic< *(facetloc+2*ip+1);ic++){ *(facetmap+accum)= *(facettrash+ic); *(status+accum)= *curstat;accum++;}
                                *curstat= *curstat+1;
							   }
				}
}
//---------------------------------------------------------------------------
void TForm1::sort_by_partition1(long *indat_nop1,float *indat_c1,long cFace,long *arbFace,long *rbTem,
   long facetmap[],long facettrash[],long facetloc[],long status[],float partition[],
   long ctranche,long lwFace,long upFace,float lolim,float upmax)
// Version to replace status[nFace] with facetloc[+/-]........... In development
{long pval=0,ic=0,ip=0,is=0,ist=0,ie=0,t3=1000,accum=0,accum0=0,purtranche=0,lows=0,mids=0,tops=0
//,procd=0,shift=0,ism=0,istart=0,iend=0,itf=0,itr=0
,curstat= -1;
 float cval=float(cFace)/float(ctranche),deltranche=(upmax-lolim)/(float(ctranche*cFace-1)),dmargin=(deltranche*float(ctranche*cFace)-upmax+lolim)/2.,zcor=0.;
 for(ic=0;ic<ctranche*cFace;ic++)facettrash[ic]=0;
 for(ic=lwFace;ic<upFace+1;ic++){is=facetmap[ic];ie= *(arbFace+is)/t3;
                                 facettrash[long((*(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2)-lolim+dmargin)/deltranche)]++;
								}
 partition[0]=lolim-deltranche;accum=accum0=0;purtranche=1;
 for(ip=0;ip<ctranche*cFace;ip++){accum=accum+facettrash[ip];pval=long(float(purtranche)*cval);// while (purtranche*(cFace/ctranche)<=accum)
                                  while (pval<=accum)
                                    {partition[purtranche]=deltranche*(float(ip)+float(pval-accum0)/float(accum-accum0))+lolim-dmargin;
									 purtranche++;pval=long(float(purtranche)*cval);
                                    }
								  accum0=accum;
                                 }
 partition[ctranche]=upmax+deltranche;
// for(ip=0;ip<ctranche;ip++)facetloc[2*ip]=facetloc[2*ip+1]=ip*cFace;facetloc[2*ctranche]=ctranche*cFace;
 facetloc[0]=facetloc[1]=0;
 for(ip=1;ip<ctranche;ip++){ic=facetloc[2*ip]/labs(facetloc[2*ip]);facetloc[2*ip]=ic*ip*cFace;}
 for(ip=1;ip<ctranche;ip++)facetloc[2*ip+1]=ip*cFace;
 facetloc[2*ctranche]=ctranche*cFace;
 for(ic=lwFace;ic<upFace+1;ic++)
   {is=facetmap[ic];ie= *(arbFace+is)/t3;zcor=*(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2);lows=0;tops=ctranche-1;
    for(ip=0;ip<ctranche;ip++)
      {mids=(lows+tops)/2;if(zcor>=partition[mids] && zcor<partition[mids+1])
							{
///////////////// Code to shift overpopulated regions of facettrash[]
//if(facetloc[2*mids+1]>=facetloc[2*mids+2])
//  {procd=0;for(ism=0;ism<ctranche;ism++)procd=procd+facetloc[2*ism+1]-facetloc[2*ism];shift=min(cFace-procd,(ctranche*cFace-procd)/ctranche);
//   for(itf=1;itf<ctranche;itf++){istart=facetloc[2*itf-1]+shift;
//                                 if(istart<facetloc[2*itf]){for(ism=facetloc[2*itf];ism<facetloc[2*itf+1];ism++)facettrash[ism-facetloc[2*itf]+istart]=facettrash[ism];
//                                                            facetloc[2*itf+1]=facetloc[2*itf+1]-facetloc[2*itf]+istart;facetloc[2*itf]=istart;
//                                                           }
//                                 else if(istart==facetloc[2*itf]);
//                                 else {if(ctranche>itf)
//                                         {for(itr=ctranche-1;itr>=itf;itr++)
//                                            {iend=facetloc[2*itr+2]-shift;
//                                             if(iend>facetloc[2*itr+1]){for(ism=facetloc[2*itr+1]-1;ism>=facetloc[2*itr];ism--)facettrash[ism-facetloc[2*itr+1]+iend]=facettrash[ism];
//                                                                        facetloc[2*itr]=facetloc[2*itr]-facetloc[2*itr+1]+iend;facetloc[2*itr+1]=iend;
//                                                                       }
//                                             else break;
//                                            }
//                                         }
//                                       break;
//                                      }
//                                }
//  }
/////////////////
                             facettrash[labs(facetloc[2*mids+1])]=is;
                             if(facetloc[2*mids+1]>=0)facetloc[2*mids+1]++;
                             else facetloc[2*mids+1]--;
							 break;
							}
                          else if(zcor<partition[mids])tops=mids-1;
                          else lows=mids+1;
	  }
   }
 accum=lwFace;for(ip=0;ip<ctranche;ip++)
                {ist=labs(facetloc[2*ip+1])-labs(facetloc[2*ip]);
				 if(ist==1){facetmap[accum]=facettrash[labs(facetloc[2*ip])];
//                            status[accum]=0;
                            facetloc[2*(accum+1)]=labs(facetloc[2*(accum+1)]);
                            accum++;
						   }
                 else if(ist>1){for(ic=labs(facetloc[2*ip]);ic<labs(facetloc[2*ip+1]);ic++)
                                  {facetmap[accum]=facettrash[ic];
//                                   status[accum]= *curstat;
								   facetloc[2*(accum+1)+1]=curstat*facetloc[2*(accum+1)+1];
								   accum++;
                                  }
                                curstat= -curstat;
                               }
                }
}
//---------------------------------------------------------------------------
void TForm1::sort_by_stride(long *indat_nop1,float *indat_c1,long *arbFace,long *rbTem,long *facetmap,long lwFace,long upFace)
{long ic=0,ip=0,is=0,isp=0,ie=0,iep=0,t3=1000,twoexp=long(log(float(upFace-lwFace+1))/log(2.)),interval=long(exp(log(2.)*float(twoexp)) +0.5);
 for(ip=0;ip<twoexp;ip++) // This does not perform the final top-to-bottom term-by-term comparison.
   {for(ic=lwFace;ic<upFace+1-interval;ic++)
	  {is= *(facetmap+ic);ie= *(arbFace+is)/t3;isp= *(facetmap+ic+interval);iep= *(arbFace+isp)/t3;
	   if( *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+is)/100)+2) >
		   *(indat_c1+NDF* *(indat_nop1+MXNPEI*iep+ *(rbTem+isp)/100)+2)){ *(facetmap+ic)=isp; *(facetmap+ic+interval)=is;}
      }
    interval=interval>>1;
   }
}
//---------------------------------------------------------------------------
void TForm1::sort_by_bubble(long *indat_nop1,float *indat_c1,long *arbFace,long *rbTem,long *facetmap,long lwFace,long upFace)
{int isw=0;long ic=0,ip=0,is0=0,is1=0,ie0=0,ie1=0,t3=1000; // Inefficient pair-by-pair bubble sort
 for(ic=lwFace;ic<upFace;ic++)
   {isw=0;for(ip=lwFace;ip<upFace+lwFace-ic;ip++)
            {is0= *(facetmap+ip);ie0= *(arbFace+is0)/t3;is1= *(facetmap+ip+1);ie1= *(arbFace+is1)/t3;
             if( *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie0+ *(rbTem+is0)/100)+2)>
				 *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie1+ *(rbTem+is1)/100)+2)){ *(facetmap+ip)=is1; *(facetmap+ip+1)=is0;isw=1;}
			}
    if(!isw)break;
   }
}
//---------------------------------------------------------------------------
void TForm1::FDsort_low(long *indat_nop1,float *indat_c1,long nFace,long *arbFace,long *rbTem,int *edgFace,long *arbFace1,long *rbTem1,int *edgFace1)
// Sort in increasing order (Buckets & efficient stride sort used)  Global NDF,MXNPEI
// Note: Fastest execution for 96<ntranche<192 (old optimum=256)
{int iswflag=0,itemi=0;long ftemp=0,ic=0,ip=0,itemp=0,ie=0,iep=0,t3=1000,twoexp=0,interval=0,ntranche=160,tacc=0,tacc1=0,tacc2=0,itranche=0,tranchepop=0;
 float lolim=0.,uplim=0.,upmax=0.,deltranche=0.;
 if(nFace<2){honk<<nFace<<" nFacets\n";extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsort_low insufficient nFacets",L"Terminate",MB_OK);exit(0);}
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 for(ic=0;ic<nFace;ic++)*(arbFace1+ic)=*(arbFace+ic);for(ic=0;ic<nFace;ic++)*(rbTem1+ic)=*(rbTem+ic);for(ic=0;ic<nFace;ic++)*(edgFace1+ic)=*(edgFace+ic);
//
 lolim=1.e30;upmax= -1.e30;
 for(ic=0;ic<nFace;ic++){ie= *(arbFace+ic)/t3;
						 if(lolim> *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+ic)/100)+2))lolim= *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+ic)/100)+2);
                         if(upmax< *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+ic)/100)+2))upmax= *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+ic)/100)+2);
						}
 deltranche=(upmax-lolim)/float(ntranche);uplim=lolim;lolim=lolim-0.1;tranchepop=nFace;tacc=0;
//
 for(itranche=0;itranche<ntranche;itranche++)
   {if(itranche==ntranche-1){for(ic=0;ic<tranchepop;ic++){*(arbFace+tacc+ic)= *(arbFace1+ic);*(rbTem+tacc+ic)= *(rbTem1+ic);*(edgFace+tacc+ic)= *(edgFace1+ic);}tacc2=tranchepop;}
	else {uplim=uplim+deltranche;tacc1=tacc2=0;
          for(ic=0;ic<tranchepop;ic++){ie= *(arbFace1+ic)/t3;
                                       if(*(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem1+ic)/100)+2)>lolim && *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem1+ic)/100)+2)<=uplim)
										 {*(arbFace+tacc+tacc2)= *(arbFace1+ic);*(rbTem+tacc+tacc2)= *(rbTem1+ic);*(edgFace+tacc+tacc2)= *(edgFace1+ic);tacc2++;
                                         }
                                       else {*(arbFace1+tacc1)= *(arbFace1+ic);*(rbTem1+tacc1)= *(rbTem1+ic);*(edgFace1+tacc1)= *(edgFace1+ic);tacc1++;}
                                      }
		  tranchepop=tacc1;
		 }
    if(tacc2==1)tacc++;
    else if(tacc2){twoexp=long(log(float(tacc2))/log(2.));interval=long(exp(log(2.)*float(twoexp)) +0.5);
				   for(ip=0;ip<twoexp;ip++)
                     {for(ic=tacc;ic<tacc+tacc2-interval;ic++)
                        {ie= *(arbFace+ic)/t3;iep= *(arbFace+ic+interval)/t3;
                         if( *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+ic)/100)+2) > *(indat_c1+NDF* *(indat_nop1+MXNPEI*iep+ *(rbTem+ic+interval)/100)+2))
						   {ftemp= *(rbTem+ic);*(rbTem+ic)= *(rbTem+ic+interval);*(rbTem+ic+interval)=ftemp;
							itemp= *(arbFace+ic);*(arbFace+ic)= *(arbFace+ic+interval);*(arbFace+ic+interval)=itemp;
                            itemi= *(edgFace+ic);*(edgFace+ic)= *(edgFace+ic+interval);*(edgFace+ic+interval)=itemi;
                           }
                        }
                      interval=interval>>1;
					 }
				   for(ip=0;ip<tacc2-1;ip++)
                     {iswflag=0;for(ic=tacc;ic<tacc+tacc2-ip-1;ic++)
                                  {ie= *(arbFace+ic)/t3;iep= *(arbFace+ic+1)/t3;
                                   if( *(indat_c1+NDF* *(indat_nop1+MXNPEI*ie+ *(rbTem+ic)/100)+2) > *(indat_c1+NDF* *(indat_nop1+MXNPEI*iep+ *(rbTem+ic+1)/100)+2))
									 {ftemp= *(rbTem+ic); *(rbTem+ic)= *(rbTem+ic+1);*(rbTem+ic+1)=ftemp;
									  itemp= *(arbFace+ic); *(arbFace+ic)= *(arbFace+ic+1); *(arbFace+ic+1)=itemp;
                                      itemi= *(edgFace+ic); *(edgFace+ic)= *(edgFace+ic+1); *(edgFace+ic+1)=itemi;iswflag=1;
									 }
                                  }
                      if(iswflag==0)break;
                     }
				   tacc=tacc+tacc2;
				  }
//
    lolim=uplim;
   }
//
//    }
//__finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::FDpaintplot(int isel,long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
// 4&6&8-n elements only; isel=0 Canvas & isel=1 tBitmap->Canvas
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
//  These are IDEAS conventions (NOT CAP)
//	  .      JOINT6/1, 2, 3, 1, 4, 0,
//	  .             2, 3, 1, 3, 5, 0,
//	  .             5, 6, 4, 2, 6, 0,
//	  .             4, 5, 6, 0, 0, 0/
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int npts=0;long ic=0,ie=0,fType=0,iside=0,ip=0,ipr=0,
 ir=0,
   eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;TPoint ptDraw[MAXPOINTS];
//// arbFacet[nFacets]=ies*t3+fType*10+5;
// tBitmap->Canvas->Pen->Width=1;


//honk<<long(clLtGray)<<" Blackcheque_clLtGray\n";
//honk<<long(clRed)<<" Blackcheck_clRed\n";
//honk<<long(clBlack)<<" Blackcheck_clBlack\n";
//honk<<long(clWhite)<<" Blackcheck_clWhite\n";


 for(ic=0;ic<nFace;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3; //Reactivated EFP 2/29/2012
//////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////

//honk<<ic<<" "<<nFace<<" FDPaintCHECK "<<ie<<" "<<iside<<" "<<ieGID<<" ccc "<<base.allGrp<<" "<<wp.nWeldGroup<<"\n";

//	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
//	if(fType==1)tBitmap->Canvas->Brush->Color=clLtGray;
//	else {ir=ieGID-9*(ieGID/9);
//          if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;  else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
////          else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen; else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
//		  else if(ir==4)tBitmap->Canvas->Brush->Color=clNavy;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
//		  else if(ir==4)tBitmap->Canvas->Brush->Color=clYellow;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
//		  else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive; else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
//          else          tBitmap->Canvas->Brush->Color=clRed;
//         }

	  if(isel){

			   if(ieGID==0 || ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Width=1;
			   else tBitmap->Canvas->Pen->Width=2;
/*
	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clWhite;
	if(fType==1)tBitmap->Canvas->Brush->Color=clLtGray;
	else {
		  ir=ieGID-9*(ieGID/9);
//		  if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
//		  else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen ;else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
//		  else if(ir==4)tBitmap->Canvas->Brush->Color=clNavy  ;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
//		  else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive ;else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
//		  else          tBitmap->Canvas->Brush->Color=clRed;

//		  if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;
//		  else tBitmap->Canvas->Brush->Color=clRed; //Per Bud's request, all welds in red. EFP 4/03/2010
tBitmap->Canvas->Brush->Color=clBlack;
		 }
*/


//honk<<ic<<" "<<ie<<" "<<iside<<" "<<nFace<<" "<<ieGID<<" "<<wp.nWeldGroup<<" "<<ieGID-wp.nWeldGroup-1<<" FDpaintplot\n";


if(ieGID==0 || ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;
////else if(ieGID==1 || ieGID==2)tBitmap->Canvas->Pen->Color=clRed;
////else tBitmap->Canvas->Pen->Color=wp.WeldColor[ieGID-3];
//else if(ieGID<wp.nWeldGroup+1)
else if(ieGID<base.allGrp)
	   {
		if(wp.PAINT_SEL){
		  ir=ieGID-8*(ieGID/8);
		  if     (ir==0)tBitmap->Canvas->Pen->Color=clLtGray;else if(ir==1)tBitmap->Canvas->Pen->Color=clBlue;
		  else if(ir==2)tBitmap->Canvas->Pen->Color=clGreen ;else if(ir==3)tBitmap->Canvas->Pen->Color=clLime;
		  else if(ir==4)tBitmap->Canvas->Pen->Color=clNavy  ;else if(ir==5)tBitmap->Canvas->Pen->Color=clYellow;
		  else if(ir==6)tBitmap->Canvas->Pen->Color=clOlive ;else tBitmap->Canvas->Pen->Color=clMaroon;
///////////////////
//honk<<ic<<" "<<nFace<<" "<<ie<<" Budaikahn WG "<<fType<<" "<<iside<<" "<<ieGID<<" "<<ir<<"\n";
///////////////////
						}
		else tBitmap->Canvas->Pen->Color=clRed;
	   }
else {
//	  tBitmap->Canvas->Pen->Color=wp.WeldColor[ieGID-wp.nWeldGroup-1];
	  tBitmap->Canvas->Pen->Color=wp.WeldColor[ieGID-base.allGrp];
///////////////////
//honk<<ic<<" "<<nFace<<" "<<ie<<" Budaikahn WP "<<fType<<" "<<iside<<" "<<ieGID<<" "<<(long)wp.WeldColor[ieGID-wp.nWeldGroup-1]<<" "<<(long)clBlack<<"\n";
///////////////////
	 }
			  }
	  else    {
			   if(ieGID==0 || ieGID==MAX_GID-1)Canvas->Pen->Width=1;
			   else Canvas->Pen->Width=2;

	if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clWhite;
	if(fType==1)Canvas->Brush->Color=clLtGray;
	else {
/*
		  ir=ieGID-9*(ieGID/9);
//		  if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
//		  else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen ;else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
//		  else if(ir==4)tBitmap->Canvas->Brush->Color=clNavy  ;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
//		  else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive ;else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
//		  else          tBitmap->Canvas->Brush->Color=clRed;

//		  if     (ir==0)Canvas->Brush->Color=clLtGray;
//		  else Canvas->Brush->Color=clRed; //Per Bud's request, all welds in red. EFP 4/03/2010
tBitmap->Canvas->Brush->Color=clBlack;
*/
if(ieGID==0 || ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;
////else if(ieGID==1 || ieGID==2)Canvas->Pen->Color=clRed;
////else Canvas->Pen->Color=wp.WeldColor[ieGID-3];
//else if(ieGID<wp.nWeldGroup+1)
else if(ieGID<base.allGrp)
	   {
		if(wp.PAINT_SEL){
		  ir=ieGID-8*(ieGID/8);
		  if     (ir==0)Canvas->Pen->Color=clLtGray;else if(ir==1)Canvas->Pen->Color=clBlue;
		  else if(ir==2)Canvas->Pen->Color=clGreen ;else if(ir==3)Canvas->Pen->Color=clLime;
		  else if(ir==4)Canvas->Pen->Color=clNavy  ;else if(ir==5)Canvas->Pen->Color=clYellow;
		  else if(ir==6)Canvas->Pen->Color=clOlive ;else Canvas->Pen->Color=clMaroon;
						}
		else Canvas->Pen->Color=clRed;
	   }
else {
//	  Canvas->Pen->Color=wp.WeldColor[ieGID-wp.nWeldGroup-1];
	  Canvas->Pen->Color=wp.WeldColor[ieGID-base.allGrp];
	 }
		 }

//honk<<ic<<" "<<long(Canvas->Pen->Color)<<" BlackcheckCanv "<<long(clBlack)<<"\n";

			  }


//honk<<ic<<" "<<long(tBitmap->Canvas->Pen->Color)<<" Blackcheck\n";
//if(tBitmap->Canvas->Pen->Color==clBlack)honk<<" tbitEureka\n";
//if(Canvas->Pen->Color==clBlack)honk<<" CanvEureka\n";

/////////////////////////////
//tBitmap->Canvas->Pen->Color=clGreen;
//////////////////////////////
	if(eltype==5)
	  {for(ip=0;ip<3;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
						   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
						  }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,2);else tBitmap->Canvas->Polygon(ptDraw,2);
	  }
	else if(eltype==7)
	  {if(iside>2)npts=3;else npts=4;
	   for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
							  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
							 }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,npts-1);else tBitmap->Canvas->Polygon(ptDraw,npts-1);
	  }
	else
	  {for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
						   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
						  }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,3);else tBitmap->Canvas->Polygon(ptDraw,3);
	  }
   }
 tBitmap->Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::FDpaintplotnm(long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[],int edgFace[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//                 3,2,6,7,
//                 0,3,7,4,
//                 0,1,2,3,
//                 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
//  These are IDEAS conventions (NOT CAP)
//	  .      JOINT6/1, 2, 3, 1, 4, 0,
//	  .             2, 3, 1, 3, 5, 0,
//	  .             5, 6, 4, 2, 6, 0,
//	  .             4, 5, 6, 0, 0, 0/
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
				 2,0,3,5,
                 0,2,1,0,
                 3,4,5,0};
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
                 3,0,1};
 int npts=0,iloc=0,ilocp=0;long ic=0,ie=0,fType=0,iside=0,ip=0,ir=0,eltype=0,bscode=0,node=0,ieGID=0,ig=0,igp=0,t3=1000,t5=100000,t7=10000000;TPoint ptDraw[MAXPOINTS];
// arbFacet[nFacets]=ies*t3+fType*10+5;
 for(ic=0;ic<nFace;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;
    else {if(fType==1){tBitmap->Canvas->Brush->Color=clLtGray;tBitmap->Canvas->Pen->Color=clLtGray;}
          else {ir=ieGID-9*(ieGID/9);
				if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;  else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
				else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen; else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
				else if(ir==4)tBitmap->Canvas->Brush->Color=clNavy;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
				else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive; else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
				else          tBitmap->Canvas->Brush->Color=clRed;   tBitmap->Canvas->Pen->Color=Canvas->Brush->Color;
               }
         }
	if(eltype==5)
      {for(ip=0;ip<3;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
                           ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
                          }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,2);
	   else {tBitmap->Canvas->Polygon(ptDraw,2);tBitmap->Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;
             for(ig=0;ig<3;ig++)
			   {if((edgFace[ic]-ilocp*(edgFace[ic]/ilocp))/iloc){igp=ig+1;if(igp>=3)igp=0;
tBitmap->Canvas->MoveTo(ptDraw[ig].x,ptDraw[ig].y);tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
																  }
                iloc=iloc*10;ilocp=ilocp*10;
               }
			}
      }
    else if(eltype==7)
      {if(iside>2)npts=3;else npts=4;
       for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
							  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
							 }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,npts-1);
	   else {tBitmap->Canvas->Polygon(ptDraw,npts-1);tBitmap->Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;
			 for(ig=0;ig<npts;ig++)
               {if((edgFace[ic]-ilocp*(edgFace[ic]/ilocp))/iloc){igp=ig+1;if(igp>=npts)igp=0;
tBitmap->Canvas->MoveTo(ptDraw[ig].x,ptDraw[ig].y);tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
																  }
                iloc=iloc*10;ilocp=ilocp*10;
               }
			}
      }
    else
	  {for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
                           ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
                          }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,3);
	   else {tBitmap->Canvas->Polygon(ptDraw,3);tBitmap->Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;
             for(ig=0;ig<4;ig++)
               {if((edgFace[ic]-ilocp*(edgFace[ic]/ilocp))/iloc){igp=ig+1;if(igp>=4)igp=0;
tBitmap->Canvas->MoveTo(ptDraw[ig].x,ptDraw[ig].y);tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
                                                                  }
				iloc=iloc*10;ilocp=ilocp*10;
               }
            }
      }
   }
 tBitmap->Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::FDpaintplots(long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[],long indat_nfsect,long indat_fsect[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//                 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
//  These are IDEAS conventions (NOT CAP)
//	  .      JOINT6/1, 2, 3, 1, 4, 0,
//	  .             2, 3, 1, 3, 5, 0,
//	  .             5, 6, 4, 2, 6, 0,
//	  .             4, 5, 6, 0, 0, 0/
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int npts=0,oldwidth=0,isw=0;
 long ic=0,ie=0,fType=0,iside=0,ip=0,ipp=0,ir=0,eltype=0,bscode=0,node=0,ieGID=0,ies=0,isides=0,ics=0,act=0,stact[4],t3=1000,t5=100000,t7=10000000;
// Caution: arbFacets[] not in ascending element order so full indat_fsect[] search necessary
// arbFacet[nFacets]=ies*t3+fType*10+5;
 TPoint ptDraw[MAXPOINTS];oldwidth=tBitmap->Canvas->Pen->Width;
 for(ic=0;ic<nFace;ic++)
   {isw=0;ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
	tBitmap->Canvas->Pen->Width=oldwidth;
	for(ics=0;ics<indat_nfsect;ics++){ies=indat_fsect[ics]/10000;isides=indat_fsect[ics]/1000-10*ies;
									  if(ie==ies && iside==isides)
										{act=(indat_fsect[ics]-1000*(indat_fsect[ics]/1000))/10;
										 if(act>7){stact[3]=1;act=act-8;}else stact[3]=0;if(act>3){stact[2]=1;act=act-4;}else stact[2]=0;
										 if(act>1){stact[1]=1;act=act-2;}else stact[1]=0;if(act)stact[0]=1;else stact[0]=0;
										 isw=1;break;
										}
									 }
	if(fType==1)tBitmap->Canvas->Brush->Color=clLtGray;
	else {ir=ieGID-9*(ieGID/9);
		  if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;  else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
		  else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen; else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
		  else if(ir==4)tBitmap->Canvas->Brush->Color=clNavy;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
		  else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive; else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
		  else          tBitmap->Canvas->Brush->Color=clRed;
		 }
	if(isw)
	  {tBitmap->Canvas->Pen->Color=tBitmap->Canvas->Brush->Color;
	   if(eltype==5)
		 {npts=3;for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
										ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
									   }
		  tBitmap->Canvas->Polygon(ptDraw,npts-1);tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Pen->Width=3;
		  for(ip=0;ip<npts;ip++){if(stact[ip])
								  {ipp=ip+1;if(ipp>=npts)ipp=0;
								   ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
								   ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
								   ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
								   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);
								   tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);tBitmap->Canvas->LineTo(ptDraw[1].x,ptDraw[1].y);
								  }
								}
		 }
	   else if(eltype==7)
		 {if(iside>2)npts=3;else npts=4;
		  for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
								 ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
								}
		  tBitmap->Canvas->Polygon(ptDraw,npts-1);tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Pen->Width=3;
		  for(ip=0;ip<npts;ip++){if(stact[ip])
								  {ipp=ip+1;if(ipp>=npts)ipp=0;
								   ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
								   ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
								   ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
								   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);
								   tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);tBitmap->Canvas->LineTo(ptDraw[1].x,ptDraw[1].y);
								  }
								}
		 }
	   else
		 {npts=4;for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
										ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
									   }
		  tBitmap->Canvas->Polygon(ptDraw,npts-1);tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Pen->Width=3;
		  for(ip=0;ip<npts;ip++){if(stact[ip])
								  {ipp=ip+1;if(ipp>=npts)ipp=0;
								   ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
								   ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
								   ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
								   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);
								   tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);tBitmap->Canvas->LineTo(ptDraw[1].x,ptDraw[1].y);
								  }
								}
		 }
	   tBitmap->Canvas->Pen->Width=oldwidth;
	  }
	else
	  {if(eltype==5)
		 {for(ip=0;ip<3;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
							  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
							 }
//		  if(ieGID==MAX_GID-1){if(ShowEdge1->Checked==true)tBitmap->Canvas->Polyline(ptDraw,2);}else
		  tBitmap->Canvas->Polygon(ptDraw,2);
		 }
	   else if(eltype==7)
		 {if(iside>2)npts=3;else npts=4;
		  for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
								 ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
								}
//		  if(ieGID==MAX_GID-1){if(ShowEdge1->Checked==true)tBitmap->Canvas->Polyline(ptDraw,npts-1);}else
		  tBitmap->Canvas->Polygon(ptDraw,npts-1);
		 }
	   else
		 {for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
							  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
							 }
//		  if(ieGID==MAX_GID-1){if(ShowEdge1->Checked==true)tBitmap->Canvas->Polyline(ptDraw,3);}else
		  tBitmap->Canvas->Polygon(ptDraw,3);
		 }
	  }
   }
 tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Pen->Width=oldwidth;
}
//---------------------------------------------------------------------------
void TForm1::FDshadeplot(long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
//  These are IDEAS conventions (NOT CAP)
//	  .      JOINT6/1, 2, 3, 1, 4, 0,
//	  .             2, 3, 1, 3, 5, 0,
//	  .             5, 6, 4, 2, 6, 0,
//	  .             4, 5, 6, 0, 0, 0/
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int npts=0;
 long ic=0,ie=0,fType=0,iside=0,ip=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;TPoint ptDraw[MAXPOINTS];
// arbFacet[nFacets]=ies*t3+fType*10+5;
 for(ic=0;ic<nFace;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
// Hexadecimal 0x00......
	if(fType<12)      tBitmap->Canvas->Brush->Color=TColor(0x00EFEFEF);else if(fType==12)tBitmap->Canvas->Brush->Color=TColor(0x00DFDFDF);
	else if(fType==13)tBitmap->Canvas->Brush->Color=TColor(0x00CFCFCF);else if(fType==14)tBitmap->Canvas->Brush->Color=TColor(0x00BFBFBF);
	else if(fType==15)tBitmap->Canvas->Brush->Color=TColor(0x00AFAFAF);else if(fType==16)tBitmap->Canvas->Brush->Color=TColor(0x009F9F9F);
	else if(fType==17)tBitmap->Canvas->Brush->Color=TColor(0x008F8F8F);else if(fType==18)tBitmap->Canvas->Brush->Color=TColor(0x007F7F7F);
	else if(fType==19)tBitmap->Canvas->Brush->Color=TColor(0x006F6F6F);else if(fType==20)tBitmap->Canvas->Brush->Color=TColor(0x005F5F5F);
	else if(fType==21)tBitmap->Canvas->Brush->Color=TColor(0x004F4F4F);else if(fType==22)tBitmap->Canvas->Brush->Color=TColor(0x003F3F3F);
	else if(fType==23)tBitmap->Canvas->Brush->Color=TColor(0x002F2F2F);else if(fType==24)tBitmap->Canvas->Brush->Color=TColor(0x001F1F1F);
	else              tBitmap->Canvas->Brush->Color=TColor(0x000F0F0F);
//
    if(eltype==5)
      {for(ip=0;ip<3;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
                           ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
                          }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,2);else tBitmap->Canvas->Polygon(ptDraw,2);
      }
    else if(eltype==7)
      {if(iside>2)npts=3;else npts=4;
       for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                              ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
                             }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,npts-1);else tBitmap->Canvas->Polygon(ptDraw,npts-1);
      }
    else
      {for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
                           ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
						  }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,3);else tBitmap->Canvas->Polygon(ptDraw,3);
	  }
   }
 tBitmap->Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::FDshadeplotnm(long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
//  These are IDEAS conventions (NOT CAP)
//	  .      JOINT6/1, 2, 3, 1, 4, 0,
//	  .             2, 3, 1, 3, 5, 0,
//	  .             5, 6, 4, 2, 6, 0,
//	  .             4, 5, 6, 0, 0, 0/
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int npts=0;long ic=0,ie=0,fType=0,iside=0,ip=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;TPoint ptDraw[MAXPOINTS];
// arbFacet[nFacets]=ies*t3+fType*10+5;
 for(ic=0;ic<nFace;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;
// Hexadecimal 0x00......
	else {if(fType<12)      tBitmap->Canvas->Brush->Color=TColor(0x00EFEFEF);else if(fType==12)tBitmap->Canvas->Brush->Color=TColor(0x00DFDFDF);
		  else if(fType==13)tBitmap->Canvas->Brush->Color=TColor(0x00CFCFCF);else if(fType==14)tBitmap->Canvas->Brush->Color=TColor(0x00BFBFBF);
		  else if(fType==15)tBitmap->Canvas->Brush->Color=TColor(0x00AFAFAF);else if(fType==16)tBitmap->Canvas->Brush->Color=TColor(0x009F9F9F);
		  else if(fType==17)tBitmap->Canvas->Brush->Color=TColor(0x008F8F8F);else if(fType==18)tBitmap->Canvas->Brush->Color=TColor(0x007F7F7F);
		  else if(fType==19)tBitmap->Canvas->Brush->Color=TColor(0x006F6F6F);else if(fType==20)tBitmap->Canvas->Brush->Color=TColor(0x005F5F5F);
		  else if(fType==21)tBitmap->Canvas->Brush->Color=TColor(0x004F4F4F);else if(fType==22)tBitmap->Canvas->Brush->Color=TColor(0x003F3F3F);
		  else if(fType==23)tBitmap->Canvas->Brush->Color=TColor(0x002F2F2F);else if(fType==24)tBitmap->Canvas->Brush->Color=TColor(0x001F1F1F);
		  else              tBitmap->Canvas->Brush->Color=TColor(0x000F0F0F);tBitmap->Canvas->Pen->Color=tBitmap->Canvas->Brush->Color;
		 }
//
    if(eltype==5)
	  {for(ip=0;ip<3;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
                           ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
						  }
       if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,2);else tBitmap->Canvas->Polygon(ptDraw,2);
      }
    else if(eltype==7)
      {if(iside>2)npts=3;else npts=4;
       for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                              ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
							 }
       if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,npts-1);else tBitmap->Canvas->Polygon(ptDraw,npts-1);
      }
    else
	  {for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
                           ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
                          }
	   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,3);else tBitmap->Canvas->Polygon(ptDraw,3);
      }
   }
 tBitmap->Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::FDcontourplot(long indat_nop1[],long indat_matno[],float indat_c1[],float indat_result[],long nFace,long arbFace[],long rbTem[],int edgFace[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
                 2,0,3,
				 3,0,1};
 int nsidept=0,sflag=0,sindic=0,sws=0,sms=0,slam=0,iloc=0,ilocp=0;
 long ic=0,ie=0,fType=0,iside=0,ip=0,igp=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t4=10000,t5=100000,t7=10000000;
 TPoint ptDraw[MAXPOINTS];tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Pen->Width=1;
// arbFacet[nFacets]=ies*t3+fType*10+5;
 for(ic=0;ic<nFace;ic++)
      {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	   eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	   ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
//	   if(ieGID==MAX_GID-1)
	   if(1==0)
//		 {if(ShowEdge1->Checked)
		 {if(1==0)
			{tBitmap->Canvas->Pen->Color=clLtGray;
			 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
															   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
                          }
             else if(eltype==7)
			   {if(iside>2)nsidept=3;else nsidept=4;
				for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                                          ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
			   }
			 else
               {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
													ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
               }
			 tBitmap->Canvas->Polyline(ptDraw,nsidept-1);
            }
		 }
	   else
        {if(fType==1)
            {tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Brush->Color=clLtGray;
			 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
															   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
                          }
			 else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
                                for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                                                          ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
							   }
             else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
													   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
				  }
             tBitmap->Canvas->Polygon(ptDraw,nsidept-1);
			}
	   else
        {sectionproc(ic,ie,iside,eltype,indat_nop1,indat_c1,indat_result);
	 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
											   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
			  }
	 else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
							for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
			                              ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
				   }
	 else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
			                           ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
		  }
         if(ShowFEMesh->Checked)
		   {tBitmap->Canvas->Pen->Color=clGray;tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);sflag=rbTem[ic]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
		{igp=ip+1;if(igp>=nsidept)igp=0;sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		 tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
		}
		   }
		 else
           {tBitmap->Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;sflag=rbTem[ic]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
	      {sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		   if((edgFace[ic]-ilocp*(edgFace[ic]/ilocp))/iloc)
				 {igp=ip+1;if(igp>=nsidept)igp=0;tBitmap->Canvas->MoveTo(ptDraw[ip].x,ptDraw[ip].y);
                  tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
                 }
			   iloc=iloc*10;ilocp=ilocp*10;
	      }
           }
	 }
   }
//
  }
 tBitmap->Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::FDcontourplotC(long indat_nop1[],long indat_matno[],float indat_c1[],float indat_result[],long nFace,long arbFace[],long rbTem[],int edgFace[],float mutFace[],int iswFace[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int nsidept=0,sflag=0,sindic=0,sws=0,sms=0,slam=0,iloc=0,ilocp=0;
 long ic=0,ie=0,fType=0,iside=0,ip=0,igp=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t4=10000,t5=100000,t7=10000000;
 long ic1=0,ie1=0,fType1=0,iside1=0,isw=0,eltype1=0
// ,bscode1=0,node1=0,ieGID1=0
 ;

 long imaxx=0,iminx=0,imaxy=0,iminy=0
 //,iGdiffx=0,iGdiffy=0
 ;
 float res_avg=0.
// ,x_avg=0.,y_avg=0.,catchment=0.,x_avg1=0.,y_avg1=0.
 ;
 TPoint ptDraw[MAXPOINTS],ptDraw1[MAXPOINTS];Canvas->Pen->Color=clBlack;Canvas->Pen->Width=1;
// arbFacet[nFacets]=ies*t3+fType*10+5;


 for(ic=0;ic<nFace;ic++)iswFace[ic]=0;
 for(ic=0;ic<nFace;ic++)
	  {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	   eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	   ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	   if(ieGID==MAX_GID-1)
//		 {if(ShowEdge1->Checked)
		 {if(1==0)
			{Canvas->Pen->Color=clLtGray;
			 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
															   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
						  }
			 else if(eltype==7)
			   {if(iside>2)nsidept=3;else nsidept=4;
				for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
										  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
			   }
			 else
			   {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
													ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
			   }
			 Canvas->Polyline(ptDraw,nsidept-1);
			}
		 }
	   else
		{if(fType==1)
			{Canvas->Pen->Color=clBlack;Canvas->Brush->Color=clLtGray;
			 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
															   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
						  }
			 else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
								for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
														  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
							   }
			 else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
													   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
				  }
			 Canvas->Polygon(ptDraw,nsidept-1);
			}
	   else
		{
////////////////////////////////
//x_avg=y_avg=
res_avg=0.;
if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){
												  res_avg=res_avg+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
												 }
			 }
else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
				   for(ip=0;ip<nsidept;ip++){
											 res_avg=res_avg+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
											}
				  }
else {nsidept=4;for(ip=0;ip<nsidept;ip++){
										  res_avg=res_avg+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
										 }
	 }
//x_avg=x_avg/float(nsidept);y_avg=y_avg/float(nsidept);
res_avg=res_avg/float(nsidept);
////catchment=3.*sqrt(max(dist1,dist2));
////catchment=3.*sqrt(min(dist1,dist2));
//catchment=float(ClientWidth)/50.;
//if(res_avg>25.+3.){
if(fabs(mutFace[ic]-res_avg)>100.){ //TBD Generalize 100.
		 mutFace[ic]=res_avg;
////////////////////////////////
   imaxx=imaxy= -1000000;iminx=iminy=1000000;
   nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
									   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
if(imaxx<ptDraw[ip].x)imaxx=ptDraw[ip].x;
if(iminx>ptDraw[ip].x)iminx=ptDraw[ip].x;
if(imaxy<ptDraw[ip].y)imaxy=ptDraw[ip].y;
if(iminy>ptDraw[ip].y)iminy=ptDraw[ip].y;
//honk<<ic+1<<" "<<ip+1<<" IC/IP "<<ptDraw[ip].x<<" "<<ptDraw[ip].y<<" CW/H "<<ClientWidth<<" "<<ClientHeight<<"\n";
									  }
honk<<ic+1<<" "<<ieGID<<" "<<imaxx-iminx<<" size/resCH "<<imaxy-iminy<<"\n";


 for(ic1=ic;ic1<nFace;ic1++)
	  {ie1=arbFace[ic1]/t3;fType1=(arbFace[ic1]-ie1*t3)/10;iside1=arbFace[ic1]-ie1*t3-fType1*10;
	   eltype1=indat_matno[ie1]/t7;
	   isw=0;
	   nsidept=4;for(ip=0;ip<nsidept;ip++){
					ptDraw1[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]]+0.5);
					ptDraw1[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]+1]+0.5);
//if(ptDraw1[ip].x<=imaxx && ptDraw1[ip].x>=iminx && ptDraw1[ip].y<=imaxy && ptDraw1[ip].y>=iminy){isw=1;break;}
if(ptDraw1[ip].x<=imaxx+10 && ptDraw1[ip].x>=iminx-10 && ptDraw1[ip].y<=imaxy+10 && ptDraw1[ip].y>=iminy-10){isw=1;break;}
										  }
	   if(isw){
//honk<<ic1+1<<" "<<ieGID1<<" shadow\n";
			   iswFace[ic1]=1;

/*
		 sectionprocC(ic1,ie1,iside1,eltype1,indat_nop1,indat_c1,indat_result);
	 if(eltype1==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]]+0.5);
											   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]+1]+0.5);}
			  }
	 else if(eltype1==7){if(iside1>2)nsidept=3;else nsidept=4;
							for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]]+0.5);
										  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]+1]+0.5);}
				   }
	 else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]]+0.5);
									   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]+1]+0.5);}
		  }
		 if(ShowFEMesh->Checked)
		   {Canvas->Pen->Color=clGray;Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);sflag=rbTem[ic1]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
		{igp=ip+1;if(igp>=nsidept)igp=0;sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		 Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
		}
		   }
		 else
		   {Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;sflag=rbTem[ic1]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
		  {sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		   if((edgFace[ic1]-ilocp*(edgFace[ic1]/ilocp))/iloc)
				 {igp=ip+1;if(igp>=nsidept)igp=0;Canvas->MoveTo(ptDraw[ip].x,ptDraw[ip].y);
				  Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
				 }
			   iloc=iloc*10;ilocp=ilocp*10;
		  }
		   }
*/


			  }
	  }
////////////////////////////////
								  }
////////////////////////////////

	 }
   }
//
  }
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
 for(ic1=0;ic1<nFace;ic1++)
   {if(iswFace[ic1])
		{ie1=arbFace[ic1]/t3;fType1=(arbFace[ic1]-ie1*t3)/10;iside1=arbFace[ic1]-ie1*t3-fType1*10;eltype1=indat_matno[ie1]/t7;
		 sectionprocC(ic1,ie1,iside1,eltype1,indat_nop1,indat_c1,indat_result);
	 if(eltype1==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]]+0.5);
											   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]+1]+0.5);}
			  }
	 else if(eltype1==7){if(iside1>2)nsidept=3;else nsidept=4;
							for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]]+0.5);
										  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]+1]+0.5);}
				   }
	 else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]]+0.5);
									   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]+1]+0.5);}
		  }
		 if(ShowFEMesh->Checked)
		   {Canvas->Pen->Color=clGray;Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);sflag=rbTem[ic1]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
		{igp=ip+1;if(igp>=nsidept)igp=0;sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		 Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
		}
		   }
		 else
		   {Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;sflag=rbTem[ic1]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
		  {sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		   if((edgFace[ic1]-ilocp*(edgFace[ic1]/ilocp))/iloc)
				 {igp=ip+1;if(igp>=nsidept)igp=0;Canvas->MoveTo(ptDraw[ip].x,ptDraw[ip].y);
				  Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
				 }
			   iloc=iloc*10;ilocp=ilocp*10;
		  }
		   }
		}
   }
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
 Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::FDcontourplotCa(long indat_nop1[],long indat_matno[],float indat_c1[],float indat_result[],long nFace,long arbFace[],long rbTem[],int edgFace[],int *iswFace)
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int nsidept=0,sflag=0,sindic=0,sws=0,sms=0,slam=0,iloc=0,ilocp=0;
 long igp=0,ip=0,
// ic=0,ie=0,fType=0,iside=0,eltype=0,
// bscode=0,node=0,ieGID=0,t5=100000,
 t3=1000,t4=10000,t7=10000000;
 long ic1=0,ie1=0,fType1=0,iside1=0,eltype1=0
// ,bscode1=0,node1=0,ieGID1=0,isw=0
 ;

// long imaxx=0,iminx=0,imaxy=0,iminy=0,iGdiffx=0,iGdiffy=0;
// float x_avg=0.,y_avg=0.,catchment=0.,res_avg=0.,x_avg1=0.,y_avg1=0.;
 TPoint ptDraw[MAXPOINTS];Canvas->Pen->Color=clBlack;Canvas->Pen->Width=1;
// arbFacet[nFacets]=ies*t3+fType*10+5;
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
 for(ic1=0;ic1<nFace;ic1++)
   {if(*(iswFace+ic1))
		{ie1=arbFace[ic1]/t3;fType1=(arbFace[ic1]-ie1*t3)/10;iside1=arbFace[ic1]-ie1*t3-fType1*10;eltype1=indat_matno[ie1]/t7;
		 sectionprocC(ic1,ie1,iside1,eltype1,indat_nop1,indat_c1,indat_result);
	 if(eltype1==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]]+0.5);
											   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]+1]+0.5);}
			  }
	 else if(eltype1==7){if(iside1>2)nsidept=3;else nsidept=4;
							for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]]+0.5);
										  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]+1]+0.5);}
				   }
	 else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]]+0.5);
									   ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]+1]+0.5);}
		  }
		 if(ShowFEMesh->Checked)
		   {Canvas->Pen->Color=clGray;Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);sflag=rbTem[ic1]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
		{igp=ip+1;if(igp>=nsidept)igp=0;sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		 Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
		}
		   }
		 else
		   {Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;sflag=rbTem[ic1]/t4;sindic=sflag;sms=0;slam=1;
		for(ip=0;ip<nsidept;ip++)
		  {sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
		   if((edgFace[ic1]-ilocp*(edgFace[ic1]/ilocp))/iloc)
				 {igp=ip+1;if(igp>=nsidept)igp=0;Canvas->MoveTo(ptDraw[ip].x,ptDraw[ip].y);
				  Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
				 }
			   iloc=iloc*10;ilocp=ilocp*10;
		  }
		   }
		}
   }
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
//ooooooooooooooooooooooooooooooooooooo
 Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::FDcontourplotC1(long indat_nop1[],long indat_matno[],float indat_c1[],float indat_result[],long nFace,long arbFace[],long rbTem[],int edgFace[],float mutFace[],int iswFace[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int nsidept=0,catchment=10
// ,sflag=0,sindic=0,sws=0,sms=0,slam=0,iloc=0,ilocp=0
;
 long ic=0,ie=0,fType=0,iside=0,ip=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000
// ,igp=0,t4=10000
 ;
 long ic1=0,ie1=0,fType1=0,iside1=0,eltype1=0;
 int imaxx=0,iminx=0,imaxy=0,iminy=0,xi=0,yi=0,isw=0;
 float res_avg=0.;
// arbFacet[nFacets]=ies*t3+fType*10+5;
// for(ic=0;ic<nFace;ic++)iswFace[ic]=0;
 for(ic=0;ic<nFace;ic++)
	  {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	   eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;
	   node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	   ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	   if(ieGID==MAX_GID-1)continue;
	   else
		{if(fType==1)continue;
		 else
		  {
res_avg=0.;
if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++)res_avg=res_avg+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];}
else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
				   for(ip=0;ip<nsidept;ip++)res_avg=res_avg+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
				  }
else {nsidept=4;for(ip=0;ip<nsidept;ip++)res_avg=res_avg+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];}
res_avg=res_avg/float(nsidept);
if(fabs(mutFace[ic]-res_avg)>100.){ //TBD Generalize 100.
								   mutFace[ic]=res_avg;
////////////////////////////////
imaxx=imaxy= -1000000;iminx=iminy=1000000;
if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){xi=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
												  yi=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
												  if(imaxx<xi)imaxx=xi;if(iminx>xi)iminx=xi;if(imaxy<yi)imaxy=yi;if(iminy>yi)iminy=yi;
												 }
			 }
else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
				   for(ip=0;ip<nsidept;ip++){xi=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
											 yi=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
											 if(imaxx<xi)imaxx=xi;if(iminx>xi)iminx=xi;if(imaxy<yi)imaxy=yi;if(iminy>yi)iminy=yi;
											}
				  }
else {nsidept=4;for(ip=0;ip<nsidept;ip++){xi=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
										  yi=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
										  if(imaxx<xi)imaxx=xi;if(iminx>xi)iminx=xi;if(imaxy<yi)imaxy=yi;if(iminy>yi)iminy=yi;
										 }
	 }
imaxx=imaxx+catchment;iminx=iminx-catchment;imaxy=imaxy+catchment;iminy=iminy-catchment;
 for(ic1=ic;ic1<nFace;ic1++)
	  {ie1=arbFace[ic1]/t3;fType1=(arbFace[ic1]-ie1*t3)/10;iside1=arbFace[ic1]-ie1*t3-fType1*10;eltype1=indat_matno[ie1]/t7;
	   isw=0;
	   if(eltype1==5){nsidept=3;for(ip=0;ip<nsidept;ip++)
								  {xi=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]]+0.5);
								   if(xi<=imaxx && xi>=iminx)
									 {yi=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata4[3*iside1+ip]]+1]+0.5);
									  if(yi<=imaxy && yi>=iminy){isw=1;break;}
									 }
								  }
					 }
	   else if(eltype1==7){if(iside1>2)nsidept=3;else nsidept=4;
						   for(ip=0;ip<nsidept;ip++)
							 {xi=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]]+0.5);
							  if(xi<=imaxx && xi>=iminx)
								{yi=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata6[4*iside1+ip]]+1]+0.5);
								 if(yi<=imaxy && yi>=iminy){isw=1;break;}
								}
							 }
						  }
	   else {nsidept=4;for(ip=0;ip<nsidept;ip++)
						 {xi=int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]]+0.5);
						  if(xi<=imaxx && xi>=iminx)
							{yi=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie1+gdata8[4*iside1+ip]]+1]+0.5);
						     if(yi<=imaxy && yi>=iminy){isw=1;break;}
							}
						 }
			}
	   if(isw)iswFace[ic1]=1;
	  }
								  }
	 }
   }
  }
}
//---------------------------------------------------------------------------
void TForm1::FDcontourplots(long indat_nop1[],long indat_matno[],float indat_c1[],float indat_result[],long nFace,long arbFace[],long rbTem[],int edgFace[],long indat_nfsect,long indat_fsect[])
// Global NDF,MXNPEI,MAXPOINTS,MAX_GID
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
                 3,4,5,0};
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
				 3,0,1};
 int nsidept=0,sflag=0,sindic=0,sws=0,sms=0,slam=0,iloc=0,ilocp=0,oldwidth=0,isw=0;
 long ic=0,ie=0,fType=0,iside=0,ip=0,ipp=0,igp=0,eltype=0,bscode=0,node=0,ieGID=0,ies=0,isides=0,ics=0,act=0,stact[4],t3=1000,t4=10000,t5=100000,t7=10000000;
// float xval=0.,yval=0.,tval0=0.,tval1=0.;
 TPoint ptDraw[MAXPOINTS];tBitmap->Canvas->Pen->Color=clBlack;oldwidth=tBitmap->Canvas->Pen->Width;
// arbFacet[nFacets]=ies*t3+fType*10+5;
 for(ic=0;ic<nFace;ic++)
      {isw=0;ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	   eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
//	   ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
	   tBitmap->Canvas->Pen->Width=oldwidth;
       if(ieGID==MAX_GID-1)
//		 {if(ShowEdge1->Checked)
		 {if(1==0)
			{tBitmap->Canvas->Pen->Color=clLtGray;
			 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
                                                               ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
                          }
			 else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
                                for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                                                          ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
							   }
             else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
                                                       ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
                  }
			 tBitmap->Canvas->Polyline(ptDraw,nsidept-1);
            }
         }
       else
        {for(ics=0;ics<indat_nfsect;ics++){ies=indat_fsect[ics]/10000;isides=indat_fsect[ics]/1000-10*ies;
										 if(ie==ies && iside==isides)
                                           {act=(indat_fsect[ics]-1000*(indat_fsect[ics]/1000))/10;
                                            if(act>7){stact[3]=1;act=act-8;}else stact[3]=0;if(act>3){stact[2]=1;act=act-4;}else stact[2]=0;
                                            if(act>1){stact[1]=1;act=act-2;}else stact[1]=0;if(act)stact[0]=1;else stact[0]=0;
                                            isw=1;break;
                                           }
										}
		 if(!isw)
            {if(ContourAll->Checked)
               {sectionproc(ic,ie,iside,eltype,indat_nop1,indat_c1,indat_result);
                if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
                                                                  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
                             }
                else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
								   for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                                                             ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
                                  }
                else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
                                                          ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
					 }
                if(ShowFEMesh->Checked)
                  {tBitmap->Canvas->Pen->Color=clGray;tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);sflag=rbTem[ic]/t4;sindic=sflag;sms=0;slam=1;
			   for(ip=0;ip<nsidept;ip++)
		      {igp=ip+1;if(igp>=nsidept)igp=0;sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
  		       tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
			  }
                  }
                else
                  {tBitmap->Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;sflag=rbTem[ic]/t4;sindic=sflag;sms=0;slam=1;
			   for(ip=0;ip<nsidept;ip++)
	             {sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
	              if((edgFace[ic]-ilocp*(edgFace[ic]/ilocp))/iloc)
                        {igp=ip+1;if(igp>=nsidept)igp=0;tBitmap->Canvas->MoveTo(ptDraw[ip].x,ptDraw[ip].y);
                         tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
						}
                      iloc=iloc*10;ilocp=ilocp*10;
         	     }
                  }
                tBitmap->Canvas->Pen->Color=clBlack;
               }
			 else   // Metallic
			   {tBitmap->Canvas->Brush->Color=clLtGray;tBitmap->Canvas->Pen->Color=tBitmap->Canvas->Brush->Color;
                if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
                                                                  ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);}
                             }
                else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
                                   for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                                                             ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);}
								  }
                else {nsidept=4;for(ip=0;ip<nsidept;ip++){ptDraw[ip].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
                                                          ptDraw[ip].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);}
                     }
                tBitmap->Canvas->Polygon(ptDraw,nsidept-1);
				if(ShowFEMesh->Checked)
                  {tBitmap->Canvas->Pen->Color=clGray;tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);sflag=rbTem[ic]/t4;sindic=sflag;sms=0;slam=1;
	           for(ip=0;ip<nsidept;ip++)
			  {igp=ip+1;if(igp>=nsidept)igp=0;sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
  		       tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
   		      }
				  }
                else
                  {tBitmap->Canvas->Pen->Color=clBlack;iloc=1;ilocp=10;sflag=rbTem[ic]/t4;sindic=sflag;sms=0;slam=1;
	           for(ip=0;ip<nsidept;ip++)
				 {sindic=sindic/10;sws=sflag-10*slam*sindic-sms;sms=sws+sms;sws=sws/slam;slam=10*slam;
	              if((edgFace[ic]-ilocp*(edgFace[ic]/ilocp))/iloc)
                        {igp=ip+1;if(igp>=nsidept)igp=0;tBitmap->Canvas->MoveTo(ptDraw[ip].x,ptDraw[ip].y);
                         tBitmap->Canvas->LineTo(ptDraw[igp].x,ptDraw[igp].y);
                        }
					  iloc=iloc*10;ilocp=ilocp*10;
         	     }
                  }
                tBitmap->Canvas->Pen->Color=clBlack;
               }
            }
		 else
		  {sectionproc(ic,ie,iside,eltype,indat_nop1,indat_c1,indat_result);tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Pen->Width=3;
//  sectionproc() pt.Draw[] is "colorband," not facet, so recreate below
           if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){if(stact[ip])
                                    {ipp=ip+1;if(ipp>=nsidept)ipp=0;
                                     ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
                                     ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
                                     ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
									 ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);
                                     tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);tBitmap->Canvas->LineTo(ptDraw[1].x,ptDraw[1].y);}
                                                            }
                        }
           else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
							  for(ip=0;ip<nsidept;ip++){if(stact[ip])
                                    {ipp=ip+1;if(ipp>=nsidept)ipp=0;
                                     ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
									 ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
                                     ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
                                     ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);
									 tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);tBitmap->Canvas->LineTo(ptDraw[1].x,ptDraw[1].y);}
                                                       }
                             }
           else {nsidept=4;for(ip=0;ip<nsidept;ip++){if(stact[ip])
									{ipp=ip+1;if(ipp>=nsidept)ipp=0;
                                     ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
                                     ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
                                     ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
                                     ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);
									 tBitmap->Canvas->MoveTo(ptDraw[0].x,ptDraw[0].y);tBitmap->Canvas->LineTo(ptDraw[1].x,ptDraw[1].y);}
                                                    }
                }
           tBitmap->Canvas->Pen->Width=oldwidth;
     }
   }
//
  }
 tBitmap->Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void TForm1::sectionproc(long ic,long ie,long iside,long eltype,long indat_nop1[],float indat_c1[],float indat_result[])
// Global NDF,MXNPEI,MAXPOINTS
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int npt=0,nsidept=0;long ip=0,ipp=0,iresmax=0,iresmin=0,itr=0;
 float xav=0.,yav=0.,res=0.,resmax=0.,resmin=0.,lwval=0.,upval=0.,lwside0=0.,upside0=0.,lwside1=0.,upside1=0.,lwside2=0.,upside2=0.,xval=0.,yval=0.,tval0=0.,tval1=0.;
 TPoint ptDraw[MAXPOINTS];
 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){xav=xav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
											   yav=yav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1];
			                           res=res+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];}
		  }
 else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
	            for(ip=0;ip<nsidept;ip++){xav=xav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
 	                                      yav=yav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1];
								  res=res+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];}
 		   }
 else {nsidept=4;for(ip=0;ip<nsidept;ip++){xav=xav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
									   yav=yav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1];
							   res=res+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];}
      }
	 xav=xav/float(nsidept);yav=yav/float(nsidept);res=res/float(nsidept);
	 for(ip=0;ip<nsidept;ip++)
		{ipp=ip+1;if(ipp>=nsidept)ipp=0;resmax=res;resmin=res;
		 if(eltype==5){if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
				   if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
			       if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
				   if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];}
		 else if(eltype==7){if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
						if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
						if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
						if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];}
		 else   {if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
			 if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
			 if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
			 if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];}
		 for(iresmax=0;resmax>ColContour[iresmax+1];iresmax++);for(iresmin=0;resmin>ColContour[iresmin+1];iresmin++);
		 if(iresmax==iresmin)
		  {if(eltype==5){ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
						   ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
						   ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
						   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);
                           ptDraw[2].x=int(xav+0.5);ptDraw[2].y=ClientHeight-int(yav+0.5);}
		   else if(eltype==7){ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                           ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
						   ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
						   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);
                           ptDraw[2].x=int(xav+0.5);ptDraw[2].y=ClientHeight-int(yav+0.5);}
		   else   {ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
						   ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
                           ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
						   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);
						   ptDraw[2].x=int(xav+0.5);ptDraw[2].y=ClientHeight-int(yav+0.5);}

// Color contour scheme modified by EFP for some reason?
//                     if(Legend_custom->Checked)
//                     {if     (iresmax==0)Canvas->Brush->Color=clWhite; else if(iresmax==1)Canvas->Brush->Color=clLtGray;
//                      else if(iresmax==2)Canvas->Brush->Color=clBlue;  else if(iresmax==3)Canvas->Brush->Color=clGreen;
//                      else if(iresmax==4)Canvas->Brush->Color=clLime;  else if(iresmax==5)Canvas->Brush->Color=clNavy;
//                      else if(iresmax==6)Canvas->Brush->Color=clYellow;else if(iresmax==7)Canvas->Brush->Color=clOlive;
//                      else if(iresmax==8)Canvas->Brush->Color=clMaroon;else if(iresmax==9)Canvas->Brush->Color=clRed;
//                      else               Canvas->Brush->Color=clWhite; Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
//                     else
//                     {if     (iresmax==0)Canvas->Brush->Color=clLtGray;  else if(iresmax==1)Canvas->Brush->Color=clBlue;
//                      else if(iresmax==2)Canvas->Brush->Color=clGreen; else if(iresmax==3)Canvas->Brush->Color=clLime;
//                      else if(iresmax==4)Canvas->Brush->Color=clNavy;else if(iresmax==5)Canvas->Brush->Color=clYellow;
//                      else if(iresmax==6)Canvas->Brush->Color=clOlive; else if(iresmax==7)Canvas->Brush->Color=clMaroon;
//                      else               Canvas->Brush->Color=clRed;   Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
// Original contour color scheme
					if(Legend_custom->Checked)
					 {if     (iresmax==0)tBitmap->Canvas->Brush->Color=clWhite; else if(iresmax==1)tBitmap->Canvas->Brush->Color=clNavy;
					  else if(iresmax==2)tBitmap->Canvas->Brush->Color=clBlue;  else if(iresmax==3)tBitmap->Canvas->Brush->Color=clGreen;
					  else if(iresmax==4)tBitmap->Canvas->Brush->Color=clLime;  else if(iresmax==5)tBitmap->Canvas->Brush->Color=clLtGray;
					  else if(iresmax==6)tBitmap->Canvas->Brush->Color=clYellow;else if(iresmax==7)tBitmap->Canvas->Brush->Color=clOlive;
					  else if(iresmax==8)tBitmap->Canvas->Brush->Color=clMaroon;else if(iresmax==9)tBitmap->Canvas->Brush->Color=clRed;
					  else               tBitmap->Canvas->Brush->Color=clWhite;
                     }
				   else
					 {if     (iresmax==0)tBitmap->Canvas->Brush->Color=clNavy;  else if(iresmax==1)tBitmap->Canvas->Brush->Color=clBlue;
					  else if(iresmax==2)tBitmap->Canvas->Brush->Color=clGreen; else if(iresmax==3)tBitmap->Canvas->Brush->Color=clLime;
					  else if(iresmax==4)tBitmap->Canvas->Brush->Color=clLtGray;else if(iresmax==5)tBitmap->Canvas->Brush->Color=clYellow;
					  else if(iresmax==6)tBitmap->Canvas->Brush->Color=clOlive; else if(iresmax==7)tBitmap->Canvas->Brush->Color=clMaroon;
					  else               tBitmap->Canvas->Brush->Color=clRed;
					 }
				   tBitmap->Canvas->Pen->Color=tBitmap->Canvas->Brush->Color;
//
				   tBitmap->Canvas->Polygon(ptDraw,2);
		  }
		else
		  {if(eltype==5)
			  {if(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])
				  lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
						   else lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
						   upside0=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]-lwside0;
						   if(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]<res)lwside1=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
						   else lwside1=res;
						   upside1=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+res-lwside1;
                           if(res<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])lwside2=res;
						   else lwside2=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
						   upside2=res+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]-lwside2;}
				   else if(eltype==7)
			  {if(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])
				  lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
                           else lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
						   upside0=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]-lwside0;
                           if(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]<res)lwside1=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
						   else lwside1=res;
                           upside1=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+res-lwside1;
						   if(res<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])lwside2=res;
                           else lwside2=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
						   upside2=res+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]-lwside2;}
				   else   {if(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])
				  lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
                           else lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
						   upside0=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]-lwside0;
                           if(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]<res)lwside1=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
						   else lwside1=res;
						   upside1=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+res-lwside1;
						   if(res<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])lwside2=res;
						   else lwside2=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
                           upside2=res+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]-lwside2;}
				   for(itr=iresmin;itr<=iresmax;itr++)
				{npt=0;lwval=ColContour[itr];upval=ColContour[itr+1];
// Edge side 0
				 if(lwval<upside0 && upval>=lwside0)
					{if(upside0-lwside0 <1.e-6)
//					{if(upside0-lwside0 <1.e-2)
						{if(eltype==5){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);npt=npt+1;}
						 else if(eltype==7){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);npt=npt+1;}
						 else{
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);npt=npt+1;}
						}
					 else
						{if(eltype==5){
   tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],lwval);
   if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
   tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],upval);
   if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else   {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
										  }
//
						 else if(eltype==7){
   tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],lwval);
   if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
   tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],upval);
   if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
										  }
//
						 else         {
   tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],lwval);
   if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
   tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],upval);
   if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
											}
						}
					}
// Interior side 1
				 if(lwval<upside1 && upval>=lwside1)
					{if(upside1-lwside1 <1.e-6)
//					{if(upside1-lwside1 <1.e-2)
						{if(eltype==5){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;}
						 else if(eltype==7){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;}
						 else         {
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;}
						}
					 else  {if(eltype==5)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],res,lwval);
	if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
	tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],res,upval);
    if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1<tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else if(eltype==7)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],res,lwval);
	if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
    tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],res,upval);
    if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1<tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],res,lwval);
	if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
	tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],res,upval);
    if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1<tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
						}
					}
// Interior side 2
				 if(lwval<upside2 && upval>=lwside2)
					{if(upside2-lwside2 <1.e-6)
//					{if(upside2-lwside2 <1.e-2)
						{if(eltype==5){
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);npt=npt+1;}
						 else if(eltype==7){
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);npt=npt+1;}
						 else         {
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);npt=npt+1;}
						}
					 else {if(eltype==5)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],res,lwval);
    if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
	tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],res,upval);
	if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else if(eltype==7)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],res,lwval);
	if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
    tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],res,upval);
	if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],res,lwval);
    if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
    tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],res,upval);
	if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
						}
					}
//// Color contour scheme modified by EFP for some reason
//                    if(Legend_custom->Checked)
//                     {if     (itr==0)Canvas->Brush->Color=clWhite; else if(itr==1)Canvas->Brush->Color=clLtGray;
//                      else if(itr==2)Canvas->Brush->Color=clBlue;  else if(itr==3)Canvas->Brush->Color=clGreen;
//                      else if(itr==4)Canvas->Brush->Color=clLime;  else if(itr==5)Canvas->Brush->Color=clNavy;
//                      else if(itr==6)Canvas->Brush->Color=clYellow;else if(itr==7)Canvas->Brush->Color=clOlive;
//                      else if(itr==8)Canvas->Brush->Color=clMaroon;else if(itr==9)Canvas->Brush->Color=clRed;
//                      else           Canvas->Brush->Color=clWhite; Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
//                    else
//                     {if     (itr==0)Canvas->Brush->Color=clLtGray;  else if(itr==1)Canvas->Brush->Color=clBlue;
//                      else if(itr==2)Canvas->Brush->Color=clGreen; else if(itr==3)Canvas->Brush->Color=clLime;
//                      else if(itr==4)Canvas->Brush->Color=clNavy;else if(itr==5)Canvas->Brush->Color=clYellow;
//                      else if(itr==6)Canvas->Brush->Color=clOlive; else if(itr==7)Canvas->Brush->Color=clMaroon;
//                      else           Canvas->Brush->Color=clRed;   Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
// Original contour color scheme
					if(Legend_custom->Checked)
					 {if     (itr==0)tBitmap->Canvas->Brush->Color=clWhite; else if(itr==1)tBitmap->Canvas->Brush->Color=clNavy;
					  else if(itr==2)tBitmap->Canvas->Brush->Color=clBlue;  else if(itr==3)tBitmap->Canvas->Brush->Color=clGreen;
					  else if(itr==4)tBitmap->Canvas->Brush->Color=clLime;  else if(itr==5)tBitmap->Canvas->Brush->Color=clLtGray;
					  else if(itr==6)tBitmap->Canvas->Brush->Color=clYellow;else if(itr==7)tBitmap->Canvas->Brush->Color=clOlive;
					  else if(itr==8)tBitmap->Canvas->Brush->Color=clMaroon;else if(itr==9)tBitmap->Canvas->Brush->Color=clRed;
					  else           tBitmap->Canvas->Brush->Color=clWhite;
                     }
                   else
					 {if     (itr==0)tBitmap->Canvas->Brush->Color=clNavy;  else if(itr==1)tBitmap->Canvas->Brush->Color=clBlue;
					  else if(itr==2)tBitmap->Canvas->Brush->Color=clGreen; else if(itr==3)tBitmap->Canvas->Brush->Color=clLime;
					  else if(itr==4)tBitmap->Canvas->Brush->Color=clLtGray;else if(itr==5)tBitmap->Canvas->Brush->Color=clYellow;
					  else if(itr==6)tBitmap->Canvas->Brush->Color=clOlive; else if(itr==7)tBitmap->Canvas->Brush->Color=clMaroon;
					  else           tBitmap->Canvas->Brush->Color=clRed;
                     }
				   tBitmap->Canvas->Pen->Color=tBitmap->Canvas->Brush->Color;
//
					tBitmap->Canvas->Polygon(ptDraw,npt-1);
				}
		  }
		}
}
//---------------------------------------------------------------------------
void TForm1::sectionprocC(long ic,long ie,long iside,long eltype,long indat_nop1[],float indat_c1[],float indat_result[])
// Global NDF,MXNPEI,MAXPOINTS
//{int gdata8[24]={0,1,5,4,
//                 1,2,6,5,
//                 3,2,6,7,
//                 0,3,7,4,
//                 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int npt=0,nsidept=0;long ip=0,ipp=0,iresmax=0,iresmin=0,itr=0;
 float xav=0.,yav=0.,res=0.,resmax=0.,resmin=0.,lwval=0.,upval=0.,lwside0=0.,upside0=0.,lwside1=0.,upside1=0.,lwside2=0.,upside2=0.,xval=0.,yval=0.,tval0=0.,tval1=0.;
 TPoint ptDraw[MAXPOINTS];
 if(eltype==5){nsidept=3;for(ip=0;ip<nsidept;ip++){xav=xav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
											   yav=yav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1];
			                           res=res+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];}
	      }
 else if(eltype==7){if(iside>2)nsidept=3;else nsidept=4;
	            for(ip=0;ip<nsidept;ip++){xav=xav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
										  yav=yav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1];
								  res=res+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];}
 		   }
 else {nsidept=4;for(ip=0;ip<nsidept;ip++){xav=xav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
  	                                   yav=yav+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1];
							   res=res+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];}
	  }
	 xav=xav/float(nsidept);yav=yav/float(nsidept);res=res/float(nsidept);
	 for(ip=0;ip<nsidept;ip++)
		{ipp=ip+1;if(ipp>=nsidept)ipp=0;resmax=res;resmin=res;
		 if(eltype==5){if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
				   if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
			       if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
				   if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];}
		 else if(eltype==7){if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
						if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
			            if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
						if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];}
		 else   {if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
			 if(resmax<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])resmax=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
			 if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
			 if(resmin>indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])resmin=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];}
		 for(iresmax=0;resmax>ColContour[iresmax+1];iresmax++);for(iresmin=0;resmin>ColContour[iresmin+1];iresmin++);
		 if(iresmax==iresmin)
		  {if(eltype==5){ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
						   ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);
                           ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
						   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);
                           ptDraw[2].x=int(xav+0.5);ptDraw[2].y=ClientHeight-int(yav+0.5);}
		   else if(eltype==7){ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
                           ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);
                           ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
						   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);
                           ptDraw[2].x=int(xav+0.5);ptDraw[2].y=ClientHeight-int(yav+0.5);}
		   else   {ptDraw[0].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
						   ptDraw[0].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);
                           ptDraw[1].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
						   ptDraw[1].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);
						   ptDraw[2].x=int(xav+0.5);ptDraw[2].y=ClientHeight-int(yav+0.5);}

// Color contour scheme modified by EFP for some reason?
//                     if(Legend_custom->Checked)
//                     {if     (iresmax==0)Canvas->Brush->Color=clWhite; else if(iresmax==1)Canvas->Brush->Color=clLtGray;
//                      else if(iresmax==2)Canvas->Brush->Color=clBlue;  else if(iresmax==3)Canvas->Brush->Color=clGreen;
//                      else if(iresmax==4)Canvas->Brush->Color=clLime;  else if(iresmax==5)Canvas->Brush->Color=clNavy;
//                      else if(iresmax==6)Canvas->Brush->Color=clYellow;else if(iresmax==7)Canvas->Brush->Color=clOlive;
//                      else if(iresmax==8)Canvas->Brush->Color=clMaroon;else if(iresmax==9)Canvas->Brush->Color=clRed;
//                      else               Canvas->Brush->Color=clWhite; Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
//                     else
//                     {if     (iresmax==0)Canvas->Brush->Color=clLtGray;  else if(iresmax==1)Canvas->Brush->Color=clBlue;
//                      else if(iresmax==2)Canvas->Brush->Color=clGreen; else if(iresmax==3)Canvas->Brush->Color=clLime;
//                      else if(iresmax==4)Canvas->Brush->Color=clNavy;else if(iresmax==5)Canvas->Brush->Color=clYellow;
//                      else if(iresmax==6)Canvas->Brush->Color=clOlive; else if(iresmax==7)Canvas->Brush->Color=clMaroon;
//                      else               Canvas->Brush->Color=clRed;   Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
// Original contour color scheme
					if(Legend_custom->Checked)
					 {if     (iresmax==0)Canvas->Brush->Color=clWhite; else if(iresmax==1)Canvas->Brush->Color=clNavy;
					  else if(iresmax==2)Canvas->Brush->Color=clBlue;  else if(iresmax==3)Canvas->Brush->Color=clGreen;
					  else if(iresmax==4)Canvas->Brush->Color=clLime;  else if(iresmax==5)Canvas->Brush->Color=clLtGray;
					  else if(iresmax==6)Canvas->Brush->Color=clYellow;else if(iresmax==7)Canvas->Brush->Color=clOlive;
					  else if(iresmax==8)Canvas->Brush->Color=clMaroon;else if(iresmax==9)Canvas->Brush->Color=clRed;
					  else               Canvas->Brush->Color=clWhite;
					 }
				   else
					 {if     (iresmax==0)Canvas->Brush->Color=clNavy;  else if(iresmax==1)Canvas->Brush->Color=clBlue;
					  else if(iresmax==2)Canvas->Brush->Color=clGreen; else if(iresmax==3)Canvas->Brush->Color=clLime;
					  else if(iresmax==4)Canvas->Brush->Color=clLtGray;else if(iresmax==5)Canvas->Brush->Color=clYellow;
					  else if(iresmax==6)Canvas->Brush->Color=clOlive; else if(iresmax==7)Canvas->Brush->Color=clMaroon;
					  else               Canvas->Brush->Color=clRed;
					 }
				   Canvas->Pen->Color=Canvas->Brush->Color;
//
				   Canvas->Polygon(ptDraw,2);
		  }
		else
		  {if(eltype==5)
			  {if(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])
				  lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
						   else lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
						   upside0=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]-lwside0;
						   if(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]<res)lwside1=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]];
						   else lwside1=res;
						   upside1=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+res-lwside1;
						   if(res<indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]])lwside2=res;
						   else lwside2=indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
						   upside2=res+indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]-lwside2;}
				   else if(eltype==7)
			  {if(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])
				  lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
						   else lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
						   upside0=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]-lwside0;
						   if(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]<res)lwside1=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]];
						   else lwside1=res;
						   upside1=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+res-lwside1;
						   if(res<indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]])lwside2=res;
						   else lwside2=indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
						   upside2=res+indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]-lwside2;}
                   else   {if(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])
				  lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
                           else lwside0=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
						   upside0=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]-lwside0;
                           if(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]<res)lwside1=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]];
						   else lwside1=res;
						   upside1=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+res-lwside1;
                           if(res<indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]])lwside2=res;
						   else lwside2=indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
						   upside2=res+indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]-lwside2;}
				   for(itr=iresmin;itr<=iresmax;itr++)
				{npt=0;lwval=ColContour[itr];upval=ColContour[itr+1];
// Edge side 0
				 if(lwval<upside0 && upval>=lwside0)
					{if(upside0-lwside0 <1.e-6)
//					{if(upside0-lwside0 <1.e-2)
						{if(eltype==5){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);npt=npt+1;}
						 else if(eltype==7){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);npt=npt+1;}
						 else{
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);npt=npt+1;}
						}
					 else
						{if(eltype==5){
   tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],lwval);
   if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
   tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],upval);
   if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else   {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
										  }
//
						 else if(eltype==7){
   tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],lwval);
   if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
   tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],upval);
   if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
										  }
//
						 else         {
   tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],lwval);
   if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
   tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],upval);
   if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]];
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1];
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
											}
						}
					}
// Interior side 1
				 if(lwval<upside1 && upval>=lwside1)
					{if(upside1-lwside1 <1.e-6)
//					{if(upside1-lwside1 <1.e-2)
						{if(eltype==5){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;}
						 else if(eltype==7){
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;}
						 else         {
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+0.5);npt=npt+1;
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;}
						}
					 else  {if(eltype==5)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],res,lwval);
    if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
	tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]],res,upval);
    if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1<tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else if(eltype==7)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],res,lwval);
	if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
    tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]],res,upval);
	if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1<tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],res,lwval);
    if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
	tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]],res,upval);
    if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1<tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ip]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
						}
					}
// Interior side 2
				 if(lwval<upside2 && upval>=lwside2)
					{if(upside2-lwside2 <1.e-6)
//					{if(upside2-lwside2 <1.e-2)
						{if(eltype==5){
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+0.5);npt=npt+1;}
						 else if(eltype==7){
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+0.5);npt=npt+1;}
						 else         {
ptDraw[npt].x=int(xav+0.5);ptDraw[npt].y=ClientHeight-int(yav+0.5);npt=npt+1;
ptDraw[npt].x=int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+0.5);
ptDraw[npt].y=ClientHeight-int(indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+0.5);npt=npt+1;}
						}
					 else {if(eltype==5)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],res,lwval);
    if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
	tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]],res,upval);
    if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else if(eltype==7)
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],res,lwval);
    if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
    tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]],res,upval);
	if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
//
						 else
   {tval0=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],res,lwval);
    if(tval0>1.)tval0=1.;if(tval0<0.)tval0=0.;
    tval1=val_interp(indat_result[indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]],res,upval);
	if(tval1>1.)tval1=1.;if(tval1<0.)tval1=0.;
							 if(tval1>tval0){
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							 else {
xval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval0*xav;
yval=(1.-tval0)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval0*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;
xval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]]+tval1*xav;
yval=(1.-tval1)*indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+ipp]]+1]+tval1*yav;
ptDraw[npt].x=int(xval+0.5);ptDraw[npt].y=ClientHeight-int(yval+0.5);npt=npt+1;}
							}
						}
					}
//// Color contour scheme modified by EFP for some reason
//                    if(Legend_custom->Checked)
//                     {if     (itr==0)Canvas->Brush->Color=clWhite; else if(itr==1)Canvas->Brush->Color=clLtGray;
//                      else if(itr==2)Canvas->Brush->Color=clBlue;  else if(itr==3)Canvas->Brush->Color=clGreen;
//                      else if(itr==4)Canvas->Brush->Color=clLime;  else if(itr==5)Canvas->Brush->Color=clNavy;
//                      else if(itr==6)Canvas->Brush->Color=clYellow;else if(itr==7)Canvas->Brush->Color=clOlive;
//                      else if(itr==8)Canvas->Brush->Color=clMaroon;else if(itr==9)Canvas->Brush->Color=clRed;
//                      else           Canvas->Brush->Color=clWhite; Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
//                    else
//                     {if     (itr==0)Canvas->Brush->Color=clLtGray;  else if(itr==1)Canvas->Brush->Color=clBlue;
//                      else if(itr==2)Canvas->Brush->Color=clGreen; else if(itr==3)Canvas->Brush->Color=clLime;
//                      else if(itr==4)Canvas->Brush->Color=clNavy;else if(itr==5)Canvas->Brush->Color=clYellow;
//                      else if(itr==6)Canvas->Brush->Color=clOlive; else if(itr==7)Canvas->Brush->Color=clMaroon;
//                      else           Canvas->Brush->Color=clRed;   Canvas->Pen->Color=Canvas->Brush->Color;
//                     }
// Original contour color scheme
					if(Legend_custom->Checked)
					 {if     (itr==0)Canvas->Brush->Color=clWhite; else if(itr==1)Canvas->Brush->Color=clNavy;
					  else if(itr==2)Canvas->Brush->Color=clBlue;  else if(itr==3)Canvas->Brush->Color=clGreen;
					  else if(itr==4)Canvas->Brush->Color=clLime;  else if(itr==5)Canvas->Brush->Color=clLtGray;
					  else if(itr==6)Canvas->Brush->Color=clYellow;else if(itr==7)Canvas->Brush->Color=clOlive;
					  else if(itr==8)Canvas->Brush->Color=clMaroon;else if(itr==9)Canvas->Brush->Color=clRed;
					  else           Canvas->Brush->Color=clWhite;
					 }
				   else
					 {if     (itr==0)Canvas->Brush->Color=clNavy;  else if(itr==1)Canvas->Brush->Color=clBlue;
					  else if(itr==2)Canvas->Brush->Color=clGreen; else if(itr==3)Canvas->Brush->Color=clLime;
					  else if(itr==4)Canvas->Brush->Color=clLtGray;else if(itr==5)Canvas->Brush->Color=clYellow;
					  else if(itr==6)Canvas->Brush->Color=clOlive; else if(itr==7)Canvas->Brush->Color=clMaroon;
					  else           Canvas->Brush->Color=clRed;
					 }
				   Canvas->Pen->Color=Canvas->Brush->Color;
//
				   Canvas->Polygon(ptDraw,npt-1);
				}
		  }
		}
}
//---------------------------------------------------------------------------
float TForm1::val_interp(float res0,float res1,float rval){return (rval-res0)/(res1-res0);}
//---------------------------------------------------------------------------
void TForm1::FDlegend()
{int xleg=0,yleg0=0,yleg1=0,yleginc=0,ir=0,jr=0,xtxnum=0,ytxnum=0,ndec=4,subst0=0,subst1=0;
 float value=0.;char buf[15];TPoint ptDraw[MAXPOINTS];
 xleg=ClientWidth/20;yleg0=ClientHeight/4;yleg1=ClientHeight*3/4;
 if(Legend_custom->Checked)yleginc=(yleg1-yleg0)/(nColContour-3);else yleginc=(yleg1-yleg0)/(nColContour-1);
 xtxnum=xleg+5;ytxnum=yleg0-yleginc+8;
 ptDraw[0].x=0;   ptDraw[0].y=ClientHeight-(yleg0-yleginc);ptDraw[1].x=xleg;ptDraw[1].y=ClientHeight-(yleg0-yleginc);
 ptDraw[2].x=xleg;ptDraw[2].y=ClientHeight-yleg0;ptDraw[3].x=0;   ptDraw[3].y=ClientHeight-yleg0;
 if(Legend_custom->Checked){subst0=1;subst1=nColContour-1;}else {subst0=0;subst1=nColContour;}
 for(ir=subst0;ir<subst1;ir++)
	{for(jr=0;jr<4;jr++)ptDraw[jr].y=ptDraw[jr].y-yleginc;
				   tBitmap->Canvas->Pen->Color=clBlack;
//// Color contour scheme modified by EFP for some reason
//                   if(Legend_custom->Checked)
//                     {if     (ir==0)Canvas->Brush->Color=clWhite;else if(ir==1)Canvas->Brush->Color=clLtGray;
//                      else if(ir==2)Canvas->Brush->Color=clBlue;else if(ir==3)Canvas->Brush->Color=clGreen;
//                      else if(ir==4)Canvas->Brush->Color=clLime;else if(ir==5)Canvas->Brush->Color=clNavy;
//                      else if(ir==6)Canvas->Brush->Color=clYellow;else if(ir==7)Canvas->Brush->Color=clOlive;
//                      else if(ir==8)Canvas->Brush->Color=clMaroon;else if(ir==9)Canvas->Brush->Color=clRed;
//                      else          Canvas->Brush->Color=clWhite;
//                     }
//                   else
//                     {if     (ir==0)Canvas->Brush->Color=clLtGray;else if(ir==1)Canvas->Brush->Color=clBlue;
//                      else if(ir==2)Canvas->Brush->Color=clGreen;else if(ir==3)Canvas->Brush->Color=clLime;
//                      else if(ir==4)Canvas->Brush->Color=clNavy;else if(ir==5)Canvas->Brush->Color=clYellow;
//                      else if(ir==6)Canvas->Brush->Color=clOlive;else if(ir==7)Canvas->Brush->Color=clMaroon;
//                      else          Canvas->Brush->Color=clRed;
//                     }
// Original contour color scheme
                    if(Legend_custom->Checked)
					 {if     (ir==0)tBitmap->Canvas->Brush->Color=clWhite; else if(ir==1)tBitmap->Canvas->Brush->Color=clNavy;
					  else if(ir==2)tBitmap->Canvas->Brush->Color=clBlue;  else if(ir==3)tBitmap->Canvas->Brush->Color=clGreen;
					  else if(ir==4)tBitmap->Canvas->Brush->Color=clLime;  else if(ir==5)tBitmap->Canvas->Brush->Color=clLtGray;
					  else if(ir==6)tBitmap->Canvas->Brush->Color=clYellow;else if(ir==7)tBitmap->Canvas->Brush->Color=clOlive;
					  else if(ir==8)tBitmap->Canvas->Brush->Color=clMaroon;else if(ir==9)tBitmap->Canvas->Brush->Color=clRed;
					  else           tBitmap->Canvas->Brush->Color=clWhite;
                     }
				   else
					 {if     (ir==0)tBitmap->Canvas->Brush->Color=clNavy;  else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
					  else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen; else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
					  else if(ir==4)tBitmap->Canvas->Brush->Color=clLtGray;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
					  else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive; else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
					  else           tBitmap->Canvas->Brush->Color=clRed;
                     }
//

                   tBitmap->Canvas->Polygon(ptDraw,3);ytxnum=ytxnum+yleginc;tBitmap->Canvas->Pen->Color=clBlack;tBitmap->Canvas->Brush->Color=clWhite;
	           value=float(ColContour[ir]);gcvt(value,ndec,buf);tBitmap->Canvas->TextOut(xtxnum,ClientHeight-ytxnum,buf);
	}
 ytxnum=ytxnum+yleginc;tBitmap->Canvas->Pen->Color=clBlack;
 if(Legend_custom->Checked)value=float(ColContour[nColContour-1]);else value=float(ColContour[nColContour]);
 gcvt(value,ndec,buf);tBitmap->Canvas->TextOut(xtxnum,ClientHeight-ytxnum,buf);ytxnum=ytxnum+yleginc;
//// Use library function    fnsplit   here   (Library ref. p106))
}

//---------------------------------------------------------------------------
void TForm1::CmContour()
//Test for FE geo file & FE results file & facets
{int ipx=0;float rmax= -1.e28,rmin=1.e28,rintv=0.;long jp=0,ip=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000;
////FDtrans_frame_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres,2-1,25.476738);
//FDtrans_frame_results(base.npoin,base.c1,base.res1,nColRes,fl_feres,2-1,25.476738);
//FDtrans_frame_results(base.npoin,base.c1,base.res1,nColRes,fl_feres,1-1,90.);
 if(base.nop1)
   {if(fl_feres)
	  {if(Legend_custom->Checked)
		 {nColContour=9+2;rintv=(leg_rmax-leg_rmin)/float(nColContour-2);ColContour[0]= -1.e28;ColContour[1]=leg_rmin;
		  ColContour[nColContour-1]=leg_rmax+fabs(leg_rmax)/1000000.;ColContour[nColContour]=1.e28;
		  for(ipx=2;ipx<nColContour-1;ipx++)ColContour[ipx]=ColContour[ipx-1]+rintv;ColContour[1]=leg_rmin-fabs(leg_rmin)/1000000.;
		 }
	   else
		 {for(ip=0;ip<indat.nelt;ip++)
			{eltype=indat.matno[ip]/t7;bscode=(indat.matno[ip]-eltype*t7)/t5;node=(indat.matno[ip]-eltype*t7-bscode*t5)/t3;
			 for(jp=0;jp<node;jp++){if(rmax<indat.result[indat.nop1[MXNPEI*ip+jp]])rmax=indat.result[indat.nop1[MXNPEI*ip+jp]];
									if(rmin>indat.result[indat.nop1[MXNPEI*ip+jp]])rmin=indat.result[indat.nop1[MXNPEI*ip+jp]];
								   }
			}
		  nColContour=9;rintv=(rmax-rmin)/float(nColContour);ColContour[0]=rmin;ColContour[nColContour]=rmax+fabs(rmax)/1000000.;
		  for(ipx=1;ipx<nColContour;ipx++)ColContour[ipx]=ColContour[ipx-1]+rintv;
		  ColContour[0]=rmin-fabs(rmin)/1000000.;leg_rmin=rmin;leg_rmax=rmax;
		 }
	   iCircleplot=2;Invalidate();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"02Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::CmContour_Lg(float rmin,float rmax)
{//Test for FE geo file & FE results file & facets
 int ipx=0;float rintv=0.;
 if(base.nop1)
   {if(fl_feres)
	  {if(Legend_custom->Checked)
		 {nColContour=9+2;rintv=(rmax-rmin)/float(nColContour-2);ColContour[0]= -1.e28;ColContour[1]=rmin;
		  ColContour[nColContour-1]=rmax+fabs(rmax)/1000000.;ColContour[nColContour]=1.e28;
		  for(ipx=2;ipx<nColContour-1;ipx++)ColContour[ipx]=ColContour[ipx-1]+rintv;ColContour[1]=rmin-fabs(rmin)/1000000.;
		 }
	   else
		 {nColContour=9;rintv=(rmax-rmin)/float(nColContour);ColContour[0]=rmin;ColContour[nColContour]=rmax+fabs(rmax)/1000000.;
		  for(ipx=1;ipx<nColContour;ipx++)ColContour[ipx]=ColContour[ipx-1]+rintv;ColContour[0]=rmin-fabs(rmin)/1000000.;
		 }
	   iCircleplot=2;Invalidate();        //   UpdateWindow();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"03Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::FDsel_res(int selIndex,long indat_npoin,float indat_res1[],float indat_result[],long nColRes,int fl_feres)
{long i=0;
 if(fl_feres==1){if(selIndex<9)for(i=0;i<indat_npoin;i++)indat_result[i]=indat_res1[nColRes*i+long(selIndex)];else FD_PSTR(selIndex-9,nColRes,indat_npoin,indat_res1,indat_result,3);}
 else if(fl_feres==4){if(selIndex<9)for(i=0;i<indat_npoin;i++)indat_result[i]=indat_res1[nColRes*i+long(selIndex)];
					  else if(selIndex>8 && selIndex<17)FD_PSTR(selIndex-9,nColRes,indat_npoin,indat_res1,indat_result,3);
					  else if(selIndex>16 && selIndex<23)for(i=0;i<indat_npoin;i++)indat_result[i]=indat_res1[nColRes*i+long(selIndex-8)];
					  else if(selIndex>22 && selIndex<29)FD_PSTR(selIndex-23,nColRes,indat_npoin,indat_res1,indat_result,9);
					  else for(i=0;i<indat_npoin;i++)indat_result[i]=indat_res1[nColRes*i+long(selIndex-14)];
					 }
 else for(i=0;i<indat_npoin;i++)indat_result[i]=indat_res1[nColRes*i+long(selIndex)];
}
//---------------------------------------------------------------------------
void TForm1::FD_PSTR(int isel,long stor,long indat_npoin,float indat_res1[],float indat_result[],long loc)
// function SQRT,ABS,AMAX1,AMIN1
// isel=0  --> n1
//     =1      n2
//     =2      n3
//     =3      P1 most tensile
//     =4      P2 middle
//     =5      P3 most compressive
//     =6      Tresca
//     =7      vonMises
//     =8      Findley
{int IT=0,ICRMIN=0,IK=0,INXT=0,IPRV=0,ITNRMX=100;long I=0;
 float RI1=0.,RI2=0.,RI3=0.,BBB=0.,FC1=0.,FC2=0.,STR=0.,STR0=0.,RN1=0.,RD1=0.,TEST=0.,DIV=0.,B1=0.,B2=0.,BSQ=0.,PMAGMAX=0.,STRMX=0.,VCRMIN=0.,
   STRS1=0.,STRS2=0.,STRS3=0.,STRS4=0.,STRS5=0.,STRS6=0.,PRST1=0.,PRST2=0.,PRST3=0.,VONMIS=0.,RLC[3],VC[3],EPS=1.E-6,TOL=0.005,PGMAX=0.;
 for(I=0;I<indat_npoin;I++){
	STRS1=indat_res1[stor*I+loc];STRS2=indat_res1[stor*I+loc+1];STRS3=indat_res1[stor*I+loc+2];
	STRS4=indat_res1[stor*I+loc+3];STRS5=indat_res1[stor*I+loc+4];STRS6=indat_res1[stor*I+loc+5];
	RI1=STRS1+STRS2+STRS3;RI2=STRS1*STRS2+STRS2*STRS3+STRS1*STRS3-STRS4*STRS4-STRS5*STRS5-STRS6*STRS6;
	RI3=STRS1*STRS2*STRS3+2.*STRS4*STRS5*STRS6-STRS1*STRS6*STRS6-STRS2*STRS5*STRS5-STRS3*STRS4*STRS4;
//	HPRESS=RI1/3.
	BBB=RI1*RI1-3.*RI2;
	if(BBB>0.){VONMIS=sqrt(BBB);FC1=BBB/4.5;} else{VONMIS=0.;FC1=0.;}
//  Initial trial stress STR=1000000.   THIS IS NOT APROPOS FOR STRAIN........
	STR=1.E6;STR0=STR;FC2=RI3-RI1*RI2/9.;
	for(IT=0;IT<ITNRMX;IT++)
	  {RN1=STR*FC1+FC2;RD1=RI2- STR*(2.*RI1- 3.*STR);
		STR=STR/1.5 +RI1/9. +RN1/RD1;
		if(fabs(RD1)<EPS)break;
		if(fabs(STR)>EPS)TEST=(1. -STR0/STR);else TEST=STR-STR0;
		if(fabs(TEST)<TOL)break;
		STR0=STR;
	  }
//	WRITE(6,*)'WARNING:No N-R convg for stress node/iter',I+1,ITNRMX
	if(fabs(STR)<EPS)DIV=RI2;else DIV=RI3/STR;
	B1=(RI1-STR)/2.;BSQ=B1*B1-DIV;if(BSQ>0.)B2=sqrt(BSQ);else B2=0.;
	if(STR>(B1+B2)){PRST1=STR;PRST2=B1+B2;PRST3=B1-B2;}
	else {PRST1=B1+B2;if(STR>(B1-B2))PRST2=STR;else PRST2=B1-B2;PRST3=STR+B1-B2-PRST2;}
	if(fabs(PRST1)>fabs(PRST3)){PMAGMAX=fabs(PRST1);STRMX=PRST1;}else {PMAGMAX=fabs(PRST3);STRMX=PRST3;}
	if(PMAGMAX>PGMAX)PGMAX=PMAGMAX;VC[0]=STRS6*(STRMX-STRS1)+STRS4*STRS5;
	VC[1]=STRS5*(STRMX-STRS2)+STRS4*STRS6;VC[2]=STRS4*(STRMX-STRS3)+STRS5*STRS6;
	VCRMIN=1.E15;ICRMIN=0;
	for(IK=0;IK<NDF;IK++){if(fabs(VC[IK])<VCRMIN){VCRMIN=fabs(VC[IK]);ICRMIN=IK+1;}}
	if(VCRMIN<EPS)
	  {INXT=(-4+ICRMIN*(11-3*ICRMIN))/2;IPRV=(16-ICRMIN*(13-3*ICRMIN))/2;
		RLC[ICRMIN-1]=PMAGMAX;RLC[INXT-1]=0.;RLC[IPRV-1]=0.;
	  }
	else
	 {RLC[0]=PMAGMAX*VC[1]*VC[2]/sqrt(VC[1]*VC[1]*VC[2]*VC[2]+VC[0]*VC[0]*(VC[1]*VC[1]+VC[2]*VC[2]));
	  RLC[1]=RLC[0]*VC[0]/VC[1];RLC[2]=RLC[0]*VC[0]/VC[2];
	  }
	if(isel==0)     indat_result[I]=RLC[0];else if(isel==1)indat_result[I]=RLC[1];
	else if(isel==2)indat_result[I]=RLC[2];else if(isel==3)indat_result[I]=PRST1;
	else if(isel==4)indat_result[I]=PRST2;else if(isel==5)indat_result[I]=PRST3;
	else if(isel==6)indat_result[I]=(PRST1-PRST3)/2.;else if(isel==7)indat_result[I]=VONMIS;
	else            indat_result[I]=0.37*(PRST1+PRST3)/2.+(PRST1-PRST3)/2.;
  }
//  Note: In the following, N3 component should be + by convention. Find a way to enforce this.
 if(isel<3){if(PGMAX<EPS)PGMAX=EPS;for(I=0;I<indat_npoin;I++)indat_result[I]=indat_result[I]/PGMAX;}
}
//---------------------------------------------------------------------------
void TForm1::FD_PSTRN(long I,float *PRST,float RLC[],float indat_res1[])
// function SQRT,ABS,AMAX1,AMIN1
// isel=0  --> n1
//     =1      n2
//     =2      n3
//     =3      P1 most tensile
//     =4      P2 middle
//     =5      P3 most compressive
//     =6      Tresca
//     =7      vonMises
//     =8      Findley
{int IT=0,ICRMIN=0,IK=0,INXT=0,IPRV=0,ITNRMX=100;
 float RI1=0.,RI2=0.,RI3=0.,BBB=0.,FC1=0.,FC2=0.,STR=0.,STR0=0.,RN1=0.,RD1=0.,TEST=0.,DIV=0.,B1=0.,B2=0.,BSQ=0.,
	   PMAGMAX=0.,STRMX=0.,VCRMIN=0.,STRS1=0.,STRS2=0.,STRS3=0.,STRS4=0.,STRS5=0.,STRS6=0.,RNORM=0.,PRST1=0.,PRST2=0.,PRST3=0.,
//        RLC[3],
        VC[3],EPS=1.E-6,TOL=0.005,PGMAX=0.;
 STRS1=indat_res1[9*I+3];STRS2=indat_res1[9*I+4];STRS3=indat_res1[9*I+5];
 STRS4=indat_res1[9*I+6];STRS5=indat_res1[9*I+7];STRS6=indat_res1[9*I+8];
 RI1=STRS1+STRS2+STRS3;RI2=STRS1*STRS2+STRS2*STRS3+STRS1*STRS3-STRS4*STRS4-STRS5*STRS5-STRS6*STRS6;
 RI3=STRS1*STRS2*STRS3+2.*STRS4*STRS5*STRS6-STRS1*STRS6*STRS6-STRS2*STRS5*STRS5-STRS3*STRS4*STRS4;
//	HPRESS=RI1/3.
 BBB=RI1*RI1-3.*RI2;
 if(BBB>0.)FC1=BBB/4.5;else FC1=0.;
//  Initial trial stress STR=1000000.
 STR=1.E6;STR0=STR;FC2=RI3-RI1*RI2/9.;
 for(IT=0;IT<ITNRMX;IT++)
   {RN1=STR*FC1+FC2;RD1=RI2- STR*(2.*RI1- 3.*STR);STR=STR/1.5 +RI1/9. +RN1/RD1;
    if(fabs(RD1)<EPS)break;
    if(fabs(STR)>EPS)TEST=(1. -STR0/STR);else TEST=STR-STR0;
    if(fabs(TEST)<TOL)break;
    STR0=STR;
   }
//	WRITE(6,*)'WARNING:No N-R convg for stress node/iter',I+1,ITNRMX
 if(fabs(STR)<EPS)DIV=RI2;else DIV=RI3/STR;
 B1=(RI1-STR)/2.;BSQ=B1*B1-DIV;
 if(BSQ>0.)B2=sqrt(BSQ);else B2=0.;
 if(STR>(B1+B2)){PRST1=STR;PRST2=B1+B2;PRST3=B1-B2;}
 else {PRST1=B1+B2;if(STR>(B1-B2))PRST2=STR;else PRST2=B1-B2;PRST3=STR+B1-B2-PRST2;}
 if(fabs(PRST1)>fabs(PRST3)){PMAGMAX=fabs(PRST1);STRMX=PRST1;}
 else                       {PMAGMAX=fabs(PRST3);STRMX=PRST3;}
 if(PMAGMAX>PGMAX)PGMAX=PMAGMAX;VC[0]=STRS6*(STRMX-STRS1)+STRS4*STRS5;
 VC[1]=STRS5*(STRMX-STRS2)+STRS4*STRS6;VC[2]=STRS4*(STRMX-STRS3)+STRS5*STRS6;VCRMIN=1.E15;ICRMIN=0;
 for(IK=0;IK<NDF;IK++){if(fabs(VC[IK])<VCRMIN){VCRMIN=fabs(VC[IK]);ICRMIN=IK+1;}}
 if(VCRMIN<EPS){INXT=(-4+ICRMIN*(11-3*ICRMIN))/2;IPRV=(16-ICRMIN*(13-3*ICRMIN))/2;
				RLC[ICRMIN-1]=PMAGMAX;RLC[INXT-1]=0.;RLC[IPRV-1]=0.;
               }
 else{RLC[0]=PMAGMAX*VC[1]*VC[2]/sqrt(VC[1]*VC[1]*VC[2]*VC[2]+VC[0]*VC[0]*(VC[1]*VC[1]+VC[2]*VC[2]));
	  RLC[1]=RLC[0]*VC[0]/VC[1];RLC[2]=RLC[0]*VC[0]/VC[2];
     }
 RNORM=RLC[0]*RLC[0]+RLC[1]*RLC[1]+RLC[2]*RLC[2];
 if(RNORM>TOL*TOL){RNORM=sqrt(RNORM);RLC[0]=RLC[0]/RNORM;RLC[1]=RLC[1]/RNORM;RLC[2]=RLC[2]/RNORM;}
 else {RLC[0]=1.;RLC[1]=RLC[2]=0.;}
 *PRST=PRST1;
}
//---------------------------------------------------------------------------
void TForm1::FD_PSTRD(float STRS[],float STRN[],float *PRST,float *CSTN,float *PRSTC,float *CSTNC,float creep_c,float creep_n)
{long IT=0,ICRMIN=0,IK=0,INXT=0,IPRV=0,ITNRMX=100;
 float RI1=0.,RI2=0.,RI3=0.,BBB=0.,FC1=0.,FC2=0.,STR=0.,STR0=0.,RN1=0.,RD1=0.,TEST=0.,DIV=0.,B1=0.,B2=0.,BSQ=0.,PRST1=0.,PRST2=0.,PRST3=0.,
       PMAGMAX=0.,STRMX=0.,VCRMIN=0.,RAD=0.,RLC0=0.,RLC1=0.,RLC2=0.,RLC3=0.,RLC4=0.,RLC5=0.,RLC6=0.,RLC7=0.,RLC8=0.,
	   CSTN1=0.,CSTN2=0.,CSTN3=0.,EPS=1.E-6,TOL=0.005,VC[3],RLC[3],PRST1V=0.,PRST2V=0.,PRST3V=0.;
////////////////
for(IT=0;IT<6;IT++)STRS[IT]=STRS[IT]/1000.; // psi to ksi
////////////////
 RI1=STRS[0]+STRS[1]+STRS[2];RI2=STRS[0]*STRS[1]+STRS[1]*STRS[2]+STRS[0]*STRS[2]-STRS[3]*STRS[3]-STRS[4]*STRS[4]-STRS[5]*STRS[5];
 RI3=STRS[0]*STRS[1]*STRS[2]+2.*STRS[3]*STRS[4]*STRS[5]-STRS[0]*STRS[5]*STRS[5]-STRS[1]*STRS[4]*STRS[4]-STRS[2]*STRS[3]*STRS[3];
 BBB=RI1*RI1-3.*RI2;if(BBB>0.)FC1=BBB/4.5;else FC1=0.;
//  Initial trial stress STR=1000000.
 STR=1.E6;STR0=STR;FC2=RI3-RI1*RI2/9.;
 for(IT=0;IT<ITNRMX;IT++)
    {RN1=STR*FC1+FC2;RD1=RI2-STR*(2.*RI1-3.*STR);STR=STR/1.5 +RI1/9. +RN1/RD1;
     if(fabs(RD1)<EPS)break;
     else {if(fabs(STR)>EPS)TEST=(1.-STR0/STR);else TEST=STR-STR0;
           if(fabs(TEST)<TOL)break;else STR0=STR;
		  }
    }
//      WRITE(6,*)'WARNING:No N-R convg for iter',ITNRMX
 if(fabs(STR)<EPS)DIV=RI2;else DIV=RI3/STR;
 B1=(RI1-STR)/2.;BSQ=B1*B1-DIV;
 if(BSQ>0.)B2=sqrt(BSQ);else B2=0.;
 if(STR>B1+B2){PRST1=STR;PRST2=B1+B2;PRST3=B1-B2;}
 else {PRST1=B1+B2;PRST2=max(STR,B1-B2);PRST3=min(STR,B1-B2);}
//  Principal direction for P1 tensile stress
 PMAGMAX=fabs(PRST1);STRMX=PRST1;VC[0]=STRS[5]*(STRMX-STRS[0])+STRS[3]*STRS[4];
 VC[1]=STRS[4]*(STRMX-STRS[1])+STRS[3]*STRS[5];VC[2]=STRS[3]*(STRMX-STRS[2])+STRS[4]*STRS[5];
 VCRMIN=1.E15;ICRMIN=0;
 for(IK=0;IK<NDF;IK++)if(VC[IK]<VCRMIN){VCRMIN=fabs(VC[IK]);ICRMIN=IK+1;}
 if(VCRMIN<EPS){INXT=(-4+ICRMIN*(11-3*ICRMIN))/2;IPRV=(16-ICRMIN*(13-3*ICRMIN))/2;
				RLC[ICRMIN-1]=PMAGMAX;RLC[INXT-1]=0.;RLC[IPRV-1]=0.;
			   }
 else {RLC[0]=PMAGMAX*VC[1]*VC[2]/sqrt(VC[1]*VC[2]*VC[1]*VC[2]+VC[0]*VC[0]*(VC[1]*VC[1]+VC[2]*VC[2]));
       RLC[1]=RLC[0]*VC[0]/VC[1];RLC[2]=RLC[0]*VC[0]/VC[2];
      }
 RAD=sqrt(RLC[0]*RLC[0]+RLC[1]*RLC[1]+RLC[2]*RLC[2]);
 RLC[0]=RLC[0]/RAD;RLC[1]=RLC[1]/RAD;RLC[2]=RLC[2]/RAD;RLC0=RLC[0];RLC1=RLC[1];RLC2=RLC[2];
//  Principal direction for P2 tensile stress
 PMAGMAX=fabs(PRST2);STRMX=PRST2;VC[0]=STRS[5]*(STRMX-STRS[0])+STRS[3]*STRS[4];
 VC[1]=STRS[4]*(STRMX-STRS[1])+STRS[3]*STRS[5];VC[2]=STRS[3]*(STRMX-STRS[2])+STRS[4]*STRS[5];
 VCRMIN=1.E15;ICRMIN=0;
 for(IK=0;IK<NDF;IK++)if(VC[IK]<VCRMIN){VCRMIN=fabs(VC[IK]);ICRMIN=IK+1;}
 if(VCRMIN<EPS){INXT=(-4+ICRMIN*(11-3*ICRMIN))/2;IPRV=(16-ICRMIN*(13-3*ICRMIN))/2;
				RLC[ICRMIN-1]=PMAGMAX;RLC[INXT-1]=0.;RLC[IPRV-1]=0.;
               }
 else {RLC[0]=PMAGMAX*VC[1]*VC[2]/sqrt(VC[1]*VC[2]*VC[1]*VC[2]+VC[0]*VC[0]*(VC[1]*VC[1]+VC[2]*VC[2]));
       RLC[1]=RLC[0]*VC[0]/VC[1];RLC[2]=RLC[0]*VC[0]/VC[2];
      }
 RAD=sqrt(RLC[0]*RLC[0]+RLC[1]*RLC[1]+RLC[2]*RLC[2]);
 RLC[0]=RLC[0]/RAD;RLC[1]=RLC[1]/RAD;RLC[2]=RLC[2]/RAD;RLC3=RLC[0];RLC4=RLC[1];RLC5=RLC[2];
 RLC6=RLC1*RLC[2]-RLC2*RLC[1];RLC7=RLC2*RLC[0]-RLC0*RLC[2];RLC8=RLC0*RLC[1]-RLC1*RLC[0];
//
PRST1V=PRST1;PRST2V=PRST2;PRST3V=PRST3; // ksi stress only
//PRST1V=PRST1/1000.;PRST2V=PRST2/1000.;PRST3V=PRST3/1000.; //  psi stress only...........
// if(fabs(creep_n)>0.0001)
//   {if(PRST1V>0.)CSTN1=float(exp(double(creep_n)*(log(double(PRST1V))+log(double(creep_c))/double(creep_n))));else CSTN1=0.;
//    if(PRST2V>0.)CSTN2=float(exp(double(creep_n)*(log(double(PRST2V))+log(double(creep_c))/double(creep_n))));else CSTN2=0.;
//    if(PRST3V>0.)CSTN3=float(exp(double(creep_n)*(log(double(PRST3V))+log(double(creep_c))/double(creep_n))));else CSTN3=0.;
//   }
// else {CSTN1=CSTN2=CSTN3=0.;}
 if(fabs(creep_n)>0.0001)
   {CSTN1=float(exp(double(creep_n)*(log(double(fabs(PRST1V)))+log(double(creep_c))/double(creep_n))));if(PRST1V<0.)CSTN1= -CSTN1;
    CSTN2=float(exp(double(creep_n)*(log(double(fabs(PRST2V)))+log(double(creep_c))/double(creep_n))));if(PRST2V<0.)CSTN2= -CSTN2;
    CSTN3=float(exp(double(creep_n)*(log(double(fabs(PRST3V)))+log(double(creep_c))/double(creep_n))));if(PRST3V<0.)CSTN3= -CSTN3;
   }
 else {CSTN1=CSTN2=CSTN3=0.;}

//if(fabs(creep_n)>0.0001 && CSTN3< -0.14)honk<<creep_n<<" "<<PRST1V<<" "<<PRST2V<<" "<<PRST3V<<" P/C "<<CSTN1<<" "<<CSTN2<<" "<<CSTN3<<"\n";
//honk<<creep_n<<" "<<PRST1V<<" "<<PRST2V<<" "<<PRST3V<<" P/C "<<CSTN1<<" "<<CSTN2<<" "<<CSTN3<<"\n";

//
 STRN[0]=CSTN1*RLC0*RLC0+CSTN2*RLC3*RLC3+CSTN3*RLC6*RLC6;STRN[1]=CSTN1*RLC1*RLC1+CSTN2*RLC4*RLC4+CSTN3*RLC7*RLC7;
 STRN[2]=CSTN1*RLC2*RLC2+CSTN2*RLC5*RLC5+CSTN3*RLC8*RLC8;STRN[3]=CSTN1*RLC0*RLC1+CSTN2*RLC3*RLC4+CSTN3*RLC6*RLC7;
 STRN[4]=CSTN1*RLC0*RLC2+CSTN2*RLC3*RLC5+CSTN3*RLC6*RLC8;STRN[5]=CSTN1*RLC1*RLC2+CSTN2*RLC4*RLC5+CSTN3*RLC7*RLC8;
 *PRST=PRST1;*CSTN=CSTN1;
 *PRSTC=PRST3;*CSTNC=CSTN3;
/////////////////
for(IT=0;IT<6;IT++)STRS[IT]=STRS[IT]*1000.; // ksi to psi
 *PRST= *PRST*1000.; *PRSTC= *PRSTC*1000.;
/////////////////
}
//---------------------------------------------------------------------------
void TForm1::FD_PSTRG(float STRS[],float *PRST1,float *PRST2,float *PRST3)
{long IT=0,ICRMIN=0,IK=0,INXT=0,IPRV=0,ITNRMX=100;
 float RI1=0.,RI2=0.,RI3=0.,BBB=0.,FC1=0.,FC2=0.,STR=0.,STR0=0.,RN1=0.,RD1=0.,TEST=0.,DIV=0.,B1=0.,B2=0.,BSQ=0.,
       PMAGMAX=0.,STRMX=0.,VCRMIN=0.,RAD=0.,EPS=1.E-6,TOL=0.005,VC[3],RLC[3];
 RI1=STRS[0]+STRS[1]+STRS[2];RI2=STRS[0]*STRS[1]+STRS[1]*STRS[2]+STRS[0]*STRS[2]-STRS[3]*STRS[3]-STRS[4]*STRS[4]-STRS[5]*STRS[5];
 RI3=STRS[0]*STRS[1]*STRS[2]+2.*STRS[3]*STRS[4]*STRS[5]-STRS[0]*STRS[5]*STRS[5]-STRS[1]*STRS[4]*STRS[4]-STRS[2]*STRS[3]*STRS[3];
 BBB=RI1*RI1-3.*RI2;if(BBB>0.)FC1=BBB/4.5;else FC1=0.;
//  Initial trial stress STR=1000000.
 STR=1.E6;STR0=STR;FC2=RI3-RI1*RI2/9.;
 for(IT=0;IT<ITNRMX;IT++)
	{RN1=STR*FC1+FC2;RD1=RI2-STR*(2.*RI1-3.*STR);STR=STR/1.5 +RI1/9. +RN1/RD1;
     if(fabs(RD1)<EPS)break;
     else {if(fabs(STR)>EPS)TEST=(1.-STR0/STR);else TEST=STR-STR0;
		   if(fabs(TEST)<TOL)break;else STR0=STR;
          }
    }
//      WRITE(6,*)'WARNING:No N-R convg for iter',ITNRMX
 if(fabs(STR)<EPS)DIV=RI2;else DIV=RI3/STR;
 B1=(RI1-STR)/2.;BSQ=B1*B1-DIV;
 if(BSQ>0.)B2=sqrt(BSQ);else B2=0.;
 if(STR>B1+B2){*PRST1=STR;*PRST2=B1+B2;*PRST3=B1-B2;}
 else {*PRST1=B1+B2;*PRST2=max(STR,B1-B2);*PRST3=min(STR,B1-B2);}
//  Principal direction for P1 tensile stress
 PMAGMAX=fabs(*PRST1);STRMX= *PRST1;VC[0]=STRS[5]*(STRMX-STRS[0])+STRS[3]*STRS[4];
 VC[1]=STRS[4]*(STRMX-STRS[1])+STRS[3]*STRS[5];VC[2]=STRS[3]*(STRMX-STRS[2])+STRS[4]*STRS[5];
 VCRMIN=1.E15;ICRMIN=0;
 for(IK=0;IK<NDF;IK++)if(VC[IK]<VCRMIN){VCRMIN=fabs(VC[IK]);ICRMIN=IK+1;}
 if(VCRMIN<EPS){INXT=(-4+ICRMIN*(11-3*ICRMIN))/2;IPRV=(16-ICRMIN*(13-3*ICRMIN))/2;
                RLC[ICRMIN-1]=PMAGMAX;RLC[INXT-1]=0.;RLC[IPRV-1]=0.;
			   }
 else {RLC[0]=PMAGMAX*VC[1]*VC[2]/sqrt(VC[1]*VC[2]*VC[1]*VC[2]+VC[0]*VC[0]*(VC[1]*VC[1]+VC[2]*VC[2]));
       RLC[1]=RLC[0]*VC[0]/VC[1];RLC[2]=RLC[0]*VC[0]/VC[2];
      }
 RAD=sqrt(RLC[0]*RLC[0]+RLC[1]*RLC[1]+RLC[2]*RLC[2]);
 RLC[0]=RLC[0]/RAD;RLC[1]=RLC[1]/RAD;RLC[2]=RLC[2]/RAD;
//  Principal direction for P2 tensile stress
 PMAGMAX=fabs(*PRST2);STRMX=*PRST2;VC[0]=STRS[5]*(STRMX-STRS[0])+STRS[3]*STRS[4];
 VC[1]=STRS[4]*(STRMX-STRS[1])+STRS[3]*STRS[5];VC[2]=STRS[3]*(STRMX-STRS[2])+STRS[4]*STRS[5];
 VCRMIN=1.E15;ICRMIN=0;
 for(IK=0;IK<NDF;IK++)if(VC[IK]<VCRMIN){VCRMIN=fabs(VC[IK]);ICRMIN=IK+1;}
 if(VCRMIN<EPS){INXT=(-4+ICRMIN*(11-3*ICRMIN))/2;IPRV=(16-ICRMIN*(13-3*ICRMIN))/2;
				RLC[ICRMIN-1]=PMAGMAX;RLC[INXT-1]=0.;RLC[IPRV-1]=0.;
               }
 else {RLC[0]=PMAGMAX*VC[1]*VC[2]/sqrt(VC[1]*VC[2]*VC[1]*VC[2]+VC[0]*VC[0]*(VC[1]*VC[1]+VC[2]*VC[2]));
	   RLC[1]=RLC[0]*VC[0]/VC[1];RLC[2]=RLC[0]*VC[0]/VC[2];
      }
 RAD=sqrt(RLC[0]*RLC[0]+RLC[1]*RLC[1]+RLC[2]*RLC[2]);
 RLC[0]=RLC[0]/RAD;RLC[1]=RLC[1]/RAD;RLC[2]=RLC[2]/RAD;
}
//---------------------------------------------------------------------------
void TForm1::CmPmContour_public()
{if(iResSel+1){FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);if(CustomLeg){delete CustomLeg;CustomLeg=NULL;}
               Legend_auto->Checked=true;Legend_custom->Checked=1-Legend_auto->Checked;CmContour();
              }
 else {delete ResultsForm;ResultsForm=NULL;}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Legend_autoExecute(TObject *Sender)
{if(fl_feres){if(CustomLeg){delete CustomLeg;CustomLeg=NULL;}
              Legend_auto->Checked=true;Legend_custom->Checked=1-Legend_auto->Checked;CmContour();
             }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Legend_customExecute(TObject *Sender)
{if(fl_feres)
   {if(iResSel>=0)
	  {if(!CustomLeg){Legend_auto->Checked=false;Legend_custom->Checked=1-Legend_auto->Checked;
					  CustomLeg=new TForm3(leg_rmax,leg_rmin,this);CustomLeg->Show();
					 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Custom legend dialog box exists",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must use ResultSelector first",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::wahea_public() // Legend coding
{float convent=3.4e38,recMax=CustomLeg->MaxForm3,recMin=CustomLeg->MinForm3;
 if(recMax==convent && recMin==convent) // Convention to close box
   {Legend_auto->Checked=true;Legend_custom->Checked=1-Legend_auto->Checked;
	if(CustomLeg){delete CustomLeg;CustomLeg=NULL;} // "if()" should not be necessary???
   }
 else {if(recMax <= recMin)
		 {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Incorrect custom max/min",L"Switched to auto",MB_OK);
		  Legend_auto->Checked=true;Legend_custom->Checked=1-Legend_auto->Checked;
		 }
	   else {Legend_auto->Checked=false;Legend_custom->Checked=1-Legend_auto->Checked;leg_rmin=recMin;leg_rmax=recMax;}
	  }
 CmContour();
}
//---------------------------------------------------------------------------
void TForm1::annot_public() // Annotation coding
{AnsiString leg_rmax=AnnotForm->RSMaxF;
 if(strlen(leg_rmax.c_str()))
   {if(ANNOTcount==0){AnnotArr0=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==1){AnnotArr1=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==2){AnnotArr2=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==3){AnnotArr3=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==4){AnnotArr4=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==5){AnnotArr5=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==6){AnnotArr6=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==7){AnnotArr7=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==8){AnnotArr8=leg_rmax;ANNOTcount++;FDrestore();}
	else if(ANNOTcount==9){AnnotArr9=leg_rmax;ANNOTcount++;FDrestore();}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"More than 10 annotations",L"Failure",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Enter non-null annotation",L"Failure",MB_OK);}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
void TForm1::rothea_public()
{float convent=3.4e38,R0=RotaForm->Angle0,R1=RotaForm->Angle1,R2=RotaForm->Angle2;
 if(R0==convent && R1==convent && R2==convent){if(RotaForm){// delete RotaForm;
															RotaForm=NULL;}
											  } // R0/R1/R2 Close() convention
 else {rangle[0]=R0;rangle0[0]=rangle0[0]+rangle[0];
	   rangle[1]=R1;rangle0[1]=rangle0[1]+rangle[1];
	   rangle[2]=R2;rangle0[2]=rangle0[2]+rangle[2];
	   FDrotate(0,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);
	   FDrotate_axisplot(0,rangle); //EFP 9/17/2010
	   iCullyesno=0;Invalidate();
	  }
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
void TForm1::rotheaFix_public()   // This does NOT work correctly
{rangle[0]=RotaFixForm->Angle0;rangle0[0]=rangle0[0]+rangle[0];
 rangle[1]=RotaFixForm->Angle1;rangle0[1]=rangle0[1]+rangle[1];
 rangle[2]=RotaFixForm->Angle2;rangle0[2]=rangle0[2]+rangle[2];
 FDrotate(0,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);
 FDrotate_axisplot(0,rangle); //EFP 9/17/2010
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iCullyesno=0;Invalidate();
}
//---------------------------------------------------------------------------
void TForm1::rothea1_public()  // UNDO  This does NOT work correctly
{rangle[0]= RotaForm->Angle0;rangle0[0]=rangle0[0]-rangle[0];
 rangle[1]= RotaForm->Angle1;rangle0[1]=rangle0[1]-rangle[1];
 rangle[2]= RotaForm->Angle2;rangle0[2]=rangle0[2]-rangle[2];
 FDrotate(1,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);
 FDrotate_axisplot(1,rangle); //EFP 9/17/2010
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iCullyesno=0;Invalidate();
}
//---------------------------------------------------------------------------
void TForm1::rothea_reset_public()  // This does NOT reset correctly
{float AA=0.,BB=0.,VV=0.;int nper=0;
 AA= rangle0[0];VV=(AA+180.)/360.;if(VV<0.){nper=int(VV+0.001);BB=AA+540.+360.*float(nper);}else {nper=int(VV-0.001);BB=AA+180.-360.*float(nper);}
 rangle[0]= (BB-180.);rangle0[0]=0.;
 AA= rangle0[1];VV=(AA+180.)/360.;if(VV<0.){nper=int(VV+0.001);BB=AA+540.+360.*float(nper);}else {nper=int(VV-0.001);BB=AA+180.-360.*float(nper);}
 rangle[1]= (BB-180.);rangle0[1]=0.;
 AA= rangle0[2];VV=(AA+180.)/360.;if(VV<0.){nper=int(VV+0.001);BB=AA+540.+360.*float(nper);}else {nper=int(VV-0.001);BB=AA+180.-360.*float(nper);}
 rangle[2]= (BB-180.);rangle0[2]=0.;
 trans_op[0]=trans_op[1]=trans_op[2]=0.;prod_op[0][0]=prod_op[1][1]=prod_op[2][2]=1.;
 prod_op[0][1]=prod_op[0][2]=prod_op[1][0]=0.;prod_op[1][2]=prod_op[2][0]=prod_op[2][1]=0.;
 FDrotate(1,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);
 FDrotate_axisplot(1,rangle); //EFP 9/17/2010
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iCullyesno=0;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::RotateExecute(TObject *Sender)
{float VV=0.;
 if(base.nop1){if(!RotaForm){RotaForm=new TForm4(VV,VV,VV,this);RotaForm->Show();}
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Rotation dialog box exists",L"Halt",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"04Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void TForm1::FDrotate(int transpose,long indat_npoin,float indat_c1[],float rangle[],float trans_op[],float prod_op[][3],float rot_op[][3],long nDefects,float CrackCor[])
// Global NDF
{long i=0;float sumx=0.,sumy=0.,sumz=0.,cenx=0.,ceny=0.,cenz=0.,xmx= -1.E20,xmn=1.E20,ymx= -1.E20,ymn=1.E20,zmx= -1.E20,zmn=1.E20,
  r11=0.,r12=0.,r13=0.,r21=0.,r22=0.,r23=0.,r31=0.,r32=0.,r33=0.,ri11=0.,ri12=0.,ri13=0.,ri21=0.,ri22=0.,ri23=0.,ri31=0.,ri32=0.,ri33=0.,pix=4.*atan(1.)/180.;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
// for(i=0;i<indat_npoin;i++)
//   {if(xmx<indat_c1[NDF*i  ])xmx=indat_c1[NDF*i  ];if(xmn>indat_c1[NDF*i  ])xmn=indat_c1[NDF*i  ];
//	if(ymx<indat_c1[NDF*i+1])ymx=indat_c1[NDF*i+1];if(ymn>indat_c1[NDF*i+1])ymn=indat_c1[NDF*i+1];
//	if(zmx<indat_c1[NDF*i+2])zmx=indat_c1[NDF*i+2];if(zmn>indat_c1[NDF*i+2])zmn=indat_c1[NDF*i+2];
//	}
// cenx=(xmx-xmn)/2.;ceny=(ymx-ymn)/2.;cenz=(zmx-zmn)/2.;
 honk<<gl_indatMedian[0]<<" "<<gl_indatMedian[1]<<" "<<gl_indatMedian[2]<<" enteringFDrot\n";

 cenx=gl_indatMedian[0];ceny=gl_indatMedian[1];cenz=gl_indatMedian[2];
 r11=  cos(pix*rangle[1])*cos(pix*rangle[2]);
 r12= -cos(pix*rangle[1])*sin(pix*rangle[2]);r13=  sin(pix*rangle[1]);
 r21=  cos(pix*rangle[0])*sin(pix*rangle[2])+sin(pix*rangle[0])*sin(pix*rangle[1])*cos(pix*rangle[2]);
 r22=  cos(pix*rangle[0])*cos(pix*rangle[2])-sin(pix*rangle[0])*sin(pix*rangle[1])*sin(pix*rangle[2]);
 r23= -sin(pix*rangle[0])*cos(pix*rangle[1]);
 r31=  sin(pix*rangle[0])*sin(pix*rangle[2])-cos(pix*rangle[0])*sin(pix*rangle[1])*cos(pix*rangle[2]);
 r32=  sin(pix*rangle[0])*cos(pix*rangle[2])+cos(pix*rangle[0])*sin(pix*rangle[1])*sin(pix*rangle[2]);
 r33=  cos(pix*rangle[0])*cos(pix*rangle[1]);
 if(transpose){float temp=r12;r12=r21;r21=temp;temp=r13;r13=r31;r31=temp;temp=r23;r23=r32;r32=temp;}
//
// ri11=r11*rot_op[0][0]+r12*rot_op[1][0]+r13*rot_op[2][0];ri21=r21*rot_op[0][0]+r22*rot_op[1][0]+r23*rot_op[2][0];ri31=r31*rot_op[0][0]+r32*rot_op[1][0]+r33*rot_op[2][0];
// ri12=r11*rot_op[0][1]+r12*rot_op[1][1]+r13*rot_op[2][1];ri22=r21*rot_op[0][1]+r22*rot_op[1][1]+r23*rot_op[2][1];ri32=r31*rot_op[0][1]+r32*rot_op[1][1]+r33*rot_op[2][1];
// ri13=r11*rot_op[0][2]+r12*rot_op[1][2]+r13*rot_op[2][2];ri23=r21*rot_op[0][2]+r22*rot_op[1][2]+r23*rot_op[2][2];ri33=r31*rot_op[0][2]+r32*rot_op[1][2]+r33*rot_op[2][2];
// rot_op[0][0]=ri11;rot_op[0][1]=ri12;rot_op[0][2]=ri13;rot_op[1][0]=ri21;rot_op[1][1]=ri22;rot_op[1][2]=ri23;rot_op[2][0]=ri31;rot_op[2][1]=ri32;rot_op[2][2]=ri33;
//

/////////////////////////////////////////////////
 xmx= -1.E20;xmn=1.E20;ymx= -1.E20;ymn=1.E20;zmx= -1.E20;zmn=1.E20;
 for(i=0;i<indat_npoin;i++)
   {if(xmx<indat_c1[NDF*i  ])xmx=indat_c1[NDF*i  ];if(xmn>indat_c1[NDF*i  ])xmn=indat_c1[NDF*i  ];
	if(ymx<indat_c1[NDF*i+1])ymx=indat_c1[NDF*i+1];if(ymn>indat_c1[NDF*i+1])ymn=indat_c1[NDF*i+1];
	if(zmx<indat_c1[NDF*i+2])zmx=indat_c1[NDF*i+2];if(zmn>indat_c1[NDF*i+2])zmn=indat_c1[NDF*i+2];
   }
honk<<xmx<<" "<<xmn<<" XY "<<ymx<<" "<<ymn<<" YZ "<<zmx<<" "<<zmn<<" FDrotBEF\n";
honk<<(xmx+xmn)/2. <<" XY "<<(ymx+ymn)/2. <<" YZ "<<(zmx+zmn)/2. <<" avgFDrotBEF\n";
/////////////////////////////////////////////////

 xmx= -1.E20;xmn=1.E20;ymx= -1.E20;ymn=1.E20;zmx= -1.E20;zmn=1.E20;
 for(i=0;i<indat_npoin;i++)
   {sumx=r11*(indat_c1[NDF*i]-cenx)+r12*(indat_c1[NDF*i+1]-ceny)+r13*(indat_c1[NDF*i+2]-cenz);
	sumy=r21*(indat_c1[NDF*i]-cenx)+r22*(indat_c1[NDF*i+1]-ceny)+r23*(indat_c1[NDF*i+2]-cenz);
	sumz=r31*(indat_c1[NDF*i]-cenx)+r32*(indat_c1[NDF*i+1]-ceny)+r33*(indat_c1[NDF*i+2]-cenz);
	indat_c1[NDF*i]=sumx;indat_c1[NDF*i+1]=sumy;indat_c1[NDF*i+2]=sumz;
	if(xmx<indat_c1[NDF*i  ])xmx=indat_c1[NDF*i  ];if(xmn>indat_c1[NDF*i  ])xmn=indat_c1[NDF*i  ];
	if(ymx<indat_c1[NDF*i+1])ymx=indat_c1[NDF*i+1];if(ymn>indat_c1[NDF*i+1])ymn=indat_c1[NDF*i+1];
	if(zmx<indat_c1[NDF*i+2])zmx=indat_c1[NDF*i+2];if(zmn>indat_c1[NDF*i+2])zmn=indat_c1[NDF*i+2];
   }
honk<< (xmx+xmn)/2. <<" AdjX "<<xmx<<" "<<xmn<<"\n";
honk<< (ymx+ymn)/2. <<" AdjY "<<ymx<<" "<<ymn<<"\n";
honk<< (zmx+zmn)/2. <<" AdjZ "<<zmx<<" "<<zmn<<"\n";

// gl_indatMedian[0]=gl_indatMedian[0]-(xmx+xmn)/2.;
// gl_indatMedian[1]=gl_indatMedian[1]-(ymx+ymn)/2.;
// gl_indatMedian[2]=gl_indatMedian[2]-(zmx+zmn)/2.;
//// gl_indatMedian[0]=gl_indatMedian[0]+(xmx+xmn)/2.;
//// gl_indatMedian[1]=gl_indatMedian[1]+(ymx+ymn)/2.;
//// gl_indatMedian[2]=gl_indatMedian[2]+(zmx+zmn)/2.;

 honk<<gl_indatMedian[0]<<" "<<gl_indatMedian[1]<<" "<<gl_indatMedian[2]<<" applyFDrot\n";
 for(i=0;i<indat_npoin;i++)
   {indat_c1[NDF*i  ]=indat_c1[NDF*i  ]+gl_indatMedian[0];
	indat_c1[NDF*i+1]=indat_c1[NDF*i+1]+gl_indatMedian[1];
	indat_c1[NDF*i+2]=indat_c1[NDF*i+2]+gl_indatMedian[2];
   }
/////////////////////////////////////////////////
 xmx= -1.E20;xmn=1.E20;ymx= -1.E20;ymn=1.E20;zmx= -1.E20;zmn=1.E20;
 for(i=0;i<indat_npoin;i++)
   {if(xmx<indat_c1[NDF*i  ])xmx=indat_c1[NDF*i  ];if(xmn>indat_c1[NDF*i  ])xmn=indat_c1[NDF*i  ];
	if(ymx<indat_c1[NDF*i+1])ymx=indat_c1[NDF*i+1];if(ymn>indat_c1[NDF*i+1])ymn=indat_c1[NDF*i+1];
	if(zmx<indat_c1[NDF*i+2])zmx=indat_c1[NDF*i+2];if(zmn>indat_c1[NDF*i+2])zmn=indat_c1[NDF*i+2];
   }
honk<<xmx<<" "<<xmn<<" XY "<<ymx<<" "<<ymn<<" YZ "<<zmx<<" "<<zmn<<" FDrotAFT\n";
honk<<(xmx+xmn)/2. <<" XY "<<(ymx+ymn)/2. <<" YZ "<<(zmx+zmn)/2. <<" avgFDrotAFT\n";
/////////////////////////////////////////////////
if(nDefects)
{for(long iq=0;iq<nDefects;iq++)
 {for(long ic=0;ic<3;ic++)
   {sumx=r11*(CrackCor[9*iq+3*ic+0]-cenx)+r12*(CrackCor[9*iq+3*ic+1]-ceny)+r13*(CrackCor[9*iq+3*ic+2]-cenz);
	sumy=r21*(CrackCor[9*iq+3*ic+0]-cenx)+r22*(CrackCor[9*iq+3*ic+1]-ceny)+r23*(CrackCor[9*iq+3*ic+2]-cenz);
	sumz=r31*(CrackCor[9*iq+3*ic+0]-cenx)+r32*(CrackCor[9*iq+3*ic+1]-ceny)+r33*(CrackCor[9*iq+3*ic+2]-cenz);
	CrackCor[9*iq+3*ic+0]=sumx+gl_indatMedian[0];CrackCor[9*iq+3*ic+1]=sumy+gl_indatMedian[1];CrackCor[9*iq+3*ic+2]=sumz+gl_indatMedian[2];
   }
 }
}
// trans_op[0]=trans_op[0]+cenx*prod_op[0][0]+ceny*prod_op[0][1]+cenz*prod_op[0][2];
// trans_op[1]=trans_op[1]+cenx*prod_op[1][0]+ceny*prod_op[1][1]+cenz*prod_op[1][2];
// trans_op[2]=trans_op[2]+cenx*prod_op[2][0]+ceny*prod_op[2][1]+cenz*prod_op[2][2];
// ri11=r11*prod_op[0][0]+r12*prod_op[0][1]+r13*prod_op[0][2];ri12=r21*prod_op[0][0]+r22*prod_op[0][1]+r23*prod_op[0][2];ri13=r31*prod_op[0][0]+r32*prod_op[0][1]+r33*prod_op[0][2];
// ri21=r11*prod_op[1][0]+r12*prod_op[1][1]+r13*prod_op[1][2];ri22=r21*prod_op[1][0]+r22*prod_op[1][1]+r23*prod_op[1][2];ri23=r31*prod_op[1][0]+r32*prod_op[1][1]+r33*prod_op[1][2];
// ri31=r11*prod_op[2][0]+r12*prod_op[2][1]+r13*prod_op[2][2];ri32=r21*prod_op[2][0]+r22*prod_op[2][1]+r23*prod_op[2][2];ri33=r31*prod_op[2][0]+r32*prod_op[2][1]+r33*prod_op[2][2];
// prod_op[0][0]=ri11;prod_op[1][0]=ri21;prod_op[2][0]=ri31;prod_op[0][1]=ri12;prod_op[1][1]=ri22;prod_op[2][1]=ri32;prod_op[0][2]=ri13;prod_op[1][2]=ri23;prod_op[2][2]=ri33;
//
//   }
//__finally {
Screen->Cursor=Save_Cursor;
//}
//
}
//---------------------------------------------------------------------------
void TForm1::FDrotate_axisplot(int transpose,float rangle[])
// Global NDF
{long i=0;float sumx=0.,sumy=0.,sumz=0.,cenx=0.,ceny=0.,cenz=0.,
  r11=0.,r12=0.,r13=0.,r21=0.,r22=0.,r23=0.,r31=0.,r32=0.,r33=0.,pix=4.*atan(1.)/180.;
 cenx=ceny=cenz=0.;
 r11=  cos(pix*rangle[1])*cos(pix*rangle[2]);
 r12= -cos(pix*rangle[1])*sin(pix*rangle[2]);r13=  sin(pix*rangle[1]);
 r21=  cos(pix*rangle[0])*sin(pix*rangle[2])+sin(pix*rangle[0])*sin(pix*rangle[1])*cos(pix*rangle[2]);
 r22=  cos(pix*rangle[0])*cos(pix*rangle[2])-sin(pix*rangle[0])*sin(pix*rangle[1])*sin(pix*rangle[2]);
 r23= -sin(pix*rangle[0])*cos(pix*rangle[1]);
 r31=  sin(pix*rangle[0])*sin(pix*rangle[2])-cos(pix*rangle[0])*sin(pix*rangle[1])*cos(pix*rangle[2]);
 r32=  sin(pix*rangle[0])*cos(pix*rangle[2])+cos(pix*rangle[0])*sin(pix*rangle[1])*sin(pix*rangle[2]);
 r33=  cos(pix*rangle[0])*cos(pix*rangle[1]);
 if(transpose){float temp=r12;r12=r21;r21=temp;temp=r13;r13=r31;r31=temp;temp=r23;r23=r32;r32=temp;}
 for(i=0;i<7;i++)
   {sumx=cenx+r11*ap.x[i]+r12*ap.y[i]+r13*ap.z[i];
	sumy=ceny+r21*ap.x[i]+r22*ap.y[i]+r23*ap.z[i];
	sumz=cenz+r31*ap.x[i]+r32*ap.y[i]+r33*ap.z[i];
	ap.x[i]=sumx;ap.y[i]=sumy;ap.z[i]=sumz;
   }
}
//---------------------------------------------------------------------------
void TForm1::FDrot_status(long indat_npoin,float indat_c1[],float rot_op[][3],long nDefects,float CrackCor[])
// Global NDF
{long i=0;float sumx=0.,sumy=0.,sumz=0.,cenx=0.,ceny=0.,cenz=0.,xmx= -1.E20,xmn=1.E20,ymx= -1.E20,ymn=1.E20,zmx= -1.E20,zmn=1.E20,r11=0.,r12=0.,r13=0.,r21=0.,r22=0.,r23=0.,r31=0.,r32=0.,r33=0.;
// GID-based code supplanted
// for(long i=0;i<indat_nelt;i++)
//  {eltype=indat_matno[i]/t7;
//	bscode=(indat_matno[i]-eltype*t7)/t5;
//	node=(indat_matno[i]-eltype*t7-bscode*t5)/t3;
//	ieGID=indat_matno[i]-eltype*t7-bscode*t5-node*t3;
//	FDcopy_nop(i,eltype,i_nop);
//	for(long in=0;in<node;in++)
//	  {sumx=sumx+indat_c1[i_nop[in]];sumy=sumy+indat_c2[i_nop[in]];sumz=sumz+indat_c3[i_nop[in]];
//	  }
//  }
 for(i=0;i<indat_npoin;i++)
   {if(xmx<indat_c1[NDF*i  ])xmx=indat_c1[NDF*i  ];if(xmn>indat_c1[NDF*i  ])xmn=indat_c1[NDF*i  ];
	if(ymx<indat_c1[NDF*i+1])ymx=indat_c1[NDF*i+1];if(ymn>indat_c1[NDF*i+1])ymn=indat_c1[NDF*i+1];
    if(zmx<indat_c1[NDF*i+2])zmx=indat_c1[NDF*i+2];if(zmn>indat_c1[NDF*i+2])zmn=indat_c1[NDF*i+2];
    }
 cenx=(xmx-xmn)/2.;ceny=(ymx-ymn)/2.;cenz=(zmx-zmn)/2.;
 r11=rot_op[0][0];r21=rot_op[1][0];r31=rot_op[2][0];r12=rot_op[0][1];r22=rot_op[1][1];r32=rot_op[2][1];r13=rot_op[0][2];r23=rot_op[1][2];r33=rot_op[2][2];
 for(i=0;i<indat_npoin;i++)
   {sumx=cenx+r11*(indat_c1[NDF*i]-cenx)+r12*(indat_c1[NDF*i+1]-ceny)+r13*(indat_c1[NDF*i+2]-cenz);
    sumy=ceny+r21*(indat_c1[NDF*i]-cenx)+r22*(indat_c1[NDF*i+1]-ceny)+r23*(indat_c1[NDF*i+2]-cenz);
    sumz=cenz+r31*(indat_c1[NDF*i]-cenx)+r32*(indat_c1[NDF*i+1]-ceny)+r33*(indat_c1[NDF*i+2]-cenz);
    indat_c1[NDF*i]=sumx;indat_c1[NDF*i+1]=sumy;indat_c1[NDF*i+2]=sumz;
   }
if(nDefects)
{for(long iq=0;iq<nDefects;iq++)
 {for(long ic=0;ic<3;ic++)
   {sumx=cenx+r11*(CrackCor[9*iq+3*ic+0]-cenx)+r12*(CrackCor[9*iq+3*ic+1]-ceny)+r13*(CrackCor[9*iq+3*ic+2]-cenz);
	sumy=ceny+r21*(CrackCor[9*iq+3*ic+0]-cenx)+r22*(CrackCor[9*iq+3*ic+1]-ceny)+r23*(CrackCor[9*iq+3*ic+2]-cenz);
	sumz=cenz+r31*(CrackCor[9*iq+3*ic+0]-cenx)+r32*(CrackCor[9*iq+3*ic+1]-ceny)+r33*(CrackCor[9*iq+3*ic+2]-cenz);
	CrackCor[9*iq+3*ic+0]=sumx;CrackCor[9*iq+3*ic+1]=sumy;CrackCor[9*iq+3*ic+2]=sumz;
   }
 }
}
}
//---------------------------------------------------------------------------
void TForm1::secthea_public()
// global everything
{int *edgFace1=NULL;long *arbFace1=NULL,*rbTem1=NULL;
 long in=0,inp=0;float dum=0.,x1=0.,y1=0.,z1=0.,x2=0.,y2=0.,z2=0.,x3=0.,y3=0.,z3=0.,cmin=0.,cmax=0.,cval=0.,det=0.,ang0=0.,ang1=0.,PRST=0.,TOL=0.001,pix=4.*atan(1.)/180.;
 if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
 if(section_frame==7)
   {isectsw=SectWedgeForm->sectionsel0;sectdval[0]=SectWedgeForm->Angle0;
	sectdval[1]=SectWedgeForm->Bngle0;sectdval[2]=SectWedgeForm->Cngle0;
	FDsect_base_indatw_mem(isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
	  base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
				 FDdynmem_manage(4,dum,dum,indat.npoin,dum,nColRes,dum,dum,dum,dum,dum,dum,dum,dum);
				}
	FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
	  indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
	nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
	try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
		 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
		 }
	catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
	FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
	FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//    FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
	if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
	if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();}
	else {iCircleplot=1;Invalidate();}
   }
 else if(section_frame==6)
// indat (screen) mesh nodes, with inbase cartesian geom
   {inp= -1+SectqsdForm->Angle1;
	if(inp>=0 && inp<indat.npoin)
	  {FD_PSTRN(inp,&PRST,sect_plane,indat.res1);isectsw=SectqsdForm->sectionsel0;
	   for(in=0;in<6;in++)sectdval[in]=0.;
	   sectdval[0]=indat.bc1[NDF*inp]*sect_plane[0]+indat.bc1[NDF*inp+1]*sect_plane[1]+indat.bc1[NDF*inp+2]*sect_plane[2];
	   SectqsdForm->setAngle0(sectdval[0]);SectqsdForm->setBngle1(sect_plane[0]);
	   SectqsdForm->setBngle2(sect_plane[1]);SectqsdForm->setBngle3(sect_plane[2]);SectqsdForm->setBngle4(PRST);
	   FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	   if(iplotflag)FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	   FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);
	   if(fl_feres){FDdynmem_manage(-4,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
					FDdynmem_manage(4,dum,dum,indat.npoin,dum,nColRes,dum,dum,dum,dum,dum,dum,dum,dum);
				   }
	   FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	   FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	   FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
       nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
	   try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
			arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
			}
	   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
	   FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
	   FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//       FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
	   if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
	   if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	   FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();}
	   else {iCircleplot=1;Invalidate();}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Inadmissable node number",L"Repeat",MB_OK);}
   }
 else if(section_frame==5)
   {x1=Sect1p2rForm->Bngle1;y1=Sect1p2rForm->Bngle2;z1=Sect1p2rForm->Bngle3;ang0=Sect1p2rForm->Angle0;ang1=Sect1p2rForm->Angle1;
	sect_plane[0]=cos(ang0*pix)*cos(ang1*pix);sect_plane[1]=sin(ang0*pix)*cos(ang1*pix);sect_plane[2]=sin(ang1*pix);
	isectsw=Sect1p2rForm->sectionsel0;for(in=0;in<6;in++)sectdval[in]=0.;sectdval[0]=x1*sect_plane[0]+y1*sect_plane[1]+z1*sect_plane[2];
	FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
				 FDdynmem_manage(4,dum,dum,indat.npoin,dum,nColRes,dum,dum,dum,dum,dum,dum,dum,dum);
				}
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
	nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
	try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
		 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
		 }
	catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
	FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
	FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//    FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
                         catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
	if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
	if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();}
	else {iCircleplot=1;Invalidate();}
   }
 else if(section_frame==4)
   {x1=Sect3ptForm->Bngle1;y1=Sect3ptForm->Bngle2;z1=Sect3ptForm->Bngle3;
	x2=Sect3ptForm->Bngle4;y2=Sect3ptForm->Bngle5;z2=Sect3ptForm->Bngle6;
	x3=Sect3ptForm->Bngle7;y3=Sect3ptForm->Bngle8;z3=Sect3ptForm->Bngle9;
	det=x1*(y2*z3-y3*z2)+y1*(z2*x3-z3*x2)+z1*(x2*y3-x3*y2);
	if(fabs(det)>TOL)
	  {sect_plane[0]= -(y2*z3-y3*z2+y3*z1-y1*z3+y1*z2-y2*z1)/det;
	   sect_plane[1]= -(z2*x3-z3*x2+z3*x1-z1*x3+z1*x2-z2*x1)/det;
	   sect_plane[2]= -(x2*y3-x3*y2+x3*y1-x1*y3+x1*y2-x2*y1)/det;
	   isectsw=Sect3ptForm->sectionsel0;for(in=0;in<6;in++)sectdval[in]=0.;
       sectdval[0]=x1*sect_plane[0]+y1*sect_plane[1]+z1*sect_plane[2];
       cmin=1.E20;cmax= -1.E20;
//       for(in=0;in<base.npoin;in++)
//         {cval=base.c1[NDF*in]*sect_plane[0]+base.c1[NDF*in+1]*sect_plane[1]+base.c1[NDF*in+2]*sect_plane[2];
//          if(cmin>cval)cmin=cval;if(cmax<cval)cmax=cval;
//         }
       for(in=0;in<indat.npoin;in++)
         {cval=indat.bc1[NDF*in]*sect_plane[0]+indat.bc1[NDF*in+1]*sect_plane[1]+indat.bc1[NDF*in+2]*sect_plane[2];
          if(cmin>cval)cmin=cval;if(cmax<cval)cmax=cval;
         }
       Sect3ptForm->setAngle1(cmin);Sect3ptForm->setAngle2(cmax);Sect3ptForm->setAngle0(sectdval[0]);
	   Sect3ptForm->Label1->Caption=FloatToStr(cmin);Sect3ptForm->Label2->Caption=FloatToStr(cmax);
	   FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
         base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
       if(iplotflag)FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
       FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);
       if(fl_feres){FDdynmem_manage(-4,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
					FDdynmem_manage(4,dum,dum,indat.npoin,dum,nColRes,dum,dum,dum,dum,dum,dum,dum,dum);
                   }
	   FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
         indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	   FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	   FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
       nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
	   try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
			arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
			}
	   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
	   FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
	   FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//       FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
	   if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
	   if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	   FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();}
	   else {iCircleplot=1;Invalidate();}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Points do not form a plane",L"Repeat",MB_OK);}
   }
 else
   {isectsw=SectionForm->sectionsel0;for(in=0;in<6;in++)sectdval[in]=0.;sectdval[section_frame-1]=SectionForm->Angle0;
	FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
				 FDdynmem_manage(4,dum,dum,indat.npoin,dum,nColRes,dum,dum,dum,dum,dum,dum,dum,dum);
				}
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
	nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
	try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
		 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
		 }
	catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
	FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
	FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//    FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
	if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
	if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
				 FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();}
	else {iCircleplot=1;Invalidate();}
   }
}
//---------------------------------------------------------------------------
void TForm1::secthea1_public()
// global everything
{int *edgFace1=NULL;long *arbFace1=NULL,*rbTem1=NULL;
 int ic=0;long in=0;float dummy=0.;sectmx=1.E20;sectmn= -1.E20;if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
 FDbase_indat(1,shapecombo,iplotflag,nColRes);
 FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
 if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			  FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			  FDbase_indat(2,shapecombo,iplotflag,nColRes);
//			  FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
			  nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
			  try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
				   arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
				   }
			  catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
			  FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
			  FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//              FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
			  if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
			  if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();
			 }
 else {
//       FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
	   nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
	   try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
			arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
			}
	   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
	   FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
	   FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//       FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
	   if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;iCircleplot=1;Invalidate();
	  }
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 section_frame=0;for(ic=0;ic<6;ic++)sectdval[ic]=0.;
 if(SectionForm){delete SectionForm;SectionForm=NULL;}if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
 if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;}if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
}
//---------------------------------------------------------------------------
void TForm1::secthea2_public()
// global everything
{long in=0,irmax=0,irmin=0,iswx=0,iswn=0;float dummy=0.,rmax= -1.E20,rmin=1.E20;
 if(fl_feres)
   {if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
	FDbase_indat(1,shapecombo,iplotflag,nColRes);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
	if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				}
	FDbase_indat(2,shapecombo,iplotflag,nColRes);
	if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);
// Try this to fix shifting max-min points
	iswx=iswn=0;
	for(in=0;in<indat.npoin;in++)
//    for(in=0;in<base.npoin;in++)
	  {if(rmax<indat.result[in]){if(sectmx>indat.result[in]){rmax=indat.result[in];irmax=in;iswx=1;}}
       if(rmin>indat.result[in]){if(sectmn<indat.result[in]){rmin=indat.result[in];irmin=in;iswn=1;}}
      }
	if(!iswx || !iswn)
	  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No node found-->Reset",L"Failed",MB_OK);
	   irmax=irmin=1;
	  }
	sectmx=rmax;sectmn=rmin;
	if(section_frame==7)
	  {isectsw=SectWedgeForm->sectionsel0;
	   if(abs(isectsw)>100)for(in=0;in<3;in++)sectdval[in]=indat.bc1[NDF*irmax+in];
	   else                for(in=0;in<3;in++)sectdval[in]=indat.bc1[NDF*irmin+in];
	   SectWedgeForm->setAngle0(sectdval[0]);SectWedgeForm->setBngle0(sectdval[1]);SectWedgeForm->setCngle0(sectdval[2]);
	  }
	else if(section_frame==6);
	else if(section_frame==5)
	  {isectsw=Sect1p2rForm->sectionsel0;
	   if(abs(isectsw)>100)sectdval[0]=indat.bc1[NDF*irmax]*sect_plane[0]+indat.bc1[NDF*irmax+1]*sect_plane[1]+indat.bc1[NDF*irmax+2]*sect_plane[2];
	   else                sectdval[0]=indat.bc1[NDF*irmin]*sect_plane[0]+indat.bc1[NDF*irmin+1]*sect_plane[1]+indat.bc1[NDF*irmin+2]*sect_plane[2];
	   Sect1p2rForm->setAngle0(sectdval[0]);
	  }
	else if(section_frame==4)
	  {isectsw=Sect3ptForm->sectionsel0;
	   if(abs(isectsw)>100)sectdval[0]=indat.bc1[NDF*irmax]*sect_plane[0]+indat.bc1[NDF*irmax+1]*sect_plane[1]+indat.bc1[NDF*irmax+2]*sect_plane[2];
	   else                sectdval[0]=indat.bc1[NDF*irmin]*sect_plane[0]+indat.bc1[NDF*irmin+1]*sect_plane[1]+indat.bc1[NDF*irmin+2]*sect_plane[2];
	   Sect3ptForm->setAngle0(sectdval[0]);
	  }
	else
	  {isectsw=SectionForm->sectionsel0;
	   if(abs(isectsw)>100)sectdval[section_frame-1]=indat.bc1[NDF*irmax+section_frame-1];
	   else                sectdval[section_frame-1]=indat.bc1[NDF*irmin+section_frame-1];
	   SectionForm->setAngle0(sectdval[section_frame-1]);
	  }
	secthea4();
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
void TForm1::secthea3_public()
// global everything
{long i=0;float xmx= -1.E20,xmn=1.E20,ymx= -1.E20,ymn=1.E20,zmx= -1.E20,zmn=1.E20,cval=0.;
 if(section_frame==6);
 else if(section_frame==4)
   {for(i=0;i<indat.npoin;i++)
      {cval=indat.bc1[NDF*i]*sect_plane[0]+indat.bc1[NDF*i+1]*sect_plane[1]+indat.bc1[NDF*i+2]*sect_plane[2];
	   if(xmn>cval)xmn=cval;if(xmx<cval)xmx=cval;
      }
    sectdval[3]=(xmx-xmn)/float(MAX_SECTIONSTEP);sectdval[0]=xmn-sectdval[3]/2.;
   }
 else
   {for(i=0;i<indat.npoin;i++)
     {if(xmx<indat.bc1[NDF*i  ])xmx=indat.bc1[NDF*i  ];if(xmn>indat.bc1[NDF*i  ])xmn=indat.bc1[NDF*i  ];
      if(ymx<indat.bc1[NDF*i+1])ymx=indat.bc1[NDF*i+1];if(ymn>indat.bc1[NDF*i+1])ymn=indat.bc1[NDF*i+1];
      if(zmx<indat.bc1[NDF*i+2])zmx=indat.bc1[NDF*i+2];if(zmn>indat.bc1[NDF*i+2])zmn=indat.bc1[NDF*i+2];
	 }
    sectdval[3]=(xmx-xmn)/float(MAX_SECTIONSTEP);sectdval[4]=(ymx-ymn)/float(MAX_SECTIONSTEP);
    sectdval[5]=(zmx-zmn)/float(MAX_SECTIONSTEP);
	sectdval[0]=xmn-sectdval[3]/2.;sectdval[1]=ymn-sectdval[4]/2.;sectdval[2]=zmx+sectdval[5]/2.;
   }
 iSpecRes=0;Timer4->Interval=TIMER_INTV;Timer4->Enabled=true;
}
//---------------------------------------------------------------------------
void TForm1::secthea4()
// global everything
// Used by SEARCH Max/Min (i.e. when plane info is known)
{int *edgFace1=NULL;long *arbFace1=NULL,*rbTem1=NULL;
 long in=0;float dummy=0.;if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
 if(section_frame==7)
   {FDsect_base_indatw_mem(isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
      base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
    if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
    FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
    if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                }
    FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
	  indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else if(section_frame==6);
 else if(section_frame==4 || section_frame==5)
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
         base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
    if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
    FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
    if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                }
    FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
         base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
    if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
    FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                }
    FDsect_base_indat(1,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
         indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
// FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
 nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
 try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
	  arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
	  }
 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
 FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
// FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
 if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();}
 else {iCircleplot=1;Invalidate();}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::SectheaGo(TObject *Sender) //Existence of model (base.nop1) should be checked in calling "timer start function"  EFP 3/22/2012
{int *edgFace1=NULL;long *arbFace1=NULL,*rbTem1=NULL;
 long in=0;float dummy=0.;if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
 if(section_frame==7)
   {sectdval[0]=sectdval[0]+sectdval[3];SectWedgeForm->setAngle0( -sectdval[0]);
	sectdval[1]=sectdval[1]+sectdval[4];SectWedgeForm->setBngle0( -sectdval[1]);
	sectdval[2]=sectdval[2]-sectdval[5];SectWedgeForm->setCngle0( -sectdval[2]);
	FDsect_base_indatw_mem(isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
	  base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				}
	FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
	  indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else if(section_frame==6);
 else if(section_frame==5)
	  {sectdval[0]=sectdval[0]+sectdval[3];Sect1p2rForm->setAngle0(sectdval[0]);
	   FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	   if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	   FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	   if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
					FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				   }
	   FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	  }
 else if(section_frame==4)
	  {sectdval[0]=sectdval[0]+sectdval[3];Sect3ptForm->setAngle0(sectdval[0]);
       FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
         base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	   if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	   FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
       if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                    FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				   }
	   FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
         indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
      }
 else {sectdval[section_frame-1]=sectdval[section_frame-1]+sectdval[section_frame+2];
       SectionForm->setAngle0(sectdval[section_frame-1]);
       FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
         base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
       if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	   FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
       if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                    FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
                   }
       FDsect_base_indat(1,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
         indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
      }
 FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
// FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

// Minimize "blank screen" time by preprocessing
 nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
 try {
///////
//if(arbFacet){delete [] arbFacet; *arbFacet=NULL;}if(rbTemp){delete [] rbTemp; *rbTemp=NULL;}
//if(edgFacet){delete [] edgFacet; *edgFacet=NULL;}if(mutFacet){delete [] mutFacet; *mutFacet=NULL;}
///////
	  arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
	  }
 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
 FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
// FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
 if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
 if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
 FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();}
 else {iCircleplot=1;Invalidate();}
//
 iSpecRes++;if(iSpecRes==MAX_SECTIONSTEP){iSpecRes=0;Timer4->Enabled=false;}
}
//---------------------------------------------------------------------------
void TForm1::defshapehea_public(){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////

								  shapecombo=ShapeForm->Angle0;FDrestore();}
//---Reset------------------------------------------------------------------
void TForm1::defshapehea1_public(){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////

								   shapecombo=0.;FDrestore();ShapeForm->setAngle0(shapecombo);}
//---------------------------------------------------------------------------
void TForm1::res_scalehea_public()
//{long ic=0;resscale=ScaleForm->Angle0;for(ic=0;ic<nColRes*base.npoin;ic++)base.res1[ic]=resscale*base.res1[ic];
{long ic=0;resscale=ScaleForm->Angle0;for(ic=0;ic<nColRes*base.npoin;ic++)base.res1[ic]=resscale*base.res1[ic];
 FDbase_indat(2,shapecombo,iplotflag,nColRes);
 if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
 FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);
 CmContour();
}
//---Reset------------------------------------------------------------------
void TForm1::res_scalehea1_public(){resscale=1.;ScaleForm->setAngle0(resscale);
									extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported-> reopen result file",L"Halt",MB_OK);return;
								   }
//---------------------------------------------------------------------------
void __fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button,TShiftState Shift, int X, int Y)
{enum TMouseButton { mbLeft, mbRight, mbMiddle };
// long NodeNum=0,ie=0,iside=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
// float rv=0.,xave=0.,yave=0.,zave=0.,xnor=0.,ynor=0.,znor=0.,rave=0.,RN1=0.,RN2=0.,RN3=0.;
////////////////////////////////////////////
 int CRB=0,
//////////
CRBsection=0,// Coding for FEMAP users EFP 12/20/2010
//////////
iPers=iPersistVFT/100,jPers=(iPersistVFT-100*iPers)/10,
// TB1H=0,P1W=0,
 CCB=0,CRB_sel=0,CRB_selx=0,CRB_ckShape=0,circFlag=0,girthFlag=0;
// int ip=0,ipp=0,ippp=0,signp=0,signm=0,isw=0; // unsigned long prod=1,aflag=0;
 long ip=0,ipp=0,ippp=0,signp=0,signm=0,isw=0,nipismin=0,nipismax=0,curiside=0,dumrec=0; // unsigned long prod=1,aflag=0;
////////////
long ik=0,ic=0,iss=0,ies=0,isides=0;//Coding for FEMAP users EFP 12/20/2010
///////////
 long NodeNum=0,ie=0,
// iGID=0,
 iside=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,eltype5=0,bscode5=0,node5=0,ieGID5=0,
   is=0,in=0,ir=0,ipx=0,nGIDmax=nGID,
//   GIDspac=1+(nGIDmax-1)/16,
   saflag[(MAX_GID+1)/16],
//   prod=1,aflag=0,
   numdum=0,eltype1=0,bscode1=0,node1=0,ieGID1=0,ip1=0,is1=0,iside1=0,
   //in1=0,
   ie1=0,ilat=0,icount=0,icount3=0,icount3a=0,icount3b=0,eltype2=0,bscode2=0,node2=0,ieGID2=0,
   inw=0,isw3=0,ie2=0,in3=0,ipp3=0,ie3=0,ipp3a=0,in3a=0,eltype3=0,bscode3=0,node3=0,ieGID3=0,
//   count_curr_sttEl=0,GIDwp=0,
   *dumarr=NULL,*dumactive=NULL,*dummap=NULL,*duminv=NULL
//   ,*dumsw=NULL
   ,*dumgrp=NULL;
 float rv=0.,xave=0.,yave=0.,zave=0.,xnor=0.,ynor=0.,znor=0.,rave=0.,zero=0.,dx1=0.,dy1=0.,dx3=0.,dy3=0.,norm=0.,RN1=0.,RN2=0.,RN3=0.,
	   DJD=0.,HN[9],SN[20],SG[60],DJR[9+1],xc=0.,yc=0.,zc=0.,xnor1=0.,ynor1=0.,znor1=0.,dist=0.,areafac=0.;
//                            11: Pivot freehand rotate (timer-based, right mouse button)
//                              & Pan (timer-based, left mouse button)
//                            13: ZoomInContinuous (timer-based, left mouse button BUT SHOULD BE MOUSEWHEEL)
//                            16: MaskElem0
///////////// New VFT coding ////////////////////////////////
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7},
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7},
	 opp_arr8[6]={2,3,0,1,5,4};//TBD: Add vertplot[15] coding
// char extensChar[]="Query Element ELSET= "; //EFP 10/03/2011
// char extensChar[]="Query Element ELSET= ",extensChar1[]=" + weld pass= "; //EFP 10/03/2011
// char extensChar[]="Query ELSET= ",extensChar1[]=" + WP= "; //EFP 10/03/2011
 char extensChar[]="Query ELSET= ",extensChar1[]="Weld Pass= ",extensChar2[]="Sequence# ",extensChar3[]=" of "; //EFP 10/03/2011
// String extensCharS=L"Query ELSET= ",extensCharS1=L"Weld Pass= "; //EFP 10/03/2011
 TPoint ptDraw[MAXPOINTS];

//Convention: CRB_sel=CreateLinWeldPass->CheckISEL
//  0-> Create full length
//  1-> Create partial length
//  2-> Edit full length
//  3-> Edit partial length
//  4-> Create full length from entire weld group section
////////////////////////////////////////////
 if(Button==mbLeft)
   {if(FD_LButtonstatus==1)
	  {if(QNode){delete QNode;QNode=NULL;}if(QElem){delete QElem;QElem=NULL;}if(QNDist){delete QNDist;QNDist=NULL;}
	   zoomDrag=true;zoomRect.left=zoomRect.right=X;zoomRect.top=zoomRect.bottom=Y;
	  }
	else if(FD_LButtonstatus==2) // Convert to FORTRAN format (ie. begin with 1)
	  {if(QElem){delete QElem;QElem=NULL;}if(QNDist){delete QNDist;QNDist=NULL;}
	   NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
//nnnnnnnnnn
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
//nnnnnnnnnn
	   if(iResSel+1)rv=indat.result[NodeNum];else rv=0.;
//	   if(!QNode){QNode=new TForm5(NodeNum+1,indat.bc1[NDF*NodeNum],indat.bc1[NDF*NodeNum+1],indat.bc1[NDF*NodeNum+2],iResSel+1,rv,this);QNode->Show();
	   if(!QNode){QNode=new TForm5(base.node_map[NodeNum]+1,indat.bc1[NDF*NodeNum],indat.bc1[NDF*NodeNum+1],indat.bc1[NDF*NodeNum+2],iResSel+1,rv,this);QNode->Show();
				 }
//	   else {QNode->setNodeQueryNum(NodeNum+1);
	   else {QNode->setNodeQueryNum(base.node_map[NodeNum]+1);
			 QNode->setNodeQueryXCor(indat.bc1[NDF*NodeNum  ]);
			 QNode->setNodeQueryYCor(indat.bc1[NDF*NodeNum+1]);QNode->setNodeQueryZCor(indat.bc1[NDF*NodeNum+2]);
			 QNode->setNodeQueryValue(iResSel+1,rv);
			}
	  }
	else if(FD_LButtonstatus==3) //This option must have active "Close" Button1  EFP 3/29/2012
// Convert to FORTRAN format (ie. begin with 1)
	  {if(QNode){delete QNode;QNode=NULL;}if(QNDist){delete QNDist;QNDist=NULL;}
	   FDelem_interrog1(X,Y,&ie,&iside,&RN1,&RN2,&RN3,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   if(ie>=0 && ie<base.nelt)
				{eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
//				 ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
				 FDelem_interrogpt1(ie,iside,eltype,node,RN1,RN2,RN3,&xave,&yave,&zave,&xnor,&ynor,&znor,&rave,&areafac,base.nop1,indat.nop1,base.c1,indat.result);
				 if(iResSel+1)rv=rave;else rv=0.;

honk<<ie<<" concise/origIE "<<base.el_map[ie]<<"\n";

////	ieGID=0;for(ipr=base.trackELSET[ie];ipr<base.trackELSET[ie+1];ipr++) //EFP 2/11/2012
////			  {ip=base.trackELSET[ie]+base.trackELSET[ie+1]-ipr-1;
////			   honk<<ie<<" "<<ip<<" "<<base.trackELSET[ie+1]<<" Tippui "<<base.arrELSET[ip]<<" "<<base.allGrp-wp.nWeldGroup-1<<"\n";
////			   if(base.arrELSET[ip]>base.allGrp-wp.nWeldGroup-1){ieGID=base.arrELSET[ip];break;}
////			  }
//				 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//				 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0){ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];isw=0;
//																	}
//				 else {ieGID1=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];
//					   ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//					   isw=1;
//					  }
ieGID1=ieGID=indat.arrELSET[ie];isw=0;


				 if(!QElem){QElem=new TForm6(base.el_map[ie]+1,iside+1,ieGID+1,xave,yave,zave,xnor,ynor,znor,iResSel+1,rv,this);
QElem->setFacetArea(areafac);
							QElem->Button1->Enabled=true;QElem->Button1->Visible=true; //EFP 3/29/2012
//if(ieGID==0)QElem->Caption="Query element: base metal";
//else if(ieGID<wp.nWeldGroup+1)
//	 {char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
//	  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
//	  StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
//	  QElem->Caption=fnNeed;delete [] fnNeed;
//	 }
//else {
//	  char *fnNeed=new char[strlen(wp.name[ieGID-wp.nWeldGroup-1].t_str())+strlen(extensChar)+1]; //Correction EFP 12/16/2011
//	  StringCchCopy(fnNeed,strlen(wp.name[ieGID-wp.nWeldGroup-1].t_str())+strlen(extensChar)+1,extensChar);
//	  StringCchCat(fnNeed,strlen(wp.name[ieGID-wp.nWeldGroup-1].t_str())+strlen(extensChar)+1,wp.name[ieGID-wp.nWeldGroup-1].t_str());
//	  QElem->Caption=fnNeed;delete [] fnNeed;
//	 }
if(ieGID==0){QElem->Label11->Enabled=false;QElem->Label11->Visible=false;
			 QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
			 QElem->Height=110;
			 QElem->Caption="Query element: base metal";
			}
else if(!isw){
			  char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
			  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
			  StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
			  QElem->Label11->Enabled=false;QElem->Label11->Visible=false;
			  QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
			  QElem->Height=110;
			  QElem->Caption=fnNeed;delete [] fnNeed;//Should add *fnNeed=NULL; ???
			 }
else {
//	  char *fnNeed=new char[strlen(wp.name[ieGID-base.allGrp].t_str())+strlen(extensChar)+1]; //Correction EFP 12/16/2011
//	  StringCchCopy(fnNeed,strlen(wp.name[ieGID-base.allGrp].t_str())+strlen(extensChar)+1,extensChar);
//	  StringCchCat(fnNeed,strlen(wp.name[ieGID-base.allGrp].t_str())+strlen(extensChar)+1,wp.name[ieGID-base.allGrp].t_str());
//	  QElem->Caption=fnNeed;delete [] fnNeed;
////	  char *fnNeed=new char[strlen(extensChar)+strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar1)+strlen(wp.name[ieGID-base.allGrp].t_str())+1]; //Correction EFP 12/16/2011
////	  StringCchCopy(fnNeed,strlen(extensChar)+strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar1)+strlen(wp.name[ieGID-base.allGrp].t_str())+1,extensChar);
////	  StringCchCat(fnNeed,strlen(extensChar)+strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar1)+strlen(wp.name[ieGID-base.allGrp].t_str())+1,base.groupsname[ieGID-1].t_str());
////	  StringCchCat(fnNeed,strlen(extensChar)+strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar1)+strlen(wp.name[ieGID-base.allGrp].t_str())+1,extensChar1);
////	  StringCchCat(fnNeed,strlen(extensChar)+strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar1)+strlen(wp.name[ieGID-base.allGrp].t_str())+1,wp.name[ieGID-base.allGrp].t_str());
////	  QElem->Caption=fnNeed;delete [] fnNeed;

			  char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
			  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
			  StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
			  QElem->Caption=fnNeed;delete [] fnNeed;
//			  String *fnNees=new String[base.groupsname[ieGID-1].Length()+extensCharS.Length()+1];
//			  StringCchCopyW(fnNees.w_str(),base.groupsname[ieGID-1].Length()+extensCharS.Length()+1,extensCharS.w_str());
//			  StringCchCatW(fnNees.w_str(),base.groupsname[ieGID-1].Length()+extensCharS.Length()+1,base.groupsname[ieGID-1].w_str());
//			  QElem->Caption=fnNees;delete [] fnNees;
	  QElem->Label11->Enabled=true;QElem->Label11->Visible=true;
	  char *fnNeed1=new char[strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1]; //Correction EFP 12/16/2011
	  StringCchCopy(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,extensChar1);
	  StringCchCat(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,wp.name[ieGID1-base.allGrp].t_str());
	  QElem->Label11->Caption=fnNeed1;delete [] fnNeed1;
//
	  QElem->Label12->Enabled=true;QElem->Label12->Visible=true;
	  char *fnNeed2=new char[strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1]; //EFP 3/29/2012
	  StringCchCopy(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar2);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str());
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar3);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.nWeldPass)).t_str());
	  QElem->Label12->Caption=fnNeed2;delete [] fnNeed2;
//
	  QElem->Height=130;
	 }


//////QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
//////QElem->Label13->Enabled=false;QElem->Label13->Visible=false;
////QElem->Label12->Enabled=true;QElem->Label12->Visible=true;
////QElem->Label13->Enabled=true;QElem->Label13->Visible=true;
//honk<<ieGID1-base.allGrp<<" "<<wp.seqNum[ieGID1-base.allGrp]<<" NNNNmmmmmmmpppppp\n";
//QElem->Label12->Caption=IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).w_str();
//QElem->Label13->Caption=L" seq out of ";
//QElem->Label14->Caption=IntToStr(__int64(wp.nWeldPass)).w_str();
							QElem->Show();
						   }
				 else {QElem->setElemQueryNum(base.el_map[ie]+1);//Correction EFP 12/20/2010
					   QElem->setElemQuerySide(iside+1);QElem->setElemQueryGID(ieGID+1);QElem->setElemQueryXCor(xave);
					   QElem->setElemQueryYCor(yave);QElem->setElemQueryZCor(zave);QElem->setElemQueryNx(xnor);QElem->setElemQueryNy(ynor);
					   QElem->setElemQueryNz(znor);QElem->setElemQueryValue(iResSel+1,rv);
QElem->setFacetArea(areafac);
//if(ieGID==0)QElem->Caption="Query element: base metal";
//else if(ieGID<wp.nWeldGroup+1)
//	 {char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
//	  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
//	  StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
//	  QElem->Caption=fnNeed;delete [] fnNeed;
//	 }
//else {char *fnNeed=new char[strlen(wp.name[ieGID-wp.nWeldGroup-1].t_str())+strlen(extensChar)+1]; //Correction EFP 12/16/2011
//	  StringCchCopy(fnNeed,strlen(wp.name[ieGID-wp.nWeldGroup-1].t_str())+strlen(extensChar)+1,extensChar);
//	  StringCchCat(fnNeed,strlen(wp.name[ieGID-wp.nWeldGroup-1].t_str())+strlen(extensChar)+1,wp.name[ieGID-wp.nWeldGroup-1].t_str());
//	  QElem->Caption=fnNeed;delete [] fnNeed;
//	 }
if(ieGID==0){QElem->Label11->Enabled=false;QElem->Label11->Visible=false;
			 QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
			 QElem->Height=110;
			 QElem->Caption="Query element: base metal";
			}
else if(!isw){char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
			  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
			  StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
			  QElem->Label11->Enabled=false;QElem->Label11->Visible=false;
			  QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
			  QElem->Height=110;
			  QElem->Caption=fnNeed;delete [] fnNeed;
			 }
else {
//			  char *fnNeed=new char[strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar)+1];
//			  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar)+1,extensChar);
//			  StringCchCat(fnNeed,strlen(base.groupsname[ieGID1-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID1-1].t_str());
//			  QElem->Caption=fnNeed;delete [] fnNeed;
//	  QElem->Label11->Enabled=true;QElem->Label11->Visible=true;
//	  char *fnNeed1=new char[strlen(wp.name[ieGID-base.allGrp].t_str())+strlen(extensChar1)+1]; //Correction EFP 12/16/2011
//	  StringCchCopy(fnNeed1,strlen(wp.name[ieGID-base.allGrp].t_str())+strlen(extensChar1)+1,extensChar1);
//	  StringCchCat(fnNeed1,strlen(wp.name[ieGID-base.allGrp].t_str())+strlen(extensChar1)+1,wp.name[ieGID-base.allGrp].t_str());
//	  QElem->Label11->Caption=fnNeed1;delete [] fnNeed1;
//	  QElem->Height=130;

			  char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
			  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
			  StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
			  QElem->Caption=fnNeed;delete [] fnNeed;
//			  String *fnNees=new String[base.groupsname[ieGID-1].Length()+extensCharS.Length()+1];
//			  StringCchCopyW(fnNees,base.groupsname[ieGID-1].Length()+extensCharS.Length()+1,extensCharS);
//			  StringCchCatW(fnNees,base.groupsname[ieGID-1].Length()+extensCharS.Length()+1,base.groupsname[ieGID-1]);
//			  QElem->Caption=fnNees;delete [] fnNees;
	  QElem->Label11->Enabled=true;QElem->Label11->Visible=true;
	  char *fnNeed1=new char[strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1]; //Correction EFP 12/16/2011
	  StringCchCopy(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,extensChar1);
	  StringCchCat(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,wp.name[ieGID1-base.allGrp].t_str());
	  QElem->Label11->Caption=fnNeed1;delete [] fnNeed1;
//
	  QElem->Label12->Enabled=true;QElem->Label12->Visible=true;
	  char *fnNeed2=new char[strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1]; //EFP 3/29/2012
	  StringCchCopy(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar2);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str());
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar3);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.nWeldPass)).t_str());
	  QElem->Label12->Caption=fnNeed2;delete [] fnNeed2;
//
	  QElem->Height=130;
	 }


					  }
				}
	   else {if(!QElem){QElem=new TForm6(0,0,0,zero,zero,zero,zero,zero,zero,iResSel+1,rv,this);
QElem->setFacetArea(zero);
						QElem->Button1->Enabled=true;QElem->Button1->Visible=true; //EFP 3/29/2012
//QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
//QElem->Label13->Enabled=false;QElem->Label13->Visible=false;
QElem->Label11->Enabled=false;QElem->Label11->Visible=false;
QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
						QElem->Caption="Query element: Click again";
						QElem->Show();
					   }
			 else {QElem->setElemQueryNum(0);//Correction EFP 12/20/2010
				   QElem->setElemQuerySide(0);QElem->setElemQueryGID(0);QElem->setElemQueryXCor(zero);
				   QElem->setElemQueryYCor(zero);QElem->setElemQueryZCor(zero);QElem->setElemQueryNx(zero);QElem->setElemQueryNy(zero);
				   QElem->setElemQueryNz(zero);QElem->setElemQueryValue(iResSel+1,rv);
QElem->setFacetArea(zero);
//QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
//QElem->Label13->Enabled=false;QElem->Label13->Visible=false;
QElem->Label11->Enabled=false;QElem->Label11->Visible=false;
QElem->Label12->Enabled=false;QElem->Label12->Visible=false;
				   QElem->Caption="Query element: Click again";
				  }
			}

	  }
////	else if(FD_LButtonstatus==4)
	else if(FD_LButtonstatus==21)
// Convert to FORTRAN format (ie. begin with 1)
	  {if(qndNodeNum1> -1)
		 {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
//nnnnnnnnnn
		  Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
		  Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
//nnnnnnnnnn
		  rave=sqrt((indat.bc1[NDF*NodeNum  ]-indat.bc1[NDF*qndNodeNum1  ])*(indat.bc1[NDF*NodeNum  ]-indat.bc1[NDF*qndNodeNum1  ])+
					(indat.bc1[NDF*NodeNum+1]-indat.bc1[NDF*qndNodeNum1+1])*(indat.bc1[NDF*NodeNum+1]-indat.bc1[NDF*qndNodeNum1+1])+
					(indat.bc1[NDF*NodeNum+2]-indat.bc1[NDF*qndNodeNum1+2])*(indat.bc1[NDF*NodeNum+2]-indat.bc1[NDF*qndNodeNum1+2]));
//		  QNDist->setQNDnodeN(2,NodeNum+1);
		  QNDist->setQNDnodeN(2,base.node_map[NodeNum]+1);
		  QNDist->setQNDnodeXYZD(4,indat.bc1[NDF*NodeNum  ]);
		  QNDist->setQNDnodeXYZD(5,indat.bc1[NDF*NodeNum+1]);QNDist->setQNDnodeXYZD(6,indat.bc1[NDF*NodeNum+2]);
		  QNDist->setQNDnodeXYZD(10,rave);
		  if(rave>0.000001){RN1=(indat.bc1[NDF*NodeNum  ]-indat.bc1[NDF*qndNodeNum1  ])/rave;if(RN1<0.001 && RN1> -0.001)RN1=0.;
							RN2=(indat.bc1[NDF*NodeNum+1]-indat.bc1[NDF*qndNodeNum1+1])/rave;if(RN2<0.001 && RN2> -0.001)RN2=0.;
							RN3=(indat.bc1[NDF*NodeNum+2]-indat.bc1[NDF*qndNodeNum1+2])/rave;if(RN3<0.001 && RN3> -0.001)RN3=0.;
							QNDist->setQNDnodeXYZD(7,RN1);QNDist->setQNDnodeXYZD(8,RN2);QNDist->setQNDnodeXYZD(9,RN3);
						   }
		  qndNodeNum1= -1;
		 }
	   else
		 {if(QNode){delete QNode;QNode=NULL;}if(QElem){delete QElem;QElem=NULL;}
		  NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
//nnnnnnnnnn
		  Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
		  Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
//nnnnnnnnnn
//		  qndNodeNum1=NodeNum;if(!QNDist){QNDist=new TForm15(this);QNDist->Show();}
		  qndNodeNum1=NodeNum;if(!QNDist){QNDist=new TForm24(this);QNDist->Caption="Query nodal distance";
										  QNDist->Label1->Caption="N#1";QNDist->Edit1->Text="***";
										  QNDist->Label2->Caption="X";QNDist->Label3->Caption="Y";QNDist->Label4->Caption="Z";
										  QNDist->Edit2->Text="***";QNDist->Edit3->Text="***";QNDist->Edit4->Text="***";
										  QNDist->Label5->Caption="N#2";QNDist->Edit5->Text="***";
										  QNDist->Label6->Caption="X";QNDist->Label7->Caption="Y";QNDist->Label8->Caption="Z";
										  QNDist->Edit6->Text="***";QNDist->Edit7->Text="***";QNDist->Edit8->Text="***";
										  QNDist->Label9->Caption="Dist";QNDist->Edit9->Text="***";
										  QNDist->Label10->Caption="DirX";QNDist->Label11->Caption="DirY";QNDist->Label12->Caption="DirZ";
										  QNDist->Edit10->Text="***";QNDist->Edit11->Text="***";QNDist->Edit12->Text="***";
										  QNDist->Button1->Caption="Close";QNDist->Color=clRed;QNDist->Show();
										 }
//		  QNDist->setQNDnodeN(1,NodeNum+1);
		  QNDist->setQNDnodeN(1,base.node_map[NodeNum]+1);
		  QNDist->setQNDnodeXYZD(1,indat.bc1[NDF*NodeNum  ]);
		  QNDist->setQNDnodeXYZD(2,indat.bc1[NDF*NodeNum+1]);QNDist->setQNDnodeXYZD(3,indat.bc1[NDF*NodeNum+2]);
		  QNDist->setQNDnodeN(-2,base.node_map[NodeNum]+1);
		  QNDist->setQNDnodeXYZD(-4,rv);QNDist->setQNDnodeXYZD(-5,rv);
		  QNDist->setQNDnodeXYZD(-6,rv);QNDist->setQNDnodeXYZD(-7,rv);QNDist->setQNDnodeXYZD(-8,rv);
		  QNDist->setQNDnodeXYZD(-9,rv);QNDist->setQNDnodeXYZD(-10,rv);
		 }
	  }
/////////////////////////// Reuse zoomRect.etc
//////	else if(FD_LButtonstatus==5){zoomRect.left=zoomRect.right=X;zoomRect.top=zoomRect.bottom=Y;}
//	else if(FD_LButtonstatus==8){zoomRect.left=zoomRect.right=X;zoomRect.top=zoomRect.bottom=Y;}// Changed from 5-.8 to match VFTgen
///////////////////////////
//    else if(FD_LButtonstatus==9);
	else if(FD_LButtonstatus==10){if(ANLINcount<ANNOT_CHAR){AnLINIndex[4*ANLINcount]=X;AnLINIndex[4*ANLINcount+1]=Y;}}


/*
	else if(FD_LButtonstatus==4){if(polypts==0){polycord[0]=X;polycord[1]=ClientHeight-Y;polypts++;Canvas->MoveTo(X,Y);}}
	else if(FD_LButtonstatus==5){if(polypts==0){polycord[0]=X;polycord[1]=ClientHeight-Y;polypts++;Canvas->MoveTo(X,Y);}}
	else if(FD_LButtonstatus==6 || FD_LButtonstatus==7 || FD_LButtonstatus==16){if(polypts==0){polycord[0]=X;polycord[1]=ClientHeight-Y;polypts++;Canvas->MoveTo(X,Y);}}
*/
	else if(FD_LButtonstatus==16){if(polypts==0){polycord[0]=X;polycord[1]=ClientHeight-Y;polypts++;Canvas->MoveTo(X,Y);}}
/////////////////////////// Reuse zoomRect.etc   FormMouse
	else if(FD_LButtonstatus==8){zoomRect.left=zoomRect.right=X;zoomRect.top=zoomRect.bottom=Y;}
	else if(FD_LButtonstatus==11){zoomRect.left=zoomRect.right=X;zoomRect.top=zoomRect.bottom=Y;
////								  stateVFT=2;iplotflag=2;Timer5->Interval=250;Timer5->Enabled=true;

								  stateVFT=2;iplotflag=2;Timer2->Interval=250;Timer2->Enabled=true;
//								  stateVFT=2;iplotflag=2;Timer2->Interval=10;Timer2->Enabled=true;

////                                  stateVFT=2;iplotflag=2;Timer5->Interval=1050;Timer5->Enabled=true;
								 }
//    else if(FD_LButtonstatus==11){stateVFT=3;Xpan0=X;Ypan0=Y;panMouseM=0;
//                                  iplotflag=2;iCullyesno=1;Timer5->Interval=250;Timer5->Enabled=true;
//                                 }
///////////////////////////
	else if(FD_LButtonstatus==13){iplotflag=2;iCullyesno=1;Timer2->Interval=250;Timer2->Enabled=true;}

//    else if(FD_LButtonstatus==13){iplotflag=2;iCullyesno=1;Timer5->Interval=1050;Timer5->Enabled=true;}
	else if(FD_LButtonstatus==22) //Pistol-shot weld direction changes  EFP 2/23/2012
	  {if(QNode){delete QNode;QNode=NULL;}if(QNDist){delete QNDist;QNDist=NULL;} //This option must have inactive "Close" Button1  EFP 3/29/2012
	   FDelem_interrog1(X,Y,&ie,&iside,&RN1,&RN2,&RN3,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   if(ie>=0 && ie<base.nelt)
				{eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
				 FDelem_interrogpt1(ie,iside,eltype,node,RN1,RN2,RN3,&xave,&yave,&zave,&xnor,&ynor,&znor,&rave,&areafac,base.nop1,indat.nop1,base.c1,indat.result);
				 if(iResSel+1)rv=rave;else rv=0.;
//				 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//				 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0){ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];isw=0;
//																	}
//				 else {ieGID1=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];
//					   ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];isw=1;
//					  }
ieGID1=ieGID=indat.arrELSET[ie];isw=1;

				 if(ieGID==0 || !isw){if(QElem){delete QElem;QElem=NULL;}
									  extern PACKAGE void __fastcall Beep(void);
									  Application->MessageBox(L"Left-click again to seek weldpass or right-click to quit",L"Weldpass not found",MB_OK);
									 }
				 else {if(!QElem){QElem=new TForm6(base.el_map[ie]+1,iside+1,ieGID+1,xave,yave,zave,xnor,ynor,znor,iResSel+1,rv,this);
								  QElem->Button1->Enabled=false;QElem->Button1->Visible=false;//EFP 3/29/2012
								  char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
								  StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
								  StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
								  QElem->Caption=fnNeed;delete [] fnNeed;
								  QElem->Label11->Enabled=true;QElem->Label11->Visible=true;
								  char *fnNeed1=new char[strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1]; //Correction EFP 12/16/2011
								  StringCchCopy(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,extensChar1);
								  StringCchCat(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,wp.name[ieGID1-base.allGrp].t_str());
								  QElem->Label11->Caption=fnNeed1;delete [] fnNeed1;
//
	  QElem->Label12->Enabled=true;QElem->Label12->Visible=true;
	  char *fnNeed2=new char[strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1]; //EFP 3/29/2012
	  StringCchCopy(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar2);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str());
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar3);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.nWeldPass)).t_str());
	  QElem->Label12->Caption=fnNeed2;delete [] fnNeed2;
//
								  QElem->Height=114;
//QElem->Label12->Enabled=true;QElem->Label12->Visible=true;
//QElem->Label13->Enabled=true;QElem->Label13->Visible=true;
//honk<<ieGID1-base.allGrp<<" "<<wp.seqNum[ieGID1-base.allGrp]<<" NNNNmmmmmmmpppppp\n";
//QElem->Label12->Caption=IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).w_str();
//QElem->Label13->Caption=L" seq out of ";
//QElem->Label14->Caption=IntToStr(__int64(wp.nWeldPass)).w_str();
								  QElem->Show();
								 }
					   else {QElem->setElemQueryNum(base.el_map[ie]+1);//Correction EFP 12/20/2010
							 QElem->setElemQuerySide(iside+1);QElem->setElemQueryGID(ieGID+1);QElem->setElemQueryXCor(xave);
							 QElem->setElemQueryYCor(yave);QElem->setElemQueryZCor(zave);QElem->setElemQueryNx(xnor);QElem->setElemQueryNy(ynor);
							 QElem->setElemQueryNz(znor);QElem->setElemQueryValue(iResSel+1,rv);
							 char *fnNeed=new char[strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1];
							 StringCchCopy(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,extensChar);
							 StringCchCat(fnNeed,strlen(base.groupsname[ieGID-1].t_str())+strlen(extensChar)+1,base.groupsname[ieGID-1].t_str());
							 QElem->Caption=fnNeed;delete [] fnNeed;
//							 QElem->Label11->Enabled=true;QElem->Label11->Visible=true;//Not necessary?
							 char *fnNeed1=new char[strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1]; //Correction EFP 12/16/2011
							 StringCchCopy(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,extensChar1);
							 StringCchCat(fnNeed1,strlen(wp.name[ieGID1-base.allGrp].t_str())+strlen(extensChar1)+1,wp.name[ieGID1-base.allGrp].t_str());
							 QElem->Label11->Caption=fnNeed1;delete [] fnNeed1;
//
//	  QElem->Label12->Enabled=true;QElem->Label12->Visible=true; //Not necesary???
	  char *fnNeed2=new char[strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1]; //EFP 3/29/2012
	  StringCchCopy(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar2);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str());
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,extensChar3);
	  StringCchCat(fnNeed2,strlen(extensChar2)+strlen(IntToStr(__int64(wp.seqNum[ieGID1-base.allGrp])).t_str())+
							 strlen(extensChar3)+strlen(IntToStr(__int64(wp.nWeldPass)).t_str())+1,IntToStr(__int64(wp.nWeldPass)).t_str());
	  QElem->Label12->Caption=fnNeed2;delete [] fnNeed2;
//
							 QElem->Height=114;
							}
///////////////////////////
					   iPersistVFT=iPersistVFT+10*(1-jPers); //reset[]= 10*sequence+direction, where seq starts with 1  EFP 3/28/2012
					   RevProg0(ieGID1-base.allGrp);ip=wp.reset[ieGID1-base.allGrp]-10*(wp.reset[ieGID1-base.allGrp]/10);
					   wp.reset[ieGID1-base.allGrp]=10*(wp.reset[ieGID1-base.allGrp]/10)+1-ip;
					   for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
													  wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
													  wp.util_arr[ir]=wp.util_arr[ir]+10; //Activate all
													 }
//	  ShowWP_hide->Checked=false;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=true;
					   Invalidate();
///////////////////////////
					  }

				}
	   else {if(QElem){delete QElem;QElem=NULL;}
			 extern PACKAGE void __fastcall Beep(void);
			 Application->MessageBox(L"Left-click again to seek weldpass or right-click to quit",L"Weldpass not found",MB_OK);
			}
	  }

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
	else if(FD_LButtonstatus==17)
// Convert to FORTRAN format (ie. begin with 1)
	  {FDelem_interrog1(X,Y,&ie,&iside,&RN1,&RN2,&RN3,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   if(ie>=0){eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
////				 ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
				 eltype3=base.orig_matno[ie]/t7;bscode3=(base.orig_matno[ie]-eltype3*t7)/t5;node3=(base.orig_matno[ie]-eltype3*t7-bscode3*t5)/t3;
////				 eltype3=indat.orig_matno[ie]/t7;bscode3=(indat.orig_matno[ie]-eltype3*t7)/t5;node3=(indat.orig_matno[ie]-eltype3*t7-bscode3*t5)/t3;
////				 ieGID3=base.orig_matno[ie]-eltype3*t7-bscode3*t5-node3*t3;

//////				 eltype5=base.matno[ie]/t7;bscode5=(base.matno[ie]-eltype5*t7)/t5;node5=(base.matno[ie]-eltype5*t7-bscode5*t5)/t3;ieGID5=base.matno[ie]-eltype5*t7-bscode5*t5-node5*t3;
////				 FDelem_interrogpt1(ie,iside,eltype,node,RN1,RN2,RN3,&xave,&yave,&zave,&xnor,&ynor,&znor,&rave,&areafac,base.nop1,indat.nop1,base.c1,indat.result);
////				 if(iResSel+1)rv=rave;else rv=0.;
////////////////////////////////////
//				 if(indat.trackELSET[ie]+1==indat.trackELSET[ie+1]){ieGID=ieGID3=0;} //Added EFP 2/09/2012
//				 else {
//					   if(wp.elStart !=ie){wp.pending=0;wp.elStart=ie;}
//					   if(indat.trackELSET[ie]+wp.pending+1==indat.trackELSET[ie+1]){
//ieGID=indat.arrELSET[indat.trackELSET[ie]+wp.pending];
//ieGID3=indat.orig_arrELSET[indat.trackELSET[ie]+wp.pending];
//extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"This element has no more weld groups",L"Notice",MB_OK);
//																				  }
//					   else {wp.pending=wp.pending+1;
//							 ieGID=indat.arrELSET[indat.trackELSET[ie]+wp.pending];
//							 ieGID3=indat.orig_arrELSET[indat.trackELSET[ie]+wp.pending];
//							}
//					  }
wp.pending=0;wp.elStart=ie;ieGID=ieGID3=indat.arrELSET[ie];

//honk<<ie<<" "<<iside<<" Arrival "<<wp.pending<<" "<<wp.elStart<<" "<<indat.trackELSET[ie]+wp.pending<<" "<<ieGID<<"\n";
honk<<ie<<" "<<iside<<" ArrivalURU "<<wp.pending<<" "<<wp.elStart<<" "<<ieGID3<<" "<<ieGID<<"\n";
				 if(eltype!=8 || eltype3!=8){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex element selected for weld pass processing",L"Terminate",MB_OK);exit(0);}
//////////////////////////////////
				}
	   if(CreateLinWeldPass)
				{
				if(CreateLinWeldPass->PageControl1->TabIndex==0)
				{CRB=CreateLinWeldPass->CheckRadioB;CCB=CreateLinWeldPass->CheckCheckB;
				 CRB_selx=CreateLinWeldPass->CheckISEL;
				 if(CRB_selx==1)     {CRB_sel=1;CRBsection=0;}
////				 else if(CRB_selx==2){CRB_sel=0;CRBsection=0;} //CRB_selx=4/5/6/7 are Edit
////				 else if(CRB_selx==3){CRB_sel=1;CRBsection=1;}    // EFP 9/22/2010  Note: CRB_sel=0 -> Full;1 -> Partial
				 else if(CRB_selx==2){CRB_sel=0;CRBsection=1;}    // EFP 12/21/2010  Note: CRBsection=0 ->User-selected width, 1->Entire section
				 else if(CRB_selx==3){CRB_sel=1;CRBsection=1;}
				 else if(CRB_selx==4){CRB_sel=0;CRBsection=0;}
				 else if(CRB_selx==5){CRB_sel=1;CRBsection=0;}
				 else if(CRB_selx==6){CRB_sel=0;CRBsection=1;}
				 else if(CRB_selx==7){CRB_sel=1;CRBsection=1;}
				 else                {CRB_sel=0;CRBsection=0;}
				 CRB_ckShape=CreateLinWeldPass->CheckShape; // 0=noncircular,1=fullcircle,2=partialcircle,3=fullgirth,4=partialgirth
				 circFlag=(wp.boolFlags[wp.PRECORD]-100*(wp.boolFlags[wp.PRECORD]/100))/10;
				 girthFlag=(wp.boolFlags[wp.PRECORD]-10000*(wp.boolFlags[wp.PRECORD]/100000))/10000;
				 if(CRB_ckShape==1 || CRB_ckShape==2){wp.boolFlags[wp.PRECORD]=wp.boolFlags[wp.PRECORD]+10*(1-circFlag);
													  circFlag=1;girthFlag=0;
													 }
				 else if(CRB_ckShape==3 || CRB_ckShape==4){wp.boolFlags[wp.PRECORD]=wp.boolFlags[wp.PRECORD]+10000*(1-girthFlag);
														   circFlag=0;girthFlag=1;
														  }

//honk<<CRB<<" CRB in FMDown "<<CRB_sel<<" "<<CRBsection<<" "<<node<<" "<<wp.count_curr_sttEl<<"\n";
				 if(CRB==1) // All Start Elements
				   {if(ieGID && (node==8 || node==20))
					  {
////////////////////////// EFP 2/09/2012
					   if(wp.count_curr_sttEl==0)
						 {wp.avis=10*(wp.avis/10); //EFP 6/26/2011 Set first col to zero
						  if(wp.CreateWPassMode)wp.GIDwp=10*ieGID3+iside; // The GID/iside of the first facet to be clicked becomes the definitive GID.
						  else wp.GIDwp=10*(1+wp.nWeldGroup+wp.PRECORD)+wp.temp_eles[wp.memWGa*wp.PRECORD+0]-10*(wp.temp_eles[wp.memWGa*wp.PRECORD+0]/10);
						 }
/////////
					   else if(!wp.CreateWPassMode){wp.count_curr_sttEl=0; // EFP 3/30/2012
													wp.GIDwp=10*(1+wp.nWeldGroup+wp.PRECORD)+wp.temp_eles[wp.memWGa*wp.PRECORD+0]-10*(wp.temp_eles[wp.memWGa*wp.PRECORD+0]/10);
												   }
/////////
///////// The following was introduced for VFTshell, so disconnect for VFTsolid  EFP 2/29/2012
//					   else {
////////////////////////// start Paint outline of weld group  EFP 9/01/2011
//if(wp.CreateWPassMode)
////{ir=base.orig_arrELSET[base.trackELSET[ie]+wp.pending-1]-8*(base.orig_arrELSET[base.trackELSET[ie]+wp.pending-1]/8);
//{ir=base.orig_arrELSET[base.trackELSET[ie]+wp.pending]-8*(base.orig_arrELSET[base.trackELSET[ie]+wp.pending]/8);
// if     (ir==0)Canvas->Pen->Color=clLtGray;else if(ir==1)Canvas->Pen->Color=clBlue;
// else if(ir==2)Canvas->Pen->Color=clGreen ;else if(ir==3)Canvas->Pen->Color=clLime;
// else if(ir==4)Canvas->Pen->Color=clNavy  ;else if(ir==5)Canvas->Pen->Color=clYellow;
// else if(ir==6)Canvas->Pen->Color=clOlive ;else Canvas->Pen->Color=clMaroon;
// Canvas->Pen->Width=1;
// for(ie1=0;ie1<base.nelt;ie1++)
//   {for(is1=base.trackELSET[ie1];is1<base.trackELSET[ie1+1];is1++)
////	  {if(base.orig_arrELSET[is1]==base.orig_arrELSET[base.trackELSET[ie]+wp.pending-1])
//	  {if(base.orig_arrELSET[is1]==base.orig_arrELSET[base.trackELSET[ie]+wp.pending])
//		 {Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]  ]+0.5),ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]+1]+0.5));
//		  for(ip1=1;ip1<4;ip1++)Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+ip1]  ]+0.5),ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+ip1]+1]+0.5));
//		 }
//	  }
//   }
//}
//else {
//// ir=base.arrELSET[base.trackELSET[ie]+wp.pending-1]-8*(base.arrELSET[base.trackELSET[ie]+wp.pending-1]/8);
// ir=base.arrELSET[base.trackELSET[ie]+wp.pending]-8*(base.arrELSET[base.trackELSET[ie]+wp.pending]/8);
// if     (ir==0)Canvas->Pen->Color=clLtGray;else if(ir==1)Canvas->Pen->Color=clBlue;
// else if(ir==2)Canvas->Pen->Color=clGreen ;else if(ir==3)Canvas->Pen->Color=clLime;
// else if(ir==4)Canvas->Pen->Color=clNavy  ;else if(ir==5)Canvas->Pen->Color=clYellow;
// else if(ir==6)Canvas->Pen->Color=clOlive ;else Canvas->Pen->Color=clMaroon;
// Canvas->Pen->Width=1;
// for(ie1=0;ie1<base.nelt;ie1++)
//   {for(is1=base.trackELSET[ie1];is1<base.trackELSET[ie1+1];is1++)
////	  {if(base.arrELSET[is1]==base.arrELSET[base.trackELSET[ie]+wp.pending-1])
//	  {if(base.arrELSET[is1]==base.arrELSET[base.trackELSET[ie]+wp.pending])
//		 {Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]  ]+0.5),ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]+1]+0.5));
//		  for(ip1=1;ip1<4;ip1++)Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+ip1]  ]+0.5),ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+ip1]+1]+0.5));
//		 }
//	  }
//   }
//	 }
//					   Canvas->Pen->Width=1;
//						  if(wp.CreateWPassMode)wp.GIDwp=10*ieGID3+iside; // The GID/iside of the first facet to be clicked becomes the definitive GID.
//						  else wp.GIDwp=10*(1+wp.nWeldGroup+wp.PRECORD)+wp.temp_eles[wp.memWGa*wp.PRECORD+0]-10*(wp.temp_eles[wp.memWGa*wp.PRECORD+0]/10);
//							 wp.count_curr_sttEl=0;
//							}
//////////////////////////
					   if((wp.CreateWPassMode && ieGID==wp.GIDwp/10) || //Remove iside check EFP 4/10/2011
						  (!wp.CreateWPassMode && (ieGID==wp.GIDwp/10 || ieGID==wp.prevGID[wp.PRECORD]))) //Revision: Generalize iside EFP 5/02/2010
										  {
//Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
		  ir=ieGID-9*(ieGID/9);
		  if     (ir==0)Canvas->Brush->Color=clRed;
		  else if(ir==1)Canvas->Brush->Color=clLtGray; // Coding for color contrast
		  else if(ir==2)Canvas->Brush->Color=clBlue;
		  else if(ir==3)Canvas->Brush->Color=clGreen;
		  else if(ir==4)Canvas->Brush->Color=clLime;
		  else if(ir==5)Canvas->Brush->Color=clNavy;
		  else if(ir==6)Canvas->Brush->Color=clYellow;
		  else if(ir==7)Canvas->Brush->Color=clOlive;
		  else          Canvas->Brush->Color=clMaroon;
		  if     (ir==0)Canvas->Pen->Color=clMaroon; // Coding for double color contrast
		  else if(ir==1)Canvas->Pen->Color=clRed;
		  else if(ir==2)Canvas->Pen->Color=clLtGray;
		  else if(ir==3)Canvas->Pen->Color=clBlue;
		  else if(ir==4)Canvas->Pen->Color=clGreen;
		  else if(ir==5)Canvas->Pen->Color=clLime;
		  else if(ir==6)Canvas->Pen->Color=clNavy;
		  else if(ir==7)Canvas->Pen->Color=clYellow;
		  else          Canvas->Pen->Color=clOlive;
		  Canvas->Pen->Width=4;
///////////////////////////////////
Canvas->Brush->Color=CreateLinWeldPass->CheckWeldColor;
Canvas->Pen->Color=clBlack;  //Source of our "All Black" problem ???
wp.WeldColor[wp.PRECORD]=CreateLinWeldPass->CheckWeldColor;

honk<<(long)wp.WeldColor[wp.PRECORD]<<" ChosenCOLOR\n";

for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]]+0.5);
					ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+1]+0.5);
				   }
Canvas->Polygon(ptDraw,4-1);
		  Canvas->Pen->Width=1;
										   if(wp.CreateWPassMode){ //Creating
										   isw=1;
										   if(wp.nWeldPass){for(ip=0;ip<wp.nWeldPass;ip++)
															  {for(in=0;in<wp.memWGa;in++)
																 {if(wp.eles[wp.memWGa*ip+in]>=0)
																	{if(wp.eles[wp.memWGa*ip+in]/10==ie)
{extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Element already in another weld pass",L"Ignore",MB_OK);isw=0;}
																	}
																  else break;
																 }
															  }
														   }
										   if(wp.count_curr_sttEl){for(in=0;in<wp.count_curr_sttEl;in++)
																	if(wp.sttEles[wp.memWGa*wp.nWeldPass+in]/10==ie)
{extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Duplicate element in weld pass",L"Ignore",MB_OK);isw=0;}
																  }
																 }
										   else {                         //Editing
										   isw=1;
										   if(wp.count_curr_sttEl){for(in=0;in<wp.count_curr_sttEl;in++)if(wp.sttEles[wp.memWGa*wp.PRECORD+in]/10==ie)
{extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Duplicate element in weld pass",L"Ignore",MB_OK);isw=0;}
																  }
												}
										   if(isw)
											 {wp.sttEles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl]=10*ie+iside;

honk<<wp.count_curr_sttEl<<" STARTelDetailsURU "<<ie<<" "<<iside<<" "<<wp.memWGa<<" "<<wp.PRECORD<<"\n";
											  for(ip=0;ip<4;ip++)wp.sttEleNodes[wp.memWGa*4*wp.PRECORD+4*wp.count_curr_sttEl+ip]=base.nop1[MXNPEL*ie+gdata8[4*iside+ip]];
											  wp.count_curr_sttEl=wp.count_curr_sttEl+1;
											 }
										  }
					   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not in current weld group or not current start face.",L"Ignore",MB_OK);}
					  }
					else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not hex-element or not in a weld group.",L"Ignore",MB_OK);}
				   }
				 else if(CRB==2)  // One Stop Element
				   {

//////////////////////
//if(!wp.CreateWPassMode){wp.count_curr_sttEl=wp.n_curr_sttEl[wp.PRECORD];CRB_sel=1;}
honk<<CRB<<" CRB in FMDown "<<CRB_sel<<" "<<CRBsection<<" "<<node<<" "<<wp.count_curr_sttEl<<"\n";
//////////////////////

					wp.pending=0;//EFP 9/01/2011  (Actually no longer needed because of wp.elStart below)
					wp.elStart= -1;//EFP 9/02/2011
///////////////////////////////// start EFP 4/17/2012
if(!wp.CreateWPassMode){
				 CRB_selx=CreateLinWeldPass->CheckFunction;
				 if(CRB_selx==1)     {CRB_sel=1;CRBsection=0;}
////				 else if(CRB_selx==2){CRB_sel=0;CRBsection=0;} //CRB_selx=4/5/6/7 are Edit
////				 else if(CRB_selx==3){CRB_sel=1;CRBsection=1;}    // EFP 9/22/2010  Note: CRB_sel=0 -> Full;1 -> Partial
				 else if(CRB_selx==2){CRB_sel=0;CRBsection=1;}    // EFP 12/21/2010  Note: CRBsection=0 ->User-selected width, 1->Entire section
				 else if(CRB_selx==3){CRB_sel=1;CRBsection=1;}
				 else if(CRB_selx==4){CRB_sel=0;CRBsection=0;}
				 else if(CRB_selx==5){CRB_sel=1;CRBsection=0;}
				 else if(CRB_selx==6){CRB_sel=0;CRBsection=1;}
				 else if(CRB_selx==7){CRB_sel=1;CRBsection=1;}
				 else                {CRB_sel=0;CRBsection=0;}
					   }
honk<<CRB_selx<<" "<<CRB_sel<<" "<<CRBsection<<" Values for EDIT\n";
///////////////////////////////// end
//					if((CRB_sel==0 || (CRB_sel==1 &&
//						 ((!wp.CreateWPassMode && ieGID3==wp.prevGID[wp.PRECORD]) ||
//						  (wp.CreateWPassMode && ieGID3==wp.GIDwp/10)))) &&  //EFP 11/23/2010
//					   (node==8 || node==20) && wp.count_curr_sttEl) //EFP 1/30/2011   Remember to test for start-stop coincidence...

////					if((CRB_sel==0 || (CRB_sel==1 &&
////						 ((!wp.CreateWPassMode) ||
////						  (wp.CreateWPassMode && ieGID3==wp.GIDwp/10)))) &&  //EFP 11/23/2010
////					   (node==8 || node==20) && wp.count_curr_sttEl) //EFP 1/30/2011   Remember to test for start-stop coincidence...

					if((CRB_sel==0 || (CRB_sel==1 &&
						 ((!wp.CreateWPassMode && ieGID3==wp.prevGID[wp.PRECORD]) ||
						  (wp.CreateWPassMode && ieGID3==wp.GIDwp/10)))) &&  //EFP 11/23/2010
					   (node==8 || node==20) && wp.count_curr_sttEl) //EFP 1/30/2011   Remember to test for start-stop coincidence...

// DIRE WARNING: When selecting a stop element in EDIT mode, the user must chose one in line with the chosen start elements.
// The software does not test for this currently.
					  {

TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
		  ir=ieGID-9*(ieGID/9);
		  if     (ir==0)Canvas->Brush->Color=clOlive; // Coding for triple color contrast
		  else if(ir==1)Canvas->Brush->Color=clMaroon;
		  else if(ir==2)Canvas->Brush->Color=clRed;
		  else if(ir==3)Canvas->Brush->Color=clLtGray;
		  else if(ir==4)Canvas->Brush->Color=clBlue;
		  else if(ir==5)Canvas->Brush->Color=clGreen;
		  else if(ir==6)Canvas->Brush->Color=clLime;
		  else if(ir==7)Canvas->Brush->Color=clNavy;
		  else          Canvas->Brush->Color=clYellow;
		  if     (ir==0)Canvas->Pen->Color=clMaroon; // Coding for double color contrast
		  else if(ir==1)Canvas->Pen->Color=clRed;
		  else if(ir==2)Canvas->Pen->Color=clLtGray;
		  else if(ir==3)Canvas->Pen->Color=clBlue;
		  else if(ir==4)Canvas->Pen->Color=clGreen;
		  else if(ir==5)Canvas->Pen->Color=clLime;
		  else if(ir==6)Canvas->Pen->Color=clNavy;
		  else if(ir==7)Canvas->Pen->Color=clYellow;
		  else          Canvas->Pen->Color=clOlive;
		  Canvas->Pen->Width=4;
xnor=ynor=znor=0.;
for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]]+0.5);
					ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+1]+0.5);
					xnor=xnor+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]  ];
					ynor=ynor+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+1];
					znor=znor+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+2];
				   }
xnor=xnor/4.;ynor=ynor/4.;znor=znor/4.;
Canvas->Polygon(ptDraw,4-1);
		  Canvas->Pen->Width=1;
					   wp.stpEle[wp.PRECORD]=10*ie+iside;

honk<<wp.stpEle[wp.PRECORD]<<" uruURU "<<wp.GIDwp<<"\n";
					   dumarr=new long[base.nelt];duminv=new long[base.nelt];dumgrp=new long[base.nelt];// Coding for FEMAP users EFP 12/20/2010
					   for(ip=0;ip<base.nelt;ip++)duminv[ip]= -1;
					   is=0;for(ip=0;ip<base.nelt;ip++){
//														eltype=base.matno[ip]/t7;bscode=(base.matno[ip]-eltype*t7)/t5;
//														node=(base.matno[ip]-eltype*t7-bscode*t5)/t3;
														eltype2=base.orig_matno[ip]/t7;bscode2=(base.orig_matno[ip]-eltype2*t7)/t5;
														node2=(base.orig_matno[ip]-eltype2*t7-bscode2*t5)/t3;

														eltype=indat.matno[ip]/t7;bscode=(indat.matno[ip]-eltype*t7)/t5;
														node=(indat.matno[ip]-eltype*t7-bscode*t5)/t3;
////														eltype2=indat.orig_matno[ip]/t7;bscode2=(indat.orig_matno[ip]-eltype2*t7)/t5;
////														node2=(indat.orig_matno[ip]-eltype2*t7-bscode2*t5)/t3;

														dumgrp[ip]=0;//EFP 8/11/2011
////														for(ipx=base.trackELSET[ip]+1;ipx<base.trackELSET[ip+1];ipx++)
////														  {ieGID= base.orig_arrELSET[ipx];//EFP 8/13/2011
////														   ieGID2=base.orig_arrELSET[ipx];
////														   if((wp.CreateWPassMode && ieGID==wp.GIDwp/10) ||
////															  (!wp.CreateWPassMode && wp.prevGID[wp.PRECORD]==ieGID2))dumgrp[ip]= -10;//EFP 8/11/2011
////														   if((wp.CreateWPassMode && wp.GIDwp/10 ==ieGID) ||
////															  (!wp.CreateWPassMode && wp.prevGID[wp.PRECORD]==ieGID2))
////															 {dumarr[is]=ip;duminv[ip]=is;is++;
////															  break;
////															 }
////														  }
//////														ipx=base.trackELSET[ip]+1; //VFTsolid only  EFP 3/05/2012
//////														ieGID= base.orig_arrELSET[ipx];//EFP 8/13/2011
//////														ieGID2=base.orig_arrELSET[ipx];
//////														if((wp.CreateWPassMode && ieGID==wp.GIDwp/10) ||
////// 														   (!wp.CreateWPassMode && wp.prevGID[wp.PRECORD]==ieGID2))dumgrp[ip]= -10;//EFP 8/11/2011
//////														if((wp.CreateWPassMode && wp.GIDwp/10 ==ieGID) ||
//////														   (!wp.CreateWPassMode && wp.prevGID[wp.PRECORD]==ieGID2))
//////														   {dumarr[is]=ip;duminv[ip]=is;is++;
//////															break;
//////														   }

//														if(indat.trackELSET[ip]+1<indat.trackELSET[ip+1]) //EFP 4/20/2012
//														  {ipx=indat.trackELSET[ip]+1;
//														   ieGID= indat.orig_arrELSET[ipx];//EFP 8/13/2011
//														   ieGID2=indat.orig_arrELSET[ipx];
//														   if((wp.CreateWPassMode && ieGID==wp.GIDwp/10 && indat.arrELSET[ipx+1]<0) ||
//															  (!wp.CreateWPassMode && wp.prevGID[wp.PRECORD]==ieGID2))
//															 {dumgrp[ip]= -10;dumarr[is]=ip;duminv[ip]=is;is++;
//															 }
//														  }

ieGID=ieGID2= base.arrELSET[ip];//EFP 8/13/2011
if((wp.CreateWPassMode && ieGID==wp.GIDwp/10) ||
  (!wp.CreateWPassMode && wp.prevGID[wp.PRECORD]==ieGID2))dumgrp[ip]= -10;//EFP 8/11/2011
if((wp.CreateWPassMode && wp.GIDwp/10 ==ieGID) ||
  (!wp.CreateWPassMode && wp.prevGID[wp.PRECORD]==ieGID2))
   {dumarr[is]=ip;duminv[ip]=is;is++;
//	break;
   }

													   } // dumarr Memory could be reduced here (nelt-->is)
///////////////// start EFP 5/08/2011
if(CRBsection)dumgrp[wp.sttEles[wp.memWGa*wp.PRECORD+0]/10]=wp.sttEles[wp.memWGa*wp.PRECORD+0]-10*(wp.sttEles[wp.memWGa*wp.PRECORD+0]/10)+1;
else {for(ip=0;ip<wp.count_curr_sttEl;ip++) //TBD: Integrity test needed
dumgrp[wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10]=wp.sttEles[wp.memWGa*wp.PRECORD+ip]-10*(wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10)+1;
	 }
///////////////// end
					   numdum=is;
					   for(ip=0;ip<numdum;ip++){eltype=base.orig_matno[dumarr[ip]]/t7;
if(eltype!=8){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex element found in candidate weld group",L"Terminate: Mesh must have hex in WG",MB_OK);exit(0);}
											   }
					   dummap=new long[6*numdum];

honk<<numdum<<" NUMDUMmmmmmmm\n";//if(1==1)exit(0);
/////////////// Test integrity of weld group mesh  EFP 3/23/2013
if(CRBsection && numdum != wp.count_curr_sttEl*(numdum/wp.count_curr_sttEl)){extern PACKAGE void __fastcall Beep(void);
	 Application->MessageBox(L"This full length/full section WG mesh does not have same #elements per slice",L"Fatal mesh defect",MB_OK);}
///////////////
					   for(ip=0;ip<6*numdum;ip++)dummap[ip]= -1;
					   for(ip=0;ip<numdum-1;ip++){for(is=0;is<6;is++) // Assumes contiguous nodal numbering
												   {if(dummap[6*ip+is]<0) //Search forward for facet coincidence by max/min opposite corners
													  {nipismin=min(base.nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],base.nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
													   nipismax=max(base.nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],base.nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
													   isw=0;
													   for(ip1=ip+1;ip1<numdum;ip1++){for(is1=0;is1<6;is1++)
																						if(dummap[6*ip1+is1]<0)
																						  {
///////////////// start EFP 1/28/2010
if((nipismin==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismin==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismin==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismin==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]) &&
   (nipismax==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismax==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismax==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismax==base.nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]))
  {dummap[6*ip+is]=10*dumarr[ip1]+is1;dummap[6*ip1+is1]=10*dumarr[ip]+is;isw=1;break;}
///////////////// end 1/28/2010
																						  }
																					  if(isw)break;
																					 }
													  }
												   }
												 }
for(ir=0;ir<numdum;ir++)
  {isw=0;
   for(ic=0;ic<numdum;ic++)
	 {ip=dumarr[ic];
	  if(dumgrp[ip]>0)
		{for(is=0;is<6;is++)
		   {if(is!=dumgrp[ip]-1 && is!=opp_arr8[dumgrp[ip]-1])
			  {if(dummap[6*ic+is]> -1)
				 {ies=dummap[6*ic+is]/10;isides=dummap[6*ic+is]-10*ies;
				  if(dumgrp[ies]< -6)
					{for(iss=0;iss<6;iss++)
					   {if(iss!=isides && iss!=opp_arr8[isides])
						  {icount=0;
						   for(ik=0;ik<4;ik++)
							 {
if(base.nop1[MXNPEL*ies+gdata8[4*iss+ik]]==base.nop1[MXNPEL*ip+gdata8[4*(dumgrp[ip]-1)+0]])icount++;
if(base.nop1[MXNPEL*ies+gdata8[4*iss+ik]]==base.nop1[MXNPEL*ip+gdata8[4*(dumgrp[ip]-1)+1]])icount++;
if(base.nop1[MXNPEL*ies+gdata8[4*iss+ik]]==base.nop1[MXNPEL*ip+gdata8[4*(dumgrp[ip]-1)+2]])icount++;
if(base.nop1[MXNPEL*ies+gdata8[4*iss+ik]]==base.nop1[MXNPEL*ip+gdata8[4*(dumgrp[ip]-1)+3]])icount++;
							 }
						   if(icount==2){dumgrp[ies]=iss+1;isw=1;break;}
						  }
					   }
					}
				 }
			  }
		   }
		 dumgrp[ip]= -dumgrp[ip];
		}
	 }
   if(isw==0)break;
  }
is=0;
for(ip=0;ip<base.nelt;ip++)
  {if(dumgrp[ip]<0 && dumgrp[ip]>= -6){
									   dumgrp[is]=10*ip-dumgrp[ip]-1;is++;
									  }
  }
for(ip=is;ip<base.nelt;ip++)dumgrp[ip]= -1;
if(CRBsection){wp.count_curr_sttEl=is;
			   for(ir=0;ir<wp.count_curr_sttEl;ir++)
				 {ik=dumgrp[ir]-10*(dumgrp[ir]/10);
				  wp.sttEles[wp.memWGa*wp.PRECORD+ir]=dumgrp[ir];
for(ip=0;ip<4;ip++)wp.sttEleNodes[wp.memWGa*4*wp.PRECORD+4*ir+ip]=base.nop1[MXNPEL*(dumgrp[ir]/10) +gdata8[4*ik+ip]];
				 }
			  }
					   if(CRB_sel){  //Partial weld. Assumption: All elements in weld group have same orientation/side numbering (Partial length weld ONLY. Fix this...)					   isw=0;
					   for(ipp=0;ipp<wp.count_curr_sttEl;ipp++)
						 {icount=0;is1=ip1=wp.sttEles[wp.memWGa*wp.PRECORD+ipp]/10; //ip1 correction EFP 1/05/2012
						  curiside=wp.sttEles[wp.memWGa*wp.PRECORD+ipp]-10*is1;icount++;
						  if(is1==wp.stpEle[wp.PRECORD]/10){isw=1;break;}
						  else {while(dummap[6*duminv[is1]+opp_arr8[curiside]]> -1)
									 {dumrec=dummap[6*duminv[is1]+opp_arr8[curiside]];
									  if(ip1==dumrec/10)break;
									  else {is1=dumrec/10;curiside=dumrec-10*(dumrec/10);icount++;
											if(is1==wp.stpEle[wp.PRECORD]/10){isw=1;break;}
										   }
									 }
							   }
						  if(isw==1)break;
						 }
					   ir=icount;icount=0;
					   for(ipp=0;ipp<wp.count_curr_sttEl;ipp++)
						 {wp.eles[wp.memWGa*wp.PRECORD+icount]=wp.sttEles[wp.memWGa*wp.PRECORD+ipp];icount++;
						  is1=wp.sttEles[wp.memWGa*wp.PRECORD+ipp]/10;
						  curiside=wp.sttEles[wp.memWGa*wp.PRECORD+ipp]-10*is1;
						  if(ir>1)
							{for(in=1;in<ir;in++)
							   {if(dummap[6*duminv[is1]+opp_arr8[curiside]]> -1)
								  {dumrec=dummap[6*duminv[is1]+opp_arr8[curiside]];
//honk<<icount<<" PARTlength "<<dumrec<<"\n";
								   wp.eles[wp.memWGa*wp.PRECORD+icount]=dumrec;icount++;
								   is1=dumrec/10;curiside=dumrec-10*(dumrec/10);
								  }
								else break;
							   }
							}
						 }
								  }
					   else { //Full length. Not necessary to have same element orientation here...
					   icount=0;
					   for(ipp=0;ipp<wp.count_curr_sttEl;ipp++)
						 {wp.eles[wp.memWGa*wp.PRECORD+icount]=wp.sttEles[wp.memWGa*wp.PRECORD+ipp];icount++;
						  is1=wp.sttEles[wp.memWGa*wp.PRECORD+ipp]/10;
						  curiside=wp.sttEles[wp.memWGa*wp.PRECORD+ipp]-10*is1;ip1=is1;

//honk<<ipp+1<<" "<<wp.count_curr_sttEl<<" sttRank & sttEL "<<wp.eles[wp.memWGa*wp.PRECORD+icount]<<" "<<icount<<"\n";
						  for(in=0;in<numdum;in++)
							{
//honk<<in+1<<" "<<numdum<<" "<<dummap[6*duminv[is1]+opp_arr8[curiside]]<<"\n";
							 if(dummap[6*duminv[is1]+opp_arr8[curiside]]> -1)
							   {dumrec=dummap[6*duminv[is1]+opp_arr8[curiside]];
								if(ip1==dumrec/10)break;
								else {wp.eles[wp.memWGa*wp.PRECORD+icount]=dumrec;
								   icount++;
								   is1=dumrec/10;
								   curiside=dumrec-10*(dumrec/10);
//honk<<wp.eles[wp.memWGa*wp.PRECORD+icount]<<" nextel "<<curiside<<"\n";
									 }
							   }
							 else break;
							}
						 }
							}
					   delete [] dumgrp;// Coding for FEMAP users    Moved EFP 5/05/2011
					   for(in=0;in<icount;in++)dumarr[in]=wp.eles[wp.memWGa*wp.PRECORD+in];
//////////////////////////////////////////// start EFP 1/31/2011
if(wp.CreateWPassMode){dist=0.;
					   for(in=0;in<wp.count_curr_sttEl;in++)
						 {for(ipp=0;ipp<icount/wp.count_curr_sttEl;ipp++){
wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*ipp+in]=dumarr[(icount/wp.count_curr_sttEl)*in+ipp];
ie1=dumarr[(icount/wp.count_curr_sttEl)*in+ipp]/10;eltype1=indat.matno[ie1]/t7;bscode1=(indat.matno[ie1]-eltype1*t7)/t5;
node1=(indat.matno[ie1]-eltype1*t7-bscode1*t5)/t3;
//////ieGID1=indat.matno[ie1]-eltype1*t7-bscode1*t5-node1*t3;
////ieGID1=base.arrELSET[base.trackELSET[ie1]+1];
//ieGID1=indat.arrELSET[indat.trackELSET[ie1]+1];
ieGID1=indat.arrELSET[ie1];

//indat.matno[ie1]=indat.matno[ie1]-ieGID1+wp.PRECORD+wp.nWeldGroup+1; //Now obsolete
//base.matno[ie1]=base.matno[ie1]-ieGID1+wp.PRECORD+wp.nWeldGroup+1; //Now obsolete

if(ieGID1<=wp.nWeldGroup)wp.prevGID[wp.PRECORD]=ieGID1; // This might not allow for repeated edits..... FIX THIS
arGID[wp.PRECORD+wp.nWeldGroup+1]=1; //Corrected EFP 11/12/2010
//////for(ipx=base.trackELSET[ie1]+1;ipx<base.trackELSET[ie1+1];ipx++)
//////  {if(ieGID1==base.orig_arrELSET[ipx])
//////	 {base.arrELSET[ipx]=wp.PRECORD+wp.nWeldGroup+1;break;
//////	 }
//////  }
////base.arrELSET[base.trackELSET[ie1]+2]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
////indat.arrELSET[indat.trackELSET[ie1]+2]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
//base.arrELSET[base.trackELSET[ie1]+1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
//indat.arrELSET[indat.trackELSET[ie1]+1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
base.arrELSET[ie1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
indat.arrELSET[ie1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012


//cccccccccccccccc start [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
xc=yc=zc=0.;iside1=dumarr[(icount/wp.count_curr_sttEl)*in+ipp]-10*ie1;
//honk<<in<<" "<<ipp<<" "<<ie1<<" "<<iside1<<" SCHN\n";
for(is1=0;is1<4;is1++){xc=xc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+0]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+0];
					   yc=yc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+1]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+1];
					   zc=zc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+2]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+2];
					  }
xc=xc/4.;yc=yc/4.;zc=zc/4.;dist=dist+sqrt(xc*xc+yc*yc+zc*zc);
//cccccccccccccccc end
																		 }
						 }
//cccccccccccccccc start [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
wp.lend[wp.PRECORD]=dist/float(wp.count_curr_sttEl);
//cccccccccccccccc end
					  }
else {
///////////////////////// start EFP 4/17/2012
					   for(in=0;in<wp.memWGa;in++){
if(wp.eles[wp.memWGa*wp.PRECORD+in]/10 >=0){
//base.arrELSET[base.trackELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]+2]= -1;
//indat.arrELSET[indat.trackELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]+2]= -1;
base.arrELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]= -1;
indat.arrELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]= -1;
////indat.matno[wp.eles[wp.memWGa*wp.PRECORD+in]/10]=
////   t3*(indat.matno[wp.eles[wp.memWGa*wp.PRECORD+in]/10]/t3)+wp.prevGID[wp.PRECORD]; //Now obsolete
////base.matno[wp.eles[wp.memWGa*wp.PRECORD+in]/10]=
////   t3*(base.matno[wp.eles[wp.memWGa*wp.PRECORD+in]/10]/t3)+wp.prevGID[wp.PRECORD]; //Now obsolete
										   }

////base.arrELSET[base.trackELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]+2]=wp.prevGID[wp.PRECORD];
////indat.arrELSET[indat.trackELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]+2]=wp.prevGID[wp.PRECORD];
//base.arrELSET[base.trackELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]+1]=wp.prevGID[wp.PRECORD];
//indat.arrELSET[indat.trackELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]+1]=wp.prevGID[wp.PRECORD];
base.arrELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]=wp.prevGID[wp.PRECORD];
indat.arrELSET[wp.eles[wp.memWGa*wp.PRECORD+in]/10]=wp.prevGID[wp.PRECORD];
												   wp.eles[wp.memWGa*wp.PRECORD+in]= -1;
												  }
///////////////////////// end
					   dist=0.;
					   for(in=0;in<wp.count_curr_sttEl;in++)
						 {for(ipp=0;ipp<icount/wp.count_curr_sttEl;ipp++){
wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*ipp+in]=dumarr[(icount/wp.count_curr_sttEl)*in+ipp];
ie1=dumarr[(icount/wp.count_curr_sttEl)*in+ipp]/10;eltype1=indat.matno[ie1]/t7;bscode1=(indat.matno[ie1]-eltype1*t7)/t5;
node1=(indat.matno[ie1]-eltype1*t7-bscode1*t5)/t3;
//ieGID1=indat.matno[ie1]-eltype1*t7-bscode1*t5-node1*t3;

//indat.matno[ie1]=indat.matno[ie1]-ieGID1+glWPRECORD+wp.nWeldGroup+1; //Special purpose coding
//base.matno[ie1]=base.matno[ie1]-ieGID1+glWPRECORD+wp.nWeldGroup+1; //Special purpose coding
////if(ieGID1<=wp.nWeldGroup)wp.prevGID[glWPRECORD]=ieGID1; // This might not allow for repeated edits..... FIX THIS
////arGID[glWPRECORD+wp.nWeldGroup+1]=1; //Corrected EFP 11/12/2010

/////////////// start EFP 1/29/2011 (Coding bypassed as simplification EFP 4/18/2012)
//if(wp.nWeldPass>1)
//  {for(inw=0;inw<wp.nWeldPass;inw++)
//	 {if(inw!=wp.PRECORD && wp.n_curr_sttEl[inw])
//						 {ie2=wp.eles[wp.memWGa*inw+0]/10;eltype2=indat.matno[ie2]/t7;bscode2=(indat.matno[ie2]-eltype2*t7)/t5;
//						  node2=(indat.matno[ie2]-eltype2*t7-bscode2*t5)/t3;ieGID2=indat.matno[ie2]-eltype2*t7-bscode2*t5-node2*t3;
//						  if(ieGID2==ieGID1){isw3=icount3=0;for(ik=0;ik<base.nelt;ik++){if(wp.eles[wp.memWGa*inw+ik]>=0)icount3++;else break;}
//											 for(in3=0;in3<wp.n_curr_sttEl[inw];in3++)
//											   {for(ipp3=0;ipp3<icount3/wp.n_curr_sttEl[inw];ipp3++)
//												  {ie3=wp.eles[wp.memWGa*inw+wp.n_curr_sttEl[inw]*ipp3+in3]/10;
//												   if(ie3==ie1){
//icount3b=0;
//for(ipp3a=0;ipp3a<icount3/wp.n_curr_sttEl[inw];ipp3a++)
//  {icount3a=0;
//   for(in3a=0;in3a<wp.n_curr_sttEl[inw];in3a++)
//	 {if(in3a!=in3){wp.eles[wp.memWGa*inw+(wp.n_curr_sttEl[inw]-1)*ipp3a+icount3a]=
//					wp.eles[wp.memWGa*inw+wp.n_curr_sttEl[inw]*ipp3a+in3a];
//					icount3a++;icount3b++;
//				   }
//	 }
//  }
//for(in3a=icount3b;in3a<base.nelt;in3a++)wp.eles[wp.memWGa*inw+in3a]= -1;
//icount3a=0;
//for(in3a=0;in3a<wp.n_curr_sttEl[inw];in3a++)if(in3a!=in3)
//											  {wp.sttEles[wp.memWGa*inw+icount3a]=wp.sttEles[wp.memWGa*inw+in3a];
//											   icount3a++;
//											  }
//wp.n_curr_sttEl[inw]=wp.n_curr_sttEl[inw]-1;isw3=1;break;
//															   }
//												  }
//												if(isw3)break;
//											   }
//											 if(!wp.n_curr_sttEl[inw]){extern PACKAGE void __fastcall Beep(void); // EFP 2/02/2011
//																	   Application->MessageBox(L"This action eliminates a weld pass.",L"Notice",MB_OK);
//																	  }
//											}
//						 }
//	 }
//  }
///////////////// end 1/29/2011

//indat.matno[ie1]=indat.matno[ie1]-ieGID1+wp.PRECORD+wp.nWeldGroup+1; //Now obsolete
//base.matno[ie1]=base.matno[ie1]-ieGID1+wp.PRECORD+wp.nWeldGroup+1; //Now obsolete

//////////// EFP 2/09/2012
//for(ipx=base.trackELSET[ie1]+1;ipx<base.trackELSET[ie1+1];ipx++) //EFP did not attend to Edit yet
//  {if(ieGID1==base.orig_arrELSET[ipx])
//	 {base.arrELSET[ipx]=wp.PRECORD+wp.nWeldGroup+1;break;
//	 }
//  }

////base.arrELSET[base.trackELSET[ie1]+2]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
////indat.arrELSET[indat.trackELSET[ie1]+2]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
//base.arrELSET[base.trackELSET[ie1]+1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
//indat.arrELSET[indat.trackELSET[ie1]+1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
base.arrELSET[ie1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
indat.arrELSET[ie1]=wp.PRECORD+wp.nWeldGroup+1; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012

//cccccccccccccccc start [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
xc=yc=zc=0.;iside1=dumarr[(icount/wp.count_curr_sttEl)*in+ipp]-10*ie1;
for(is1=0;is1<4;is1++){xc=xc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+0]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+0];
					   yc=yc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+1]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+1];
					   zc=zc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+2]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+2];
					  }
xc=xc/4.;yc=yc/4.;zc=zc/4.;dist=dist+sqrt(xc*xc+yc*yc+zc*zc);
//cccccccccccccccc end
//////////
//if(ieGID1==base.orig_arrELSET[base.trackELSET[ie1]+2])
//  base.arrELSET[base.trackELSET[ie1]+2]=wp.PRECORD+wp.nWeldGroup+1; //Edit??? VFTsolid only EFP 3/05/2012
																		 }
						 }
//cccccccccccccccc start [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
wp.lend[wp.PRECORD]=dist/float(wp.count_curr_sttEl);
//cccccccccccccccc end
	 }
					   wp.n_curr_sttEl[wp.PRECORD]=wp.count_curr_sttEl;
					   delete [] dummap;delete [] dumarr;delete [] duminv;

//vvvvvvvvvvvvvvvvv start Coding for circEles NODES  EFP 10/14/2010
// Ensure that icount is unchanged from above
if(circFlag || girthFlag)
  {xave=yave=zave=0.;
   for(in=0;in<wp.count_curr_sttEl;in++)
	 {is1=wp.eles[wp.memWGa*wp.PRECORD+in]/10;curiside=wp.eles[wp.memWGa*wp.PRECORD+in]-10*is1; //Assume 8n hex only
	  node=4;xnor1=ynor1=znor1=0.;
	  for(ip=0;ip<node;ip++)
		{xnor1=xnor1+base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]  ];
		 ynor1=ynor1+base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]+1];
		 znor1=znor1+base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]+2];
		}
	  xave=xave+xnor1/float(node);yave=yave+ynor1/float(node);zave=zave+znor1/float(node);
	 }
   xave=xave/float(wp.count_curr_sttEl);yave=yave/float(wp.count_curr_sttEl);zave=zave/float(wp.count_curr_sttEl);
   node=4;rave=1.e20;  //Assume 8n hex only
   for(in=0;in<wp.count_curr_sttEl;in++)
	 {is1=wp.eles[wp.memWGa*wp.PRECORD+in]/10;curiside=wp.eles[wp.memWGa*wp.PRECORD+in]-10*is1; //Assume 8n hex only
	  for(ip=0;ip<node;ip++)
		{rv=(xave-base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]  ])*(xave-base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]  ])+
			(yave-base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]+1])*(yave-base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]+1])+
			(zave-base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]+2])*(zave-base.c1[NDF*base.nop1[MXNPEL*is1+gdata8[4*curiside+ip]]+2]);//Correction xave->zave EFP 1/07/2011
		 if(rave>rv){rave=rv;ip1=in;ippp=ip;}
		}
	 }
   is1=wp.eles[wp.memWGa*wp.PRECORD+ip1]/10;curiside=wp.eles[wp.memWGa*wp.PRECORD+ip1]-10*is1; //Assume 8n hex only
   wp.circEles[3*wp.PRECORD+0]=base.nop1[MXNPEL*is1+gdata8[4*curiside+ippp]];
   if(CRB_sel) //Partial
	 {
	  ip=wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)/2)+ip1]/10;
	  wp.circEles[3*wp.PRECORD+1]=base.nop1[MXNPEL*ip +gdata8[4*curiside+ippp]];
	  ip=wp.eles[wp.memWGa*wp.PRECORD+icount-wp.count_curr_sttEl +ip1]/10;
	  wp.circEles[3*wp.PRECORD+2]=base.nop1[MXNPEL*ip +gdata8[4*opp_arr8[curiside]+ippp]]; //ippp not entirely accurate here
	 }
   else // Full
	 {
	  ip=wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)/3)+ip1]/10;
	  wp.circEles[3*wp.PRECORD+1]=base.nop1[MXNPEL*ip +gdata8[4*curiside+ippp]];
	  ip=wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*(2*(icount/wp.count_curr_sttEl)/3)+ip1]/10;
	  wp.circEles[3*wp.PRECORD+2]=base.nop1[MXNPEL*ip +gdata8[4*curiside+ippp]];
	 }
  }
/////////////////////// Dotted outline of weld pass elements (always 8n hex in current version)
		  in=wp.PRECORD%9;
		  if     (in==0){Canvas->Brush->Color=clYellow;Canvas->Pen->Color=clYellow;}
		  else if(in==1){Canvas->Brush->Color=clOlive;Canvas->Pen->Color=clOlive;} // Coding for quad color contrast
		  else if(in==2){Canvas->Brush->Color=clMaroon;Canvas->Pen->Color=clMaroon;}
		  else if(in==3){Canvas->Brush->Color=clRed;Canvas->Pen->Color=clRed;}
		  else if(in==4){Canvas->Brush->Color=clLtGray;Canvas->Pen->Color=clLtGray;}
		  else if(in==5){Canvas->Brush->Color=clBlue;Canvas->Pen->Color=clBlue;}
		  else if(in==6){Canvas->Brush->Color=clBlue;Canvas->Pen->Color=clBlue;}
		  else if(in==7){Canvas->Brush->Color=clLime;Canvas->Pen->Color=clLime;}
		  else if(in==8){Canvas->Brush->Color=clNavy;Canvas->Pen->Color=clNavy;}
Canvas->Brush->Color=wp.WeldColor[wp.PRECORD];Canvas->Pen->Color=wp.WeldColor[wp.PRECORD];
					   Canvas->Pen->Width=1;
					   for(in=0;in<wp.count_curr_sttEl;in++){
															 for(ipp=0;ipp<icount/wp.count_curr_sttEl;ipp++){
ie1=wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*ipp+in]/10;
eltype1=indat.matno[ie1]/t7;
is1=0;
if(eltype1==8)for(is1=0;is1<6;is1++) //Correction EFP 1/20/2011
			   {Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*is1+0]]  ]+0.5),
							   ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*is1+0]]+1]+0.5));
				for(ip1=1;ip1<4;ip1++)Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*is1+ip1]]  ]+0.5),
													 ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*is1+ip1]]+1]+0.5));
			   }
else {wp.avis=10*(wp.avis/10)+1;
	  honk<<ie1+1<<" miscreantNonHex "<<eltype1<<"\n"; // Modification EFP 5/04/2011
//	  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex-element found in this weld pass.",L"Warning",MB_OK);
	 }
																											}
															}
/////////////////////// EFP 5/04/2011
//if(wp.avis){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex-element found in this weld pass.",L"Warning",MB_OK);}
if(wp.avis-10*(wp.avis/10)){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex-element found in this weld pass.",L"Warning",MB_OK);}
///////////////////////


//The following code is rewritten below  EFP 3/22/2012
/*
xave=yave=zave=0.;
for(ip=0;ip<wp.count_curr_sttEl;ip++)
  {for(in=0;in<8;in++){xave=xave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10)+in]+0];
					   yave=yave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10)+in]+1];
					   zave=zave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10)+in]+2];
					  }
  }
xave=xave/double(8*wp.count_curr_sttEl);yave=yave/double(8*wp.count_curr_sttEl);zave=zave/double(8*wp.count_curr_sttEl);
Canvas->Pen->Width=4;

ie=wp.sttEles[wp.memWGa*wp.PRECORD+0]/10; // Use first start element face as normal (TBD: Should be done separately for Forward & Reverse)
iside=wp.sttEles[wp.memWGa*wp.PRECORD+0]-10*ie;
if(iside==0){xc=  0.;yc= -1.;zc=  0.;}else if(iside==2){xc=  0.;yc=  1.;zc=  0.;}else if(iside==1){xc=  1.;yc=  0.;zc=  0.;}else if(iside==3){xc= -1.;yc=  0.;zc=  0.;}else if(iside==4){xc=  0.;yc=  0.;zc= -1.;}else {xc=  0.;yc=  0.;zc=  1.;}
STFISO8(3,xc,yc,zc,&DJD,HN,SN,SG,DJR,indat.nop1+MXNPEL*ie,indat.c1);
wp.arrows[NDF*3*wp.PRECORD+NDF*0+0]= -HN[0];wp.arrows[NDF*3*wp.PRECORD+NDF*0+1]= -HN[1];wp.arrows[NDF*3*wp.PRECORD+NDF*0+2]= -HN[2];

				 if(CCB==1){  // Directions as above or
Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
Canvas->Ellipse(int(xave)-5,ClientHeight-(int(yave)-5),int(xave)+5,ClientHeight-(int(yave)+5));
Canvas->Brush->Color=clBlue;Canvas->Pen->Color=clBlue;
Canvas->MoveTo(int(xave),ClientHeight-int(yave));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1]))); //GIANTS
Canvas->MoveTo(int(xave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
Canvas->LineTo(int(xave+25.*(HN[0]-HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[1]-HN[0]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
						   }
				 else           {  // Reverse direction

////TBD: The following discriminant logic might just be for circular welds(Full length==Circular???)
//// i.e. CRB_sel is the wrong parameter to use, since crack shape is the determinant???
//   if(CRB_sel) //Partial length
//	 {ippp=wp.circEles[3*wp.PRECORD+0];
//	  wp.circEles[3*wp.PRECORD+0]=wp.circEles[3*wp.PRECORD+2];
//	  wp.circEles[3*wp.PRECORD+2]=ippp;
//	 }
//   else // Full length
//	 {ippp=wp.circEles[3*wp.PRECORD+1];
//	  wp.circEles[3*wp.PRECORD+1]=wp.circEles[3*wp.PRECORD+2];
//	  wp.circEles[3*wp.PRECORD+2]=ippp;
//	 }
// EFP thinks that the coding should be as follows (3/22/2012) TEST THIS!!!
// CRB_ckShape=CreateLinWeldPass->CheckShape;
// 0=noncircular,1=fullcircle,2=partialcircle,3=fullgirth,4=partialgirth
   if(CRB_ckShape==1 || CRB_ckShape==3) //fullcircle or fullgirth
	 {ippp=wp.circEles[3*wp.PRECORD+1];
	  wp.circEles[3*wp.PRECORD+1]=wp.circEles[3*wp.PRECORD+2];
	  wp.circEles[3*wp.PRECORD+2]=ippp;
	 }
   else
	 {ippp=wp.circEles[3*wp.PRECORD+0];
	  wp.circEles[3*wp.PRECORD+0]=wp.circEles[3*wp.PRECORD+2];
	  wp.circEles[3*wp.PRECORD+2]=ippp;
	 }

for(in=0;in<wp.memWGa;in++)if(wp.eles[wp.memWGa*wp.PRECORD+in]<0)break;
icount=in;
dumarr=new long[base.nelt];
for(in=0;in<icount;in++)dumarr[in]=wp.eles[wp.memWGa*wp.PRECORD+in];
// Rewrite above to allow for mixed faces on sttEles   EFP 12/02/2011
for(ipp=0;ipp<icount/wp.count_curr_sttEl;ipp++)
  {for(in=0;in<wp.count_curr_sttEl;in++){ //Correction for missing pair of brackets  EFP 3/2012
ip1=dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]-
	10*(dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]/10);
//wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*ipp+in]=
//10*(dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]/10)-ip1+opp_arr8[ip1];  //Correction  EFP 12/02/2011
wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*ipp+in]=
dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]-ip1+opp_arr8[ip1];  //Correction  EFP 3/22/2012
										}
  }
//// Figure out the following....
//for(in=0;in<wp.count_curr_sttEl;in++)wp.sttEles[wp.memWGa*wp.PRECORD+in]=wp.eles[wp.memWGa*wp.PRECORD+in]/10;//Emergency


// The following corrected  EFP 12/02/2011
for(in=0;in<wp.count_curr_sttEl;in++){
									  wp.sttEles[wp.memWGa*wp.PRECORD+in]=wp.eles[wp.memWGa*wp.PRECORD+in];
//									  is=wp.sttEles[wp.memWGa*wp.PRECORD+in]-10*(wp.sttEles[wp.memWGa*wp.PRECORD+in]/10);
//									  for(ip=0;ip<4;ip++){
//wp.sttEleNodes[wp.memWGa*4*wp.PRECORD+4*in+ip]=
//   base.nop1[MXNPEL*(wp.sttEles[wp.memWGa*wp.PRECORD+in]/10)+gdata8[4*is+ip]]; //Not necessary here since this is done in export_CTSP()  EFP 3/22/2012
//														 }
									 }
delete [] dumarr;
Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
Canvas->Ellipse(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0])-5,ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])-5),
				int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0])+5,ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])+5));
Canvas->Brush->Color=clBlue;Canvas->Pen->Color=clBlue;
Canvas->MoveTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
Canvas->LineTo(int(xave),ClientHeight-int(yave));
Canvas->MoveTo(int(xave-25.*(HN[0]-HN[1])),ClientHeight-int(yave-25.*(HN[1]-HN[0])));
Canvas->LineTo(int(xave),ClientHeight-int(yave));
Canvas->LineTo(int(xave-25.*(HN[0]+HN[1])),ClientHeight-int(yave-25.*(HN[1]+HN[0])));
wp.arrows[NDF*3*wp.PRECORD+NDF*0+0]= -wp.arrows[NDF*3*wp.PRECORD+NDF*0+0];wp.arrows[NDF*3*wp.PRECORD+NDF*0+1]= -wp.arrows[NDF*3*wp.PRECORD+NDF*0+1];wp.arrows[NDF*3*wp.PRECORD+NDF*0+2]= -wp.arrows[NDF*3*wp.PRECORD+NDF*0+2];
// TBD: Arrow reversal above is not correct since a new arrow should be computed, based on sttEles apropos  EFP 3/22/2012
								}
*/
// Corrected version of above, allowing for curved WP  EFP 3/22/2012
				 if(CCB!=1){  //Reverse directions
////TBD: The following discriminant logic might just be for circular welds(Full length==Circular???)
//// i.e. CRB_sel is the wrong parameter to use, since crack shape is the determinant???
//   if(CRB_sel) //Partial length
//	 {ippp=wp.circEles[3*wp.PRECORD+0];
//	  wp.circEles[3*wp.PRECORD+0]=wp.circEles[3*wp.PRECORD+2];
//	  wp.circEles[3*wp.PRECORD+2]=ippp;
//	 }
//   else // Full length
//	 {ippp=wp.circEles[3*wp.PRECORD+1];
//	  wp.circEles[3*wp.PRECORD+1]=wp.circEles[3*wp.PRECORD+2];
//	  wp.circEles[3*wp.PRECORD+2]=ippp;
//	 }
// EFP thinks that the coding should be as follows (3/22/2012) TEST THIS!!!
// CRB_ckShape=CreateLinWeldPass->CheckShape;
// 0=noncircular,1=fullcircle,2=partialcircle,3=fullgirth,4=partialgirth
   if(CRB_ckShape==1 || CRB_ckShape==3) //fullcircle or fullgirth
	 {ippp=wp.circEles[3*wp.PRECORD+1];
	  wp.circEles[3*wp.PRECORD+1]=wp.circEles[3*wp.PRECORD+2];
	  wp.circEles[3*wp.PRECORD+2]=ippp;
	 }
   else
	 {ippp=wp.circEles[3*wp.PRECORD+0];
	  wp.circEles[3*wp.PRECORD+0]=wp.circEles[3*wp.PRECORD+2];
	  wp.circEles[3*wp.PRECORD+2]=ippp;
	 }
for(in=0;in<wp.memWGa;in++)if(wp.eles[wp.memWGa*wp.PRECORD+in]<0)break;
icount=in;dumarr=new long[base.nelt];
for(in=0;in<icount;in++)dumarr[in]=wp.eles[wp.memWGa*wp.PRECORD+in];
for(ipp=0;ipp<icount/wp.count_curr_sttEl;ipp++)
  {for(in=0;in<wp.count_curr_sttEl;in++){ //Correction for missing pair of brackets  EFP 3/2012
ip1=    dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]-
	10*(dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]/10);
//wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*ipp+in]=
//10*(dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]/10)-ip1+opp_arr8[ip1];  //Correction  EFP 12/02/2011
wp.eles[wp.memWGa*wp.PRECORD+wp.count_curr_sttEl*ipp+in]=
dumarr[wp.count_curr_sttEl*((icount/wp.count_curr_sttEl)-ipp-1)+in]-ip1+opp_arr8[ip1];  //Correction  EFP 3/22/2012
										}
  }
delete [] dumarr;
for(in=0;in<wp.count_curr_sttEl;in++)wp.sttEles[wp.memWGa*wp.PRECORD+in]=wp.eles[wp.memWGa*wp.PRECORD+in];
						   }
xave=yave=zave=0.;
for(ip=0;ip<wp.count_curr_sttEl;ip++)
  {for(in=0;in<8;in++){xave=xave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10)+in]+0];
					   yave=yave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10)+in]+1];
					   zave=zave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*wp.PRECORD+ip]/10)+in]+2];
					  }
  }
xave=xave/double(8*wp.count_curr_sttEl);yave=yave/double(8*wp.count_curr_sttEl);zave=zave/double(8*wp.count_curr_sttEl);
ie=wp.sttEles[wp.memWGa*wp.PRECORD+0]/10; // Use first start element face as normal
iside=wp.sttEles[wp.memWGa*wp.PRECORD+0]-10*ie;

//for(ip=0;ip<8;ip++)honk<<ip<<" "<<base.nop1[MXNPEL*ie+ip]<<" "<<
//					  base.c1[NDF*base.nop1[MXNPEL*ie+ip]+0]<<" "<<
//					  base.c1[NDF*base.nop1[MXNPEL*ie+ip]+1]<<" "<<
//					  base.c1[NDF*base.nop1[MXNPEL*ie+ip]+2]<<" B\n";
//for(ip=0;ip<8;ip++)honk<<ip<<" "<<indat.nop1[MXNPEL*ie+ip]<<" "<<
//					  indat.c1[NDF*indat.nop1[MXNPEL*ie+ip]+0]<<" "<<
//					  indat.c1[NDF*indat.nop1[MXNPEL*ie+ip]+1]<<" "<<
//					  indat.c1[NDF*indat.nop1[MXNPEL*ie+ip]+2]<<" I\n";

//if(iside==0){xc=  0.;yc= -1.;zc=  0.;}else if(iside==2){xc=  0.;yc=  1.;zc=  0.;}else if(iside==1){xc=  1.;yc=  0.;zc=  0.;}else if(iside==3){xc= -1.;yc=  0.;zc=  0.;}else if(iside==4){xc=  0.;yc=  0.;zc= -1.;}else {xc=  0.;yc=  0.;zc=  1.;}
//STFISO8(3,xc,yc,zc,&DJD,HN,SN,SG,DJR,indat.nop1+MXNPEL*ie,indat.c1);
STFISO8_ncalc(ie,iside,HN,base.nop1,base.c1); //First calc to establish global arrows EFP 3/23/2012
wp.arrows[NDF*3*wp.PRECORD+NDF*0+0]= -HN[0];wp.arrows[NDF*3*wp.PRECORD+NDF*0+1]= -HN[1];wp.arrows[NDF*3*wp.PRECORD+NDF*0+2]= -HN[2];

//honk<<wp.PRECORD<<" "<<ie<<" "<<iside<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*0+0]<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*0+1]<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*0+2]<<" wpARROW_weldDir\n";
STFISO8_ncalc(ie,iside,HN,indat.nop1,indat.c1); //second calc to establish screen frame directions EFP 3/23/2012

Canvas->Pen->Width=3;
Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
Canvas->Ellipse(int(xave)-5,ClientHeight-(int(yave)-5),int(xave)+5,ClientHeight-(int(yave)+5));
Canvas->Brush->Color=clBlue;Canvas->Pen->Color=clBlue;
Canvas->MoveTo(int(xave),ClientHeight-int(yave));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1]))); //GIANTS
Canvas->MoveTo(int(xave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
Canvas->LineTo(int(xave+25.*(HN[0]-HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[1]-HN[0]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));

Screen->Cursor=Save_Cursor;

					  }
					else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not hex-element or not in current weld group or no start elements yet.",L"Ignore",MB_OK);}
				   }

				 else if(CRB==3)  // Plate1 normal to element/side
				   {
///////////// 1st start Coding to ensure that normal is on plate EFP 1/08/2011
					eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
//					ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3; //Use ieGID from above
					if(ieGID==0){

///////////// start normal & complementary coding EFP 6/26/2011
if((wp.avis-100*(wp.avis/100))/10){isw=1;eltype5=indat.matno[ie]/t7;bscode5=(indat.matno[ie]-eltype5*t7)/t5;
								   if(bscode5>=32){if(iside!=5){isides=5;isw=0;}
												   else bscode5=bscode5-32;
												  }
								   if(bscode5>=16 && isw){if(iside!=4){isides=4;isw=0;}
														  else bscode5=bscode5-16;
														 }
								   if(bscode5>=8 && isw){if(iside!=3){isides=3;isw=0;}
														 else bscode5=bscode5-8;
														}
								   if(bscode5>=4 && isw){if(iside!=2){isides=2;isw=0;}
														 else bscode5=bscode5-4;
														}
								   if(bscode5>=2 && isw){if(iside!=1){isides=1;isw=0;}
														 else bscode5=bscode5-2;
														}
								   if(bscode5>=1 && isw){if(iside!=0)isides=0;
														} //TBD: Add warning if isides not found
								  }
else isides=iside;
///////////// 1st end
					Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;xave=yave=0;  // Assumes 8/20n elements
					for(ip=0;ip<4;ip++){xave=xave+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*isides+ip]]  ];yave=yave+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*isides+ip]]+1];}
					xave=xave/double(4);yave=yave/double(4);Canvas->Ellipse(int(xave)-2,ClientHeight-(int(yave)-2),int(xave)+2,ClientHeight-(int(yave)+2));
//					if(isides==0){xc=  0.;yc= -1.;zc=  0.;}else if(isides==2){xc=  0.;yc=  1.;zc=  0.;}else if(isides==1){xc=  1.;yc=  0.;zc=  0.;}else if(isides==3){xc= -1.;yc=  0.;zc=  0.;}else if(isides==4){xc=  0.;yc=  0.;zc= -1.;}else {xc=  0.;yc=  0.;zc=  1.;}
//					STFISO8(3,xc,yc,zc,&DJD,HN,SN,SG,DJR,indat.nop1+MXNPEL*ie,indat.c1);
STFISO8_ncalc(ie,isides,HN,indat.nop1,indat.c1); //first calc to establish screen frame directions EFP 3/23/2012
					Canvas->Pen->Color=clGreen;Canvas->Pen->Width=3;Canvas->MoveTo(int(xave),ClientHeight-int(yave));
					Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])));
///////
Canvas->Pen->Width=2;
Canvas->MoveTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])+25*HN[0],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])+25*HN[1]));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])+25*HN[1],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])-25*HN[0]));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])-25*HN[1],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])+25*HN[0]));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])+25*HN[0],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])+25*HN[1]));
///////
					for(ip=0;ip<4;ip++){wp.snorm1[4*wp.PRECORD+ip]=indat.nop1[MXNPEL*ie+gdata8[4*isides+ip]];
//honk<<ip<<" "<<wp.snorm1[4*wp.PRECORD+ip]<<" PLATE1pre "<<ie<<" "<<isides<<" "<<wp.PRECORD<<"\n";
									   }
///////////
dist=1.e+24;
for(ip=0;ip<4;ip++) //Enforce CTSP normals convention (1st node at fusion line at start elements)  EFP 10/30/2012
  {for(is=0;is<wp.count_curr_sttEl;is++)
	 {ie1=wp.sttEles[wp.memWGa*wp.PRECORD+is]/10;iside1=wp.sttEles[wp.memWGa*wp.PRECORD+is]-10*ie1;
	  for(in=0;in<4;in++){
if(dist >(base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+0])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+0])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+1])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+1])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+2])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+2]))
  {dist =(base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+0])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+0])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+1])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+1])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+2])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm1[4*wp.PRECORD+ip]+2]);
   ip1=ip;
  }
						 }
	 }
  }
//honk<<ip1<<" "<<dist<<" Dist-squared PLATE1\n";
ip1--;if(ip1<0)ip1=3;
for(ip=0;ip<4;ip++){wp.snorm1[4*wp.PRECORD+ip]=indat.nop1[MXNPEL*ie+gdata8[4*isides+ip1]];
//honk<<ip<<" "<<wp.snorm1[4*wp.PRECORD+ip]<<" PLATE1pos "<<ie<<" "<<isides<<" "<<wp.PRECORD<<"\n";
					ip1++;if(ip1>3)ip1=0;
				   }
///////////

STFISO8_ncalc(ie,iside,HN,base.nop1,base.c1); //second calc to establish global arrows EFP 3/23/2012
					wp.arrows[NDF*3*wp.PRECORD+NDF*1+0]=HN[0];wp.arrows[NDF*3*wp.PRECORD+NDF*1+1]=HN[1];wp.arrows[NDF*3*wp.PRECORD+NDF*1+2]=HN[2];

////honk<<wp.PRECORD<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*1+0]<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*1+1]<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*1+2]<<" wpARROW_plate1\n";
//honk<<"plate1 details "<<wp.snorm1[4*wp.PRECORD+0]<<" "<<wp.snorm1[4*wp.PRECORD+1]<<" "<<wp.snorm1[4*wp.PRECORD+2]<<" "<<wp.snorm1[4*wp.PRECORD+3]<<"\n";
//honk<<"plate1 HN "<<HN[0]<<" "<<HN[1]<<" "<<HN[2]<<"\n";

					CreateLinWeldPass->CheckNorm1=wp.snorm1[4*wp.PRECORD+0]; //EFP 5/31/2011
///////////// 2nd start Coding to ensure that normal is on plate EFP 1/08/2011
								}
					else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Normal must be on plate material",L"Failure",MB_OK);}
///////////// 2nd end
				   }
				 else if(CRB==4)  // Plate2 normal to element/side
				   {
///////////// 1st start Coding to ensure that normal is on plate EFP 1/08/2011
					eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
//					ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3; //Use ieGID from above
					if(ieGID==0){

///////////// start normal & complementary coding EFP 6/26/2011
if((wp.avis-100*(wp.avis/100))/10){isw=1;eltype5=indat.matno[ie]/t7;bscode5=(indat.matno[ie]-eltype5*t7)/t5;
								   if(bscode5>=32){if(iside!=5){isides=5;isw=0;}
												   else bscode5=bscode5-32;
												  }
								   if(bscode5>=16 && isw){if(iside!=4){isides=4;isw=0;}
														  else bscode5=bscode5-16;
														 }
								   if(bscode5>=8 && isw){if(iside!=3){isides=3;isw=0;}
														 else bscode5=bscode5-8;
														}
								   if(bscode5>=4 && isw){if(iside!=2){isides=2;isw=0;}
														 else bscode5=bscode5-4;
														}
								   if(bscode5>=2 && isw){if(iside!=1){isides=1;isw=0;}
														 else bscode5=bscode5-2;
														}
								   if(bscode5>=1 && isw){if(iside!=0)isides=0;
														} //TBD: Add warning if isides not found
								  }
else isides=iside;
///////////// 1st end
					Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;xave=yave=0;    // Assumes 8/20n elements
					for(ip=0;ip<4;ip++){xave=xave+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*isides+ip]]  ];yave=yave+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*isides+ip]]+1];}
					xave=xave/double(4);yave=yave/double(4);Canvas->Ellipse(int(xave)-2,ClientHeight-(int(yave)-2),int(xave)+2,ClientHeight-(int(yave)+2));
//					if(isides==0){xc=  0.;yc= -1.;zc=  0.;}else if(isides==2){xc=  0.;yc=  1.;zc=  0.;}else if(isides==1){xc=  1.;yc=  0.;zc=  0.;}else if(isides==3){xc= -1.;yc=  0.;zc=  0.;}else if(isides==4){xc=  0.;yc=  0.;zc= -1.;}else {xc=  0.;yc=  0.;zc=  1.;}
//					STFISO8(3,xc,yc,zc,&DJD,HN,SN,SG,DJR,indat.nop1+MXNPEL*ie,indat.c1);
STFISO8_ncalc(ie,isides,HN,indat.nop1,indat.c1); //first calc to establish screen frame directions EFP 3/23/2012
					Canvas->Pen->Color=clLime;Canvas->Pen->Width=3;Canvas->MoveTo(int(xave),ClientHeight-int(yave));
					Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])));
///////
Canvas->Pen->Width=2;
Canvas->MoveTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])+25*HN[0],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])+25*HN[1]));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])+25*HN[1],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])-25*HN[0]));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])-25*HN[1],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])+25*HN[0]));
Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[0])+25*HN[0],ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*HN[1])+25*HN[1]));
///////
					for(ip=0;ip<4;ip++){wp.snorm2[4*wp.PRECORD+ip]=indat.nop1[MXNPEL*ie+gdata8[4*isides+ip]];
//honk<<ip<<" "<<wp.snorm2[4*wp.PRECORD+ip]<<" PLATE2pre "<<ie<<" "<<isides<<" "<<wp.PRECORD<<"\n";
									   }
///////////
dist=1.e+24;
for(ip=0;ip<4;ip++) //Enforce CTSP normals convention (1st node at fusion line at start elements)  EFP 10/30/2012
  {for(is=0;is<wp.count_curr_sttEl;is++)
	 {ie1=wp.sttEles[wp.memWGa*wp.PRECORD+is]/10;iside1=wp.sttEles[wp.memWGa*wp.PRECORD+is]-10*ie1;
	  for(in=0;in<4;in++){
if(dist >(base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+0])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+0])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+1])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+1])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+2])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+2]))
  {dist =(base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+0])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+0]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+0])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+1])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+1]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+1])+
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+2])*
		 (base.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+in]]+2]-base.c1[NDF*wp.snorm2[4*wp.PRECORD+ip]+2]);
   ip1=ip;
  }
						 }
	 }
  }
//honk<<ip1<<" "<<dist<<" Dist-squared PLATE2\n";
ip1--;if(ip1<0)ip1=3;
for(ip=0;ip<4;ip++){wp.snorm2[4*wp.PRECORD+ip]=indat.nop1[MXNPEL*ie+gdata8[4*isides+ip1]];
//honk<<ip<<" "<<wp.snorm2[4*wp.PRECORD+ip]<<" PLATE2pos "<<ie<<" "<<isides<<" "<<wp.PRECORD<<"\n";
					ip1++;if(ip1>3)ip1=0;
				   }
///////////

STFISO8_ncalc(ie,iside,HN,base.nop1,base.c1); //second calc to establish global arrows EFP 3/23/2012
					wp.arrows[NDF*3*wp.PRECORD+NDF*2+0]=HN[0];wp.arrows[NDF*3*wp.PRECORD+NDF*2+1]=HN[1];wp.arrows[NDF*3*wp.PRECORD+NDF*2+2]=HN[2];

////honk<<wp.PRECORD<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*2+0]<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*2+1]<<" "<<wp.arrows[NDF*3*wp.PRECORD+NDF*2+2]<<" wpARROW_plate2\n";
//honk<<"plate2 details "<<wp.snorm2[4*wp.PRECORD+0]<<" "<<wp.snorm2[4*wp.PRECORD+1]<<" "<<wp.snorm2[4*wp.PRECORD+2]<<" "<<wp.snorm2[4*wp.PRECORD+3]<<"\n";
//honk<<"plate2 HN "<<HN[0]<<" "<<HN[1]<<" "<<HN[2]<<"\n";


					CreateLinWeldPass->CheckNorm2=wp.snorm2[4*wp.PRECORD+0]; //EFP 5/31/2011
///////////// 2nd start Coding to ensure that normal is on plate EFP 1/08/2011
								}
					else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Normal must be on plate material",L"Failure",MB_OK);}
///////////// 2nd end
				   }
				 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported VFT WeldPass radioButton option.",L"Terminate",MB_OK);exit(0);}
//cccccccccccc start EFP 12/20/2010
				}
			 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must select Weld Pass Location tab",L"Failure",MB_OK);}
//cccccccccccc end
				}
	   else {
			extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get CreateWeld dialog box.",L"Failure",MB_OK);
		   }
/////////////// New VFT coding //////////////
/////////////////////////////
	  }
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
	else if(FD_LButtonstatus==30) // Add Ux=0  EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Overwriting existing BC node",L"Notice",MB_OK);}
	   base.nofix[2*NodeNum+1]=1;FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==31) // Uy=0  EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Overwriting existing BC node",L"Notice",MB_OK);}
	   base.nofix[2*NodeNum+1]=2;FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==32) // Uz=0  EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Overwriting existing BC node",L"Notice",MB_OK);}
	   base.nofix[2*NodeNum+1]=3;FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==33) // Ux=Uy=0  EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Overwriting existing BC node",L"Notice",MB_OK);}
	   base.nofix[2*NodeNum+1]=4;FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==34) // Ux=Uz=0  EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Overwriting existing BC node",L"Notice",MB_OK);}
	   base.nofix[2*NodeNum+1]=5;FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==35) // Uy=Uz=0  EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Overwriting existing BC node",L"Notice",MB_OK);}
	   base.nofix[2*NodeNum+1]=6;FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==36) // Ux=Uy=Uz=0  EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Overwriting existing BC node",L"Notice",MB_OK);}
	   base.nofix[2*NodeNum+1]=7;FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==37) // Remove BC EFP 4/10/2012
	  {NodeNum=FDnode_interrog1(X,Y,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   Canvas->Ellipse(int(indat.c1[NDF*NodeNum])-4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])-4),int(indat.c1[NDF*NodeNum])+4,ClientHeight-(int(indat.c1[NDF*NodeNum+1])+4));
	   if(!base.nofix[2*NodeNum+1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not a BC node",L"Failure",MB_OK);}
	   else base.nofix[2*NodeNum+1]=0;
	   FD_LButtonstatus=FD_LBrec;
	  }
	else if(FD_LButtonstatus==23) // Element facet area EFP 5/01/2013
	  {if(QNode){delete QNode;QNode=NULL;}if(QElem){delete QElem;QElem=NULL;}if(QNDist){delete QNDist;QNDist=NULL;}
	   FDelem_interrog1(X,Y,&ie,&iside,&RN1,&RN2,&RN3,indat.nop1,indat.matno,indat.c1,nFacets,arbFacet);
	   if(ie>=0 && ie<base.nelt){Canvas->Pen->Width=3;Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
								 Canvas->Ellipse(X-5,Y-5,X+5,Y+5);rave=ElemFacetArea(ie,iside,base.nop1,base.matno,base.c1);
                                 Application->MessageBox(FloatToStr(rave).w_str(),IntToStr(__int64(base.el_map[ie]+1)).w_str(),MB_OK);
								}
	   Screen->Cursor=crSize;FD_LButtonstatus=FD_LBrec;
	  }
   }
//
//
//
//
//
 else if(Button==mbRight)
   {
/*
///////////////////////// FD_LB=4,5,6,7 not used in VFTmisc
	if(FD_LButtonstatus==4)
	  {if(polypts){Canvas->LineTo(polycord[0],ClientHeight-polycord[1]);
				   if(polypts<3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient polygon points.",L"Abandon",MB_OK);
								 FD_LButtonstatus=0;polypts=0;return;
								}
// TBD: Add a polygon integrity test here
	   signp=signm=0;
	   for(ip=0;ip<polypts;ip++)
		 {ipp=ip+1;if(ipp>=polypts)ipp=0;ippp=ipp+1;if(ippp>=polypts)ippp=0;
		  dx1=double(polycord[2*ipp]-polycord[2*ip]);dy1=double(polycord[2*ipp+1]-polycord[2*ip+1]);
		  norm=sqrt(dx1*dx1+dy1*dy1);if(norm<0.001){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Indistinct polygon points.",L"Try again",MB_OK);
													FD_LButtonstatus=0;polypts=0;return;
												   }
		  dx1=dx1/norm;dy1=dy1/norm;dx3=double(polycord[2*ippp]-polycord[2*ip]);dy3=double(polycord[2*ippp+1]-polycord[2*ip+1]);
		  norm=sqrt(dx3*dx3+dy3*dy3);if(norm<0.001){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Indistinct polygon points.",L"Try again",MB_OK);
													FD_LButtonstatus=0;polypts=0;return;
												   }
		  dx3=dx3/norm;dy3=dy3/norm;if(dx1*dy3-dx3*dy1 >=0.)signp++;else signm++;
		 }
	   if(signp==signm){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Possibly invalid criss-cross polygon.",L"Warning",MB_OK);
//                        FD_LButtonstatus=0;polypts=0;return;
					   }
//
				   nodeBCForm=new TForm11(0,0.,0,this);
//                   nodeBCForm->setAngle4(1.);nodeBCForm->setAngle5(0.);nodeBCForm->setAngle6(0.);
				   nodeBCForm->ShowModal();delete nodeBCForm;nodeBCForm=NULL;
// TBD: Highlight nodes
				   FD_LButtonstatus=0;polypts=0;
				  }
	  }
//
	else if(FD_LButtonstatus==5)
	  {if(polypts){Canvas->LineTo(polycord[0],ClientHeight-polycord[1]);
				   if(polypts<3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient polygon points.",L"Abandon",MB_OK);
								 FD_LButtonstatus=0;polypts=0;return;
								}
// TBD: Add a polygon integrity test here
				   signp=signm=0;
				   for(ip=0;ip<polypts;ip++)
					{ipp=ip+1;if(ipp>=polypts)ipp=0;ippp=ipp+1;if(ippp>=polypts)ippp=0;
					 dx1=double(polycord[2*ipp]-polycord[2*ip]);dy1=double(polycord[2*ipp+1]-polycord[2*ip+1]);
					 norm=sqrt(dx1*dx1+dy1*dy1);if(norm<0.001){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Indistinct polygon points.",L"Try again",MB_OK);
															   FD_LButtonstatus=0;polypts=0;return;
															  }
					 dx1=dx1/norm;dy1=dy1/norm;dx3=double(polycord[2*ippp]-polycord[2*ip]);dy3=double(polycord[2*ippp+1]-polycord[2*ip+1]);
					 norm=sqrt(dx3*dx3+dy3*dy3);if(norm<0.001){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Indistinct polygon points.",L"Try again",MB_OK);
															   FD_LButtonstatus=0;polypts=0;return;
															  }
					 dx3=dx3/norm;dy3=dy3/norm;if(dx1*dy3-dx3*dy1 >=0.)signp++;else signm++;
					}
				   if(signp==signm){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Possibly invalid criss-cross polygon.",L"Warning",MB_OK);
//                        FD_LButtonstatus=0;polypts=0;return;
								   }
				   for(is=0;is<GIDspac;is++)saflag[is]=0;
				   for(is=0;is<GIDspac;is++)
					 {if(16*is<nGIDmax)
						{prod=1;aflag=0;
						 for(iGID=16*is;iGID<min(long(nGIDmax),16*(is+1));iGID++)
						   {for(ie=0;ie<base.nelt;ie++){eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
														if(iGID==ieGID){aflag=aflag+prod;break;}
													   }
							prod=prod*2;
						   }
						 saflag[is]=aflag;
						}
					  else break;
					 }
				   surfBCForm=new TForm12(0,0.,0,0.,nGID,saflag,this);
				   surfBCForm->ShowModal();delete surfBCForm;surfBCForm=NULL;
// TBD: Highlight nodes
				   FD_LButtonstatus=0;polypts=0;
				  }
	  }
//	else if(FD_LButtonstatus==6 || FD_LButtonstatus==7 || FD_LButtonstatus==16)
/////////////////////////////////////////////////////////
*/
	if(FD_LButtonstatus==16)
	  {if(polypts){Canvas->LineTo(polycord[0],ClientHeight-polycord[1]);
				   if(polypts<3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient polygon points.",L"Abandon",MB_OK);
								 FD_LButtonstatus=0;polypts=0;return;
								}
// TBD: Add a polygon integrity test here
	   signp=signm=0;
	   for(ip=0;ip<polypts;ip++)
		 {ipp=ip+1;if(ipp>=polypts)ipp=0;ippp=ipp+1;if(ippp>=polypts)ippp=0;
		  dx1=double(polycord[2*ipp]-polycord[2*ip]);dy1=double(polycord[2*ipp+1]-polycord[2*ip+1]);
		  norm=sqrt(dx1*dx1+dy1*dy1);if(norm<0.001){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Indistinct polygon points.",L"Try again",MB_OK);
													FD_LButtonstatus=0;polypts=0;return;
												   }
		  dx1=dx1/norm;dy1=dy1/norm;dx3=double(polycord[2*ippp]-polycord[2*ip]);dy3=double(polycord[2*ippp+1]-polycord[2*ip+1]);
		  norm=sqrt(dx3*dx3+dy3*dy3);if(norm<0.001){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Indistinct polygon points.",L"Try again",MB_OK);
													FD_LButtonstatus=0;polypts=0;return;
												   }
		  dx3=dx3/norm;dy3=dy3/norm;if(dx1*dy3-dx3*dy1 >=0.)signp++;else signm++;
		 }
	   if(signp==signm){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Possibly invalid criss-cross polygon.",L"Warning",MB_OK);
//                        FD_LButtonstatus=0;polypts=0;return;
					   }
//				   cutelemPolyhea(FD_LButtonstatus-6);


////				   if(FD_LButtonstatus==6 || FD_LButtonstatus==7)cutelemPolyhea(FD_LButtonstatus-6);
////				   else if(FD_LButtonstatus==16)
												maskelemPolyhea(0);


//				   FD_LButtonstatus=0;
										 FD_LButtonstatus=11;stateVFT=2;
////////////////// Cursors EFP 1/21/2011
Screen->Cursor=crSizeAll;
//////////////////
				   polypts=0;
				  }
	  }
	else if(FD_LButtonstatus==11){stateVFT=3;Xpan0=X;Ypan0=Y;panMouseM=0;
								  iplotflag=2;iCullyesno=1;Timer2->Interval=250;Timer2->Enabled=true;
//								  iplotflag=2;iCullyesno=1;Timer2->Interval=10;Timer2->Enabled=true;

//                                  iplotflag=2;iCullyesno=1;Timer5->Interval=1050;Timer5->Enabled=true;
								 }
//    else if(FD_LButtonstatus==11){zoomRect.left=zoomRect.right=X;zoomRect.top=zoomRect.bottom=Y;
//                                  stateVFT=2;iplotflag=2;Timer5->Interval=250;Timer5->Enabled=true;
//                                 }

	else if(FD_LButtonstatus==22){if(QElem){delete QElem;QElem=NULL;}
								  FD_LButtonstatus=11;stateVFT=2;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
								 }
   }
// else //Middle button
//   {if(FD_LButtonstatus==11){zoomRect.left=zoomRect.right=X;zoomRect.top=zoomRect.bottom=Y;
//                             stateVFT=2;iplotflag=2;Timer5->Interval=250;Timer5->Enabled=true;
//                            }
//   }
}
//--------------------------------------------------------------------------- This does not use Button???
void __fastcall TForm1::FormMouseMove(TObject *Sender,TShiftState Shift,int X,int Y)
// "Highlight" points/lines are plotted directly to Form1->Canvas, not buffer tBitmap->Canvas
{panMouseM=1;
 if(FD_LButtonstatus==1)
	 {if(zoomDrag){zoomRect.right=X;zoomRect.bottom=Y;
				   Canvas->MoveTo(zoomRect.left,zoomRect.top);Canvas->LineTo(zoomRect.left,(zoomRect.bottom+3*zoomRect.top)/4);
				   Canvas->MoveTo(zoomRect.left,(3*zoomRect.bottom+zoomRect.top)/4);Canvas->LineTo(zoomRect.left,zoomRect.bottom);
				   Canvas->LineTo((3*zoomRect.left+zoomRect.right)/4,zoomRect.bottom);
				   Canvas->MoveTo((zoomRect.left+3*zoomRect.right)/4,zoomRect.bottom);Canvas->LineTo(zoomRect.right,zoomRect.bottom);
				   Canvas->LineTo(zoomRect.right,(3*zoomRect.bottom+zoomRect.top)/4);
				   Canvas->MoveTo(zoomRect.right,(zoomRect.bottom+3*zoomRect.top)/4);Canvas->LineTo(zoomRect.right,zoomRect.top);
				   Canvas->LineTo((zoomRect.left+3*zoomRect.right)/4,zoomRect.top);
				   Canvas->MoveTo((3*zoomRect.left+zoomRect.right)/4,zoomRect.top);Canvas->LineTo(zoomRect.left,zoomRect.top);
				  }
	 }
 else if(FD_LButtonstatus==11){if(Shift.Contains(ssLeft)){zoomRect.right=X;zoomRect.bottom=Y;}
							   if(Shift.Contains(ssRight)){Xpan1=X;Ypan1=Y;}
							  }
}
//---------------------------------------------------------------------------
void __fastcall TForm1::FormMouseUp(TObject *Sender, TMouseButton Button,TShiftState Shift, int X, int Y)
{enum TMouseButton { mbLeft, mbRight, mbMiddle }; // Draw directly on Canvas
 float rad=0.;int TB1H=0,P1W=0;
 if(Button==mbLeft)
   {if(FD_LButtonstatus==1){if(zoomDrag){zoomDrag=false;zoomRect.right=X;zoomRect.bottom=Y;FD_LButtonstatus=0;CmZoomIn2(indat.npoin,indat.c1,trans_op,prod_op,trans_zoom,prod_zoom,nDefects,CrackCor);

										 FD_LButtonstatus=FD_LBrec;
										 stateVFT=stateVFTrec;
										}
						   }
/*
	else if(FD_LButtonstatus==4)
	  {if(polypts){if(polypts<MAX_POLYPOINTS)
					 {rad=sqrt(double(X-polycord[2*polypts-2])*double(X-polycord[2*polypts-2])+double(ClientHeight-Y-polycord[2*polypts-1])*double(ClientHeight-Y-polycord[2*polypts-1]));
					  if(rad>0.00001){polycord[2*polypts]=X;polycord[2*polypts+1]=ClientHeight-Y;polypts++;Canvas->LineTo(X,Y);}
					  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must left-button-click & drag.",L"Halt",MB_OK);}
					 }
				   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must close polygon now-->right-button.",L"Halt",MB_OK);}
				  }
	  }
	else if(FD_LButtonstatus==5)
	  {if(polypts){if(polypts<MAX_POLYPOINTS)
					 {rad=sqrt(double(X-polycord[2*polypts-2])*double(X-polycord[2*polypts-2])+double(ClientHeight-Y-polycord[2*polypts-1])*double(ClientHeight-Y-polycord[2*polypts-1]));
					  if(rad>0.00001){polycord[2*polypts]=X;polycord[2*polypts+1]=ClientHeight-Y;polypts++;Canvas->LineTo(X,Y);}
					  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must left-button-click & drag.",L"Halt",MB_OK);}
					 }
				   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must close polygon now-->right-button.",L"Halt",MB_OK);}
				  }
	  }
////	else if(FD_LButtonstatus==6 || FD_LButtonstatus==7 || FD_LButtonstatus==16)
*/
	else if(FD_LButtonstatus==16)
	  {if(polypts){if(polypts<MAX_POLYPOINTS)
					 {rad=sqrt(double(X-polycord[2*polypts-2])*double(X-polycord[2*polypts-2])+double(ClientHeight-Y-polycord[2*polypts-1])*double(ClientHeight-Y-polycord[2*polypts-1]));
					  if(rad>0.00001){polycord[2*polypts]=X;polycord[2*polypts+1]=ClientHeight-Y;polypts++;Canvas->LineTo(X,Y);}
					  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must left-button-click & drag.",L"Halt",MB_OK);}
					 }
				   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must close polygon now-->right-button.",L"Halt",MB_OK);}
				  }
	  }

/////////////////////////// Reuse zoomRect.etc
////	else if(FD_LButtonstatus==5)
	else if(FD_LButtonstatus==8)// Changed from 5->8 to match VFTgen
	  {zoomRect.right=X;zoomRect.bottom=Y;FD_LButtonstatus=0;
//       rangle[0]=180.*float(-zoomRect.top+zoomRect.bottom)/float(ClientHeight);rangle0[0]=rangle0[0]+rangle[0];
//	   rangle[1]=180.*float(zoomRect.right-zoomRect.left)/float(ClientWidth);rangle0[1]=rangle0[1]+rangle[1];
	   rangle[0]=180.*float(-zoomRect.top+zoomRect.bottom)/float(ClientHeight- TB1H);rangle0[0]=rangle0[0]+rangle[0];
	   rangle[1]=180.*float(zoomRect.right-zoomRect.left)/float(ClientWidth- P1W);rangle0[1]=rangle0[1]+rangle[1];
	   rangle[2]=0.;rangle0[2]=rangle0[2]+rangle[2];
	   FDrotate(0,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);
	   FDrotate_axisplot(0,rangle); //EFP 9/17/2010
	   iCullyesno=0;Invalidate();
	  }
///////////////////////////
	else if(FD_LButtonstatus==9)
	  {Canvas->Pen->Color=clBlack;Canvas->Brush->Color=clWhite;
	   Canvas->TextOut(X,Y,"Annotation here...");FD_LButtonstatus=0;
	   if(ANNOTcount<ANNOT_CHAR){AnnotIndex[3*ANNOTcount]=X;AnnotIndex[3*ANNOTcount+1]=Y;
								 AnnotForm=new TForm20(this);AnnotForm->Caption="Annotation";
								 AnnotForm->ShowModal();delete AnnotForm;AnnotForm=NULL;
								}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Too many annotations",L"Failure",MB_OK);}
	  }
	else if(FD_LButtonstatus==10)
	  {FD_LButtonstatus=0;
	   if(ANLINcount<ANNOT_CHAR){AnLINIndex[4*ANLINcount+2]=X;AnLINIndex[4*ANLINcount+3]=Y;ANLINcount++;FDrestore();}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Too many annotations",L"Failure",MB_OK);}
	  }
	else if(FD_LButtonstatus==11){
////								  FD_LButtonstatus=0;
//								  Timer5->Enabled=false;
								  Timer2->Enabled=false;
								 }
//    else if(FD_LButtonstatus==11){FD_LButtonstatus=0;panMouseM=0;Timer5->Enabled=false;}
	else if(FD_LButtonstatus==13){
//////								  FD_LButtonstatus=0;
////								  FD_LButtonstatus=11;stateVFT=2;
//								  Timer5->Enabled=false;
								  Timer2->Enabled=false;

										 FD_LButtonstatus=FD_LBrec;
										 stateVFT=stateVFTrec;
								 }
   }
 else if(Button==mbRight)
   {if(FD_LButtonstatus==11){
//							 FD_LButtonstatus=0;
							 stateVFT=2;
//							 Timer5->Enabled=false;
							 Timer2->Enabled=false;
							}
   }
// else if(Button==mbMiddle)
//   {if(FD_LButtonstatus==11){FD_LButtonstatus=0;Timer5->Enabled=false;}
//   }
}
//---------------------------------------------------------------------------
void __fastcall TForm1::FormMouseWheel(TObject *Sender,TShiftState Shift,int WheelDelta,TPoint &MousePos,bool &Handled)
{FD_LBrec=FD_LButtonstatus;stateVFTrec=stateVFT;
 if(WheelDelta>0){zoomRect.left=int(float(ClientWidth)*0.05);zoomRect.top=int(float(ClientHeight)*0.05);
				  zoomRect.right=int(float(ClientWidth)*0.95);zoomRect.bottom=int(float(ClientHeight)*0.95);
//honk<<WheelDelta<<" MouseWheel UP\n";
				  zoomDrag=false;FD_LButtonstatus=0;
//				  CmZoomIn2();
				  CmZoomIn2(indat.npoin,indat.c1,trans_op,prod_op,trans_zoom,prod_zoom,nDefects,CrackCor);
				 }
 else if(WheelDelta<0){zoomRect.left= -int(float(ClientWidth)*0.05);zoomRect.top= -int(float(ClientHeight)*0.05);
					   zoomRect.right=int(float(ClientWidth)*1.05);zoomRect.bottom=int(float(ClientHeight)*1.05);
//honk<<WheelDelta<<" MouseWheel DOWN\n";
					   zoomDrag=false;FD_LButtonstatus=0;
//					   CmZoomIn2();
					   CmZoomIn2(indat.npoin,indat.c1,trans_op,prod_op,trans_zoom,prod_zoom,nDefects,CrackCor);
					  }

// else honk<<WheelDelta<<" No Spin\n";
 FD_LButtonstatus=FD_LBrec;stateVFT=stateVFTrec;
}
//---------------------------------------------------------------------------
void TForm1::FDside_reorder(long dside,long iside,long ie,long bnop1[],long inop1[])
// Code to re-order nodal topology, based on desired side number (dside) and encountered side (iside)  EFP 4/10/2011
{long in=0,n0=0,n1=0,n2=0,n3=0,n4=0,n5=0,n6=0,n7=0; //8-n elements ONLY
 n0=bnop1[MXNPEL*ie+0];
 n1=bnop1[MXNPEL*ie+1];
 n2=bnop1[MXNPEL*ie+2];
 n3=bnop1[MXNPEL*ie+3];
 n4=bnop1[MXNPEL*ie+4];
 n5=bnop1[MXNPEL*ie+5];
 n6=bnop1[MXNPEL*ie+6];
 n7=bnop1[MXNPEL*ie+7];
 if((dside==0 && iside==1) || (dside==1 && iside==2) || (dside==2 && iside==3) || (dside==3 && iside==0))
		{bnop1[MXNPEL*ie+0]=n1;
		 bnop1[MXNPEL*ie+1]=n2;
		 bnop1[MXNPEL*ie+2]=n3;
		 bnop1[MXNPEL*ie+3]=n0;
		 bnop1[MXNPEL*ie+4]=n5;
		 bnop1[MXNPEL*ie+5]=n6;
		 bnop1[MXNPEL*ie+6]=n7;
		 bnop1[MXNPEL*ie+7]=n4;
		}
 else if((dside==0 && iside==2) || (dside==1 && iside==3) || (dside==2 && iside==0) || (dside==3 && iside==1))
		{bnop1[MXNPEL*ie+0]=n2;
		 bnop1[MXNPEL*ie+1]=n3;
		 bnop1[MXNPEL*ie+2]=n0;
		 bnop1[MXNPEL*ie+3]=n1;
		 bnop1[MXNPEL*ie+4]=n6;
		 bnop1[MXNPEL*ie+5]=n7;
		 bnop1[MXNPEL*ie+6]=n4;
		 bnop1[MXNPEL*ie+7]=n5;
		}
 else if((dside==0 && iside==3) || (dside==1 && iside==0) || (dside==2 && iside==1) || (dside==3 && iside==2))
		{bnop1[MXNPEL*ie+0]=n3;
		 bnop1[MXNPEL*ie+1]=n0;
		 bnop1[MXNPEL*ie+2]=n1;
		 bnop1[MXNPEL*ie+3]=n2;
		 bnop1[MXNPEL*ie+4]=n7;
		 bnop1[MXNPEL*ie+5]=n4;
		 bnop1[MXNPEL*ie+6]=n5;
		 bnop1[MXNPEL*ie+7]=n6;
		}
 else if((dside==0 && iside==4) || (dside==4 && iside==2) || (dside==5 && iside==0))
		{bnop1[MXNPEL*ie+0]=n3;
		 bnop1[MXNPEL*ie+1]=n2;
		 bnop1[MXNPEL*ie+2]=n6;
		 bnop1[MXNPEL*ie+3]=n7;
		 bnop1[MXNPEL*ie+4]=n0;
		 bnop1[MXNPEL*ie+5]=n1;
		 bnop1[MXNPEL*ie+6]=n5;
		 bnop1[MXNPEL*ie+7]=n4;
		}
 else if((dside==0 && iside==5) || (dside==2 && iside==4) || (dside==4 && iside==0) || (dside==5 && iside==2))
		{bnop1[MXNPEL*ie+0]=n4;
		 bnop1[MXNPEL*ie+1]=n5;
		 bnop1[MXNPEL*ie+2]=n1;
		 bnop1[MXNPEL*ie+3]=n0;
		 bnop1[MXNPEL*ie+4]=n7;
		 bnop1[MXNPEL*ie+5]=n6;
		 bnop1[MXNPEL*ie+6]=n2;
		 bnop1[MXNPEL*ie+7]=n3;
		}
 else if((dside==1 && iside==4) || (dside==3 && iside==5))
		{bnop1[MXNPEL*ie+0]=n4;
		 bnop1[MXNPEL*ie+1]=n0;
		 bnop1[MXNPEL*ie+2]=n3;
		 bnop1[MXNPEL*ie+3]=n7;
		 bnop1[MXNPEL*ie+4]=n5;
		 bnop1[MXNPEL*ie+5]=n1;
		 bnop1[MXNPEL*ie+6]=n2;
		 bnop1[MXNPEL*ie+7]=n6;
		}
 else if((dside==1 && iside==5) || (dside==3 && iside==4) || (dside==4 && iside==3) || (dside==5 && iside==1))
		{bnop1[MXNPEL*ie+0]=n3;
		 bnop1[MXNPEL*ie+1]=n7;
		 bnop1[MXNPEL*ie+2]=n4;
		 bnop1[MXNPEL*ie+3]=n0;
		 bnop1[MXNPEL*ie+4]=n2;
		 bnop1[MXNPEL*ie+5]=n6;
		 bnop1[MXNPEL*ie+6]=n5;
		 bnop1[MXNPEL*ie+7]=n1;
		}
 else if(dside==2 && iside==5)
		{bnop1[MXNPEL*ie+0]=n0;
		 bnop1[MXNPEL*ie+1]=n3;
		 bnop1[MXNPEL*ie+2]=n7;
		 bnop1[MXNPEL*ie+3]=n4;
		 bnop1[MXNPEL*ie+4]=n1;
		 bnop1[MXNPEL*ie+5]=n2;
		 bnop1[MXNPEL*ie+6]=n6;
		 bnop1[MXNPEL*ie+7]=n5;
		}
 else if((dside==4 && iside==1) || (dside==5 && iside==3))
		{bnop1[MXNPEL*ie+0]=n1;
		 bnop1[MXNPEL*ie+1]=n5;
		 bnop1[MXNPEL*ie+2]=n6;
		 bnop1[MXNPEL*ie+3]=n2;
		 bnop1[MXNPEL*ie+4]=n0;
		 bnop1[MXNPEL*ie+5]=n4;
		 bnop1[MXNPEL*ie+6]=n7;
		 bnop1[MXNPEL*ie+7]=n3;
		}
 else if((dside==4 && iside==5) || (dside==5 && iside==4))
		{bnop1[MXNPEL*ie+0]=n6;
		 bnop1[MXNPEL*ie+1]=n5;
		 bnop1[MXNPEL*ie+2]=n4;
		 bnop1[MXNPEL*ie+3]=n7;
		 bnop1[MXNPEL*ie+4]=n2;
		 bnop1[MXNPEL*ie+5]=n1;
		 bnop1[MXNPEL*ie+6]=n0;
		 bnop1[MXNPEL*ie+7]=n3;
		}
 for(in=0;in<8;in++)inop1[MXNPEL*ie+in]=bnop1[MXNPEL*ie+in];
}
//---------------------------------------------------------------------------
void TForm1::QNodeTRASH_public(){if(QNode){// delete QNode;
										   QNode=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
								}
//---------------------------------------------------------------------------
void TForm1::QElemTRASH_public(){if(QElem){// delete QElem;
										   QElem=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
								}
//---------------------------------------------------------------------------
void TForm1::QNDistTRASH_public(){if(QNDist){// delete QNDist;
											 QNDist=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
								 }
//---------------------------------------------------------------------------
void TForm1::sectheaTRASH_public(){if(SectionForm){// delete SectionForm;
												   SectionForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
								  }
//---------------------------------------------------------------------------
void TForm1::SectWedgeTRASH_public(){if(SectWedgeForm){// delete SectWedgeForm;
													   SectWedgeForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
									}
//---------------------------------------------------------------------------
void TForm1::Sect3ptTRASH_public(){if(Sect3ptForm){// delete Sect3ptForm;
												   Sect3ptForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
								  }
//---------------------------------------------------------------------------
void TForm1::Sect1p2rTRASH_public(){if(Sect1p2rForm){// delete Sect1p2rForm;
													 Sect1p2rForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
								   }
//---------------------------------------------------------------------------
void TForm1::SectqsdTRASH_public(){if(SectqsdForm){// delete SectqsdForm;
												   SectqsdForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
								  }
//---------------------------------------------------------------------------
void TForm1::SpecSCkTRASH_public(){if(SpecSCkForm){// delete SpecSCkForm;
												   SpecSCkForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
								  }
//---------------------------------------------------------------------------
void TForm1::rotheaFixTRASH_public(){if(RotaFixForm){// delete RotaFixForm;
													 RotaFixForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
									}
//---------------------------------------------------------------------------
void TForm1::Form8TRASH_public(){if(ShapeForm){// delete ShapeForm;
											   ShapeForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
								}
//---------------------------------------------------------------------------
void TForm1::Form19TRASH_public(){if(AnalysisProgressForm){// delete AnalysisProgressForm;
														   AnalysisProgressForm=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
								 }
//---------------------------------------------------------------------------
void TForm1::SelForm17TRASH_public()
{if(GIDSelForm){delete GIDSelForm;GIDSelForm=NULL;}
 if(FwriteUNVselGID){delete FwriteUNVselGID;FwriteUNVselGID=NULL;}
FD_LButtonstatus=11; //EFP 8/29/2011
}
//---------------------------------------------------------------------------
void TForm1::annot_render(int count,int index[],
  AnsiString arr0,AnsiString arr1,AnsiString arr2,AnsiString arr3,AnsiString arr4,
  AnsiString arr5,AnsiString arr6,AnsiString arr7,AnsiString arr8,AnsiString arr9)
{int ic=0;Canvas->Pen->Color=clBlack;Canvas->Brush->Color=clWhite;
 for(ic=0;ic<count;ic++){if(ic==0)Canvas->TextOut(index[3*ic],index[3*ic+1],arr0);
						 else if(ic==1)Canvas->TextOut(index[3*ic],index[3*ic+1],arr1);
						 else if(ic==2)Canvas->TextOut(index[3*ic],index[3*ic+1],arr2);
						 else if(ic==3)Canvas->TextOut(index[3*ic],index[3*ic+1],arr3);
						 else if(ic==4)Canvas->TextOut(index[3*ic],index[3*ic+1],arr4);
						 else if(ic==5)Canvas->TextOut(index[3*ic],index[3*ic+1],arr5);
						 else if(ic==6)Canvas->TextOut(index[3*ic],index[3*ic+1],arr6);
						 else if(ic==7)Canvas->TextOut(index[3*ic],index[3*ic+1],arr7);
						 else if(ic==8)Canvas->TextOut(index[3*ic],index[3*ic+1],arr8);
						 else if(ic==9)Canvas->TextOut(index[3*ic],index[3*ic+1],arr9);
						 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"More than 10 annotations",L"Failure",MB_OK);}
						}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
void TForm1::anLIN_render(int count,int index[])
{int ic=0;Canvas->Pen->Color=clBlack;Canvas->Pen->Width=2;
 for(ic=0;ic<count;ic++){Canvas->MoveTo(index[4*ic],index[4*ic+1]);Canvas->LineTo(index[4*ic+2],index[4*ic+3]);}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}

//---------------------------------------------------------------------------
void TForm1::CmZoomIn2(long indat_npoin,float indat_c1[],float trans_op[],float prod_op[][3],float trans_zoom[],float prod_zoom[],long nDefects,float CrackCor[])
// Global NDF,iplotflag,zoomRect/etc
{long i=0;float zoomcenx=0.,zoomceny=0.,aspectr=0.,aspectz=0.,delx=0.,dely=0.,gdiff=0.;
// FD_LButtonstatus=0;
// KillTimer(ID_TIMERZOOM);
// zoomcenx=float(ptClick1.x+ptClick0.x)/2.;zoomceny=float(ptClick1.y+ptClick0.y)/2.;
// delx=float(abs(ptClick1.x-ptClick0.x));dely=float(abs(ptClick1.y-ptClick0.y));
 zoomcenx=float(zoomRect.left+zoomRect.right)/2.;zoomceny=float(2*ClientHeight-zoomRect.top-zoomRect.bottom)/2.;
 delx=float(abs(zoomRect.left-zoomRect.right));dely=float(abs(zoomRect.top-zoomRect.bottom));
 aspectr=float(ClientHeight)/float(ClientWidth);
// Zoom area must exceed 2.5% of frame height or width
 if(dely< 0.025*float(ClientHeight) || delx< 0.025*float(ClientWidth))
   {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Zoom area too small.",L"Halt",MB_OK);return;
   }
 else aspectz=dely/delx;
 if(aspectz>aspectr)delx=dely/aspectr;else dely=delx*aspectr;
 gdiff=float(ClientWidth)/delx;
///////////////////////////////////////
float xmx=0.,xmn=0.,ymx=0.,ymn=0.,zmx=0.,zmn=0.;
xmx= -1.E20;xmn=1.E20;ymx= -1.E20;ymn=1.E20;zmx= -1.E20;zmn=1.E20;
 for(i=0;i<indat_npoin;i++)
   {if(xmx<indat_c1[NDF*i  ])xmx=indat_c1[NDF*i  ];if(xmn>indat_c1[NDF*i  ])xmn=indat_c1[NDF*i  ];
	if(ymx<indat_c1[NDF*i+1])ymx=indat_c1[NDF*i+1];if(ymn>indat_c1[NDF*i+1])ymn=indat_c1[NDF*i+1];
	if(zmx<indat_c1[NDF*i+2])zmx=indat_c1[NDF*i+2];if(zmn>indat_c1[NDF*i+2])zmn=indat_c1[NDF*i+2];
   }
honk<<xmx<<" "<<xmn<<" XY "<<ymx<<" "<<ymn<<" YZ "<<zmx<<" "<<zmn<<" CmZoomIn2BEF\n";
honk<<(xmx+xmn)/2. <<" XY "<<(ymx+ymn)/2. <<" YZ "<<(zmx+zmn)/2. <<" avgCmZoomIn2BEF\n";
///////////////////////////////////////
 for(i=0;i<indat_npoin;i++){indat_c1[NDF*i  ]=(indat_c1[NDF*i  ]-zoomcenx+delx/2.)*gdiff;
							indat_c1[NDF*i+1]=(indat_c1[NDF*i+1]-zoomceny+dely/2.)*gdiff;
							indat_c1[NDF*i+2]=indat_c1[NDF*i+2]*gdiff;
						   }
///////////////////////////////////////
xmx= -1.E20;xmn=1.E20;ymx= -1.E20;ymn=1.E20;zmx= -1.E20;zmn=1.E20;
 for(i=0;i<indat_npoin;i++)
   {if(xmx<indat_c1[NDF*i  ])xmx=indat_c1[NDF*i  ];if(xmn>indat_c1[NDF*i  ])xmn=indat_c1[NDF*i  ];
	if(ymx<indat_c1[NDF*i+1])ymx=indat_c1[NDF*i+1];if(ymn>indat_c1[NDF*i+1])ymn=indat_c1[NDF*i+1];
	if(zmx<indat_c1[NDF*i+2])zmx=indat_c1[NDF*i+2];if(zmn>indat_c1[NDF*i+2])zmn=indat_c1[NDF*i+2];
   }
honk<<xmx<<" "<<xmn<<" XY "<<ymx<<" "<<ymn<<" YZ "<<zmx<<" "<<zmn<<" CmZoomIn2AFT\n";
honk<<(xmx+xmn)/2. <<" XY "<<(ymx+ymn)/2. <<" YZ "<<(zmx+zmn)/2. <<" avgCmZoomIn2AFT\n";
///////////////////////////////////////
honk<<gdiff<<" "<<float(zoomRect.left)<<" "<<float(zoomRect.top)<<" BefCmIn "<<ClientHeight<<" "<<ClientWidth<<"\n";
honk<<gl_indatMedian[0]<<" "<<gl_indatMedian[1]<<" "<<gl_indatMedian[2]<<" BefCmIn\n";
gl_indatMedian[0]=gl_indatMedian[0]*gdiff-float(zoomRect.left);
//gl_indatMedian[1]=gl_indatMedian[1]*gdiff+float(zoomRect.top);
gl_indatMedian[1]=gl_indatMedian[1]*gdiff-float(zoomRect.top);
gl_indatMedian[2]=gl_indatMedian[2]*gdiff;
honk<<gl_indatMedian[0]<<" "<<gl_indatMedian[1]<<" "<<gl_indatMedian[2]<<" AftCmIn\n";
glGdiff=glGdiff*gdiff;
honk<<gdiff<<" gdiff glGdiff "<<glGdiff<<"\n";
honk<<"\n";

if(nDefects)
{for(long iq=0;iq<nDefects;iq++)
 {for(long ic=0;ic<3;ic++){CrackCor[9*iq+3*ic+0]=(CrackCor[9*iq+3*ic+0]-zoomcenx+delx/2.)*gdiff;
						   CrackCor[9*iq+3*ic+1]=(CrackCor[9*iq+3*ic+1]-zoomceny+dely/2.)*gdiff;
						   CrackCor[9*iq+3*ic+2]=CrackCor[9*iq+3*ic+2]*gdiff;
						  }
 }
}
 trans_op[0]=trans_op[0]+(zoomcenx-delx/2.)*prod_op[0][0]+(zoomceny-dely/2.)*prod_op[0][1];
 trans_op[1]=trans_op[1]+(zoomcenx-delx/2.)*prod_op[1][0]+(zoomceny-dely/2.)*prod_op[1][1];
 trans_op[2]=trans_op[2]+(zoomcenx-delx/2.)*prod_op[2][0]+(zoomceny-dely/2.)*prod_op[2][1];
 prod_op[0][0]=prod_op[0][0]/gdiff; prod_op[0][1]=prod_op[0][1]/gdiff;
 prod_op[0][2]=prod_op[0][2]/gdiff; prod_op[1][0]=prod_op[1][0]/gdiff;
 prod_op[1][1]=prod_op[1][1]/gdiff; prod_op[1][2]=prod_op[1][2]/gdiff;
 prod_op[2][0]=prod_op[2][0]/gdiff; prod_op[2][1]=prod_op[2][1]/gdiff;prod_op[2][2]=prod_op[2][2]/gdiff;
 trans_zoom[0]=trans_zoom[0]+prod_zoom[0]*(zoomcenx-delx/2.);trans_zoom[1]=trans_zoom[1]+prod_zoom[1]*(zoomceny-dely/2.);
 prod_zoom[0]=prod_zoom[0]/gdiff;prod_zoom[1]=prod_zoom[1]/gdiff;prod_zoom[2]=prod_zoom[2]/gdiff;iplotflag=2;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ZoomInExecute(TObject *Sender)
{if(base.nop1)
//   FD_LButtonstatus=1;
//////////// Cursors EFP 1/21/2011
   {FD_LButtonstatus=1;
	Screen->Cursor=crDefault;
   }
////////////
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"05Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ZoomOutExecute(TObject *Sender)
{long i=0;
 if(base.nop1)
	  {for(i=0;i<indat.npoin;i++){indat.c1[NDF*i  ]=indat.c1[NDF*i  ]*prod_zoom[0]+trans_zoom[0];
                                  indat.c1[NDF*i+1]=indat.c1[NDF*i+1]*prod_zoom[1]+trans_zoom[1];
								  indat.c1[NDF*i+2]=indat.c1[NDF*i+2]*prod_zoom[2]+trans_zoom[2];
                                 }
if(nDefects)
{for(long iq=0;iq<nDefects;iq++)
 {for(long ic=0;ic<3;ic++){CrackCor[9*iq+3*ic+0]=CrackCor[9*iq+3*ic+0]*prod_zoom[0]+trans_zoom[0];
                           CrackCor[9*iq+3*ic+1]=CrackCor[9*iq+3*ic+1]*prod_zoom[1]+trans_zoom[1];
                           CrackCor[9*iq+3*ic+2]=CrackCor[9*iq+3*ic+2]*prod_zoom[2]+trans_zoom[2];
                          }
 }
}
       for(int j=0;j<NDF;j++){for(int ix=0;ix<NDF;ix++){prod_op[ix][j]=prod_op[ix][j]/prod_zoom[j];trans_op[ix]=trans_op[ix]-prod_op[ix][j]*trans_zoom[j];}}
	   trans_zoom[0]=0.;trans_zoom[1]=0.;trans_zoom[2]=0.;prod_zoom[0]=1.;prod_zoom[1]=1.;prod_zoom[2]=1.;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
	   iplotflag=2;Invalidate();
      }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"06Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ZoomResetExecute(TObject *Sender)
{if(base.nop1){FDresetzoom(indat.npoin,indat.c1,trans_op,prod_op,nDefects,CrackCor);rangle0[0]=0.;rangle0[1]=0.;rangle0[2]=0.;trans_op[0]=trans_op[1]=trans_op[2]=0.;
			   prod_op[0][0]=prod_op[1][1]=prod_op[2][2]=1.;prod_op[1][0]=prod_op[2][0]=prod_op[0][1]=0.;
			   prod_op[2][1]=prod_op[0][2]=prod_op[1][2]=0.;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   iplotflag=1;iCullyesno=0;Invalidate();
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"07Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::FDresetzoom(long indat_npoin,float indat_c1[],float trans_op[],float prod_op[][3],long nDefects,float CrackCor[])
// Global NDF
{long i=0;float sumx=0.,sumy=0.,sumz=0.,r11=prod_op[0][0],r12=prod_op[0][1],r13=prod_op[0][2],r21=prod_op[1][0],r22=prod_op[1][1],r23=prod_op[1][2],r31=prod_op[2][0],r32=prod_op[2][1],r33=prod_op[2][2];
 for(i=0;i<indat_npoin;i++){sumx=trans_op[0]+r11*indat_c1[NDF*i]+r12*indat_c1[NDF*i+1]+r13*indat_c1[NDF*i+2];
							sumy=trans_op[1]+r21*indat_c1[NDF*i]+r22*indat_c1[NDF*i+1]+r23*indat_c1[NDF*i+2];
							sumz=trans_op[2]+r31*indat_c1[NDF*i]+r32*indat_c1[NDF*i+1]+r33*indat_c1[NDF*i+2];
							indat_c1[NDF*i]=sumx;indat_c1[NDF*i+1]=sumy;indat_c1[NDF*i+2]=sumz;
						   }
if(nDefects)
{for(long iq=0;iq<nDefects;iq++)
 {for(long ic=0;ic<3;ic++){sumx=trans_op[0]+r11*CrackCor[9*iq+3*ic+0]+r12*CrackCor[9*iq+3*ic+1]+r13*CrackCor[9*iq+3*ic+2];
						   sumy=trans_op[1]+r21*CrackCor[9*iq+3*ic+0]+r22*CrackCor[9*iq+3*ic+1]+r23*CrackCor[9*iq+3*ic+2];
						   sumz=trans_op[2]+r31*CrackCor[9*iq+3*ic+0]+r32*CrackCor[9*iq+3*ic+1]+r33*CrackCor[9*iq+3*ic+2];
						   CrackCor[9*iq+3*ic+0]=sumx;CrackCor[9*iq+3*ic+1]=sumy;CrackCor[9*iq+3*ic+2]=sumz;
						  }
 }
}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AnnotateExecute(TObject *Sender)
{if(base.nop1)
//   FD_LButtonstatus=9;
//////////// Cursors EFP 1/21/2011
	{FD_LButtonstatus=9;
	 Screen->Cursor=crCross;
	}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"08Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AnnotLineExecute(TObject *Sender)
{if(base.nop1)
//   FD_LButtonstatus=10;
	{FD_LButtonstatus=10;
	 Screen->Cursor=crCross;
	}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"09Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ClearAnnotateExecute(TObject *Sender) //TBD: Is this OK without test for model (base.nop1) EFP 3/22/2012
{ANNOTcount=ANLINcount=0;
 for(int ic=0;ic<3*ANNOT_CHAR;ic++)AnnotIndex[ic]=0;
 for(int ic=0;ic<4*ANNOT_CHAR;ic++)AnLINIndex[ic]=0;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 FDrestore();
}

//---------------------------------------------------------------------------
void TForm1::Indig_analysis(long nCol,long nColRes,int fl_feres,float shapecombo,int section_frame,int isectsw,float sectdval[])
// base_XXX/indat_XXX variables/arrays not passed in argument list (i.e. global, due to memory allocation)
{float dummy=0.;if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
 if(nColRes)FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
 if(section_frame==7)FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
	  indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
 else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
 else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
 else FDbase_indat(2,shapecombo,iplotflag,nColRes);
 if(fl_feres==1)
   {if(nCol>8){Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;ResultsForm=new TForm2(1,this);ResultsForm->Show();}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unavailable displ/stress results.",L"Failure",MB_OK);}
   }
 else if(fl_feres==2)
   {if(nCol>0){Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;
               if(nCol==1)ResultsForm=new TForm2(31,this);
               else if(nCol==6)ResultsForm=new TForm2(32,this); // New CAP format
               else ResultsForm=new TForm2(30,this);ResultsForm->Show();
              }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unreadable results.",L"Halt",MB_OK);}
   }
 else if(fl_feres==3)
   {if(nCol>2){Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;
			   ResultsForm=new TForm2(20,this);ResultsForm->Show();
			  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unreadable displ results.",L"Halt",MB_OK);}
   }
 else if(fl_feres==4)
   {if(nCol>14){Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;
				ResultsForm=new TForm2(41,this);ResultsForm->Show();
			   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unavailable displ/stress/plastic strain results.",L"Failure",MB_OK);}
   }
 else if(fl_feres==9)
   {if(nCol>0){Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;
			   ResultsForm=new TForm2( -nColRes,this);ResultsForm->Show();
			  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unavailable generic analysis results.",L"Failure",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported analysis result in this version.",L"Failure",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::QueryNodeExecute(TObject *Sender)
{if(base.nop1){if(iPaintyesno/10)
//               FD_LButtonstatus=2;
	{FD_LButtonstatus=2;
	 Screen->Cursor=crCross;
	}
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Use VIEW/PAINT to paint",L"Halt",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"16Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::NodalDistanceExecute(TObject *Sender)
////{if(base.nop1){if(iPaintyesno/10)FD_LButtonstatus=4;
{if(base.nop1){if(iPaintyesno/10)
//               FD_LButtonstatus=21;//Changed to facilitate VFTgen
	{FD_LButtonstatus=21;
	 Screen->Cursor=crCross;
	}
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Use VIEW/PAINT to paint",L"Halt",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"17Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
long TForm1::FDnode_interrog1(int X,int Y,long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[])
// Global NDF,MXNPEI
// Policy: Consider only nodes on visible facets nFace (i.e. hidden nodes will never be selected).
//         Use highest-z node (iprez) within TOL graphical distance of (X,Y). If unavailable, use nearest node found (iprec).
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int is=0,npts=0;long iprec=0,iprez=0,ip=0,ic=0,ie=0,fType=0,iside=0,eltype=0,t3=1000,t7=10000000;
 float diff=0.,diffmin=0.,zmax=0.,TOL=5.,TOLSQ=TOL*TOL;diffmin=1.E28;zmax= -1.e28;iprez= -1; // Note that TOL measures graphical units (i.e. screen)
 for(ic=0;ic<nFace;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;eltype=indat_matno[ie]/t7;
	if(eltype==5)for(is=0;is<3;is++){ip=indat_nop1[MXNPEI*ie+gdata4[3*iside+is]];
									 diff=(indat_c1[NDF*ip  ]-float(X))*(indat_c1[NDF*ip  ]-float(X))+(indat_c1[NDF*ip+1]-float(ClientHeight-Y))*(indat_c1[NDF*ip+1]-float(ClientHeight-Y));
									 if(diff<TOLSQ && zmax<indat_c1[NDF*ip+2]){iprez=ip;zmax=indat_c1[NDF*iprez+2];}else if(diffmin>diff){diffmin=diff;iprec=ip;}
									}
	else if(eltype==7){if(iside>2)npts=3;else npts=4;
					   for(is=0;is<npts;is++){ip=indat_nop1[MXNPEI*ie+gdata6[4*iside+is]];
											  diff=(indat_c1[NDF*ip  ]-float(X))*(indat_c1[NDF*ip  ]-float(X))+(indat_c1[NDF*ip+1]-float(ClientHeight-Y))*(indat_c1[NDF*ip+1]-float(ClientHeight-Y));
											  if(diff<TOLSQ && zmax<indat_c1[NDF*ip+2]){iprez=ip;zmax=indat_c1[NDF*iprez+2];}else if(diffmin>diff){diffmin=diff;iprec=ip;}
											 }
					  }
	else for(is=0;is<4;is++){ip=indat_nop1[MXNPEI*ie+gdata8[4*iside+is]];
							 diff=(indat_c1[NDF*ip  ]-float(X))*(indat_c1[NDF*ip  ]-float(X))+(indat_c1[NDF*ip+1]-float(ClientHeight-Y))*(indat_c1[NDF*ip+1]-float(ClientHeight-Y));
							 if(diff<TOLSQ && zmax<indat_c1[NDF*ip+2]){iprez=ip;zmax=indat_c1[NDF*iprez+2];}else if(diffmin>diff){diffmin=diff;iprec=ip;}
							}
   }
//honk<<X<<" "<<ClientWidth<<" X/Ygraph "<<Y<<" "<<ClientHeight<<" ip "<<iprez<<" "<<iprec<<"\n";
 if(iprez>=0)return iprez;else return iprec;
}
//---------------------------------------------------------------------------
void TForm1::FDelem_interrog1(int X,int Y,long *eprec,long *sprec,float *RN1,float *RN2,float *RN3,
  long indat_nop1[],long indat_matno[],float indat_c1[],long nFace,long arbFace[])
// Global NDF,MXNPEI
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 int is=0,isp=0,npts=0,icount=0;long ic=0,ie=0,fType=0,iside=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000;
 float xave=0.,yave=0.,zave=0.,xmin=0.,xmax=0.,ymin=0.,ymax=0.,zmax=0.,cave=0.,cs=0.,cpt=0.,ZP=0.,RN1s=0.,RN2s=0.,RN3s=0.,
   dx=0.,dy=0.,TOLSUB=0.0001;zmax= -1.E28; *eprec= -1;
 for(ic=0;ic<nFace;ic++)
   {ie=arbFace[ic]/t3;fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
	eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
	xmin=ymin=1.E28;xmax=ymax= -1.E28;
	if(eltype==5){npts=3;for(is=0;is<npts;is++){if(xmin>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ])xmin=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ];
												if(xmax<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ])xmax=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ];
												if(ymin>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+1])ymin=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+1];
												if(ymax<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+1])ymax=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+1];
											   }
				 }
	else if(eltype==7){if(iside>2)npts=3;else npts=4;
					   for(is=0;is<npts;is++){if(xmin>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ])xmin=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ];
											  if(xmax<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ])xmax=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ];
											  if(ymin>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+1])ymin=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+1];
											  if(ymax<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+1])ymax=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+1];
											 }
					  }
	else {npts=4;for(is=0;is<npts;is++){if(xmin>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ])xmin=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ];
										if(xmax<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ])xmax=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ];
										if(ymin>indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+1])ymin=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+1];
										if(ymax<indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+1])ymax=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+1];
									   }
		 }
	if(float(X)>=xmin)
	  {if(float(X)<=xmax)
		 {if(float(ClientHeight-Y)>=ymin)
			{if(float(ClientHeight-Y)<=ymax)
			   {xave=yave=zave=0.;
				if(eltype==5)for(is=0;is<npts;is++){xave=xave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ];
													yave=yave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+1];
													zave=zave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+2];
												   }
				else if(eltype==7)for(is=0;is<npts;is++){xave=xave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ];
														 yave=yave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+1];
														 zave=zave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+2];
														}
				else for(is=0;is<npts;is++){xave=xave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ];
											yave=yave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+1];
											zave=zave+indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+2];
										   }
				xave=xave/float(npts);yave=yave/float(npts);zave=zave/float(npts);icount=0;
				for(is=0;is<npts;is++)
				  {isp=is+1;if(isp>=npts)isp=0;
				   if(eltype==5){dx=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+isp]]  ]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ];
								 dy=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+isp]]+1]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+1];
								 if(fabs(dx)>1.e-10){cs=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]+1]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ]*dy/dx;
													 cave=yave-xave*dy/dx;cpt=float(ClientHeight-Y)-float(X)*dy/dx;
													}
								 else {cs=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata4[3*iside+is]]  ];cave=xave;cpt=float(X);}
								}
				   else if(eltype==7){dx=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+isp]]  ]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ];
									  dy=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+isp]]+1]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+1];
									  if(fabs(dx)>1.e-10){cs=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]+1]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ]*dy/dx;
														  cave=yave-xave*dy/dx;cpt=float(ClientHeight-Y)-float(X)*dy/dx;
														 }
									  else {cs=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata6[4*iside+is]]  ];cave=xave;cpt=float(X);}
									 }
				   else {dx=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+isp]]  ]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ];
						 dy=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+isp]]+1]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+1];
						 if(fabs(dx)>1.e-10){cs=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]+1]-indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ]*dy/dx;
											 cave=yave-xave*dy/dx;cpt=float(ClientHeight-Y)-float(X)*dy/dx;
											}
						 else {cs=indat_c1[NDF*indat_nop1[MXNPEI*ie+gdata8[4*iside+is]]  ];cave=xave;cpt=float(X);}
						}
				   if((cave-cs)*(cpt-cs)>0.)icount++;else break;
				  }
				if(icount==npts){homsubm(ie,iside,float(X),float(ClientHeight-Y),&ZP,&RN1s,&RN2s,&RN3s,xave,yave,zave,node,eltype,indat_nop1+MXNPEI*ie,indat_c1,TOLSUB);
								 if(zmax<ZP){zmax=ZP; *eprec=ie; *sprec=iside; *RN1=RN1s; *RN2=RN2s; *RN3=RN3s;}
								}
			   }
			}
		 }
	  }
   }
}
//---------------------------------------------------------------------------
void TForm1::FDelem_interrogpt1(long ie,long iside,long eltype,long node,float xnat,float ynat,float znat,
  float *xave,float *yave,float *zave,float *xnor,float *ynor,float *znor,float *rave,float *area,
  long base_nop1[],long indat_nop1[],float base_c1[],float indat_result[])
// Global NDF,MXNPEL,MXNPEI
{int is=0;
 float xn=0.,yn=0.,zn=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],PRMT=1.E-5;
 *xave= *yave= *zave= *rave=0.;
	if(eltype==5)
	  {if(node==4)STFISO4(1,xnat,ynat,znat,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   else       STFISO10(1,xnat,ynat,znat,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   for(is=0;is<node;is++){*xave= *xave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
							  *yave= *yave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
							  *zave= *zave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
							  if(fl_feres)*rave= *rave+SN[is]*indat_result[indat_nop1[MXNPEI*ie+is]];
							 }
	   if(iside==0){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat; // STFISO4(ISL,G,E,T...) where S=1-G-E-T=0
					if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
					if(znat<PRMT)zn=2.*PRMT;else zn=znat;
					zn=1.-xn-yn;
				   }
	   else if(iside==1){xn=0.; // G=0
						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
						 if(znat<PRMT)zn=2.*PRMT;else zn=znat;
						}
	   else if(iside==2){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat; // E=0
						 yn=0.;
						 if(znat<PRMT)zn=2.*PRMT;else zn=znat;
						}
	   else {if(xnat<PRMT)xn=2.*PRMT;else xn=xnat; // T=0
			 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
			 zn=0.;
			}
	   if(node==4)STFISO4(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   else       STFISO10(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   *area=DJD; //Check this tetra element facet area
	  }
	else if(eltype==7)
	  {if(node==6)STFISO6(1,xnat,ynat,znat,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   else       STFISO15(1,xnat,ynat,znat,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   for(is=0;is<node;is++){*xave= *xave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
							  *yave= *yave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
							  *zave= *zave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
							  if(fl_feres)*rave= *rave+SN[is]*indat_result[indat_nop1[MXNPEI*ie+is]];
							 }
	   if     (iside==0){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
						 yn=1.-xn;
						}
	   else if(iside==1){xn=0.;
						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
						}
	   else if(iside==2){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
						 yn=0.;
						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
						}
	   else if(iside==3){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
						 zn= -1.;
						}
	   else {if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
			 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
			 zn=1.;
			}
	   if(node==6)STFISO6(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   else       STFISO15(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   if(iside<3) *area=DJD;else *area=DJD/2.; //Check this wedge element facet area
	  }
	else
	  {if(node==8)STFISO8(1,xnat,ynat,znat,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   else       STFISO20(1,xnat,ynat,znat,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   for(is=0;is<node;is++){*xave= *xave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
							  *yave= *yave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
							  *zave= *zave+SN[is]*base_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
							  if(fl_feres)*rave= *rave+SN[is]*indat_result[indat_nop1[MXNPEI*ie+is]];
							 }
	   if(iside==0){if(xnat< -1.+2.*PRMT)xn= -1.+2.*PRMT;else if(xnat> 1.-2.*PRMT)xn=1.-2.*PRMT;else xn=xnat;
					yn= -1.;
					if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
				   }
	   else if(iside==1){xn=1.;
						 if(ynat< -1.+2.*PRMT)yn= -1.+2.*PRMT;else if(ynat> 1.-2.*PRMT)yn=1.-2.*PRMT;else yn=ynat;
						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
						}
	   else if(iside==2){if(xnat< -1.+2.*PRMT)xn= -1.+2.*PRMT;else if(xnat> 1.-2.*PRMT)xn=1.-2.*PRMT;else xn=xnat;
						 yn=1.;
						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
						}
	   else if(iside==3){xn= -1.;
						 if(ynat< -1.+2.*PRMT)yn= -1.+2.*PRMT;else if(ynat> 1.-2.*PRMT)yn=1.-2.*PRMT;else yn=ynat;
						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
						}
	   else if(iside==4){if(xnat< -1.+2.*PRMT)xn= -1.+2.*PRMT;else if(xnat> 1.-2.*PRMT)xn=1.-2.*PRMT;else xn=xnat;
						 if(ynat< -1.+2.*PRMT)yn= -1.+2.*PRMT;else if(ynat> 1.-2.*PRMT)yn=1.-2.*PRMT;else yn=ynat;
						 zn= -1.;
						}
	   else {if(xnat< -1.+2.*PRMT)xn= -1.+2.*PRMT;else if(xnat> 1.-2.*PRMT)xn=1.-2.*PRMT;else xn=xnat;
			 if(ynat< -1.+2.*PRMT)yn= -1.+2.*PRMT;else if(ynat> 1.-2.*PRMT)yn=1.-2.*PRMT;else yn=ynat;
			 zn=1.;
			}
	   if(node==8)STFISO8(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   else       STFISO20(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	   *area=4.*DJD;
	  }
 *xnor=HN[0]; *ynor=HN[1]; *znor=HN[2];
}
////---------------------------------------------------------------------------
//void __fastcall TForm1::CrackGrowthExecute(TObject *Sender)
//{if(base.nop1){if(nDefects){iSpecCrack= -2;FDrestore(); // -2 to switch off crackplot initially
//							iSpecCrack=0;Timer1->Interval=TIMER_INTV;Timer1->Enabled=true;
//						   }
//			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get crack data first-->Show/Import",L"Halt",MB_OK);}
//			  }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"18Get geometry file->File/Open",L"Halt",MB_OK);}
//}
//---------------------------------------------------------------------------
void __fastcall TForm1::GitGo(TObject *Sender)     // CrackGrowth subroutine; Draw directly on Canvas
{
/*
 int iaseg=0,nanglesegs=0;long ic=iSpecCrack;
 float theta=0.,deltheta=0.,rc11=0.,rc21=0.,rc12=0.,rc22=0.,pi=4.*atan(1.);
 if(ShowElliptic1->Checked)
   {Canvas->MoveTo(int(CrackCor[9*ic+3*0+0]+0.5),ClientHeight-int(CrackCor[9*ic+3*0+1]+0.5));
	rc11=CrackCor[9*ic+3*1+0]-CrackCor[9*ic+3*0+0];rc21=CrackCor[9*ic+3*1+1]-CrackCor[9*ic+3*0+1];
	rc12=CrackCor[9*ic+3*2+0]-CrackCor[9*ic+3*0+0];rc22=CrackCor[9*ic+3*2+1]-CrackCor[9*ic+3*0+1];
	if(bCrackAng[2*ic+1]-bCrackAng[2*ic]>0.75*pi)nanglesegs=18*2;else nanglesegs=18;
	deltheta=180.*(bCrackAng[2*ic+1]-bCrackAng[2*ic])/(pi*float(nanglesegs));theta=180.*bCrackAng[2*ic]/pi -deltheta;
	for(iaseg=0;iaseg<nanglesegs+1;iaseg++)
	  {if(iaseg)Canvas->Pen->Width=1;else Canvas->Pen->Width=2;theta=theta+deltheta;
	   Canvas->LineTo(int(cos(theta*pi/180.)*rc11+sin(theta*pi/180.)*rc12+CrackCor[9*ic+3*0+0]+0.5),
					  ClientHeight-int(cos(theta*pi/180.)*rc21+sin(theta*pi/180.)*rc22+CrackCor[9*ic+3*0+1]+0.5));
	  }
	Canvas->Pen->Width=2;Canvas->LineTo(int(CrackCor[9*ic+3*0+0]+0.5),ClientHeight-int(CrackCor[9*ic+3*0+1]+0.5));
	Canvas->Pen->Width=1;
   }
 else
   {Canvas->Brush->Color=clWhite;
	Canvas->Ellipse(int(CrackCor[9*ic+0]+0.5)-3,ClientHeight-int(CrackCor[9*ic+1]+0.5)+3,
					int(CrackCor[9*ic+0]+0.5)+3,ClientHeight-int(CrackCor[9*ic+1]+0.5)-3);
   }

 iSpecCrack++;if(iSpecCrack==nDefects){iSpecCrack= -1;Timer1->Enabled=false;}
*/
 }

//---------------------------------------------------------------------------
void TForm1::invdet(long n,long j[],float c[])
// Storage cij   c11,c12,c13... rowwise;    j[n], c[n*n] ----------> NOTE: c[] IS DESTROYED...
{long l=0,k=0,m=0;float cc=0.,s=0.,TOL=0.0001;for(l=0;l<n;l++)j[l]=l;
 for(l=0;l<n;l++){cc=0.;m=l;for(k=l;k<n;k++){if(fabs(cc)-fabs(c[n*l+k])<0.){m=k;cc=c[n*l+k];}}
				  if(l!=m){k=j[m];j[m]=j[l];j[l]=k;for(k=0;k<n;k++){s=c[n*k+l];c[n*k+l]=c[n*k+m];c[n*k+m]=s;}}
				  c[n*l+l]=1.;
if(fabs(cc)<1.e-15){honk<<cc<<"  Noninvertible invdet: CC\n";exit(0);}
				  for(m=0;m<n;m++)c[n*l+m]=c[n*l+m]/cc;
				  for(m=0;m<n;m++){if(l!=m){cc=c[n*m+l];if(fabs(cc)>TOL){c[n*m+l]=0.;for(k=0;k<n;k++)c[n*m+k]=c[n*m+k]-cc*c[n*l+k];}}}
				 }
 for(l=0;l<n;l++){if(j[l]!=l){for(m=l+1;m<n;m++){if(j[m]==l || m==n-1)break;}j[m]=j[l];for(k=0;k<n;k++){cc=c[n*l+k];c[n*l+k]=c[n*m+k];c[n*m+k]=cc;}j[l]=l;}}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::QueryElementExecute(TObject *Sender)
{if(base.nop1){if(iPaintyesno/10)
//FD_LButtonstatus=3;
	{FD_LButtonstatus=3;
	 Screen->Cursor=crCross;
	}
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Use VIEW/PAINT to paint",L"Halt",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"20Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AnimResultExecute(TObject *Sender)
{if(base.nop1)
   {if(fl_feres)
	  {if(iResSel>=0){GIFsw=0;iSpecRes=0;Timer2->Interval=TIMER_INTV;Timer2->Enabled=true;}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must use ResultSelector first",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get result file by Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"21Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AnimResSnapExecute(TObject *Sender)
{if(base.nop1)
   {if(fl_feres)
	  {if(iResSel>=0){GIFsw=1;GIFcount=0;iSpecRes=0;Timer2->Interval=TIMER_INTV;Timer2->Enabled=true;}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must use ResultSelector first",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get result file by Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"22Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AnimMultiResultExecute(TObject *Sender) //Attempt to animate instantaneous weld metal
{//float rmax=0.,rmin=0.;
// int *iswFace=NULL;
 long eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 long i=0;float rmax= -1.e20,rmin=1.e20;

/////////////////////////
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported in this version",L"Halt",MB_OK);
if(1==1)return;
/////////////////////////

 if(base.nop1)
//   {if(fl_feres==1 || fl_feres==2 || fl_feres==4)
   {if(fl_feres==1 || fl_feres==2 || fl_feres==4 || fl_feres==9)
	  {if(iResSel>=0){GIFsw=0;

//	  trash=nMultFile;

					  MultiResultLeg(&rmax,&rmin,fl_feres,nColRes,nDefects,section_frame,isectsw,shapecombo,sectdval,iplotflag,iResSel,&nMultFile);

//honk<<trash<<" pre/post nMultFile "<<nMultFile<<"\n";

					  iswFace=new int[nFacets*nMultFile];
					  if(iswFace){if(Legend_auto->Checked)
											  {Legend_auto->Checked=false;
											   Legend_custom->Checked=1-Legend_auto->Checked;
											   leg_rmax=rmax;leg_rmin=rmin;
											  }
//////////////////////// Don't ever do this again...
///////////nMultFile=36-1;
for(i=1;i<MAX_GID;i++)arGID[i]=0;
iCullyesno=0;
arGID[0]=1;

// iplotType=2;iPaintyesno=0;
// for(i=0;i<base.nelt;i++)base.arELEM[i]=0;
// for(i=0;i<base.nelt;i++)
//	{eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//	 if(ieGID>3)base.arELEM[i]=1;
//	}


////FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
//FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
//iPaintyesno=10+1;iCullyesno=0;


for(i=0;i<64;i++)honk<<i+1<<" "<<timeVFTarr[i]<<" "<<timeVEDarr[i]<<"\n";
//for(i=0;i<wp.VEDsteps;i++)honk<<i+1<<" "<<wpRes.timeVFTarr[i]<<" "<<wpRes.timeVEDarr[i]<<"\n";
//if(1==1)exit(0);
////////////////////////
honk<<leg_rmax<<" "<<leg_rmin<<" "<<nMultFile<<" "<<nFacets<<" "<<nColContour<<" leg_rmax=rmax;leg_rmin=rmin;\n";
//for(i=0;i<nColContour+1;i++)honk<<i+1<<" "<<ColContour[i]<<" ColCon\n";
								  Legend_auto->Checked=true;
								  for(i=0;i<indat.npoin;i++)indat.result[i]=25.;
								  for(i=0;i<nFacets;i++)mutFacet[i]=25.;
								  CmContour_Lg(rmin,rmax);

								  for(i=0;i<nFacets*nMultFile;i++)iswFace[i]=0;
								  FDprecontour(iswFace,nMultFile);
//FDpreGID(iswFace,nMultFile,nFacets,arbFacet,arGID); //Coding in 3.14 Perhaps this should use arELEM[]?
////////////////////////////////////////////////////////// Coding imported from 3.13
FDpreGID(iswFace,nMultFile,nFacets,arbFacet,arGID);
iCullyesno=1;
//////////////////////////////////////////////////////////
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Show VFT weld animation?",L"Notice",MB_OK);

////								  iSpecRes=0;Timer3->Interval=TIMER_INTV*4;Timer3->Enabled=true;
						  iSpecRes=0;Timer3->Interval=TIMER_INTV*2;Timer3->Enabled=true;
//								  iSpecRes=0;Timer3->Interval=TIMER_INTV*2;Timer3->Enabled=false;
								 }
					  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient memory in AnimMultiResultExecute()",L"Terminate",MB_OK);exit(0);}
					 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must use ResultSelector first",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get stress/thermal result file by Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"23Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AnimMultiResGIFExecute(TObject *Sender)
{//float rmax=0.,rmin=0.;
 float rmax= -1.e20,rmin=1.e20;
/////////////////////////
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported in this version",L"Halt",MB_OK);
if(1==1)return;
/////////////////////////
 if(base.nop1)
//   {if(fl_feres==1 || fl_feres==2 || fl_feres==4)
   {if(fl_feres==1 || fl_feres==2 || fl_feres==4 || fl_feres==9)
	  {if(iResSel>=0){GIFsw=1;GIFcount=0;
					  MultiResultLeg(&rmax,&rmin,fl_feres,nColRes,nDefects,section_frame,isectsw,shapecombo,sectdval,iplotflag,iResSel,&nMultFile);
					  if(Legend_auto->Checked){Legend_auto->Checked=false;Legend_custom->Checked=1-Legend_auto->Checked;leg_rmax=rmax;leg_rmin=rmin;}
					  iSpecRes=0;Timer3->Interval=TIMER_INTV;Timer3->Enabled=true;
					 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must use ResultSelector first",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get stress/thermal result file by Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"24Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::MultiResultLeg(float *rmax,float *rmin,int fl_feres,long nColRes,long nDefects,
  int section_frame,int isectsw,float shapecombo,float sectdval[],int iplotflag,int iResSel,int *nMultFile)
// Global MAX_RESCOL,MXNPEI
// base_XXX/indat_XXX variables/arrays not passed in argument list due to memory allocation (i.e. global)
{float sres[9];
// long in=0,ibg=0,ip=0,i=0,np3=0,nwid=0,dummy=0;
 long in=0,ip=0,i=0,dummy=0;
 char descript0[MAX_RESCOL*13+8+1],descript1[15];
// int indic[MAX_RESCOL+1],nic=0,nrc=0,nMFile=0;
 int indic[MAX_RESCOL+1];
 long larr[MAX_RESCOL];
// int value=0,div=1,is=0;
 int is=0;
 char string[2],mResname[9];
// ifstream ntape;
// if(fl_feres==1 || fl_feres==4){mResname[ 0]='s';mResname[ 1]='t';mResname[ 2]='r';mResname[ 3]='s';mResname[ 4]='.';mResname[8]='\0';}
// else if(fl_feres==2){mResname[ 0]='c';mResname[ 1]='a';mResname[ 2]='p';mResname[ 3]='n';mResname[ 4]='.';mResname[8]='\0';}
// else if(fl_feres==9){mResname[ 0]='g';mResname[ 1]='e';mResname[ 2]='n';mResname[ 3]='r';mResname[ 4]='.';mResname[8]='\0';}
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported MultiResult Animation",L"Terminate",MB_OK);exit(0);}
// for(is=0;is<999+1;is++)
//   {div=1;for(i=0;i<3;i++){value=(is-10*div*(is/(10*div)))/div;div=10*div;itoa(value,string,10);mResname[7-i]=string[0];}
//    ntape.open(mResname,ios::nocreate,0);if(!ntape)break;else nMFile++;
//    if(ntape)
//         {ntape.getline(descript0,MAX_RESCOL*13+8+1);ntape.getline(descript0,MAX_RESCOL*13+8+1);
//          indic[0]=0;indic[1]=0;indic[2]=1;indic[3]=0;indic[4]=0;
//          parse_cdms(descript0,5,&nic,&nrc,larr,sres,indic);np3=larr[0];nwid=larr[3];
//          ntape.getline(descript0,MAX_RESCOL*13+8+1);ntape.getline(descript0,MAX_RESCOL*13+8+1);
//		  if(np3 != base.npoin){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Results file inconsistent with geom.file",L"Failure",MB_OK);exit(0);}
//		  if(nwid<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No columns in results file",L"Failure",MB_OK);exit(0);}
//		  if(fl_feres==1 && nwid<9){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Results file->Insuff.columns for stress analysis",L"Failure",MB_OK);return;}
//		  else if(fl_feres==3 && nwid<3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Results file->Insuff.columns for modal analysis",L"Failure",MB_OK);return;}
//		  else if(fl_feres==4 && nwid<15){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Results file->Insuff.columns for stress/strain analysis",L"Failure",MB_OK);return;}
//		  if(nColRes)FDdynmem_manage(-3,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
//		  nColRes=nwid;FDdynmem_manage(3,base.npoin,dummy,dummy,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
//	  for(i=0;i<np3;i++){ntape.getline(descript0,MAX_RESCOL*13+8+1);parse_cdCAP(descript0,10,&nic,&nrc,larr,sres);
//							 for(ibg=0;ibg<nColRes;ibg++){if(nwid>ibg)base.res1[nColRes*i+ibg]=sres[ibg];else base.res1[nColRes*i+ibg]=0.;}
//							}
//		  ntape.close();

//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
 for(is=0;is< *nMultFile;is++)
   {
//honk<<is+1<<" "<<nColRes<<" New IS\n";
		  if(nColRes)FDdynmem_manage(-3,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
//          nColRes=nwid;
		  FDdynmem_manage(3,base.npoin,dummy,dummy,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
		  for(i=0;i<base.npoin;i++)base.res1[nColRes*0+i]=25.;
		  if(wpRes.wIndex[is]<wpRes.wIndex[is+1])
			for(in=wpRes.wIndex[is];in<wpRes.wIndex[is+1];in++){base.res1[nColRes*0+wpRes.wActiven[in]]=wpRes.wActiveR[in];
//honk<<wpRes.wActiven[in]+1<<" "<<wpRes.wActiveR[in]<<"\n";
															   }

 if(!Undeformedmesh1->Checked){
 if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
 if(section_frame==7)
   {FDsect_base_indatw_mem(isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
	  base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
	  indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else if(section_frame==4 || section_frame==5)
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else if(section_frame>0 && section_frame<4)
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else
   {FDbase_indat(1,shapecombo,iplotflag,nColRes);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
   }
					   }
		  else {FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   }
		  if(section_frame==7)FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
			indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
		  else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
		  else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
		  else FDbase_indat(2,shapecombo,iplotflag,nColRes);
		  if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
//         }
//	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"MRLCould not open result file",L"Failure",MB_OK);exit(0);}
	FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);
	for(ip=0;ip<indat.npoin;ip++){if(*rmax<indat.result[ip])*rmax=indat.result[ip];if(*rmin>indat.result[ip])*rmin=indat.result[ip];}
   }
// *nMultFile=nMFile;
// if(nMFile>999){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"#Results files exceeds 999 limit.",L"Terminate",MB_OK);exit(0);}


//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::FDprecontour(int *iswFace,int nMultFile)
// Global MAX_RESCOL,MXNPEI
// base_XXX/indat_XXX variables/arrays not passed in argument list due to memory allocation (i.e. global)
{int is=0,in=0;long i=0,icount=0;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//honk<<nMultFile<<" nMultFile\n";if(1==1)exit(0);
	 for(is=0;is<nMultFile;is++)
		 {icount=0;
//honk<<is+1<<" "<<nFacets<<" "<<nMultFile<<" PreNew IS\n";
		  for(i=0;i<indat.npoin;i++)indat.result[i]=25.;
		  if(wpRes.wIndex[is]<wpRes.wIndex[is+1])for(in=wpRes.wIndex[is];in<wpRes.wIndex[is+1];in++)indat.result[wpRes.wActiven[in]]=wpRes.wActiveR[in];
		  FDcontourplotC1(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet,mutFacet,iswFace+is*nFacets);

		  for(i=0;i<nFacets;i++){if(*(iswFace+is*nFacets+i))icount++;
//					   honk<<is+1<<" "<<i+1<<" "<< *(iswFace+is*nFacets+i)<<"\n";
								}
//honk<<is+1<<" "<<icount<<" ICOUNT\n";
		 }
//if(1==1)exit(0);
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::FDpreGID(int *iswFace,int nMultFile,long nFace,long arbFace[],long arGID[])
// Global MAX_RESCOL,MXNPEI
// base_XXX/indat_XXX variables/arrays not passed in argument list due to memory allocation (i.e. global)
{
// int is=0,in=0;
 int is=0;
 long i=0,icount=0;
// long ic=0,ie=0,fType=0,iside=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t4=10000,t5=100000,t7=10000000;
 long ic=0,ie=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//honk<<nMultFile<<" nMultFile\n";if(1==1)exit(0);
	 for(is=0;is<nMultFile;is++)
		 {icount=0;
////honk<<is+1<<" "<<nFacets<<" "<<nMultFile<<" PreNew IS\n";
//		  for(i=0;i<indat.npoin;i++)indat.result[i]=25.;
//		  if(wpRes.wIndex[is]<wpRes.wIndex[is+1])for(in=wpRes.wIndex[is];in<wpRes.wIndex[is+1];in++)indat.result[wpRes.wActiven[in]]=wpRes.wActiveR[in];
//		  FDcontourplotC1(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet,mutFacet,iswFace+is*nFacets);

		  for(i=0;i<wp.VEDsteps;i++){if(timeVEDarr[i]<=timeVFTarr[is])arGID[i+3]=1;
//		  for(i=0;i<wp.VEDsteps;i++){if(wpRes.timeVEDarr[i]<=wpRes.timeVFTarr[is])arGID[i+3]=1;
									 else break;
									}
		  for(ic=0;ic<nFace;ic++)
			{ie=arbFace[ic]/t3;
//			fType=(arbFace[ic]-ie*t3)/10;iside=arbFace[ic]-ie*t3-fType*10;
			 eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;
			 node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
//			 ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
////////////////// EFP 2/20/2012
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
//////////////////
			 if(ieGID>2)         //Cats ass coding
			   {if(arGID[ieGID]) *(iswFace+is*nFace+ic)=1;
				else *(iswFace+is*nFace+ic)=0;
			   }
			}

		  for(i=0;i<nFacets;i++){if(*(iswFace+is*nFace+i))icount++;
//					   honk<<is+1<<" "<<i+1<<" "<< *(iswFace+is*nFacets+i)<<"\n";
								}
//honk<<is+1<<" "<<icount<<" ICOUNT_GID\n";
		 }
//if(1==1)exit(0);
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::MultiResultGo(TObject *Sender) //TBD: Is this OK without test for model (base.nop1) EFP 3/22/2012
// Global MAX_RESCOL,MXNPEI
{
// int indic[MAX_RESCOL+1],nic=0,nrc=0,value=0,div=1
 int indic[MAX_RESCOL+1]
 ,*iswFace=NULL,*edgFace1=NULL
 ;
// long in=0,ibg=0,i=0,np3=0,nwid=0,dummy=0,larr[MAX_RESCOL]
 long in=0,i=0,dummy=0,larr[MAX_RESCOL]
 ,*arbFace1=NULL,*rbTem1=NULL
 ;
 long ntranche=8,icount3=0,iWP=0,iseg=0,icdiv=0,subdivGo=6,iup=0,eltype=0,bscode=0,node=0,ieGID=0,tf3=1000,tf5=100000,tf7=10000000;
 float rmax=0.,rmin=0.,sres[MAX_RESCOL];
 char descript0[MAX_RESCOL*13+8+1],descript1[15],string[2],mResname[9];
 MEMORYSTATUS ms;ms.dwLength=sizeof(MEMORYSTATUS);
//honk<<iSpecRes<<" MultiResultGo() "<<nMultFile<<"\n";
		  if(nColRes)FDdynmem_manage(-3,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
		  FDdynmem_manage(3,base.npoin,dummy,dummy,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
		  for(i=0;i<base.npoin;i++)base.res1[nColRes*0+i]=25.;
		  if(wpRes.wIndex[iSpecRes]<wpRes.wIndex[iSpecRes+1])
			for(in=wpRes.wIndex[iSpecRes];in<wpRes.wIndex[iSpecRes+1];in++)base.res1[nColRes*0+wpRes.wActiven[in]]=wpRes.wActiveR[in];

//		  if(wpRes.wIndex[iSpecRes+1]<wpRes.wIndex[iSpecRes+2])
//			for(in=wpRes.wIndex[iSpecRes+1];in<wpRes.wIndex[iSpecRes+2];in++)base.res1[nColRes*0+wpRes.wActiven[in]]=wpRes.wActiveR[in];

// for(i=0;i<base.nelt;i++)base.arELEM[i]=0;
// for(i=0;i<base.nelt;i++){
//	eltype=base.matno[i]/tf7;bscode=(base.matno[i]-eltype*tf7)/tf5;
//	node=(base.matno[i]-eltype*tf7-bscode*tf5)/tf3;ieGID=base.matno[i]-eltype*tf7-bscode*tf5-node*tf3;
//						  if(ieGID<iSpecRes+4)base.arELEM[i]=1;
//						 }
// iplotType=2;


/*
 if(!Undeformedmesh1->Checked){
 if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
 if(section_frame==7)
   {FDsect_base_indatw_mem(isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
	  base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
	  indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else if(section_frame==4 || section_frame==5)
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else if(section_frame>0 && section_frame<4)
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
   }
 else
   {FDbase_indat(1,shapecombo,iplotflag,nColRes);
	FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
   }
						FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;  // Minimize "blank screen" time by preprocessing
						nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
						try {
							 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];
							 }
						catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
						FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
						FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
						if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
					   }
		  else {FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   }
		  if(section_frame==7){FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
								 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
							   FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;   // Minimize "blank screen" time by preprocessing
							   nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
							   try {
									arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];
									}
							   catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}
							   FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
							   FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
						 try {
							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
							 }
						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
							   if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
							  }
		  else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
		  else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
		  else FDbase_indat(2,shapecombo,iplotflag,nColRes);
		  if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
 FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);rmin=leg_rmin;rmax=leg_rmax;CmContour_Lg(rmin,rmax);if(GIFsw)WriteGIF();
*/



/*
//iplotType=2;
 for(i=0;i<indat.npoin;i++)indat.result[i]=base.res1[nColRes*0+i];
//// iswFace=new int[nFacets];if(iswFace){
//// FDcontourplotC(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet,mutFacet,iswFace);
////									 }
//// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient memory in MultiResultGo()",L"Terminate",MB_OK);exit(0);}
 FDcontourplotCa(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet,
				 iswFace+iSpecRes*nFacets);


 for(i=0;i<wp.VEDsteps;i++){if(timeVEDarr[i]<=timeVFTarr[iSpecRes])arGID[i+3]=1;
// for(i=0;i<wp.VEDsteps;i++){if(wpRes.timeVEDarr[i]<=wpRes.timeVFTarr[iSpecRes])arGID[i+3]=1;
							else break;
						   }
 iCullyesno=0;rmin=leg_rmin;rmax=leg_rmax;CmContour_Lg(rmin,rmax);if(GIFsw)WriteGIF();
*/

arGID[iSpecRes+3]=1;

///////////////mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
							   for(i=0;i<base.nelt;i++)base.arELEM[i]=0;
							   icount3=0;
							   for(i=0;i<wp.memWGa;i++){if(wp.eles[wp.memWGa*iWP+i]>=0)icount3++;else break;}
							   icdiv=icount3/subdivGo;if(icdiv<1)icdiv=1;
							   if(iseg==subdivGo-1)iup=icount3;else iup=(iseg+1)*icdiv;
							   if(iup>icount3)iup=icount3;

							   for(i=0;i<iup;i++)base.arELEM[wp.eles[wp.memWGa*iWP+i]/10]=1;


							   for(i=0;i<base.nelt;i++)base.arELEM[i]= 0;
 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/tf7;bscode=(base.matno[i]-eltype*tf7)/tf5;
						  node=(base.matno[i]-eltype*tf7-bscode*tf5)/tf3;
//						  ieGID=base.matno[i]-eltype*tf7-bscode*tf5-node*tf3;
////////////////// EFP 2/20/2012
//	 if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[i+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[i+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[i]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[i+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[i];
//////////////////
////						  if(ieGID<iSpecRes+1)base.arELEM[i]=1;
//						  if(ieGID<iSpecRes+1 && ieGID!=1 && ieGID!=2)base.arELEM[i]=1;
						  if(ieGID<iSpecRes+4 && ieGID>wp.nWeldGroup)base.arELEM[i]=1;
//base.arELEM[ieGID]=1;
//						  if(ieGID==0)honk<<i<<" ZeroGId\n";
						 }
//for(i=0;i<base.nelt;i++)if(base.arELEM[i])honk<<i<<" "<<base.arELEM[i]<<"\n";exit(0);
////////////////////////////// start EFP 2/10/2011
/*
										  nFacets=FDcullfacet_arE_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM);
										  GlobalMemoryStatus(&ms);
										  if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
											{
											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
											 FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
											}
										  else if(4*(ms.dwAvailPhys/20)>unsigned(6*nFacets))
											{
											 arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
											 FDcullfacet_arE(indat.nelt,indat.nop1,indat.matno,indat.c1,base.arELEM,arbFacet);
											 FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
											 arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
											 FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
											 delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
											}
										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory to render.",L"Terminate",MB_OK);exit(0);}
										  if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);iCullyesno=1;
*/
////////////////////////////// end
							   FDpaintplot1(0,0,nFacets-1);
////							   icTimer5=icTimer5+1;
///////////////nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
//							   FDcontourplot(indat.nop1,indat.matno,indat.c1,indat.result,nFacets,arbFacet,rbTemp,edgFacet);


 iSpecRes++;if(iSpecRes==nMultFile){delete [] iswFace;iswFace=NULL;iSpecRes=0;GIFsw=0;Timer3->Enabled=false;}
// iSpecRes++;if(iSpecRes==nMultFile/100){iSpecRes=0;GIFsw=0;Timer3->Enabled=false;}
}
//---------------------------------------------------------------------------
void TForm1::FDrestore()
// Global everything (arrays NOT passed in argument list)
{//int *edgFace1=NULL;long *arbFace1=NULL,*rbTem1=NULL;
 long in=0,dummy=0,ntranche=8,ie=0,eltype=0,bscode=0,node=0,ieGID=0,ipid=0,t7=10000000,t5=100000,t3=1000;
 base.GIDcol=2; //Bugfix EFP 3/21/2012 Always prioritize WP when RESTOREing
 if(nDefects)for(in=0;in<nDefects*9;in++)CrackCor[in]=bCrackCor[in];
 if(section_frame==7)
   {FDsect_base_indatw_mem(isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
	  base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				}
	FDsect_base_indatw(1,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
	  indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

   }
 else if(section_frame==4 || section_frame==5)
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				}
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

   }
 else if(section_frame>0 && section_frame<4)
   {FDsect_base_indat_mem(isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,base.nelt,
		 base.nop1,base.matno,base.c1,base.res1,nColRes,&indat.nelt,&indat.npoin,&indat.nfsect);
	if(iplotflag)FDdynmem_manage(-2,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
	FDdynmem_manage(2,dummy,dummy,indat.npoin,indat.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,indat.nfsect,MXNPEI);
	if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				}
	FDsect_base_indat(1,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

////		  if(iPaintyesno/10==0){
								if(iPaintyesno-10*(iPaintyesno/10)){FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
////								iCullyesno=0;
////							   }
////		  iCircleplot=1;Invalidate();

   }
 else
   {FDbase_indat(1,shapecombo,iplotflag,nColRes);
	FDrot_status(indat.npoin,indat.c1,rot_op,nDefects,CrackCor);
//	FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);iPaintyesno=1;

								if(iPaintyesno-10*(iPaintyesno/10)){
																	FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }

	if(fl_feres){FDdynmem_manage(-4,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				 FDdynmem_manage(4,dummy,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
				 FDbase_indat(2,shapecombo,iplotflag,nColRes);
				}
   }
//// Minimize "blank screen" time by preprocessing
// nFacets=FDcullfacet_mem(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID);
// try {
//	  arbFacet=new long[nFacets];rbTemp=new long[nFacets];edgFacet=new int[nFacets];mutFacet=new float[nFacets];
	  arbFacet=new long[6*base.nelt];rbTemp=new long[6*base.nelt];edgFacet=new int[6*base.nelt];mutFacet=new float[6*base.nelt];
//	  }
// catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient cull dynamic memory",L"Halt",MB_OK);exit(0);}

/////////////////// Now obsolete BUT IS IT CORRECT TO Do THIS?
//for(ie=0;ie<base.nelt;ie++)
//	{eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
//	 ipid=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
//	 indat.matno[ie]=indat.matno[ie]-ipid+ieGID;

////honk<<ie<<" FDrest inm "<<indat.matno[ie]<<"\n";
//	}


// base.GIDcol=2; // Always prioritize WP when RESTOREing
 FDcomp_nGID(base.nelt,base.matno,&nGID,arGID);  //BUT THIS USES indat.arrELSET internally....

//for(ie=0;ie<6;ie++)honk<<ie<<" "<<arGID[ie]<<" arG\n";


// FDcullfacet(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet);
 nFacets=FDcullfacetc(indat.nelt,indat.nop1,indat.matno,indat.c1,arGID,arbFacet,rbTemp);
// FDorderfacet(indat.nop1,indat.matno,indat.c1,nFacets,arbFacet,rbTemp);
//// FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet);
 FDsort_low1(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,ntranche);
//						 try {
//							  arbFace1=new long[nFacets];rbTem1=new long[nFacets];edgFace1=new int[nFacets];
//							  FDsort_low(indat.nop1,indat.c1,nFacets,arbFacet,rbTemp,edgFacet,arbFace1,rbTem1,edgFace1);
//							  delete [] arbFace1;delete [] rbTem1;delete [] edgFace1;
//						 }
//						 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient FDsort_low dynamic memory",L"Halt",MB_OK);exit(0);}
 if(!ShowFEMesh->Checked)FDculledge(indat.nop1,indat.matno,indat.bc1,nFacets,arbFacet,edgFacet);
 iplotflag=1;iCullyesno=1;
///////////////// EFP 2/28/2012
// base.GIDcol=2; // Always prioritize WP when RESTOREing
// FDcomp_nGID(base.nelt,base.matno,&nGID,arGID);
////////////// EFP 2/29/2012
//for(ie=0;ie<base.nelt;ie++)
//	{eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
//	 ipid=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
//	 indat.matno[ie]=indat.matno[ie]-ipid+ieGID;
//	}
////////////////
/////////////////
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
// float rangleSPEC[3];rangleSPEC[0]=rangleSPEC[1]=rangleSPEC[2]=0.;
// FDrotate_axisplot(0,rangleSPEC); //EFP 9/17/2010
 axis_plot_init();
// FDrotate_axisplot(1,rangle); //EFP 9/17/2010
 axis_plotXYZ(ClientWidth,ClientHeight);
 if(fl_feres){if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  FDsel_res(iResSel,indat.npoin,indat.res1,indat.result,nColRes,fl_feres);CmContour();
			 }
 else {iCircleplot=1;Invalidate();}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Cart_frameExecute(TObject *Sender)
{if(fl_feres){Cartesian1->Checked=true;Cylindframe1->Checked=false;Spherframe1->Checked=false;
			  if(section_frame==7)FDsect_base_indatw(2,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else FDbase_indat(2,shapecombo,iplotflag,nColRes);
			  if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
			  if     (fl_feres==1)ResultsForm=new TForm2(1,this);
			  else if(fl_feres==2){if(nColRes==1)ResultsForm=new TForm2(31,this);
								   else if(nColRes==6)ResultsForm=new TForm2(32,this);
								   else ResultsForm=new TForm2(30,this);
								  }
			  else if(fl_feres==3)ResultsForm=new TForm2(20,this);
////////// TForm2
			  else if(fl_feres==4)ResultsForm=new TForm2(41,this);
			  else ResultsForm=new TForm2( -nColRes,this);
			  ResultsForm->Show();
			 }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Cyl_XframeExecute(TObject *Sender)
{if(fl_feres){Cartesian1->Checked=false;Cylindframe1->Checked=true;Spherframe1->Checked=false;
			  CylXaxis1->Checked=true;CylYaxis1->Checked=false;CylZaxis1->Checked=false;CylGaxis1->Checked=false;
			  if(section_frame==7)FDsect_base_indatw(2,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else FDbase_indat(2,shapecombo,iplotflag,nColRes);
//              if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(fl_feres==1)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==2 && nColRes==6)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==3)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
			  if     (fl_feres==1)ResultsForm=new TForm2(2,this);
			  else if(fl_feres==2){if(nColRes==1)ResultsForm=new TForm2(31,this);
								   else if(nColRes==6)ResultsForm=new TForm2(33,this);
								   else ResultsForm=new TForm2(30,this);
								  }
			  else if(fl_feres==3)ResultsForm=new TForm2(21,this);
////////// TForm2
			  else if(fl_feres==4)ResultsForm=new TForm2(42,this);
			  else ResultsForm=new TForm2( -nColRes,this);
			  ResultsForm->Show();
			 }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Cyl_YframeExecute(TObject *Sender)
{if(fl_feres){Cartesian1->Checked=false;Cylindframe1->Checked=true;Spherframe1->Checked=false;
			  CylXaxis1->Checked=false;CylYaxis1->Checked=true;CylZaxis1->Checked=false;CylGaxis1->Checked=false;
			  if(section_frame==7)FDsect_base_indatw(2,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else FDbase_indat(2,shapecombo,iplotflag,nColRes);
//              if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(fl_feres==1)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==2 && nColRes==6)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==3)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
			  if     (fl_feres==1)ResultsForm=new TForm2(2,this);
			  else if(fl_feres==2){if(nColRes==1)ResultsForm=new TForm2(31,this);
								   else if(nColRes==6)ResultsForm=new TForm2(33,this);
								   else ResultsForm=new TForm2(30,this);
								  }
			  else if(fl_feres==3)ResultsForm=new TForm2(21,this);
////////// TForm2
			  else if(fl_feres==4)ResultsForm=new TForm2(42,this);
			  else ResultsForm=new TForm2( -nColRes,this);
			  ResultsForm->Show();
			 }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Cyl_ZframeExecute(TObject *Sender)
{if(fl_feres){Cartesian1->Checked=false;Cylindframe1->Checked=true;Spherframe1->Checked=false;
			  CylXaxis1->Checked=false;CylYaxis1->Checked=false;CylZaxis1->Checked=true;CylGaxis1->Checked=false;
			  if(section_frame==7)FDsect_base_indatw(2,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else FDbase_indat(2,shapecombo,iplotflag,nColRes);
//              if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(fl_feres==1)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==2 && nColRes==6)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==3)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
			  if     (fl_feres==1)ResultsForm=new TForm2(2,this);
			  else if(fl_feres==2){if(nColRes==1)ResultsForm=new TForm2(31,this);
								   else if(nColRes==6)ResultsForm=new TForm2(33,this);
								   else ResultsForm=new TForm2(30,this);
								  }
			  else if(fl_feres==3)ResultsForm=new TForm2(21,this);
////////// TForm2
			  else if(fl_feres==4)ResultsForm=new TForm2(42,this);
			  else ResultsForm=new TForm2( -nColRes,this);
			  ResultsForm->Show();
			 }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Cyl_GframeExecute(TObject *Sender)
{if(fl_feres){GenCylAxForm=new TForm10(genaxispts[0],genaxispts[1],genaxispts[2],genaxispts[3],genaxispts[4],genaxispts[5],this);
			  GenCylAxForm->ShowModal();delete GenCylAxForm;GenCylAxForm=NULL;
             }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::genaxhea_public()
{genaxispts[0]=GenCylAxForm->GAxC0;genaxispts[1]=GenCylAxForm->GAxC1;
 genaxispts[2]=GenCylAxForm->GAxC2;genaxispts[3]=GenCylAxForm->GAxC3;
 genaxispts[4]=GenCylAxForm->GAxC4;genaxispts[5]=GenCylAxForm->GAxC5;
 float rad=sqrt((genaxispts[3]-genaxispts[0])*(genaxispts[3]-genaxispts[0])+
				 (genaxispts[4]-genaxispts[1])*(genaxispts[4]-genaxispts[1])+
				 (genaxispts[5]-genaxispts[2])*(genaxispts[5]-genaxispts[2]));
 if(rad< 0.01){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Enter separate origin/axis points",L"Halt",MB_OK);return;}
 else {Cartesian1->Checked=false;Cylindframe1->Checked=true;Spherframe1->Checked=false;
	   CylXaxis1->Checked=false;CylYaxis1->Checked=false;CylZaxis1->Checked=false;CylGaxis1->Checked=true;
	   if(section_frame==7)FDsect_base_indatw(2,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	   else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	   else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
		 indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
	   else FDbase_indat(2,shapecombo,iplotflag,nColRes);
//       if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	   if(fl_feres==1)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	   else if(fl_feres==2 && nColRes==6)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	   else if(fl_feres==3)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	   else if(fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
	   if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
	   if     (fl_feres==1)ResultsForm=new TForm2(2,this);
	   else if(fl_feres==2){if(nColRes==1)ResultsForm=new TForm2(31,this);
							else if(nColRes==6)ResultsForm=new TForm2(33,this);
							else ResultsForm=new TForm2(30,this);
						   }
	   else if(fl_feres==3)ResultsForm=new TForm2(21,this);
////////// TForm2
	   else if(fl_feres==4)ResultsForm=new TForm2(42,this);
	   else ResultsForm=new TForm2( -nColRes,this);
	   ResultsForm->Show();
	  }
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Spher_frameExecute(TObject *Sender)
{if(fl_feres){Cartesian1->Checked=false;Cylindframe1->Checked=false;Spherframe1->Checked=true;
			  if(section_frame==7)FDsect_base_indatw(2,isectsw,shapecombo, -sectdval[0], -sectdval[1], -sectdval[2],&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame==4 || section_frame==5)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[0],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else if(section_frame>0 && section_frame<4)FDsect_base_indat(2,isectsw,shapecombo, -sectdval[section_frame-1],sect_plane,&indat.nvfix,base.nvfix,&indat.nedge,base.nedge,base.npoin,
				indat.c1,base.c1,base.res1,nColRes,indat.res1,base.nelt,base.matno,base.nop1,indat.matno,&indat.nelt,&indat.npoin,&indat.nfsect,indat.bc1,indat.nop1,indat.fsect);
			  else FDbase_indat(2,shapecombo,iplotflag,nColRes);
//              if(fl_feres==1 || fl_feres==3 || fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(fl_feres==1)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==2 && nColRes==6)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==3)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  else if(fl_feres==4)FDtrans_results(indat.npoin,indat.bc1,indat.res1,nColRes,fl_feres);
			  if(ResultsForm){delete ResultsForm;ResultsForm=NULL;}
			  if     (fl_feres==1)ResultsForm=new TForm2(3,this);
			  else if(fl_feres==2){if(nColRes==1)ResultsForm=new TForm2(31,this);
								   else if(nColRes==6)ResultsForm=new TForm2(34,this);
								   else ResultsForm=new TForm2(30,this);
								  }
			  else if(fl_feres==3)ResultsForm=new TForm2(22,this);
////////// TForm2
			  else if(fl_feres==4)ResultsForm=new TForm2(43,this);
			  else ResultsForm=new TForm2( -nColRes,this);
			  ResultsForm->Show();
			 }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Section_XExecute(TObject *Sender) //TBD Is this OK without test for model (base.nop1)EFP 3/22/2012
{long in=0;float cmin=0.,cmax=0.;section_frame=1;sect_plane[0]=1.;sect_plane[1]=sect_plane[2]=0.;cmin=1.E20;cmax= -1.E20;
 for(in=0;in<indat.npoin;in++){if(cmin>indat.bc1[NDF*in+long(section_frame)-1])cmin=indat.bc1[NDF*in+long(section_frame)-1];
							   if(cmax<indat.bc1[NDF*in+long(section_frame)-1])cmax=indat.bc1[NDF*in+long(section_frame)-1];
							  }
 for(in=0;in<6;in++)sectdval[in]=0.;sectdval[section_frame-1]=(cmin+cmax)/2.;sectdval[section_frame+2]=(cmax-cmin)/float(MAX_SECTIONSTEP);
 if(SectionForm){delete SectionForm;SectionForm=NULL;}   if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
 if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;}   if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
 if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}
 SectionForm=new TForm7(section_frame,sectdval[section_frame-1],cmin,cmax,this);
 SectionForm->Caption="Section across X-axis";SectionForm->Label1->Caption=FloatToStr(cmin);
 SectionForm->Label2->Caption=FloatToStr(cmax);SectionForm->Show();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Section_YExecute(TObject *Sender) //TBD Is this OK without test for model (base.nop1)EFP 3/22/2012
{long in=0;float cmin=0.,cmax=0.;section_frame=2;sect_plane[1]=1.;sect_plane[0]=sect_plane[2]=0.;cmin=1.E20;cmax= -1.E20;
 for(in=0;in<indat.npoin;in++){if(cmin>indat.bc1[NDF*in+long(section_frame)-1])cmin=indat.bc1[NDF*in+long(section_frame)-1];
							   if(cmax<indat.bc1[NDF*in+long(section_frame)-1])cmax=indat.bc1[NDF*in+long(section_frame)-1];
							  }
 for(in=0;in<6;in++)sectdval[in]=0.;sectdval[section_frame-1]=(cmin+cmax)/2.;sectdval[section_frame+2]=(cmax-cmin)/float(MAX_SECTIONSTEP);
 if(SectionForm){delete SectionForm;SectionForm=NULL;} if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
 if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;} if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
 if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}
 SectionForm=new TForm7(section_frame,sectdval[section_frame-1],cmin,cmax,this);
 SectionForm->Caption="Section across Y-axis";SectionForm->Label1->Caption=FloatToStr(cmin);
 SectionForm->Label2->Caption=FloatToStr(cmax);SectionForm->Show();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Section_ZExecute(TObject *Sender) //TBD Is this OK without test for model (base.nop1)EFP 3/22/2012
{long in=0;float cmin=0.,cmax=0.;section_frame=3;sect_plane[2]=1.;sect_plane[0]=sect_plane[1]=0.;cmin=1.E20;cmax= -1.E20;
 for(in=0;in<indat.npoin;in++){if(cmin>indat.bc1[NDF*in+long(section_frame)-1])cmin=indat.bc1[NDF*in+long(section_frame)-1];
							   if(cmax<indat.bc1[NDF*in+long(section_frame)-1])cmax=indat.bc1[NDF*in+long(section_frame)-1];
                              }
 for(in=0;in<6;in++)sectdval[in]=0.;sectdval[section_frame-1]=(cmin+cmax)/2.;sectdval[section_frame+2]=(cmax-cmin)/float(MAX_SECTIONSTEP);
 if(SectionForm){delete SectionForm;SectionForm=NULL;} if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
 if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;} if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
 if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}
 SectionForm=new TForm7(section_frame,sectdval[section_frame-1],cmin,cmax,this);
 SectionForm->Caption="Section across Z-axis";SectionForm->Label1->Caption=FloatToStr(cmin);
 SectionForm->Label2->Caption=FloatToStr(cmax);SectionForm->Show();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Section_wedgeExecute(TObject *Sender) //TBD Is this OK without test for model (base.nop1)EFP 3/22/2012
{long in=0;float xmin=1.E20,xmax= -1.E20,ymin=1.E20,ymax= -1.E20,zmin=1.E20,zmax= -1.E20;section_frame=7;
 for(in=0;in<indat.npoin;in++){if(xmin>indat.bc1[NDF*in  ])xmin=indat.bc1[NDF*in  ];if(xmax<indat.bc1[NDF*in  ])xmax=indat.bc1[NDF*in  ];
							   if(ymin>indat.bc1[NDF*in+1])ymin=indat.bc1[NDF*in+1];if(ymax<indat.bc1[NDF*in+1])ymax=indat.bc1[NDF*in+1];
							   if(zmin>indat.bc1[NDF*in+2])zmin=indat.bc1[NDF*in+2];if(zmax<indat.bc1[NDF*in+2])zmax=indat.bc1[NDF*in+2];
                              }
 if(SectionForm){delete SectionForm;SectionForm=NULL;} if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
 if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;} if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
 if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}
 SectWedgeForm=new TForm9(section_frame,(xmin+xmax)/2.,xmin,xmax,(ymin+ymax)/2.,ymin,ymax,(zmin+zmax)/2.,zmin,zmax,this);
 SectWedgeForm->Caption="Wedge section";
 SectWedgeForm->Label1->Caption=FloatToStr(xmin);SectWedgeForm->Label2->Caption=FloatToStr(xmax);
 SectWedgeForm->Label3->Caption=FloatToStr(ymin);SectWedgeForm->Label4->Caption=FloatToStr(ymax);
 SectWedgeForm->Label5->Caption=FloatToStr(zmin);SectWedgeForm->Label6->Caption=FloatToStr(zmax);SectWedgeForm->Show();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Section_3ptExecute(TObject *Sender) //TBD Is this OK without test for model (base.nop1)EFP 3/22/2012
{float cmin= -1.,cmax=1.,czero=0.;section_frame=4;
 if(SectionForm){delete SectionForm;SectionForm=NULL;} if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
 if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;} if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
 if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}
 Sect3ptForm=new TForm11(1,(cmin+cmax)/2,cmin,cmax,czero,czero,czero,czero,czero,czero,czero,czero,czero,this);
 Sect3ptForm->Caption="Section based on 3 points";
 Sect3ptForm->Label1->Caption="min";Sect3ptForm->Label2->Caption="max";Sect3ptForm->Show();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Section_1pt2rotExecute(TObject *Sender) //TBD Is this OK without test for model (base.nop1)EFP 3/22/2012
{float czero=0.;section_frame=5;
 if(SectionForm){delete SectionForm;SectionForm=NULL;} if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;}
 if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;} if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}
 if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}
 Sect1p2rForm=new TForm12(1,czero,czero,czero,czero,czero,this);Sect1p2rForm->Caption="Section - 1 point/2 rotations";Sect1p2rForm->Show();
}

//---------------------------------------------------------------------------
void __fastcall TForm1::QueryStressDirExecute(TObject *Sender)
{long in=0;float czero=0.;
 if(fl_feres==1){section_frame=6;if(SectionForm){delete SectionForm;SectionForm=NULL;}
				 if(SectWedgeForm){delete SectWedgeForm;SectWedgeForm=NULL;} if(Sect3ptForm){delete Sect3ptForm;Sect3ptForm=NULL;}
				 if(Sect1p2rForm){delete Sect1p2rForm;Sect1p2rForm=NULL;}    if(SectqsdForm){delete SectqsdForm;SectqsdForm=NULL;}
				 SectqsdForm=new TForm13(1,czero,in,czero,czero,czero,czero,this);
				 SectqsdForm->Caption="Section: P1 stress direction";SectqsdForm->Show();
				}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get stress results file->Post/Analysis",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::FDsect_base_indat_mem(int isectsw,float shapeprod,float dval,
  float sect_plane[],long *indat_nvfix,long base_nvfix,long *indat_nedge,long base_nedge,long base_npoin,long base_nelt,
  long base_nop1[],long base_matno[],float base_c1[],float base_res1[],long nColRes,long *indat_nelt,long *indat_npoin,long *indat_nfsect)
// Global NDF,MXNPEL,MXNPEI
{long ie=0,in=0,incount=0,necount=0,npcount=0,nfscount=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000;float aval=0.,bval=0.,cval=0.,rsid=0.;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 aval=sect_plane[0];bval=sect_plane[1];cval=sect_plane[2];*indat_nvfix=base_nvfix;*indat_nedge=base_nedge;npcount=base_npoin;nfscount=0;
 if(MXNPEL<=8)MXNPEI=8;else if(MXNPEL<=20)MXNPEI=20;else MXNPEI=MXNPEL;
 for(ie=0;ie<base_nelt;ie++)
	{eltype=base_matno[ie]/t7;bscode=(base_matno[ie]-eltype*t7)/t5;node=(base_matno[ie]-eltype*t7-bscode*t5)/t3;
	 if(isectsw>0)
	   {incount=0;
		if(!Undeformedmesh1->Checked)
		  {for(in=0;in<node;in++){rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
			  if(rsid>0.)incount++;
			 }
		  }
		else for(in=0;in<node;in++){rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;if(rsid>0.)incount++;}
		if(incount==node)necount++;
		else if(incount>0)
		  {if(eltype==5)     FDelem_subd4_mem(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
		   else if(eltype==7)FDelem_subd6_mem(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
		   else if(eltype==8)FDelem_subd8_mem(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsect_base_indat_mem unsupported ISEL.",L"Halt",MB_OK);return;}
		  }
		else necount++;
       }
     else
	   {incount=0;
        if(!Undeformedmesh1->Checked)
          {for(in=0;in<node;in++){rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
              if(rsid<=0.)incount++;
             }
          }
		else for(in=0;in<node;in++){rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;if(rsid<=0.)incount++;}
		if(incount==node)necount++;
		else if(incount>0)
		  {if(eltype==5)     FDelem_subd4_mem(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
		   else if(eltype==7)FDelem_subd6_mem(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
		   else if(eltype==8)FDelem_subd8_mem(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsect_base_indat_mem unsupported ISEL.",L"Halt",MB_OK);return;}
		  }
		else necount++;
	   }
	}
 if(necount<1)necount=base_nelt;*indat_nelt=necount;*indat_npoin=npcount;*indat_nfsect=nfscount;
//
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
//
}
//---------------------------------------------------------------------------
void TForm1::FDsect_base_indatw_mem(int isectsw,float shapeprod,float dval,float dval1,float dval2,
  long *indat_nvfix,long base_nvfix,long *indat_nedge,long base_nedge,long base_npoin,long base_nelt,
  long base_nop1[],long base_matno[],float base_c1[],float base_res1[],long nColRes,long *indat_nelt,long *indat_npoin,long *indat_nfsect)
// Global NDF,MXNPEL,MXNPEI
{long ie=0,in=0,incount=0,incount1=0,incount2=0,necount=0,npcount=0,nfscount=0,eltype=0,bscode=0,node=0,netemp=0,nptemp=0,nfstemp=0,t3=1000,t5=100000,t7=10000000;
 float aval=0.,bval=0.,cval=0.,rsid=0.,aval1=0.,bval1=0.,cval1=0.,aval2=0.,bval2=0.,cval2=0.;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
 *indat_nvfix=base_nvfix;*indat_nedge=base_nedge;npcount=base_npoin;nfscount=0;
 if(MXNPEL<=8)MXNPEI=8;else if(MXNPEL<=20)MXNPEI=20;else MXNPEI=MXNPEL;
 aval=1.;bval=0.;cval=0.;aval1=0.;bval1=1.;cval1=0.;aval2=0.;bval2=0.;cval2=1.;
 for(ie=0;ie<base_nelt;ie++)
	{eltype=base_matno[ie]/t7;bscode=(base_matno[ie]-eltype*t7)/t5;node=(base_matno[ie]-eltype*t7-bscode*t5)/t3;
// X-section
	 incount=0;
	 if(!Undeformedmesh1->Checked)
	   {for(in=0;in<node;in++){rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
							   if(rsid>0.)incount++;
                              }
       }
	 else for(in=0;in<node;in++){rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;if(rsid>0.)incount++;}
// Y-section
	 incount1=0;
     if(!Undeformedmesh1->Checked)
       {for(in=0;in<node;in++){rsid=aval1*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval1*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval1*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval1;
                               if(rsid>0.)incount1++;
							  }
       }
     else for(in=0;in<node;in++){rsid=aval1*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval1*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval1*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval1;if(rsid>0.)incount1++;}
// Z-section
     incount2=0;
	 if(!Undeformedmesh1->Checked)
       {for(in=0;in<node;in++){rsid=aval2*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval2*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval2*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval2;
                               if(rsid>0.)incount2++;
                              }
	   }
	 else for(in=0;in<node;in++){rsid=aval2*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval2*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval2*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval2;if(rsid>0.)incount2++;}
	 netemp=1;nptemp=1;nfstemp=1;
	 if(incount>0 && incount<node){netemp=netemp*14;nptemp=nptemp*10;nfstemp=nfstemp*8;}
	 if(incount1>0 && incount1<node){netemp=netemp*14;nptemp=nptemp*10;nfstemp=nfstemp*8;}
	 if(incount2>0 && incount2<node){netemp=netemp*14;nptemp=nptemp*10;nfstemp=nfstemp*8;}
	 necount=necount+netemp;npcount=npcount+nptemp;nfscount=nfscount+nfstemp;
	}
 if(necount<1)necount=base_nelt;*indat_nelt=necount;*indat_npoin=npcount;*indat_nfsect=nfscount;
//
honk<<*indat_nelt<<" Total el/node memory "<<*indat_npoin<<"\n";
//    }
//__finally {
Screen->Cursor=Save_Cursor;
//}
//
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subd8_mem(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isectsw,float shapeprod,
  long base_nop1[],float base_c1[],float base_res1[],long nColRes)
// Global NDF,MXNPEL
{int node=0,incount=0,in=0;float rsid=0.;node=8;incount=0;
 for(in=0;in<node;in++)
    {if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
     else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
     if(isectsw>0){if(rsid>0.)incount++;}else {if(rsid<=0.)incount++;}
    }
 if     (incount==node)*necount=*necount+1;
 else if(incount==4){*necount=*necount+14;*npcount=*npcount+6;*nfscount=*nfscount+2*4;}
 else if(incount==1 || incount==7){*necount=*necount+6;*npcount=*npcount+3;*nfscount=*nfscount+2;}
 else if(incount==3 || incount==5){*necount=*necount+9;*npcount=*npcount+5;*nfscount=*nfscount+6;}
 else if(incount==2 || incount==6){*necount=*necount+7;*npcount=*npcount+10;*nfscount=*nfscount+4;}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subd8_mem unsupported ISEL.",L"Halt",MB_OK);return;}
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subd6_mem(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isectsw,float shapeprod,
  long base_nop1[],float base_c1[],float base_res1[],long nColRes)
{int node=0,incount=0,in=0;float rsid=0.;node=6;incount=0;
 for(in=0;in<node;in++)
	{if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
	 else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
	 if(isectsw>0){if(rsid>0.)incount++;}else {if(rsid<=0.)incount++;}
	}
 if     (incount==node)*necount=*necount+1;
 else if(incount==1 || incount==5){*necount=*necount+3;*npcount=*npcount+5;*nfscount=*nfscount+2*1;}
 else if(incount==2 || incount==4){*necount=*necount+3;*npcount=*npcount+6;*nfscount=*nfscount+2*1;}
 else if(incount==3){*necount=*necount+5;*npcount=*npcount+5;*nfscount=*nfscount+2*2;}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subd6_mem unsupported ISEL.",L"Halt",MB_OK);return;}
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subd4_mem(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isectsw,float shapeprod,
  long base_nop1[],float base_c1[],float base_res1[],long nColRes)
{int node=0,incount=0,in=0;float rsid=0.;node=4;incount=0;
 for(in=0;in<node;in++)
	{if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
	 else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
	 if(isectsw>0){if(rsid>0.)incount++;}else {if(rsid<=0.)incount++;}
	}
 if     (incount==node)*necount=*necount+1;
 else if(incount>0 && incount<node){*necount=*necount+2;*npcount=*npcount+4;*nfscount=*nfscount+2*1;}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subd4_mem unsupported ISEL.",L"Halt",MB_OK);return;}
}
//---------------------------------------------------------------------------
void TForm1::FDbase_indat(int isel,float shapeprod,int iplotflag,long nColRes)
// base_XXX & indat_XXX variables/arrays NOT passed in argument list (i.e. global) due to memory-allocation (i.e. treat as __fastcall)
// Global NDF,MXNPEL,MXNPEI,MAX_GID
{long i=0,ic=0,
//ie=0,
 dum=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 if(isel==0 || isel==1)
   {if(Defshapeundefmesh1->Checked){
//	  indat.nelt=2*base.nelt;indat.npoin=2*base.npoin;indat.nfsect=0;MXNPEI=MXNPEL;indat.nvfix=base.nvfix;indat.nedge=base.nedge;
//	  if(iplotflag)FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
//	  FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);
//	  for(i=0;i<base.npoin;i++){for(ic=0;ic<NDF;ic++)indat.c1[NDF*i+ic]=base.c1[NDF*i+ic]+shapeprod*base.res1[nColRes*i+ic];}
//	  for(i=0;i<NDF*base.npoin;i++)indat.c1[i+NDF*base.npoin]=base.c1[i];
//	  for(i=0;i<NDF*indat.npoin;i++)indat.bc1[i]=indat.c1[i];
//	  for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
//							   ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3; //Deprecated EFP 2/20/2012
//							   indat.matno[i]=base.matno[i];indat.matno[i+base.nelt]=base.matno[i]+MAX_GID-1-ieGID;
//							  }
//	  for(i=0;i<MXNPEL*base.nelt;i++){indat.nop1[i]=base.nop1[i];indat.nop1[i+MXNPEL*base.nelt]=base.nop1[i]+base.npoin;}
////  SuperEl
//	  for(i=0;i<base.nelt;i++){indat.nlp[i]=base.nlp[i];indat.nlp[i+base.nelt]=base.nlp[i];}
//	  for(i=0;i<NDF*base.nelt;i++){indat.beta[i]=base.beta[i];indat.beta[i+NDF*base.nelt]=base.beta[i];}
////
honk<<" Unsupported FDbase_indat Defshapeundefmesh1->Checked \n";exit(0);
			   }
else          {
	indat.nelt=base.nelt;indat.npoin=base.npoin;indat.nfsect=0;MXNPEI=MXNPEL;indat.nvfix=base.nvfix;indat.nedge=base.nedge;
	if(iplotflag){FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
//				  FDdynmem_manage(-16,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
//				  FDdynmem_manage(-17,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
				 }
	FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);
//	FDdynmem_manage(16,dum,base.nelt,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);//EFP 8/07/2011
//	FDdynmem_manage(17,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,
////							   base.nelt+2*sumELSETel);//EFP 8/07/2011
//							   3*base.nelt);//EFP 8/25/2013  Temporary memory allocation
	if(!Undeformedmesh1->Checked)
	  {for(i=0;i<base.npoin;i++){for(ic=0;ic<NDF;ic++)indat.c1[NDF*i+ic]=base.c1[NDF*i+ic]+shapeprod*base.res1[nColRes*i+ic];}
	  }
	else for(i=0;i<NDF*base.npoin;i++)indat.c1[i]=base.c1[i];
	for(i=0;i<NDF*indat.npoin;i++)indat.bc1[i]=indat.c1[i];
	for(i=0;i<base.nelt;i++)indat.matno[i]=base.matno[i];for(i=0;i<MXNPEL*base.nelt;i++)indat.nop1[i]=base.nop1[i];
//  SuperEl
	for(i=0;i<base.nelt;i++)indat.nlp[i]=base.nlp[i];for(i=0;i<NDF*base.nelt;i++)indat.beta[i]=base.beta[i];
//

			   }
//
   }



///////////////////// EFP 8/11/2010
 else if(isel==3)
   {

//honk<<base.nelt<<" FDindat0 "<<base.npoin<<" "<<MXNPEL<<"\n";

	if(Defshapeundefmesh1->Checked){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDbase_indat unsupported ISEL",L"Halt",MB_OK);return;
								   }
	else       {
	indat.nelt=base.nelt;indat.npoin=base.npoin;indat.nfsect=0;MXNPEI=MXNPEL;indat.nvfix=base.nvfix;indat.nedge=base.nedge;
	if(iplotflag)FDdynmem_manage(-2,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	FDdynmem_manage(2,dum,dum,indat.npoin,indat.nelt,dum,dum,dum,dum,dum,dum,dum,indat.nfsect,MXNPEI);

//honk<<indat.nelt<<" FDindat1 "<<indat.npoin<<" "<<MXNPEL<<"\n";
//if(1==1)exit(0);


	if(!Undeformedmesh1->Checked)
	  {for(i=0;i<base.npoin;i++){for(ic=0;ic<NDF;ic++)indat.c1[NDF*i+ic]=base.c1[NDF*i+ic]+shapeprod*base.res1[nColRes*i+ic];}
	  }
	else for(i=0;i<NDF*base.npoin;i++)indat.c1[i]=base.c1[i];
	for(i=0;i<NDF*indat.npoin;i++)indat.bc1[i]=indat.c1[i];
  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	for(i=0;i<base.nelt;i++)indat.matno[i]=base.matno[i]; // This simple code used in place of below (EFP 9/10/2010)
//	for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
//							 node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//							 if(ieGID==0)indat.matno[i]=base.matno[i];
//							 else indat.matno[i]=base.matno[i]-ieGID+wp.nWeldPass+1;// Convention: GID of weld groups==MAX_GID
//							}
//	for(i=0;i<wp.nWeldPass;i++)
//	  {for(ic=0;ic<base.nelt;ic++)
////		 {ie=wp.eles[base.nelt*i+ic];
//		 {ie=wp.eles[base.nelt*i+ic]/10;
//		  if(ie>=0){
////		  base.arELEM[ie]=0;
// 					indat.matno[ie]=base.matno[ie]-(wp.nWeldPass+1)+i+1;
//				   }
//		  else break;
//		 }
//	  }
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^





//honk<<indat.nelt<<" FDindat2 "<<indat.npoin<<" "<<MXNPEL<<"\n";
//if(1==1)exit(0);
////////////////////////////////
////	for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
////							 node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
////							 if(ieGID<0){honk<<i+1<<" FDb_indat "<<ieGID<<"\n";exit(0);}
////							}
//	for(i=0;i<base.nelt;i++){eltype=indat.matno[i]/t7;bscode=(indat.matno[i]-eltype*t7)/t5;//EFP does not understand. Throw out for now.
//							 node=(indat.matno[i]-eltype*t7-bscode*t5)/t3;
//							 ieGID=indat.matno[i]-eltype*t7-bscode*t5-node*t3;
//							 if(ieGID<0){honk<<i+1<<" FDb_indat "<<ieGID<<"\n";exit(0);}
//							}
////////////////////////////////
	for(i=0;i<MXNPEL*base.nelt;i++)indat.nop1[i]=base.nop1[i];

//honk<<indat.nelt<<" FDindat3 "<<indat.npoin<<" "<<MXNPEL<<"\n";
//if(1==1)exit(0);
////  SuperEl
////	for(i=0;i<base.nelt;i++)indat.nlp[i]=base.nlp[i];for(i=0;i<NDF*base.nelt;i++)indat.beta[i]=base.beta[i];
//
			   }
   }
//////////////////////////


 if(isel==2){for(i=0;i<nColRes*base.npoin;i++)indat.res1[i]=base.res1[i];
			 if(Defshapeundefmesh1->Checked)for(i=0;i<nColRes*base.npoin;i++)indat.res1[i+nColRes*base.npoin]=base.res1[i];
			}
 if(isel<0 || isel>3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDbase_indat unsupported ISEL",L"Halt",MB_OK);return;}
}
//---------------------------------------------------------------------------
void TForm1::FDsect_base_indat(int isel,int isectsw,float shapeprod,float dval,float sect_plane[],long *indat_nvfix,long base_nvfix,long *indat_nedge,long base_nedge,long base_npoin,
  float indat_c1[],float base_c1[],float base_res1[],long nColRes,float indat_res1[],long base_nelt,long base_matno[],long base_nop1[],long indat_matno[],
  long *indat_nelt,long *indat_npoin,long *indat_nfsect,float indat_bc1[],long indat_nop1[],long indat_fsect[])
// Global NDF,MXNPEL,MXNPEI,MAX_GID
// isel=2-->process results only, but necount/npcount are still accumulated correctly
{long ie=0,in=0,ic=0,incount=0,necount=0,npcount=0,nfscount=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 float aval=0.,bval=0.,cval=0.,rsid=0.;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 aval=sect_plane[0];bval=sect_plane[1];cval=sect_plane[2]; *indat_nvfix=base_nvfix;*indat_nedge=base_nedge;npcount=base_npoin;nfscount=0;
 if(isel!=2)
   {if(!Undeformedmesh1->Checked)for(in=0;in<base_npoin;in++){for(ic=0;ic<NDF;ic++)indat_c1[NDF*in+ic]=base_c1[NDF*in+ic]+shapeprod*base_res1[nColRes*in+ic];}
	else for(in=0;in<NDF*base_npoin;in++)indat_c1[in]=base_c1[in];
   }
 if(nColRes>0)for(in=0;in<nColRes*base_npoin;in++)indat_res1[in]=base_res1[in];
 for(ie=0;ie<base_nelt;ie++)
	{eltype=base_matno[ie]/t7;bscode=(base_matno[ie]-eltype*t7)/t5;node=(base_matno[ie]-eltype*t7-bscode*t5)/t3;
////	 ieGID=base_matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];

	 if(isectsw>0)
	   {incount=0;
		 for(in=0;in<node;in++)
		  {if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
		   else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
		   if(rsid>0.)incount++;
		  }
		if(incount==node)
		  {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI*necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[necount]=base_matno[ie];}
		   necount++;
          }
        else if(incount>0)
          {if(eltype==5)     FDelem_subd4(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		   else if(eltype==7)FDelem_subd6(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
           else if(eltype==8)FDelem_subd8(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsect_base_indat unsupported ISEL.",L"Halt",MB_OK);return;}
		  }
		else  // To be transparent
		  {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI*necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[necount]=base_matno[ie]+MAX_GID-1-ieGID;}
		   necount++;
		  }
	   }
	 else
	   {incount=0;
		for(in=0;in<node;in++)
		  {if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
		   else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
		   if(rsid<=0.)incount++;
		  }
		if(incount==node)
		  {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI*necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[necount]=base_matno[ie];}
		   necount++;
		  }
		else if(incount>0)
		  {if(eltype==5)     FDelem_subd4(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		   else if(eltype==7)FDelem_subd6(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		   else if(eltype==8)FDelem_subd8(aval,bval,cval,dval,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsect_base_indat unsupported ISEL.",L"Halt",MB_OK);return;}
		  }
		else  // To be transparent
		  {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI*necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[necount]=base_matno[ie]+MAX_GID-1-ieGID;}
		   necount++;
		  }
	   }
	}
//
 if(isel!=2)
   {if(necount<1)
	 {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No elements found -> restore",L"Warning",MB_OK);
	  necount=base_nelt;
	  for(ie=0;ie<base_nelt;ie++){eltype=base_matno[ie]/t7;bscode=(base_matno[ie]-eltype*t7)/t5;node=(base_matno[ie]-eltype*t7-bscode*t5)/t3;
////								  ieGID=base_matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];

								  for(in=0;in<node;in++)indat_nop1[MXNPEI*ie+in]=base_nop1[MXNPEL*ie+in];indat_matno[ie]=base_matno[ie];
								 }
	 }
//
	*indat_nelt=necount;*indat_npoin=npcount;*indat_nfsect=nfscount;
// Create cartesian array
	for(in=0;in<NDF* *indat_npoin;in++)indat_bc1[in]=indat_c1[in];if(*indat_nfsect)psect_outline(1,indat_nop1,indat_matno,indat_c1,indat_bc1,*indat_nfsect,indat_fsect);
   }
//
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
//
}
//---------------------------------------------------------------------------
void TForm1::FDsect_base_indatw(int isel,int isectsw,float shapeprod,float dval1,float dval2,float dval3,long *indat_nvfix,long base_nvfix,long *indat_nedge,long base_nedge,long base_npoin,
  float indat_c1[],float base_c1[],float base_res1[],long nColRes,float indat_res1[],long base_nelt,long base_matno[],long base_nop1[],long indat_matno[],
  long *indat_nelt,long *indat_npoin,long *indat_nfsect,float indat_bc1[],long indat_nop1[],long indat_fsect[])
// isel=2-->process results only, but necount/npcount are still accumulated correctly
{long ie=0,in=0,ic=0,incount=0,necount=0,npcount=0,nfscount=0,ofscount=0,tfscount=0,cfscount=0,eltype=0,bscode=0,node=0,ieGID=0,tspel=0,t3=1000,t5=100000,t7=10000000;
 float xave=0.,yave=0.,zave=0.,aval1=0.,bval1=0.,cval1=0.,rsid1=0.,aval2=0.,bval2=0.,cval2=0.,rsid2=0.,aval3=0.,bval3=0.,cval3=0.,rsid3=0.;
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 aval1=1.;bval1=0.;cval1=0.;*indat_nvfix=base_nvfix;*indat_nedge=base_nedge;npcount=base_npoin;nfscount=0;
 if(isel!=2)
   {if(!Undeformedmesh1->Checked)for(in=0;in<base_npoin;in++){for(ic=0;ic<NDF;ic++)indat_c1[NDF*in+ic]=base_c1[NDF*in+ic]+shapeprod*base_res1[nColRes*in+ic];}
	else for(in=0;in<NDF*base_npoin;in++)indat_c1[in]=base_c1[in];
   }
 if(nColRes>0)for(in=0;in<nColRes*base_npoin;in++)indat_res1[in]=base_res1[in];
// X-plane section
 for(ie=0;ie<base_nelt;ie++)
	{eltype=base_matno[ie]/t7;bscode=(base_matno[ie]-eltype*t7)/t5;node=(base_matno[ie]-eltype*t7-bscode*t5)/t3;
////	 ieGID=base_matno[ie]-eltype*t7-bscode*t5-node*t3;
	 incount=0;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];

	 for(in=0;in<node;in++)
          {if(!Undeformedmesh1->Checked)rsid1=aval1*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval1*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval1*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval1;
           else rsid1=aval1*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval1*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval1*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval1;
           if(rsid1>0.)incount++;
		  }
     if(incount==node)
	   {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI*necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[necount]=base_matno[ie];}
        necount++;
       }
	 else if(incount>0)
       {if(eltype==5)     FDelem_subd4(aval1,bval1,cval1,dval1,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,0,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		else if(eltype==7)FDelem_subd6(aval1,bval1,cval1,dval1,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,0,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		else if(eltype==8)FDelem_subd8(aval1,bval1,cval1,dval1,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,0,base_nop1,base_matno,base_c1,base_res1,nColRes,indat_nop1,indat_matno,indat_c1,indat_res1,indat_fsect);
		else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsect_base_indatw unsupported ISEL.",L"Halt",MB_OK);return;}
	   }
	 else {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI*necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[necount]=base_matno[ie];}
		   necount++;
		  }
	}
 *indat_nelt=necount;*indat_npoin=npcount;*indat_nfsect=nfscount;ofscount=nfscount;
// Y-plane section
 aval2=0.;bval2=1.;cval2=0.;
 for(ie=0;ie< *indat_nelt;ie++)
	{eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
////	 ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
	 incount=0;
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];

	 for(in=0;in<node;in++){rsid2=aval2*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ]+bval2*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1]+cval2*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2]+dval2;
							if(rsid2>0.)incount++;
						   }
	 if(incount>0 && incount<node)
	   {if     (eltype==5)FDelem_subc4(aval2,bval2,cval2,dval2,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,1,indat_nop1,indat_matno,indat_c1,indat_res1,nColRes,*indat_nfsect,indat_fsect);
		else if(eltype==7)FDelem_subc6(aval2,bval2,cval2,dval2,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,1,indat_nop1,indat_matno,indat_c1,indat_res1,nColRes,*indat_nfsect,indat_fsect);
		else if(eltype==8)FDelem_subc8(aval2,bval2,cval2,dval2,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,1,1,indat_nop1,indat_matno,indat_c1,indat_res1,nColRes,*indat_nfsect,indat_fsect);
		else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsect_base_indatw unsupported ISEL.",L"Halt",MB_OK);return;}
	   }
	}
 *indat_nelt=necount;*indat_npoin=npcount;
 if(nfscount){tfscount=ofscount;psect_compact(0,&tfscount,aval2,bval2,cval2,dval2,1,indat_nop1,indat_matno,indat_c1,indat_fsect);
			  cfscount=tfscount;for(ic=ofscount;ic<nfscount;ic++){indat_fsect[tfscount]=indat_fsect[ic];tfscount++;}
			  ofscount=cfscount;psect_compact(ofscount,&tfscount,aval2,bval2,cval2,dval2,1,indat_nop1,indat_matno,indat_c1,indat_fsect);
			  psect_compact(ofscount,&tfscount,aval1,bval1,cval1,dval1,1,indat_nop1,indat_matno,indat_c1,indat_fsect);nfscount=tfscount;
			 }
 *indat_nfsect=nfscount;ofscount=nfscount;
//////////////////////////////////
// Z-plane section
 aval3=0.;bval3=0.;cval3=1.;
 for(ie=0;ie< *indat_nelt;ie++)
	{eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
////	 ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
	 incount=0;
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];

	 for(in=0;in<node;in++){rsid3=aval3*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ]+bval3*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1]+cval3*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2]+dval3;
                            if(rsid3>0.)incount++;
                           }
	 if(incount>0 && incount<node)
       {if     (eltype==5)FDelem_subc4(aval3,bval3,cval3,dval3,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,0,2,indat_nop1,indat_matno,indat_c1,indat_res1,nColRes,*indat_nfsect,indat_fsect);
        else if(eltype==7)FDelem_subc6(aval3,bval3,cval3,dval3,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,0,2,indat_nop1,indat_matno,indat_c1,indat_res1,nColRes,*indat_nfsect,indat_fsect);
        else if(eltype==8)FDelem_subc8(aval3,bval3,cval3,dval3,&necount,&npcount,&nfscount,ie,isel,isectsw,shapeprod,0,2,indat_nop1,indat_matno,indat_c1,indat_res1,nColRes,*indat_nfsect,indat_fsect);
		else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDsect_base_indatw unsupported ISEL.",L"Halt",MB_OK);return;}
	   }
	}
 *indat_nelt=necount;*indat_npoin=npcount;
 if(nfscount){tfscount=ofscount;psect_compact(0,&tfscount,aval3,bval3,cval3,dval3, 0,indat_nop1,indat_matno,indat_c1,indat_fsect);
			  cfscount=tfscount;for(ic=ofscount;ic<nfscount;ic++){indat_fsect[tfscount]=indat_fsect[ic];tfscount++;}
			  ofscount=cfscount;psect_compact(ofscount,&tfscount,aval3,bval3,cval3,dval3, 0,indat_nop1,indat_matno,indat_c1,indat_fsect);
			  psect_compact(ofscount,&tfscount,aval1,bval1,cval1,dval1,1,indat_nop1,indat_matno,indat_c1,indat_fsect);
			  psect_compact(ofscount,&tfscount,aval2,bval2,cval2,dval2,1,indat_nop1,indat_matno,indat_c1,indat_fsect);nfscount=tfscount;
			 }
 *indat_nfsect=nfscount;
//
 if(isel!=2)
   {if(necount<1)
	 {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No elements found -> restore",L"Warning",MB_OK);
	  necount=base_nelt;
	  for(ie=0;ie<base_nelt;ie++){eltype=base_matno[ie]/t7;bscode=(base_matno[ie]-eltype*t7)/t5;node=(base_matno[ie]-eltype*t7-bscode*t5)/t3;
////								  ieGID=base_matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
// 	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];

								  indat_matno[ie]=base_matno[ie];
								  for(in=0;in<node;in++)indat_nop1[MXNPEI*ie+in]=base_nop1[MXNPEL*ie+in];
								 }
	  *indat_nfsect=0;
	 }
	*indat_nelt=necount;*indat_npoin=npcount;
// Create cartesian array
	for(in=0;in<NDF* *indat_npoin;in++)indat_bc1[in]=indat_c1[in];
//
   }
//
 tspel=0;
 for(ie=0;ie< *indat_nelt;ie++)
	{eltype=indat_matno[ie]/t7;bscode=(indat_matno[ie]-eltype*t7)/t5;node=(indat_matno[ie]-eltype*t7-bscode*t5)/t3;
////	 ieGID=indat_matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];

	 xave=yave=zave=0.;
	 for(in=0;in<node;in++){xave=xave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ];yave=yave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1];
							zave=zave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2];
						   }
     xave=xave/float(node);yave=yave/float(node);zave=zave/float(node);
// Add isectsw laterality switch
     rsid1=aval1*xave+bval1*yave+cval1*zave+dval1;rsid2=aval2*xave+bval2*yave+cval2*zave+dval2;rsid3=aval3*xave+bval3*yave+cval3*zave+dval3;
	 if(rsid1<=0. && rsid2<=0. && rsid3>0.){tspel++;indat_matno[ie]=indat_matno[ie]+MAX_GID-1-ieGID;}
	}
 if(!tspel){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No sectioned elements found.",L"Notice",MB_OK);}
 if(*indat_nfsect)psect_outline(3,indat_nop1,indat_matno,indat_c1,indat_bc1,*indat_nfsect,indat_fsect);
////////////////////////////////////
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
//
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subd8(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isel,int isectsw,float shapeprod,int swplt,
  long base_nop1[],long base_matno[],float base_c1[],float base_res1[],long nColRes,long indat_nop1[],long indat_matno[],float indat_c1[],float indat_res1[],long indat_fsect[])
// Global NDF,MXNPEL,MXNPEI,MXNPELS,MAX_GID
{long t3=1000,t5=100000,t7=10000000,teltype=0,tbscode=0,tnode=0,ueltype=0,ubscode=0,unode=0,uieGID=0,nop4[14*MXNPELS],tmatno[14],i=0,sfsect[14],sectn=0;
 int node=0,nodemx=0,incount=0,in=0,ic=0,ip=0,ipp=0,iet=0,icp=0,tnelt=0,flagarr[MXNPELS],flagnd[20],is=0,iside=0,fp=0,isw=0,starr[3]
// ,inrec=0,isiderec=0
;
 float rsid=0.,tcoor[20*NDF],xave=0.,yave=0.,zave=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 node=8;nodemx=20;incount=0;for(ip=0;ip<nodemx;ip++)flagnd[ip]=0;for(ip=0;ip<14;ip++)sfsect[ip]= -1;
 for(in=0;in<node;in++)
	{if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
	 else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
	 if(isectsw>0){if(rsid>0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}else {if(rsid<=0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}
	}
 if(incount==node)
   {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI* *necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[*necount]=base_matno[ie];}
    *necount= *necount+1;
   }
 else if(incount>0)
	{FDnode_subd8(aval,bval,cval,dval,ie,tcoor,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
	 if(incount==4)elnum44_d8(&tnelt,flagarr,nop4,tmatno,base_matno[ie],sfsect);
	 else if(incount==2 || incount==6)
		{iside=0;isw=0;
		 while(iside<6 && isw<1)
			{for(ip=0;ip<2;ip++)
				{ipp=ip+2;fp=flagarr[gdata8[4*iside+ip]]+flagarr[gdata8[4*iside+ipp]];
//				 if(incount==2 && fp==2){isw=1;isiderec=iside;inrec=ip;break;} // isiderec & inrec not currently used
//				 if(incount==6 && fp==0){isw=1;isiderec=iside;inrec=ip;break;}
				 if(incount==2 && fp==2){isw=1;break;}if(incount==6 && fp==0){isw=1;break;}
				}
			 iside++;
			}
		 if(isw)
//  Opposite corners
			{tnelt=7;tmatno[0]=base_matno[ie];for(icp=1;icp<5;icp++)tmatno[icp]=base_matno[ie]-(8-7)*t7-(8-6)*1000;
						 tmatno[5]=base_matno[ie]-(8-5)*t7-(8-4)*1000;tmatno[6]=base_matno[ie]-(8-5)*t7-(8-4)*1000;
if     (flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]=13;nop4[MXNPELS*i+ 7]=16;
i= 1;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=19;
i= 4;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 9;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 9;nop4[MXNPELS*i+ 6]=14;nop4[MXNPELS*i+ 7]=17;
i= 1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]=16;
i= 4;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=10;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 5;i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=10;nop4[MXNPELS*i+ 6]=15;nop4[MXNPELS*i+ 7]=18;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]= 7;
i= 3;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]=17;
i= 4;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=11;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 6;i= 6;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=11;nop4[MXNPELS*i+ 6]=12;nop4[MXNPELS*i+ 7]=19;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]= 3;
i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=18;
i= 4;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 8;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]= 8;nop4[MXNPELS*i+ 7]=13;
i= 1;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;
i= 3;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=17;
i= 4;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=11;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 5;i= 6;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]= 9;nop4[MXNPELS*i+ 7]=14;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;
i= 3;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=18;
i= 4;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 8;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 6;i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]=15;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=19;
i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 9;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=15;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]=12;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 7;
i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 0;
i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=16;
i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=10;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=17;nop4[MXNPELS*i+ 6]=18;nop4[MXNPELS*i+ 7]=19;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 7;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=12;
i= 4;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]=14;
i= 5;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 6;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=16;nop4[MXNPELS*i+ 6]=17;nop4[MXNPELS*i+ 7]=18;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]=15;
i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=13;
i= 5;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 5;}
else if(flagarr[0]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]=11;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]= 9;
i= 1;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 2;
i= 3;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=13;
i= 4;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=15;
i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 1;i= 6;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 3;}
else {
//else if(flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]=10;
i= 1;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=14;
i= 4;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]=12;
i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 2;i= 6;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;}
sfsect[ 3]=10*sectn+4;sfsect[ 4]=10*sectn+4;sfsect[ 5]=10*sectn+0;sfsect[ 6]=10*sectn+0;
			}
		 else
//  Adjacent corners
			{tnelt=4;for(icp=0;icp<4;icp++)tmatno[icp]=base_matno[ie]-(8-7)*t7-(8-6)*1000;
if     (flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 7;
i= 1;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 4;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 4;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 7;
i= 3;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 5;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 7;
i= 2;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 6;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 7;}
else if(flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 4;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 0;}
else if(flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 0;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 0;nop4[MXNPELS*i+ 5]= 1;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 0;
i= 3;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 1;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 4;}
else if(flagarr[0]+flagarr[1]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 1;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;}
else if(flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 2;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 2;
i= 3;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 5;}
else {
//else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==6){
i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 2;
i= 1;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 1;
i= 3;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 6;}
//
sfsect[ 2]=10*sectn+0;sfsect[ 3]=10*sectn+0;
			}
		}
//
	 else if(incount==1 || incount==7)
		{tnelt=6;tmatno[0]=base_matno[ie]-(8-7)*t7-(8-6)*1000;for(icp=1;icp<6;icp++)tmatno[icp]=base_matno[ie]-(8-5)*t7-(8-4)*1000;
if     (flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 6;i= 2;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 7;
i= 3;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 2;i= 4;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 5;
i= 5;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 7;i= 2;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;
i= 3;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 6;
i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=10;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 4;i= 2;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 5;
i= 3;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 0;i= 4;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 7;
i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=11;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 5;i= 2;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 6;
i= 3;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 1;i= 4;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;
i= 5;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=16;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 2;i= 2;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;
i= 3;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;i= 4;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 6;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 4;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=17;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 3;i= 2;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;
i= 3;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;i= 4;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 7;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 5;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=18;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;i= 2;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;
i= 3;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 6;}
else {
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=19;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 1;i= 2;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;
i= 3;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;i= 4;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 5;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 7;}
sfsect[ 0]=10*sectn+4;sfsect[ 5]=10*sectn+0;
		}
//
	 else if(incount==3 || incount==5)
		{tnelt=9;
				 if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==3){icp=0;for(ip=0;ip<node;ip++)if(flagarr[ip]>0){starr[icp]=ip;icp++;}}
                 else {icp=0;for(ip=0;ip<node;ip++)if(flagarr[ip]<=0){starr[icp]=ip;icp++;}}
                 elnum35_d8(starr[0],starr[1],starr[2],nop4,tmatno,base_matno[ie]);
				 sfsect[ 1]=10*sectn+3;sfsect[ 2]=10*sectn+3;sfsect[ 3]=10*sectn+3;sfsect[ 4]=10*sectn+3;sfsect[ 6]=10*sectn+3;sfsect[ 8]=10*sectn+3;
		}
//
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subd8 unsupported ISEL.",L"Halt",MB_OK);return;}
	 for(iet=0;iet<tnelt;iet++){teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
									for(ic=0;ic<tnode;ic++)flagnd[nop4[iet*MXNPELS+ic]]=1;
								   }
	 for(icp=0;icp<node;icp++)flagnd[icp]=base_nop1[MXNPEL*ie+icp];
	 for(icp=node;icp<nodemx;icp++)
		{if(flagnd[icp])
		  {STFISO8(1,tcoor[icp*NDF+0],tcoor[icp*NDF+1],tcoor[icp*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
				   xval=yval=zval=0.;
				   if(!Undeformedmesh1->Checked)for(is=0;is<node;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
						}
				   else for(is=0;is<node;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
											   yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
											   zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
											  }
				   if(isel!=2){indat_c1[NDF* *npcount  ]=xval;indat_c1[NDF* *npcount+1]=yval;indat_c1[NDF* *npcount+2]=zval;}
				   if(nColRes){for(in=0;in<nColRes;in++)
								 {xval=0.;for(is=0;is<node;is++)xval=xval+SN[is]*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+in];
								  indat_res1[nColRes* *npcount+in]=xval;
								 }
							  }
				   flagnd[icp]=*npcount;*npcount=*npcount+1;
		  }
		}
		 for(iet=0;iet<tnelt;iet++)
		{teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
				 if(isel!=2)
				   {xave=yave=zave=0.;
			for(ic=0;ic<tnode;ic++){nop4[iet*MXNPELS+ic]=flagnd[nop4[iet*MXNPELS+ic]];xave=xave+indat_c1[NDF*nop4[MXNPELS*iet+ic]  ];
								yave=yave+indat_c1[NDF*nop4[MXNPELS*iet+ic]+1];zave=zave+indat_c1[NDF*nop4[MXNPELS*iet+ic]+2];
							   }
			xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
		    rsid=aval*xave+bval*yave+cval*zave+dval;
                    for(in=0;in<tnode;in++)indat_nop1[MXNPEI* *necount+in]=nop4[MXNPELS*iet+in];
					if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI* *necount+in]=0;
                    if(isectsw>0){if(rsid>0.){indat_matno[*necount]=tmatno[iet];
                                              if(sfsect[iet]> -1){indat_fsect[*nfscount]=(*necount*10+sfsect[iet])*1000; *nfscount= *nfscount+1;}
											 }
                                  else {ueltype=tmatno[iet]/t7;ubscode=(tmatno[iet]-ueltype*t7)/t5;unode=(tmatno[iet]-ueltype*t7-ubscode*t5)/t3;uieGID=tmatno[iet]-ueltype*t7-ubscode*t5-unode*t3;
                                        if(swplt)indat_matno[*necount]=tmatno[iet]+MAX_GID-1-uieGID;else indat_matno[*necount]=tmatno[iet];
                                       }
                                 }
                    else {if(rsid<=0.){indat_matno[*necount]=tmatno[iet];
                                       if(sfsect[iet]> -1){indat_fsect[*nfscount]=(*necount*10+sfsect[iet])*1000; *nfscount= *nfscount+1;}
                                      }
                          else      {ueltype=tmatno[iet]/t7;ubscode=(tmatno[iet]-ueltype*t7)/t5;unode=(tmatno[iet]-ueltype*t7-ubscode*t5)/t3;uieGID=tmatno[iet]-ueltype*t7-ubscode*t5-unode*t3;
									 if(swplt)indat_matno[*necount]=tmatno[iet]+MAX_GID-1-uieGID;else indat_matno[*necount]=tmatno[iet];
                                    }
						 }
//
                   }
                 *necount=*necount+1;
		}
	}
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subd6(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isel,int isectsw,float shapeprod,int swplt,
  long base_nop1[],long base_matno[],float base_c1[],float base_res1[],long nColRes,long indat_nop1[],long indat_matno[],float indat_c1[],float indat_res1[],long indat_fsect[])
// Global NDF,MXNPEL,MXNPEI,MXNPELS,MAX_GID
{long t3=1000,t5=100000,t7=10000000,teltype=0,tbscode=0,tnode=0,ueltype=0,ubscode=0,unode=0,uieGID=0,nop4[5*MXNPELS],tmatno[5],i=0,sfsect[14],sectn=0;
 int node=0,nodemx=0,incount=0,in=0,ic=0,ip=0,iet=0,icp=0,tnelt=0,flagarr[MXNPELS],is=0,dflag= -1,flagnd[15];
 float rsid=0.,xave=0.,yave=0.,zave=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],tcoor[15*NDF];
 node=6;nodemx=15;incount=0;for(ip=0;ip<nodemx;ip++)flagnd[ip]=0;for(ip=0;ip<14;ip++)sfsect[ip]= -1;
 for(in=0;in<node;in++)
	{if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
     else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
	 if(isectsw>0){if(rsid>0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}else {if(rsid<=0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}
    }
 if(incount==node){if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI* *necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[*necount]=base_matno[ie];} *necount=*necount+1;}
 else if(incount>0)
	{FDnode_subd6(aval,bval,cval,dval,ie,tcoor,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);
	 if(incount==1 || incount==5)
		{tnelt=3;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie]-(7-5)*t7-(6-4)*1000;
if     (flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]= 2;nop4[MXNPELS*i+ 7]= 1;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 8;
i= 2;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 6;nop4[MXNPELS*i+ 6]= 0;nop4[MXNPELS*i+ 7]= 2;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 3;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]= 1;nop4[MXNPELS*i+ 7]= 0;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 7;
i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]= 4;nop4[MXNPELS*i+ 7]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=12;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]= 5;nop4[MXNPELS*i+ 7]= 3;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=13;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 4;}
else {i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]= 3;nop4[MXNPELS*i+ 7]= 4;
	  i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=14;
      i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;}
				 sfsect[ 1]=10*sectn+4;sfsect[ 2]=10*sectn+0;
//
		}
	 else if(incount==2 || incount==4)
		{
if     (flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]==4){
tnelt=3;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]=11;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 3;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 4;
sfsect[ 0]=10*sectn+5;sfsect[ 2]=10*sectn+0;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]==4){
tnelt=3;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 5;
sfsect[ 0]=10*sectn+5;sfsect[ 2]=10*sectn+0;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]==4){
tnelt=3;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]= 9;nop4[MXNPELS*i+ 7]=10;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 3;
sfsect[ 0]=10*sectn+5;sfsect[ 2]=10*sectn+0;}
else if(flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]==4){
tnelt=3;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]=10;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 2;
sfsect[ 0]=10*sectn+5;sfsect[ 2]=10*sectn+0;}
else if(flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==4){
tnelt=3;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 6;nop4[MXNPELS*i+ 6]= 9;nop4[MXNPELS*i+ 7]=11;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 0;
sfsect[ 0]=10*sectn+5;sfsect[ 2]=10*sectn+0;}
else if(flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==4){
tnelt=3;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 3;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]= 9;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 1;
sfsect[ 0]=10*sectn+5;sfsect[ 2]=10*sectn+0;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]==4){
tnelt=2;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]= 3;nop4[MXNPELS*i+ 7]= 4;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
sfsect[ 0]=10*sectn+0;sfsect[ 1]=10*sectn+0;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]==4){
tnelt=2;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]= 5;nop4[MXNPELS*i+ 7]= 3;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
sfsect[ 0]=10*sectn+0;sfsect[ 1]=10*sectn+0;}
else {tnelt=2;tmatno[0]=base_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]= 4;nop4[MXNPELS*i+ 7]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 3;
sfsect[ 0]=10*sectn+0;sfsect[ 1]=10*sectn+0;}
		}
//
	 else if(incount==3)
		{if(flagarr[0]+flagarr[1]+flagarr[2]==0 || flagarr[0]+flagarr[1]+flagarr[2]==3)
                   {tnelt=2;tmatno[0]=base_matno[ie];tmatno[1]=base_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=11;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=10;
sfsect[ 0]=10*sectn+4;sfsect[ 1]=10*sectn+4;
				   }
                 else
                   {FDnode_dir6(aval,bval,cval,dval,ie,isectsw,shapeprod,&dflag,base_nop1,base_c1,base_res1,nColRes);
tnelt=5;tmatno[0]=base_matno[ie];tmatno[1]=base_matno[ie];tmatno[2]=base_matno[ie];
tmatno[3]=base_matno[ie]-(7-5)*t7-(6-4)*1000;tmatno[4]=base_matno[ie]-(7-5)*t7-(6-4)*1000;
if     (flagarr[0]+flagarr[1]+flagarr[3]==0 || flagarr[0]+flagarr[1]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 3;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;i= 4;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[2]+flagarr[5]==0 || flagarr[0]+flagarr[2]+flagarr[5]==3){
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 7;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 4;i= 4;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[1]+flagarr[2]+flagarr[4]==0 || flagarr[1]+flagarr[2]+flagarr[4]==3){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[1]+flagarr[4]==0 || flagarr[0]+flagarr[1]+flagarr[4]==3){
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 7;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 5;i= 4;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[1]+flagarr[2]+flagarr[5]==0 || flagarr[1]+flagarr[2]+flagarr[5]==3){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;}
else {
i= 0;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 4;i= 4;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 1;}
sfsect[ 0]=10*sectn+4;sfsect[ 1]=10*sectn+0;sfsect[ 2]=10*sectn+0;sfsect[ 3]=10*sectn+0;
                   }
		}
//
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subd6 unsupported ISEL.",L"Halt",MB_OK);return;}
	 for(iet=0;iet<tnelt;iet++){teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
									for(ic=0;ic<tnode;ic++)flagnd[nop4[iet*MXNPELS+ic]]=1;
								   }
	 for(icp=0;icp<node;icp++)flagnd[icp]=base_nop1[MXNPEL*ie+icp];
	 for(icp=node;icp<nodemx;icp++)
		{if(flagnd[icp])
		  {STFISO6(1,tcoor[icp*NDF+0],tcoor[icp*NDF+1],tcoor[icp*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
				   xval=yval=zval=0.;
				   if(!Undeformedmesh1->Checked)for(is=0;is<node;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
						}
				   else for(is=0;is<node;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
											   yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
											   zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
											  }
				   if(isel!=2){indat_c1[NDF* *npcount  ]=xval;indat_c1[NDF* *npcount+1]=yval;indat_c1[NDF* *npcount+2]=zval;}
				   if(nColRes){for(in=0;in<nColRes;in++)
								 {xval=0.;for(is=0;is<node;is++)xval=xval+SN[is]*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+in];
								  indat_res1[nColRes* *npcount+in]=xval;
								 }
							  }
				   flagnd[icp]=*npcount;*npcount=*npcount+1;
		  }
		}
		 for(iet=0;iet<tnelt;iet++)
		{teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
				 if(isel!=2)
				   {xave=yave=zave=0.;
			for(ic=0;ic<tnode;ic++){nop4[iet*MXNPELS+ic]=flagnd[nop4[iet*MXNPELS+ic]];xave=xave+indat_c1[NDF*nop4[MXNPELS*iet+ic]  ];
								yave=yave+indat_c1[NDF*nop4[MXNPELS*iet+ic]+1];zave=zave+indat_c1[NDF*nop4[MXNPELS*iet+ic]+2];
			                   }
			xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
			rsid=aval*xave+bval*yave+cval*zave+dval;
                    for(in=0;in<tnode;in++)indat_nop1[MXNPEI* *necount+in]=nop4[MXNPELS*iet+in];
                    if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI* *necount+in]=0;
					if(isectsw>0){if(rsid>0.){indat_matno[*necount]=tmatno[iet];if(sfsect[iet]> -1){indat_fsect[*nfscount]=(*necount*10+sfsect[iet])*1000; *nfscount= *nfscount+1;}}
                                  else {ueltype=tmatno[iet]/t7;ubscode=(tmatno[iet]-ueltype*t7)/t5;unode=(tmatno[iet]-ueltype*t7-ubscode*t5)/t3;uieGID=tmatno[iet]-ueltype*t7-ubscode*t5-unode*t3;
                                        if(swplt)indat_matno[*necount]=tmatno[iet]+MAX_GID-1-uieGID;else indat_matno[*necount]=tmatno[iet];
                                       }
                                 }
                    else {if(rsid<=0.){indat_matno[*necount]=tmatno[iet];if(sfsect[iet]> -1){indat_fsect[*nfscount]=(*necount*10+sfsect[iet])*1000; *nfscount= *nfscount+1;}}
                          else      {ueltype=tmatno[iet]/t7;ubscode=(tmatno[iet]-ueltype*t7)/t5;unode=(tmatno[iet]-ueltype*t7-ubscode*t5)/t3;uieGID=tmatno[iet]-ueltype*t7-ubscode*t5-unode*t3;
                                     if(swplt)indat_matno[*necount]=tmatno[iet]+MAX_GID-1-uieGID;else indat_matno[*necount]=tmatno[iet];
                                    }
                         }
//
                   }
				 *necount=*necount+1;
		}
	  }
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subd4(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isel,int isectsw,float shapeprod,int swplt,
  long base_nop1[],long base_matno[],float base_c1[],float base_res1[],long nColRes,long indat_nop1[],long indat_matno[],float indat_c1[],float indat_res1[],long indat_fsect[])
// Global NDF,MXNPEL,MXNPEI,MXNPELS,MAX_GID
{long t3=1000,t5=100000,t7=10000000,teltype=0,tbscode=0,tnode=0,ueltype=0,ubscode=0,unode=0,uieGID=0,nop4[2*MXNPELS],tmatno[2],i=0,sfsect[14],sectn=0;
 int node=0,nodemx=0,incount=0,in=0,ic=0,ip=0,iet=0,icp=0,tnelt=0,flagarr[MXNPELS],is=0,flagnd[10];
 float rsid=0.,xave=0.,yave=0.,zave=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],tcoor[10*NDF];
 node=4;nodemx=10;incount=0;for(ip=0;ip<10;ip++)flagnd[ip]=0;for(ip=0;ip<14;ip++)sfsect[ip]= -1;
 for(in=0;in<node;in++)
	{if(!Undeformedmesh1->Checked)rsid=aval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]  ])+
bval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+1])+
cval*(base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+in]+2])+dval;
	 else rsid=aval*base_c1[NDF*base_nop1[MXNPEL*ie+in]  ]+bval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+1]+cval*base_c1[NDF*base_nop1[MXNPEL*ie+in]+2]+dval;
     if(isectsw>0){if(rsid>0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}else {if(rsid<=0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}
	}
 if(incount==node)
   {if(isel!=2){for(in=0;in<node;in++)indat_nop1[MXNPEI* *necount+in]=base_nop1[MXNPEL*ie+in];indat_matno[*necount]=base_matno[ie];}
    *necount=*necount+1;
   }
 else if(incount>0)
	{FDnode_subd4(aval,bval,cval,dval,ie,tcoor,isectsw,shapeprod,base_nop1,base_c1,base_res1,nColRes);tnelt=2;
         if(incount==1 || incount==3)
		{tmatno[0]=base_matno[ie]-(5-7)*t7-(4-6)*1000;tmatno[1]=base_matno[ie];
		 if     (flagarr[1]+flagarr[2]+flagarr[3]==0 || flagarr[1]+flagarr[2]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 0;}
		 else if(flagarr[0]+flagarr[2]+flagarr[3]==0 || flagarr[0]+flagarr[2]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 1;}
		 else if(flagarr[0]+flagarr[1]+flagarr[3]==0 || flagarr[0]+flagarr[1]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 2;}
		 else {
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 3;}
                 sfsect[ 0]=10*sectn+4;sfsect[ 1]=10*sectn+0;
                }
		 else if(incount==2)
                {tmatno[0]=base_matno[ie]-(5-7)*t7-(4-6)*1000;tmatno[1]=tmatno[0];
                 if(flagarr[0]+flagarr[1]==0 || flagarr[0]+flagarr[1]==2){
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 3;}
                 else if(flagarr[1]+flagarr[2]==0 || flagarr[1]+flagarr[2]==2){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 3;}
                 else {
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 0;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 3;}
				 sfsect[ 0]=10*sectn+0;sfsect[ 1]=10*sectn+0;
			}
         else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subd4 unsupported ISEL.",L"Halt",MB_OK);return;}
	 for(iet=0;iet<tnelt;iet++){teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
									for(ic=0;ic<tnode;ic++)flagnd[nop4[iet*MXNPELS+ic]]=1;
								   }
	 for(icp=0;icp<node;icp++)flagnd[icp]=base_nop1[MXNPEL*ie+icp];
	 for(icp=node;icp<nodemx;icp++)
		{if(flagnd[icp])
		  {STFISO4(1,tcoor[icp*NDF+0],tcoor[icp*NDF+1],tcoor[icp*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
                   xval=yval=zval=0.;
                   if(!Undeformedmesh1->Checked)for(is=0;is<node;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
                        }
				   else for(is=0;is<node;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
                                               yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
											   zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
											  }
                   if(isel!=2){indat_c1[NDF* *npcount  ]=xval;indat_c1[NDF* *npcount+1]=yval;indat_c1[NDF* *npcount+2]=zval;}
                   if(nColRes){for(in=0;in<nColRes;in++)
                                 {xval=0.;for(is=0;is<node;is++)xval=xval+SN[is]*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+in];
								  indat_res1[nColRes* *npcount+in]=xval;
                                 }
                              }
                   flagnd[icp]=*npcount;*npcount=*npcount+1;
		  }
		}
		 for(iet=0;iet<tnelt;iet++)
		{teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
                 if(isel!=2)
				   {xave=yave=zave=0.;for(ic=0;ic<tnode;ic++)
			               {nop4[iet*MXNPELS+ic]=flagnd[nop4[iet*MXNPELS+ic]];xave=xave+indat_c1[NDF*nop4[MXNPELS*iet+ic]  ];
							yave=yave+indat_c1[NDF*nop4[MXNPELS*iet+ic]+1];zave=zave+indat_c1[NDF*nop4[MXNPELS*iet+ic]+2];
						   }
		    xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
		    rsid=aval*xave+bval*yave+cval*zave+dval;
					for(in=0;in<tnode;in++)indat_nop1[MXNPEI* *necount+in]=nop4[MXNPELS*iet+in];
                    if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI* *necount+in]=0;
                    if(isectsw>0){if(rsid>0.){indat_matno[*necount]=tmatno[iet];if(sfsect[iet]> -1){indat_fsect[*nfscount]=(*necount*10+sfsect[iet])*1000; *nfscount= *nfscount+1;}}
                                  else {ueltype=tmatno[iet]/t7;ubscode=(tmatno[iet]-ueltype*t7)/t5;unode=(tmatno[iet]-ueltype*t7-ubscode*t5)/t3;uieGID=tmatno[iet]-ueltype*t7-ubscode*t5-unode*t3;
                                        if(swplt)indat_matno[*necount]=tmatno[iet]+MAX_GID-1-uieGID;else indat_matno[*necount]=tmatno[iet];
                                       }
                                 }
                    else {if(rsid<=0.){indat_matno[*necount]=tmatno[iet];if(sfsect[iet]> -1){indat_fsect[*nfscount]=(*necount*10+sfsect[iet])*1000; *nfscount= *nfscount+1;}}
                          else      {ueltype=tmatno[iet]/t7;ubscode=(tmatno[iet]-ueltype*t7)/t5;unode=(tmatno[iet]-ueltype*t7-ubscode*t5)/t3;uieGID=tmatno[iet]-ueltype*t7-ubscode*t5-unode*t3;
                                     if(swplt)indat_matno[*necount]=tmatno[iet]+MAX_GID-1-uieGID;else indat_matno[*necount]=tmatno[iet];
                                    }
                         }
//
                   }
				 *necount=*necount+1;
		}
        }
}
//---------------------------------------------------------------------------
void TForm1::FDnode_subd8(float aval,float bval,float cval,float dval,long ie,float tcoor[],int isectsw,float shapeprod,long base_nop1[],float base_c1[],float base_res1[],long nColRes)
// Global NDF,MXNPEL
{int is=0,ic=0,ip=0,ipp=0,iside=0;float rsid0=0.,rsid1=0.,rmax=0.,rmin=0.,val=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
// int gdata8[24]={0,1,5,4,
//                 1,2,6,5,
//                 3,2,6,7,
//				 0,3,7,4,
//                 0,1,2,3,
//                 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
// int infill8[24]={ 8,13,16,12, //TBD: Check that this OK with revised gdata[24]
//				   9,14,17,13,
//				  10,14,18,15,
//				  11,15,19,12,
//				   8, 9,10,11,
//				  16,17,18,19};
 int infill8[24]={ 8,13,16,12, //TBD: Check that this is OK with revised gdata8[24]
                   9,14,17,13,
//                  10,14,18,15,
				  10,15,18,14,
//				  11,15,19,12,
				  11,12,19,15,
//				   8, 9,10,11,
                  10, 9, 8,11,
				  16,17,18,19};
 ip=0;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]= -1.;ip=1;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]= -1.;
 ip=2;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;    ip=3;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;
 ip=4;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]=1.;  ip=5;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]=1.;
 ip=6;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;      ip=7;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;
 for(ic=0;ic<NDF;ic++){tcoor[ 8*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[1*NDF+ic])/2.;tcoor[ 9*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[2*NDF+ic])/2.;
					   tcoor[10*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[3*NDF+ic])/2.;tcoor[11*NDF+ic]=(tcoor[3*NDF+ic]+tcoor[0*NDF+ic])/2.;
					   for(ip=0;ip<4;ip++)tcoor[(ip+12)*NDF+ic]=(tcoor[ip*NDF+ic]+tcoor[(ip+4)*NDF+ic])/2.;
					   tcoor[16*NDF+ic]=(tcoor[4*NDF+ic]+tcoor[5*NDF+ic])/2.;tcoor[17*NDF+ic]=(tcoor[5*NDF+ic]+tcoor[6*NDF+ic])/2.;
					   tcoor[18*NDF+ic]=(tcoor[6*NDF+ic]+tcoor[7*NDF+ic])/2.;tcoor[19*NDF+ic]=(tcoor[7*NDF+ic]+tcoor[4*NDF+ic])/2.;
					  }
//  Side#
 for(iside=0;iside<6;iside++)
	{for(ip=0;ip<4;ip++)
		{ipp=ip+1;if(ipp>3)ipp=0;
		 STFISO8(1,tcoor[gdata8[4*iside+ip]*NDF+0],tcoor[gdata8[4*iside+ip]*NDF+1],tcoor[gdata8[4*iside+ip]*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
		 xval=yval=zval=0.;
                 if(!Undeformedmesh1->Checked)for(is=0;is<8;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
                        }
		 else for(is=0;is<8;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
			                  yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
			                  zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
			                 }
		 rsid0=aval*xval+bval*yval+cval*zval+dval;
		 STFISO8(1,tcoor[gdata8[4*iside+ipp]*NDF+0],tcoor[gdata8[4*iside+ipp]*NDF+1],tcoor[gdata8[4*iside+ipp]*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
		 xval=yval=zval=0.;
				 if(!Undeformedmesh1->Checked)for(is=0;is<8;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
                        }
		 else for(is=0;is<8;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
							  yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
			                  zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
			                 }
		 rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
		 rmin=rsid0+rsid1-rmax;
		 if(rmax>0. && rmin<=0.)
                   {val=rsid1/(rsid1-rsid0);if(val< 0.001)val=0.001;if(val> 0.999)val=0.999;
					for(ic=0;ic<NDF;ic++)tcoor[infill8[4*iside+ip]*NDF+ic]=val*tcoor[gdata8[4*iside+ip]*NDF+ic]+(1.-val)*tcoor[gdata8[4*iside+ipp]*NDF+ic];
                   }
		}
	}
}
//---------------------------------------------------------------------------
void TForm1::FDnode_subd6(float aval,float bval,float cval,float dval,long ie,float tcoor[],int isectsw,float shapeprod,long base_nop1[],float base_c1[],float base_res1[],long nColRes)
// Global NDF,MXNPEL
{int is=0,ic=0,ip=0,ipp=0,iside=0,nepts=0;float rsid0=0.,rsid1=0.,rmax=0.,rmin=0.,val=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
                 2,0,3,5,
				 0,2,1,0,
                 3,4,5,0};
 int infill6[20]={ 6,10,12, 9,
                   7,11,13,10,
                   8, 9,14,11,
                   8, 7, 6, 0,
				  12,13,14, 0};
 ip=0;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=1;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;
 ip=2;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=3;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 ip=4;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;  ip=5;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 for(ic=0;ic<NDF;ic++){tcoor[ 6*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[1*NDF+ic])/2.;tcoor[ 7*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[2*NDF+ic])/2.;tcoor[ 8*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[0*NDF+ic])/2.;
					   for(ip=0;ip<3;ip++)tcoor[(ip+9)*NDF+ic]=(tcoor[ip*NDF+ic]+tcoor[(ip+3)*NDF+ic])/2.;
					   tcoor[12*NDF+ic]=(tcoor[3*NDF+ic]+tcoor[4*NDF+ic])/2.;tcoor[13*NDF+ic]=(tcoor[4*NDF+ic]+tcoor[5*NDF+ic])/2.;tcoor[14*NDF+ic]=(tcoor[5*NDF+ic]+tcoor[3*NDF+ic])/2.;
                      }
//  Side#
 for(iside=0;iside<5;iside++)
	{if(iside<3)nepts=4;else nepts=3;
	 for(ip=0;ip<nepts;ip++)
		{ipp=ip+1;if(ipp>nepts-1)ipp=0;
		 STFISO6(1,tcoor[gdata6[4*iside+ip]*NDF+0],tcoor[gdata6[4*iside+ip]*NDF+1],tcoor[gdata6[4*iside+ip]*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
		 xval=yval=zval=0.;
                 if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
                        }
		 else for(is=0;is<6;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
							  yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
			                  zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
							 }
		 rsid0=aval*xval+bval*yval+cval*zval+dval;
		 STFISO6(1,tcoor[gdata6[4*iside+ipp]*NDF+0],tcoor[gdata6[4*iside+ipp]*NDF+1],tcoor[gdata6[4*iside+ipp]*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
		 xval=yval=zval=0.;
                 if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
                        }
		 else for(is=0;is<6;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
			                  yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
							  zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
			                 }
		 rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
		 rmin=rsid0+rsid1-rmax;
		 if(rmax>0. && rmin<=0.)
				   {val=rsid1/(rsid1-rsid0);if(val< 0.001)val=0.001;if(val> 0.999)val=0.999;
					for(ic=0;ic<NDF;ic++)tcoor[infill6[4*iside+ip]*NDF+ic]=val*tcoor[gdata6[4*iside+ip]*NDF+ic]+(1.-val)*tcoor[gdata6[4*iside+ipp]*NDF+ic];
                   }
		}
	}
}
//---------------------------------------------------------------------------
void TForm1::FDnode_subd4(float aval,float bval,float cval,float dval,long ie,float tcoor[],int isectsw,float shapeprod,long base_nop1[],float base_c1[],float base_res1[],long nColRes)
// Global NDF,MXNPEL
{int is=0,ic=0,ip=0,ipp=0,iside=0;float rsid0=0.,rsid1=0.,rmax=0.,rmin=0.,val=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
				 3,0,1};
 int infill4[12]={6,5,4,
                  5,9,8,
				  6,7,9,
                  7,4,8};
 ip=0;tcoor[NDF*ip+0]=1.;tcoor[NDF*ip+1]=0.;tcoor[NDF*ip+2]=0.;ip=1;tcoor[NDF*ip+0]=0.;tcoor[NDF*ip+1]=1.;tcoor[NDF*ip+2]=0.;
 ip=2;tcoor[NDF*ip+0]=0.;tcoor[NDF*ip+1]=0.;tcoor[NDF*ip+2]=1.;ip=3;tcoor[NDF*ip+0]=0.;tcoor[NDF*ip+1]=0.;tcoor[NDF*ip+2]=0.;
 for(ic=0;ic<NDF;ic++){tcoor[ 4*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[1*NDF+ic])/2.;tcoor[ 5*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[2*NDF+ic])/2.;
                       tcoor[ 6*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[0*NDF+ic])/2.;tcoor[ 7*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[3*NDF+ic])/2.;
                       tcoor[ 8*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[3*NDF+ic])/2.;tcoor[ 9*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[3*NDF+ic])/2.;
					  }
//  Side#
 for(iside=0;iside<4;iside++)
	{for(ip=0;ip<3;ip++)
		{ipp=ip+1;if(ipp>2)ipp=0;
		 STFISO4(1,tcoor[gdata4[3*iside+ip]*NDF+0],tcoor[gdata4[3*iside+ip]*NDF+1],tcoor[gdata4[3*iside+ip]*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
		 xval=yval=zval=0.;
                 if(!Undeformedmesh1->Checked)for(is=0;is<4;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
						}
		 else for(is=0;is<4;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
                  			  yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
			                  zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
							 }
		 rsid0=aval*xval+bval*yval+cval*zval+dval;
		 STFISO4(1,tcoor[gdata4[3*iside+ipp]*NDF+0],tcoor[gdata4[3*iside+ipp]*NDF+1],tcoor[gdata4[3*iside+ipp]*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
		 xval=yval=zval=0.;
                 if(!Undeformedmesh1->Checked)for(is=0;is<4;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
                        }
		 else for(is=0;is<4;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
			                  yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
			                  zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
							 }
			 rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
		 rmin=rsid0+rsid1-rmax;
		 if(rmax>0. && rmin<=0.)
                   {val=rsid1/(rsid1-rsid0);if(val< 0.001)val=0.001;if(val> 0.999)val=0.999;
                    for(ic=0;ic<NDF;ic++)tcoor[infill4[3*iside+ip]*NDF+ic]=val*tcoor[gdata4[3*iside+ip]*NDF+ic]+(1.-val)*tcoor[gdata4[3*iside+ipp]*NDF+ic];
                   }
		}
          }
}
//---------------------------------------------------------------------------
void TForm1::FDnode_dir6(float aval,float bval,float cval,float dval,long ie,int isectsw,float shapeprod,int *flag,long base_nop1[],float base_c1[],float base_res1[],long nColRes)
// Global NDF,MXNPEL
{int is=0,ip=0,ipp=0,ips=0;   // Subr. to determine diag.cuts across wedges
 float rsid0=0.,rsid1=0.,rsid2=0.,rmax=0.,rmin=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],tcoor[6*NDF]; *flag= -1;
 ip=0;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=1;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;
 ip=2;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=3;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 ip=4;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;  ip=5;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 for(ip=0;ip<3;ip++)
   {ipp=ip+3;STFISO6(1,tcoor[ip*NDF+0],tcoor[ip*NDF+1],tcoor[ip*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
    xval=yval=zval=0.;
    if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
                        }
    else for(is=0;is<6;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
                             zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
							}
    rsid0=aval*xval+bval*yval+cval*zval+dval;
    STFISO6(1,tcoor[ipp*NDF+0],tcoor[ipp*NDF+1],tcoor[ipp*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
	xval=yval=zval=0.;
    if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
						}
    else for(is=0;is<6;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
                             yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
                             zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];
                            }
	rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
    rmin=rsid0+rsid1-rmax;
    if(rmax>0. && rmin<=0.)
      {ips=ip+1;if(ips>2)ips=0;STFISO6(1,tcoor[ips*NDF+0],tcoor[ips*NDF+1],tcoor[ips*NDF+2],&DJD,HN,SN,SG,DJR,base_nop1+MXNPEL*ie,base_c1);
       xval=yval=zval=0.;
       if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);}
	   else for(is=0;is<6;is++){xval=xval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]  ];
                                yval=yval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+1];
								zval=zval+SN[is]*base_c1[NDF*base_nop1[MXNPEL*ie+is]+2];}
	   rsid2=aval*xval+bval*yval+cval*zval+dval;if(rsid2>rsid0)rmax=rsid2;else rmax=rsid0;
       rmin=rsid0+rsid2-rmax;if(rmax>0. && rmin<=0.)*flag= -ip-1;else *flag=ip+1;
	   break;
	  }
   }
}
//---------------------------------------------------------------------------
void TForm1::FDnode_cir6(float aval,float bval,float cval,float dval,long ie,int isectsw,float shapeprod,int *flag,long indat_nop1[],float indat_c1[])
// Global NDF,MXNPEL
{int is=0,ip=0,ipp=0,ips=0;   // Subr. to determine diag.cuts across wedges
 float rsid0=0.,rsid1=0.,rsid2=0.,rmax=0.,rmin=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],tcoor[6*NDF]; *flag= -1;
 ip=0;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=1;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;
 ip=2;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=3;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 ip=4;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;  ip=5;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 for(ip=0;ip<3;ip++)
   {ipp=ip+3;STFISO6(1,tcoor[ip*NDF+0],tcoor[ip*NDF+1],tcoor[ip*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEL*ie,indat_c1);
    xval=yval=zval=0.;
// indat_c1[] already contains     shapeprod*base_res1[]???
//    if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
//xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
//yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
//zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
//                        }
//    else
    for(is=0;is<6;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]  ];yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]+1];
                        zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]+2];
                       }
    rsid0=aval*xval+bval*yval+cval*zval+dval;STFISO6(1,tcoor[ipp*NDF+0],tcoor[ipp*NDF+1],tcoor[ipp*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEL*ie,indat_c1);
	xval=yval=zval=0.;
//    if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
//xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
//yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
//zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
//                        }
//    else
    for(is=0;is<6;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]  ];yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]+1];
                        zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]+2];
					   }
    rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
    rmin=rsid0+rsid1-rmax;
    if(rmax>0. && rmin<=0.)
      {ips=ip+1;if(ips>2)ips=0;STFISO6(1,tcoor[ips*NDF+0],tcoor[ips*NDF+1],tcoor[ips*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEL*ie,indat_c1);
       xval=yval=zval=0.;
//       if(!Undeformedmesh1->Checked)for(is=0;is<6;is++){
//xval=xval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]  ]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]  ]);
//yval=yval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+1]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+1]);
//zval=zval+SN[is]*(base_c1[NDF*base_nop1[MXNPEL*ie+is]+2]+shapeprod*base_res1[nColRes*base_nop1[MXNPEL*ie+is]+2]);
//                        }
//       else
	   for(is=0;is<6;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]  ];
                           yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]+1];
						   zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEL*ie+is]+2];}
       rsid2=aval*xval+bval*yval+cval*zval+dval;if(rsid2>rsid0)rmax=rsid2;else rmax=rsid0;
       rmin=rsid0+rsid2-rmax;if(rmax>0. && rmin<=0.)*flag= -ip-1;else *flag=ip+1;
       break;
      }
   }
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subc8(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isel,int isectsw,float shapeprod,int iswf,long sectn,
  long indat_nop1[],long indat_matno[],float indat_c1[],float indat_res1[],long nColRes,long indat_nfsect,long indat_fsect[])
// Global NDF,MXNPEI,MXNPELS,MAX_NSECTION
// Note that Left-right switch isectsw is related to exposed face switch isw.... figure it out
{long t3=1000,t5=100000,t7=10000000,teltype=0,tbscode=0,tnode=0,nop4[14*MXNPELS],tmatno[14],i=0,sfsect[14*MAX_NSECTION],isidep=0,iep=0,nprior=0,aprior[2],asect=0,apr=0;
 int node=0,nodemx=0,incount=0,in=0,ic=0,ip=0,ipp=0,iet=0,icp=0,tnelt=0,flagarr[MXNPELS],flagnd[20],is=0,iside=0,fp=0,isw=0,starr[3]
// ,inrec=0,isiderec=0
;
 float rsid=0.,tcoor[20*NDF],xave=0.,yave=0.,zave=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],tol=1.e-4;
// int gdata8[24]={0,1,5,4,
//                 1,2,6,5,
//                 3,2,6,7,
//				 0,3,7,4,
//                 0,1,2,3,
//                 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 node=8;nodemx=20;incount=0;for(ip=0;ip<nodemx;ip++)flagnd[ip]=0;for(ip=0;ip<14*MAX_NSECTION;ip++)sfsect[ip]= -1;
 for(in=0;in<node;in++)
    {rsid=aval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ]+bval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1]+cval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2]+dval;
     if(isectsw>0){if(rsid>0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}else {if(rsid<=0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}
    }
 if(incount>0 && incount<node)
	{FDnode_subc8(aval,bval,cval,dval,ie,tcoor,isectsw,shapeprod,indat_nop1,indat_c1);nprior=0;
////////////////////////////
if(indat_nfsect){for(ic=0;ic<indat_nfsect;ic++)
				  {if(indat_fsect[ic]> -1)
                    {iep=indat_fsect[ic]/10000;
					 if(iep==ie){isidep=indat_fsect[ic]/1000-10*iep;asect=indat_fsect[ic]-10*(indat_fsect[ic]/10);
                                 aprior[nprior]=10*asect+isidep;indat_fsect[ic]= -1;nprior=nprior+1;
                                 if(ic+1<indat_nfsect)
                                   {if(indat_fsect[ic+1]> -1)
                                      {iep=indat_fsect[ic+1]/10000;
									   if(iep==ie)
                                         {isidep=indat_fsect[ic+1]/1000-10*iep;asect=indat_fsect[ic+1]-10*(indat_fsect[ic+1]/10);
                                          aprior[nprior]=10*asect+isidep;indat_fsect[ic+1]= -1;nprior=nprior+1;
                                         }
                                      }
                                   }
								 break;
                                }
                    }
				  }
                }
////////////////////////////
	 if(incount==4)elnum44c_d8(&tnelt,flagarr,nop4,tmatno,indat_matno[ie],sfsect,nprior,aprior,sectn);
	 else if(incount==2 || incount==6)
		{iside=0;isw=0;
		 while(iside<6 && isw<1)
			{for(ip=0;ip<2;ip++)
				{ipp=ip+2;fp=flagarr[gdata8[4*iside+ip]]+flagarr[gdata8[4*iside+ipp]];
//				 if(incount==2 && fp==2){isw=1;isiderec=iside;inrec=ip;break;} //isiderec & inrec not currently used
//				 if(incount==6 && fp==0){isw=1;isiderec=iside;inrec=ip;break;}
				 if(incount==2 && fp==2){isw=1;break;}if(incount==6 && fp==0){isw=1;break;}
				}
			 iside++;
			}
		 if(isw)
//  Opposite corners
			{tnelt=7;tmatno[0]=indat_matno[ie];for(icp=1;icp<5;icp++)tmatno[icp]=indat_matno[ie]-(8-7)*t7-(8-6)*1000;
						 tmatno[5]=indat_matno[ie]-(8-5)*t7-(8-4)*1000;tmatno[6]=indat_matno[ie]-(8-5)*t7-(8-4)*1000;
if     (flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]=13;nop4[MXNPELS*i+ 7]=16;
i= 1;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=19;
i= 4;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 9;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 9;nop4[MXNPELS*i+ 6]=14;nop4[MXNPELS*i+ 7]=17;
i= 1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]=16;
i= 4;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=10;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 5;i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=10;nop4[MXNPELS*i+ 6]=15;nop4[MXNPELS*i+ 7]=18;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]= 7;
i= 3;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]=17;
i= 4;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=11;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 6;i= 6;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=11;nop4[MXNPELS*i+ 6]=12;nop4[MXNPELS*i+ 7]=19;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]= 3;
i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=18;
i= 4;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 8;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]= 8;nop4[MXNPELS*i+ 7]=13;
i= 1;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;
i= 3;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=17;
i= 4;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=11;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 5;i= 6;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]= 9;nop4[MXNPELS*i+ 7]=14;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;
i= 3;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=18;
i= 4;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 8;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 6;i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]=15;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=19;
i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 9;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=15;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]=12;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 7;
i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 0;
i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=16;
i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=10;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=17;nop4[MXNPELS*i+ 6]=18;nop4[MXNPELS*i+ 7]=19;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 7;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=12;
i= 4;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]=14;
i= 5;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 6;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]=16;nop4[MXNPELS*i+ 6]=17;nop4[MXNPELS*i+ 7]=18;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]=15;
i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]=13;
i= 5;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 5;}
else if(flagarr[0]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]=11;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]= 9;
i= 1;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 2;
i= 3;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=13;
i= 4;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=15;
i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 1;i= 6;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 3;}
else {
//else if(flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]=10;
i= 1;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=14;
i= 4;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]=12;
i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 2;i= 6;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;}
 sfsect[ 3*MAX_NSECTION]=10*sectn+4;sfsect[ 4*MAX_NSECTION]=10*sectn+4;sfsect[ 5*MAX_NSECTION]=10*sectn+0;sfsect[ 6*MAX_NSECTION]=10*sectn+0;
 if(nprior){sfsearch35_d8(0,8,nop4,sfsect,8,nprior,aprior,4);sfsearch35_d8(0,8,nop4,sfsect,8,nprior,aprior,5);
            sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,2);
            sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,3);sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,4);
			sfsearch35_d8(2,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(2,7,nop4,sfsect,8,nprior,aprior,2);
            sfsearch35_d8(2,7,nop4,sfsect,8,nprior,aprior,3);sfsearch35_d8(2,7,nop4,sfsect,8,nprior,aprior,4);
            sfsearch35_d8(3,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(3,7,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(3,7,nop4,sfsect,8,nprior,aprior,3);
			sfsearch35_d8(4,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(4,7,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(4,7,nop4,sfsect,8,nprior,aprior,3);
            sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,3);
            sfsearch35_d8(6,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(6,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(6,5,nop4,sfsect,8,nprior,aprior,3);
           }
			}
		 else
//  Adjacent corners
			{tnelt=4;for(icp=0;icp<4;icp++)tmatno[icp]=indat_matno[ie]-(8-7)*t7-(8-6)*1000;
if     (flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 7;
i= 1;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 4;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 4;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 7;
i= 3;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 5;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 7;
i= 2;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 6;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=19;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=18;nop4[MXNPELS*i+ 5]= 7;}
else if(flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 4;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 0;}
else if(flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 0;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 0;nop4[MXNPELS*i+ 5]= 1;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 0;
i= 3;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]==6){
i= 0;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 1;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=16;nop4[MXNPELS*i+ 5]= 4;}
else if(flagarr[0]+flagarr[1]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 1;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;}
else if(flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 6;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[6]+flagarr[7]==6){
i= 0;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 2;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 2;
i= 3;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 5;}
else {
//else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==6){
i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 2;
i= 1;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=17;nop4[MXNPELS*i+ 5]= 1;
i= 3;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 6;}
//
 sfsect[ 2*MAX_NSECTION]=10*sectn+0;sfsect[ 3*MAX_NSECTION]=10*sectn+0;
 if(nprior){sfsearch35_d8(0,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(0,7,nop4,sfsect,8,nprior,aprior,2);
            sfsearch35_d8(0,7,nop4,sfsect,8,nprior,aprior,3);sfsearch35_d8(0,7,nop4,sfsect,8,nprior,aprior,4);
            sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,2);
            sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,3);sfsearch35_d8(1,7,nop4,sfsect,8,nprior,aprior,4);
            sfsearch35_d8(2,7,nop4,sfsect,8,nprior,aprior,3);sfsearch35_d8(2,7,nop4,sfsect,8,nprior,aprior,4);
            sfsearch35_d8(3,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(3,7,nop4,sfsect,8,nprior,aprior,2);
			sfsearch35_d8(3,7,nop4,sfsect,8,nprior,aprior,3);sfsearch35_d8(3,7,nop4,sfsect,8,nprior,aprior,4);
           }
			}
		}
//
	 else if(incount==1 || incount==7)
		{tnelt=6;tmatno[0]=indat_matno[ie]-(8-7)*t7-(8-6)*1000;for(icp=1;icp<6;icp++)tmatno[icp]=indat_matno[ie]-(8-5)*t7-(8-4)*1000;
if     (flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 6;i= 2;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 7;
i= 3;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 2;i= 4;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 5;
i= 5;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 7;i= 2;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;
i= 3;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 6;
i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=10;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 4;i= 2;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 5;
i= 3;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 0;i= 4;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 7;
i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=11;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 5;i= 2;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 6;
i= 3;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 1;i= 4;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;
i= 5;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=16;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 2;i= 2;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;
i= 3;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;i= 4;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 6;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 4;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=17;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 3;i= 2;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;
i= 3;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;i= 4;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 7;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 5;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[7]==7){
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=18;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;i= 2;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;
i= 3;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 6;}
else {
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]=15;nop4[MXNPELS*i+ 5]=19;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 1;i= 2;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;
i= 3;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;i= 4;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 5;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 7;}
 sfsect[ 0*MAX_NSECTION]=10*sectn+4;sfsect[ 5*MAX_NSECTION]=10*sectn+0;
 if(nprior){sfsearch35_d8(0,7,nop4,sfsect,8,nprior,aprior,0);sfsearch35_d8(0,7,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(0,7,nop4,sfsect,8,nprior,aprior,2);
            sfsearch35_d8(2,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(2,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(2,5,nop4,sfsect,8,nprior,aprior,3);
			sfsearch35_d8(3,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(3,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(3,5,nop4,sfsect,8,nprior,aprior,3);
            sfsearch35_d8(4,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(4,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(4,5,nop4,sfsect,8,nprior,aprior,3);
			sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,3);
		   }
		}
//
	 else if(incount==3 || incount==5)
		{tnelt=9;
                 if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==3){icp=0;for(ip=0;ip<node;ip++)if(flagarr[ip]>0){starr[icp]=ip;icp++;}}
                 else {icp=0;for(ip=0;ip<node;ip++)if(flagarr[ip]<=0){starr[icp]=ip;icp++;}}
                 elnum35_d8(starr[0],starr[1],starr[2],nop4,tmatno,indat_matno[ie]);
 sfsect[ 1*MAX_NSECTION]=10*sectn+3;sfsect[ 2*MAX_NSECTION]=10*sectn+3;sfsect[ 3*MAX_NSECTION]=10*sectn+3;
 sfsect[ 4*MAX_NSECTION]=10*sectn+3;sfsect[ 6*MAX_NSECTION]=10*sectn+3;sfsect[ 8*MAX_NSECTION]=10*sectn+0;
 if(nprior){sfsearch35_d8(0,8,nop4,sfsect,8,nprior,aprior,0);sfsearch35_d8(0,8,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(0,8,nop4,sfsect,8,nprior,aprior,2);
            sfsearch35_d8(0,8,nop4,sfsect,8,nprior,aprior,3);sfsearch35_d8(0,8,nop4,sfsect,8,nprior,aprior,5);
            sfsearch35_d8(1,5,nop4,sfsect,8,nprior,aprior,0);sfsearch35_d8(2,5,nop4,sfsect,8,nprior,aprior,0);
			sfsearch35_d8(3,5,nop4,sfsect,8,nprior,aprior,0);sfsearch35_d8(4,5,nop4,sfsect,8,nprior,aprior,0);
            sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(5,5,nop4,sfsect,8,nprior,aprior,3);
			sfsearch35_d8(6,5,nop4,sfsect,8,nprior,aprior,0);
            sfsearch35_d8(7,5,nop4,sfsect,8,nprior,aprior,1);sfsearch35_d8(7,5,nop4,sfsect,8,nprior,aprior,2);sfsearch35_d8(7,5,nop4,sfsect,8,nprior,aprior,3);
			sfsearch35_d8(8,5,nop4,sfsect,8,nprior,aprior,0);
           }
		}
//
         else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subc8 unsupported ISEL.",L"Halt",MB_OK);return;}
	 for(iet=0;iet<tnelt;iet++){teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
                                    for(ic=0;ic<tnode;ic++)flagnd[nop4[iet*MXNPELS+ic]]=1;
                                   }
	 for(icp=0;icp<node;icp++)flagnd[icp]=indat_nop1[MXNPEI*ie+icp];
	 for(icp=node;icp<nodemx;icp++)
		{if(flagnd[icp])
		  {STFISO8(1,tcoor[icp*NDF+0],tcoor[icp*NDF+1],tcoor[icp*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
                   xval=yval=zval=0.;
                   for(is=0;is<node;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
										  yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
                                          zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
										 }
				   if(isel!=2){indat_c1[NDF* *npcount  ]=xval;indat_c1[NDF* *npcount+1]=yval;indat_c1[NDF* *npcount+2]=zval;}
                   if(nColRes){for(in=0;in<nColRes;in++)
                                 {xval=0.;for(is=0;is<node;is++)xval=xval+SN[is]*indat_res1[nColRes*indat_nop1[MXNPEI*ie+is]+in];
								  indat_res1[nColRes* *npcount+in]=xval;
                                 }
                              }
				   flagnd[icp]=*npcount;*npcount=*npcount+1;
		  }
		}
         for(iet=0;iet<tnelt;iet++)
           {teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
            if(iet==0)
		{if(isel!=2)
                   {xave=yave=zave=0.;
                    for(in=0;in<tnode;in++){indat_nop1[MXNPEI*ie+in]=flagnd[nop4[MXNPELS*iet+in]];xave=xave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ];
											yave=yave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1];zave=zave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2];
                                           }
					xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
                    if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI*ie+in]=0;
                    indat_matno[ie]=tmatno[iet];
//////////////////////////// Add switch........  if(isectsw>0){if(rsid>0.)
                    rsid=aval*xave+bval*yave+cval*zave+dval;
					ip=0;if(iswf)
                           {if(rsid>0.-tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                              indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                           }
                         else
						   {if(rsid<=0.+tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                              indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
						   }
                    for(ip=1;ip<MAX_NSECTION;ip++)
					  {if(sfsect[iet*MAX_NSECTION+ip]> -1)
						{asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                         indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                      }
////////////////////////////
                   }
                }
            else
		{if(isel!=2)
                   {xave=yave=zave=0.;
                    for(in=0;in<tnode;in++){indat_nop1[MXNPEI* *necount+in]=flagnd[nop4[MXNPELS*iet+in]];xave=xave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]  ];
                                            yave=yave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]+1];zave=zave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]+2];
                                           }
                    xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
                    if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI* *necount+in]=0;
                    indat_matno[*necount]=tmatno[iet];
//////////////////////////// Add switch........  if(isectsw>0){if(rsid>0.)
                    rsid=aval*xave+bval*yave+cval*zave+dval;
					ip=0;if(iswf)
                           {if(rsid>0.-tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                              indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                           }
						 else
                           {if(rsid<=0.+tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                              indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
						   }
                    for(ip=1;ip<MAX_NSECTION;ip++)
					  {if(sfsect[iet*MAX_NSECTION+ip]> -1)
                        {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                         indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
					  }
////////////////////////////
				   }
				 *necount=*necount+1;
		}
           }
	}
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subc6(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isel,int isectsw,float shapeprod,int iswf,long sectn,
  long indat_nop1[],long indat_matno[],float indat_c1[],float indat_res1[],long nColRes,long indat_nfsect,long indat_fsect[])
// Global NDF,MXNPEI,MXNPELS,MAX_NSECTION
{long t3=1000,t5=100000,t7=10000000,teltype=0,tbscode=0,tnode=0,nop4[5*MXNPELS],tmatno[5],i=0,sfsect[14*MAX_NSECTION],isidep=0,iep=0,nprior=0,aprior[2],asect=0,apr=0;
 int node=0,nodemx=0,incount=0,in=0,ic=0,ip=0,iet=0,icp=0,tnelt=0,flagarr[MXNPELS],is=0,dflag= -1,flagnd[15];
 float rsid=0.,xave=0.,yave=0.,zave=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],tcoor[15*NDF],tol=1.e-4;
 node=6;nodemx=15;incount=0;for(ip=0;ip<nodemx;ip++)flagnd[ip]=0;for(ip=0;ip<14*MAX_NSECTION;ip++)sfsect[ip]= -1;
 for(in=0;in<node;in++)
    {rsid=aval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ]+bval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1]+cval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2]+dval;
	 if(isectsw>0){if(rsid>0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}else {if(rsid<=0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}
    }
 if(incount>0 && incount<node)
	{FDnode_subc6(aval,bval,cval,dval,ie,tcoor,isectsw,shapeprod,indat_nop1,indat_c1);nprior=0;
////////////////////////////
if(indat_nfsect){for(ic=0;ic<indat_nfsect;ic++)
                  {if(indat_fsect[ic]> -1)
					{iep=indat_fsect[ic]/10000;
                     if(iep==ie){isidep=indat_fsect[ic]/1000-10*iep;asect=indat_fsect[ic]-10*(indat_fsect[ic]/10);
                                 aprior[nprior]=10*asect+isidep;indat_fsect[ic]= -1;nprior=nprior+1;
                                 if(ic+1<indat_nfsect)
                                   {if(indat_fsect[ic+1]> -1)
                                      {iep=indat_fsect[ic+1]/10000;
									   if(iep==ie)
                                         {isidep=indat_fsect[ic+1]/1000-10*iep;asect=indat_fsect[ic+1]-10*(indat_fsect[ic+1]/10);
                                          aprior[nprior]=10*asect+isidep;indat_fsect[ic+1]= -1;nprior=nprior+1;
										 }
                                      }
								   }
								 break;
                                }
                    }
				  }
                }
////////////////////////////
	 if(incount==1 || incount==5)
		{tnelt=3;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie]-(7-5)*t7-(6-4)*1000;
if     (flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]= 2;nop4[MXNPELS*i+ 7]= 1;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 8;
i= 2;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 6;nop4[MXNPELS*i+ 6]= 0;nop4[MXNPELS*i+ 7]= 2;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 6;
i= 2;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 3;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]= 1;nop4[MXNPELS*i+ 7]= 0;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 7;
i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]= 4;nop4[MXNPELS*i+ 7]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]=12;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 3;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]+flagarr[5]==5){
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]= 5;nop4[MXNPELS*i+ 7]= 3;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=13;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 4;}
else {i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]= 3;nop4[MXNPELS*i+ 7]= 4;
      i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=14;
      i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;}
				 sfsect[ 1*MAX_NSECTION]=10*sectn+4;sfsect[ 2*MAX_NSECTION]=10*sectn+0;
                 if(nprior){for(ic=1;ic<6;ic++)sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);
							sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,0);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,1);
							sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,3);for(ic=1;ic<4;ic++)sfsearch_d6(2,5,nop4,sfsect,8,nprior,aprior,ic);
                           }
//
		}
	 else if(incount==2 || incount==4){
if     (flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]==4){
tnelt=3;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]=11;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 3;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 4;
sfsect[ 0*MAX_NSECTION]=10*sectn+5;sfsect[ 2*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<5;ic++){sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
                               sfsearch_d6(2,7,nop4,sfsect,8,nprior,aprior,ic);
                              }
          }
										  }
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[4]==4){
tnelt=3;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 5;
sfsect[ 0*MAX_NSECTION]=10*sectn+5;sfsect[ 2*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<5;ic++){sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
                               sfsearch_d6(2,7,nop4,sfsect,8,nprior,aprior,ic);
                              }
          }
                                                                                                         }
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]==0 || flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]==4){
tnelt=3;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]= 9;nop4[MXNPELS*i+ 7]=10;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 3;
sfsect[ 0*MAX_NSECTION]=10*sectn+5;sfsect[ 2*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<5;ic++){sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
							   sfsearch_d6(2,7,nop4,sfsect,8,nprior,aprior,ic);
                              }
          }
																										 }
else if(flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[0]+flagarr[3]+flagarr[4]+flagarr[5]==4){
tnelt=3;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 8;nop4[MXNPELS*i+ 6]=11;nop4[MXNPELS*i+ 7]=10;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]= 2;
sfsect[ 0*MAX_NSECTION]=10*sectn+5;sfsect[ 2*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<5;ic++){sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
                               sfsearch_d6(2,7,nop4,sfsect,8,nprior,aprior,ic);
                              }
          }
                                                                                                         }
else if(flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[1]+flagarr[3]+flagarr[4]+flagarr[5]==4){
tnelt=3;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 6;nop4[MXNPELS*i+ 6]= 9;nop4[MXNPELS*i+ 7]=11;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 0;
sfsect[ 0*MAX_NSECTION]=10*sectn+5;sfsect[ 2*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<5;ic++){sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
							   sfsearch_d6(2,7,nop4,sfsect,8,nprior,aprior,ic);
                              }
          }
																										 }
else if(flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==0 || flagarr[2]+flagarr[3]+flagarr[4]+flagarr[5]==4){
tnelt=3;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 3;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]=10;nop4[MXNPELS*i+ 7]= 9;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]= 1;
sfsect[ 0*MAX_NSECTION]=10*sectn+5;sfsect[ 2*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<5;ic++){sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
							   sfsearch_d6(2,7,nop4,sfsect,8,nprior,aprior,ic);
							  }
          }
                                                                                                         }
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]==0 || flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]==4){
tnelt=2;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]=14;nop4[MXNPELS*i+ 6]= 3;nop4[MXNPELS*i+ 7]= 4;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
sfsect[ 0*MAX_NSECTION]=10*sectn+0;sfsect[ 1*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<6;ic++)sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);
           for(ic=1;ic<5;ic++)sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
          }
                                                                                                         }
else if(flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]==0 || flagarr[0]+flagarr[2]+flagarr[3]+flagarr[5]==4){
tnelt=2;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 0;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]= 5;nop4[MXNPELS*i+ 7]= 3;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
sfsect[ 0*MAX_NSECTION]=10*sectn+0;sfsect[ 1*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<6;ic++)sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);
		   for(ic=1;ic<5;ic++)sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);
          }
                                                                                                         }
else {tnelt=2;tmatno[0]=indat_matno[ie]-(7-8)*t7-(6-8)*1000;tmatno[1]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]=12;nop4[MXNPELS*i+ 6]= 4;nop4[MXNPELS*i+ 7]= 5;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 3;
sfsect[ 0*MAX_NSECTION]=10*sectn+0;sfsect[ 1*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<6;ic++)sfsearch_d6(0,8,nop4,sfsect,8,nprior,aprior,ic);for(ic=1;ic<5;ic++)sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);}
     }
		}
//
	 else if(incount==3)
		{if(flagarr[0]+flagarr[1]+flagarr[2]==0 || flagarr[0]+flagarr[1]+flagarr[2]==3)
				   {tnelt=2;tmatno[0]=indat_matno[ie];tmatno[1]=indat_matno[ie];
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=10;nop4[MXNPELS*i+ 5]=11;
i= 1;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=10;
sfsect[ 0*MAX_NSECTION]=10*sectn+4;sfsect[ 1*MAX_NSECTION]=10*sectn+4;
if(nprior){for(ic=0;ic<4;ic++){sfsearch_d6(0,7,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic);}}
                   }
				 else
                   {FDnode_cir6(aval,bval,cval,dval,ie,isectsw,shapeprod,&dflag,indat_nop1,indat_c1);
tnelt=5;tmatno[0]=indat_matno[ie];tmatno[1]=indat_matno[ie];tmatno[2]=indat_matno[ie];
tmatno[3]=indat_matno[ie]-(7-5)*t7-(6-4)*1000;tmatno[4]=indat_matno[ie]-(7-5)*t7-(6-4)*1000;
if     (flagarr[0]+flagarr[1]+flagarr[3]==0 || flagarr[0]+flagarr[1]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 3;
i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;i= 4;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[0]+flagarr[2]+flagarr[5]==0 || flagarr[0]+flagarr[2]+flagarr[5]==3){
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 7;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 5;
i= 2;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 4;i= 4;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 1;}
else if(flagarr[1]+flagarr[2]+flagarr[4]==0 || flagarr[1]+flagarr[2]+flagarr[4]==3){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 4;
i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;}
else if(flagarr[0]+flagarr[1]+flagarr[4]==0 || flagarr[0]+flagarr[1]+flagarr[4]==3){
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]=13;nop4[MXNPELS*i+ 5]= 7;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 0;
i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 5;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 5;i= 4;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 2;}
else if(flagarr[1]+flagarr[2]+flagarr[5]==0 || flagarr[1]+flagarr[2]+flagarr[5]==3){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]=14;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 1;
i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 3;
i= 3;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 3;i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;}
else {
i= 0;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 2;
i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 4;
i= 3;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 4;i= 4;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 1;}
sfsect[ 0*MAX_NSECTION]=10*sectn+4;sfsect[ 1*MAX_NSECTION]=10*sectn+0;sfsect[ 2*MAX_NSECTION]=10*sectn+0;sfsect[ 3*MAX_NSECTION]=10*sectn+0;
if(nprior){for(ic=1;ic<4;ic++){sfsearch_d6(0,7,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(1,7,nop4,sfsect,8,nprior,aprior,ic+1);
                               sfsearch_d6(2,7,nop4,sfsect,8,nprior,aprior,ic);sfsearch_d6(4,5,nop4,sfsect,8,nprior,aprior,ic);
                              }
           sfsearch_d6(3,5,nop4,sfsect,8,nprior,aprior,1);
          }
                   }
		}
//
         else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subc6 unsupported ISEL.",L"Halt",MB_OK);return;}
	 for(iet=0;iet<tnelt;iet++){teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
                                    for(ic=0;ic<tnode;ic++)flagnd[nop4[iet*MXNPELS+ic]]=1;
								   }
	 for(icp=0;icp<node;icp++)flagnd[icp]=indat_nop1[MXNPEI*ie+icp];
	 for(icp=node;icp<nodemx;icp++)
		{if(flagnd[icp])
		  {STFISO6(1,tcoor[icp*NDF+0],tcoor[icp*NDF+1],tcoor[icp*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
                   xval=yval=zval=0.;
                   for(is=0;is<node;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
										  yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
                                          zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
                                         }
                   if(isel!=2){indat_c1[NDF* *npcount  ]=xval;indat_c1[NDF* *npcount+1]=yval;indat_c1[NDF* *npcount+2]=zval;}
                   if(nColRes){for(in=0;in<nColRes;in++)
                                 {xval=0.;for(is=0;is<node;is++)xval=xval+SN[is]*indat_res1[nColRes*indat_nop1[MXNPEI*ie+is]+in];
								  indat_res1[nColRes* *npcount+in]=xval;
                                 }
                              }
				   flagnd[icp]=*npcount;*npcount=*npcount+1;
		  }
		}
		 for(iet=0;iet<tnelt;iet++)
           {teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
            if(iet==0)
		{if(isel!=2)
                   {xave=yave=zave=0.;
                    for(in=0;in<tnode;in++){indat_nop1[MXNPEI*ie+in]=flagnd[nop4[MXNPELS*iet+in]];
                                            xave=xave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ];yave=yave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1];
                                            zave=zave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2];
                                           }
                    xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
                    if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI*ie+in]=0;
                    indat_matno[ie]=tmatno[iet];
//////////////////////////// Add switch........  if(isectsw>0){if(rsid>0.)
                    rsid=aval*xave+bval*yave+cval*zave+dval;
                    ip=0;if(iswf)
						   {if(rsid>0.-tol && sfsect[iet*MAX_NSECTION+ip]> -1)
							 {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
							  indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                           }
                         else
                           {if(rsid<=0.+tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
							  indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                           }
					for(ip=1;ip<MAX_NSECTION;ip++)
                       {if(sfsect[iet*MAX_NSECTION+ip]> -1)
                         {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                          indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
					   }
////////////////////////////
                   }
				}
            else
		{if(isel!=2)
				   {xave=yave=zave=0.;
                    for(in=0;in<tnode;in++){indat_nop1[MXNPEI* *necount+in]=flagnd[nop4[MXNPELS*iet+in]];xave=xave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]  ];
                                            yave=yave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]+1];zave=zave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]+2];
										   }
                    xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
                    if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI* *necount+in]=0;
                    indat_matno[*necount]=tmatno[iet];
//////////////////////////// Add switch........  if(isectsw>0){if(rsid>0.)
                    rsid=aval*xave+bval*yave+cval*zave+dval;
                    ip=0;if(iswf)
                           {if(rsid>0.-tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                              indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                           }
                         else
						   {if(rsid<=0.+tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
							  indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                           }
                    for(ip=1;ip<MAX_NSECTION;ip++)
                      {if(sfsect[iet*MAX_NSECTION+ip]> -1)
                        {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
						 indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;}
                      }
////////////////////////////
                   }
                 *necount=*necount+1;
		}
		   }
      }
}
//---------------------------------------------------------------------------
void TForm1::FDelem_subc4(float aval,float bval,float cval,float dval,long *necount,long *npcount,long *nfscount,long ie,int isel,int isectsw,float shapeprod,int iswf,long sectn,
  long indat_nop1[],long indat_matno[],float indat_c1[],float indat_res1[],long nColRes,long indat_nfsect,long indat_fsect[])
// Global NDF,MXNPEI,MXNPELS,MAX_NSECTION
{long t3=1000,t5=100000,t7=10000000,teltype=0,tbscode=0,tnode=0,nop4[2*MXNPELS],tmatno[2],i=0,sfsect[14*MAX_NSECTION],isidep=0,iep=0,nprior=0,aprior[2],asect=0,apr=0;
 int node=0,nodemx=0,incount=0,in=0,ic=0,ip=0,iet=0,icp=0,tnelt=0,flagarr[MXNPELS],is=0,flagnd[10];
 float rsid=0.,xave=0.,yave=0.,zave=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],tcoor[10*NDF],tol=1.e-4;
 node=4;nodemx=10;incount=0;for(ip=0;ip<nodemx;ip++)flagnd[ip]=0;for(ip=0;ip<14*MAX_NSECTION;ip++)sfsect[ip]= -1;
 for(in=0;in<node;in++)
    {rsid=aval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ]+bval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1]+cval*indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2]+dval;
     if(isectsw>0){if(rsid>0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}else {if(rsid<=0.){flagarr[in]=1;incount++;}else flagarr[in]=0;}
    }
 if(incount>0 && incount<node)
	{FDnode_subc4(aval,bval,cval,dval,ie,tcoor,isectsw,shapeprod,indat_nop1,indat_c1);tnelt=2;nprior=0;
////////////////////////////
if(indat_nfsect){for(ic=0;ic<indat_nfsect;ic++)
                  {if(indat_fsect[ic]> -1)
                    {iep=indat_fsect[ic]/10000;
					 if(iep==ie){isidep=indat_fsect[ic]/1000-10*iep;asect=indat_fsect[ic]-10*(indat_fsect[ic]/10);
                                 aprior[nprior]=10*asect+isidep;indat_fsect[ic]= -1;nprior=nprior+1;
								 if(ic+1<indat_nfsect)
                                   {if(indat_fsect[ic+1]> -1)
                                      {iep=indat_fsect[ic+1]/10000;
                                       if(iep==ie)
                                         {isidep=indat_fsect[ic+1]/1000-10*iep;asect=indat_fsect[ic+1]-10*(indat_fsect[ic+1]/10);
										  aprior[nprior]=10*asect+isidep;indat_fsect[ic+1]= -1;nprior=nprior+1;
                                         }
                                      }
                                   }
                                 break;
                                }
					}
                  }
                }
////////////////////////////
         if(incount==1 || incount==3)
		{tmatno[0]=indat_matno[ie]-(5-7)*t7-(4-6)*1000;tmatno[1]=indat_matno[ie];
		 if     (flagarr[1]+flagarr[2]+flagarr[3]==0 || flagarr[1]+flagarr[2]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 0;}
		 else if(flagarr[0]+flagarr[2]+flagarr[3]==0 || flagarr[0]+flagarr[2]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 8;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 1;}
		 else if(flagarr[0]+flagarr[1]+flagarr[3]==0 || flagarr[0]+flagarr[1]+flagarr[3]==3){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 2;}
		 else {
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 9;
i= 1;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 3;}
                 sfsect[ 0*MAX_NSECTION]=10*sectn+4;sfsect[ 1*MAX_NSECTION]=10*sectn+0;
                 if(nprior){for(ic=0;ic<4;ic++)sfsearch_d4(0,7,nop4,sfsect,6,nprior,aprior,ic);
                            for(ic=1;ic<4;ic++)sfsearch_d4(1,5,nop4,sfsect,6,nprior,aprior,ic);
						   }
                }
		 else if(incount==2)
                {tmatno[0]=indat_matno[ie]-(5-7)*t7-(4-6)*1000;tmatno[1]=tmatno[0];
                 if(flagarr[0]+flagarr[1]==0 || flagarr[0]+flagarr[1]==2){
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 5;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 1;
i= 1;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 7;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]= 3;}
				 else if(flagarr[1]+flagarr[2]==0 || flagarr[1]+flagarr[2]==2){
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 6;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 2;
i= 1;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 9;nop4[MXNPELS*i+ 5]= 3;}
                 else {
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 0;
i= 1;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 3;}
				 sfsect[ 0*MAX_NSECTION]=10*sectn+0;sfsect[ 1*MAX_NSECTION]=10*sectn+0;
                 if(nprior){for(ic=1;ic<5;ic++){sfsearch_d4(0,7,nop4,sfsect,6,nprior,aprior,ic);sfsearch_d4(1,7,nop4,sfsect,6,nprior,aprior,ic);}
						   }
			}
         else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"FDelem_subc4 unsupported ISEL.",L"Halt",MB_OK);return;}
	 for(iet=0;iet<tnelt;iet++){teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
									for(ic=0;ic<tnode;ic++)flagnd[nop4[iet*MXNPELS+ic]]=1;
                                   }
	 for(icp=0;icp<node;icp++)flagnd[icp]=indat_nop1[MXNPEI*ie+icp];
	 for(icp=node;icp<nodemx;icp++)
		{if(flagnd[icp])
		  {STFISO4(1,tcoor[icp*NDF+0],tcoor[icp*NDF+1],tcoor[icp*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
                   xval=yval=zval=0.;
                   for(is=0;is<node;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
                                          yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
                                          zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
                                         }
                   if(isel!=2){indat_c1[NDF* *npcount  ]=xval;indat_c1[NDF* *npcount+1]=yval;indat_c1[NDF* *npcount+2]=zval;}
                   if(nColRes){for(in=0;in<nColRes;in++)
                                 {xval=0.;for(is=0;is<node;is++)xval=xval+SN[is]*indat_res1[nColRes*indat_nop1[MXNPEI*ie+is]+in];
                                  indat_res1[nColRes* *npcount+in]=xval;
								 }
                              }
				   flagnd[icp]=*npcount;*npcount=*npcount+1;
		  }
		}
////////////////////////////..............
         for(iet=0;iet<tnelt;iet++)
		   {teltype=tmatno[iet]/t7;tbscode=(tmatno[iet]-teltype*t7)/t5;tnode=(tmatno[iet]-teltype*t7-tbscode*t5)/t3;
			if(iet==0)
		{if(isel!=2)
                   {xave=yave=zave=0.;
                    for(in=0;in<tnode;in++){indat_nop1[MXNPEI*ie+in]=flagnd[nop4[MXNPELS*iet+in]];
                                            xave=xave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]  ];yave=yave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+1];
											zave=zave+indat_c1[NDF*indat_nop1[MXNPEI*ie+in]+2];
                                           }
                    xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
					if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI*ie+in]=0;
                    indat_matno[ie]=tmatno[iet];
//////////////////////////// Add switch........  if(isectsw>0){if(rsid>0.)
					rsid=aval*xave+bval*yave+cval*zave+dval;
                    ip=0;if(iswf)
                           {if(rsid>0.-tol && sfsect[iet*MAX_NSECTION+ip]> -1)
							  {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                               indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;
                              }
                           }
                         else
                           {if(rsid<=0.+tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                              {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
                               indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;
                              }
                           }
                    for(ip=1;ip<MAX_NSECTION;ip++)
                      {if(sfsect[iet*MAX_NSECTION+ip]> -1)
						{asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
						 indat_fsect[*nfscount]=(ie*10+apr)*1000 +asect; *nfscount= *nfscount+1;
						}
                      }
////////////////////////////
                   }
                }
			else
		{if(isel!=2)
                   {xave=yave=zave=0.;
                    for(in=0;in<tnode;in++){indat_nop1[MXNPEI* *necount+in]=flagnd[nop4[MXNPELS*iet+in]];
                                            xave=xave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]  ];yave=yave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]+1];
                                            zave=zave+indat_c1[NDF*indat_nop1[MXNPEI* *necount+in]+2];
										   }
                    xave=xave/float(tnode);yave=yave/float(tnode);zave=zave/float(tnode);
                    if(tnode<MXNPEI)for(in=tnode;in<MXNPEI;in++)indat_nop1[MXNPEI* *necount+in]=0;
					indat_matno[*necount]=tmatno[iet];
//////////////////////////// Add switch........  if(isectsw>0){if(rsid>0.)
					rsid=aval*xave+bval*yave+cval*zave+dval;
					ip=0;if(iswf)
                           {if(rsid>0.-tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
							  indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;
                             }
                           }
                         else
                           {if(rsid<=0.+tol && sfsect[iet*MAX_NSECTION+ip]> -1)
                             {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
							  indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;
                             }
                           }
                    for(ip=1;ip<MAX_NSECTION;ip++)
                      {if(sfsect[iet*MAX_NSECTION+ip]> -1)
                         {asect=sfsect[iet*MAX_NSECTION+ip]/10;apr=sfsect[iet*MAX_NSECTION+ip]-10*asect;
						  indat_fsect[*nfscount]=(*necount*10+apr)*1000 +asect; *nfscount= *nfscount+1;
                         }
					  }
////////////////////////////
                   }
                 *necount=*necount+1;
		}
		   }
///////////////////////////...............
        }
}
//---------------------------------------------------------------------------
void TForm1::FDnode_subc8(float aval,float bval,float cval,float dval,long ie,float tcoor[],int isectsw,float shapeprod,long indat_nop1[],float indat_c1[])
// Global NDF,MXNPEI
{int is=0,ic=0,ip=0,ipp=0,iside=0;float rsid0=0.,rsid1=0.,rmax=0.,rmin=0.,val=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//                 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//                 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
// int infill8[24]={ 8,13,16,12, //TBD: Check that this is OK with revised gdata[24]
//				   9,14,17,13,
//                  10,14,18,15,
//                  11,15,19,12,
//                   8, 9,10,11,
//                  16,17,18,19};
 int infill8[24]={ 8,13,16,12, //TBD: Check that this is OK with revised gdata8[24]
                   9,14,17,13,
//                  10,14,18,15,
				  10,15,18,14,
//				  11,15,19,12,
				  11,12,19,15,
//				   8, 9,10,11,
                  10, 9, 8,11,
				  16,17,18,19};
 ip=0;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]= -1.;ip=1;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]= -1.;
 ip=2;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;    ip=3;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;
 ip=4;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]=1.;  ip=5;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]= -1.; tcoor[NDF*ip+2]=1.;
 ip=6;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;      ip=7;tcoor[NDF*ip+0]= -1.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;
 for(ic=0;ic<NDF;ic++){tcoor[ 8*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[1*NDF+ic])/2.;tcoor[ 9*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[2*NDF+ic])/2.;
                       tcoor[10*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[3*NDF+ic])/2.;tcoor[11*NDF+ic]=(tcoor[3*NDF+ic]+tcoor[0*NDF+ic])/2.;
                       for(ip=0;ip<4;ip++)tcoor[(ip+12)*NDF+ic]=(tcoor[ip*NDF+ic]+tcoor[(ip+4)*NDF+ic])/2.;
					   tcoor[16*NDF+ic]=(tcoor[4*NDF+ic]+tcoor[5*NDF+ic])/2.;tcoor[17*NDF+ic]=(tcoor[5*NDF+ic]+tcoor[6*NDF+ic])/2.;
                       tcoor[18*NDF+ic]=(tcoor[6*NDF+ic]+tcoor[7*NDF+ic])/2.;tcoor[19*NDF+ic]=(tcoor[7*NDF+ic]+tcoor[4*NDF+ic])/2.;
					  }
//  Side#
 for(iside=0;iside<6;iside++)
	{for(ip=0;ip<4;ip++)
		{ipp=ip+1;if(ipp>3)ipp=0;
		 STFISO8(1,tcoor[gdata8[4*iside+ip]*NDF+0],tcoor[gdata8[4*iside+ip]*NDF+1],tcoor[gdata8[4*iside+ip]*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
		 xval=yval=zval=0.;
                 for(is=0;is<8;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
                                     yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
                                     zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
                                    }
		 rsid0=aval*xval+bval*yval+cval*zval+dval;
		 STFISO8(1,tcoor[gdata8[4*iside+ipp]*NDF+0],tcoor[gdata8[4*iside+ipp]*NDF+1],tcoor[gdata8[4*iside+ipp]*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
		 xval=yval=zval=0.;
		 for(is=0;is<8;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
			             yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
						 zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
						}
		 rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
		 rmin=rsid0+rsid1-rmax;
		 if(rmax>0. && rmin<=0.)
                   {val=rsid1/(rsid1-rsid0);if(val< 0.001)val=0.001;if(val> 0.999)val=0.999;
					for(ic=0;ic<NDF;ic++)tcoor[infill8[4*iside+ip]*NDF+ic]=val*tcoor[gdata8[4*iside+ip]*NDF+ic]+(1.-val)*tcoor[gdata8[4*iside+ipp]*NDF+ic];
                   }
		}
	}
}
//---------------------------------------------------------------------------
void TForm1::FDnode_subc6(float aval,float bval,float cval,float dval,long ie,float tcoor[],int isectsw,float shapeprod,long indat_nop1[],float indat_c1[])
// Global NDF,MXNPEI
{int is=0,ic=0,ip=0,ipp=0,iside=0,nepts=0;float rsid0=0.,rsid1=0.,rmax=0.,rmin=0.,val=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
                 2,0,3,5,
				 0,2,1,0,
                 3,4,5,0};
 int infill6[20]={ 6,10,12, 9,
                   7,11,13,10,
                   8, 9,14,11,
				   8, 7, 6, 0,
                  12,13,14, 0};
 ip=0;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=1;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]= -1.;
 ip=2;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]= -1.;ip=3;tcoor[NDF*ip+0]=1.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 ip=4;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=1.; tcoor[NDF*ip+2]=1.;  ip=5;tcoor[NDF*ip+0]=0.; tcoor[NDF*ip+1]=0.; tcoor[NDF*ip+2]=1.;
 for(ic=0;ic<NDF;ic++){tcoor[ 6*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[1*NDF+ic])/2.;tcoor[ 7*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[2*NDF+ic])/2.;tcoor[ 8*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[0*NDF+ic])/2.;
					   for(ip=0;ip<3;ip++)tcoor[(ip+9)*NDF+ic]=(tcoor[ip*NDF+ic]+tcoor[(ip+3)*NDF+ic])/2.;
                       tcoor[12*NDF+ic]=(tcoor[3*NDF+ic]+tcoor[4*NDF+ic])/2.;tcoor[13*NDF+ic]=(tcoor[4*NDF+ic]+tcoor[5*NDF+ic])/2.;tcoor[14*NDF+ic]=(tcoor[5*NDF+ic]+tcoor[3*NDF+ic])/2.;
                      }
//  Side#
 for(iside=0;iside<5;iside++)
	{if(iside<3)nepts=4;else nepts=3;
	 for(ip=0;ip<nepts;ip++)
		{ipp=ip+1;if(ipp>nepts-1)ipp=0;
		 STFISO6(1,tcoor[gdata6[4*iside+ip]*NDF+0],tcoor[gdata6[4*iside+ip]*NDF+1],tcoor[gdata6[4*iside+ip]*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
		 xval=yval=zval=0.;
		 for(is=0;is<6;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
                                     yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
                                     zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
                                    }
		 rsid0=aval*xval+bval*yval+cval*zval+dval;
		 STFISO6(1,tcoor[gdata6[4*iside+ipp]*NDF+0],tcoor[gdata6[4*iside+ipp]*NDF+1],tcoor[gdata6[4*iside+ipp]*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
		 xval=yval=zval=0.;
		 for(is=0;is<6;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
			             yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
			             zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
			            }
		 rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
		 rmin=rsid0+rsid1-rmax;
		 if(rmax>0. && rmin<=0.)
                   {val=rsid1/(rsid1-rsid0);if(val< 0.001)val=0.001;if(val> 0.999)val=0.999;
                    for(ic=0;ic<NDF;ic++)tcoor[infill6[4*iside+ip]*NDF+ic]=val*tcoor[gdata6[4*iside+ip]*NDF+ic]+(1.-val)*tcoor[gdata6[4*iside+ipp]*NDF+ic];
                   }
		}
	}
}
//---------------------------------------------------------------------------
void TForm1::FDnode_subc4(float aval,float bval,float cval,float dval,long ie,float tcoor[],int isectsw,float shapeprod,long indat_nop1[],float indat_c1[])
// Global NDF,MXNPEI
{int is=0,ic=0,ip=0,ipp=0,iside=0;float rsid0=0.,rsid1=0.,rmax=0.,rmin=0.,val=0.,xval=0.,yval=0.,zval=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
				 3,0,1};
 int infill4[12]={6,5,4,
				  5,9,8,
				  6,7,9,
                  7,4,8};
 ip=0;tcoor[NDF*ip+0]=1.;tcoor[NDF*ip+1]=0.;tcoor[NDF*ip+2]=0.;ip=1;tcoor[NDF*ip+0]=0.;tcoor[NDF*ip+1]=1.;tcoor[NDF*ip+2]=0.;
 ip=2;tcoor[NDF*ip+0]=0.;tcoor[NDF*ip+1]=0.;tcoor[NDF*ip+2]=1.;ip=3;tcoor[NDF*ip+0]=0.;tcoor[NDF*ip+1]=0.;tcoor[NDF*ip+2]=0.;
 for(ic=0;ic<NDF;ic++)
   {tcoor[ 4*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[1*NDF+ic])/2.;tcoor[ 5*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[2*NDF+ic])/2.;
    tcoor[ 6*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[0*NDF+ic])/2.;tcoor[ 7*NDF+ic]=(tcoor[0*NDF+ic]+tcoor[3*NDF+ic])/2.;
    tcoor[ 8*NDF+ic]=(tcoor[1*NDF+ic]+tcoor[3*NDF+ic])/2.;tcoor[ 9*NDF+ic]=(tcoor[2*NDF+ic]+tcoor[3*NDF+ic])/2.;
   }
//  Side#
 for(iside=0;iside<4;iside++)
	{for(ip=0;ip<3;ip++)
		{ipp=ip+1;if(ipp>2)ipp=0;
		 STFISO4(1,tcoor[gdata4[3*iside+ip]*NDF+0],tcoor[gdata4[3*iside+ip]*NDF+1],tcoor[gdata4[3*iside+ip]*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
		 xval=yval=zval=0.;
		 for(is=0;is<4;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
                                     yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
									 zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
                                    }
		 rsid0=aval*xval+bval*yval+cval*zval+dval;
		 STFISO4(1,tcoor[gdata4[3*iside+ipp]*NDF+0],tcoor[gdata4[3*iside+ipp]*NDF+1],tcoor[gdata4[3*iside+ipp]*NDF+2],&DJD,HN,SN,SG,DJR,indat_nop1+MXNPEI*ie,indat_c1);
		 xval=yval=zval=0.;
		 for(is=0;is<4;is++){xval=xval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]  ];
                                     yval=yval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+1];
                                     zval=zval+SN[is]*indat_c1[NDF*indat_nop1[MXNPEI*ie+is]+2];
                                    }
		 rsid1=aval*xval+bval*yval+cval*zval+dval;if(rsid1>rsid0)rmax=rsid1;else rmax=rsid0;
		 rmin=rsid0+rsid1-rmax;
		 if(rmax>0. && rmin<=0.)
                   {val=rsid1/(rsid1-rsid0);if(val< 0.001)val=0.001;if(val> 0.999)val=0.999;
                    for(ic=0;ic<NDF;ic++)tcoor[infill4[3*iside+ip]*NDF+ic]=val*tcoor[gdata4[3*iside+ip]*NDF+ic]+(1.-val)*tcoor[gdata4[3*iside+ipp]*NDF+ic];
				   }
		}
		  }
}
//---------------------------------------------------------------------------
void TForm1::elnum35_d8(int low,int mid,int hih,long nop4[],long tmatno[],long base_m)
// Global MXNPELS
{int i=0,icp=0;long t7=10000000;tmatno[0]=base_m;for(icp=1;icp<9;icp++)tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;
 if(low==0)
   {if(mid==1){if(hih==2){
i= 0;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 4;nop4[MXNPELS*i+ 6]= 5;nop4[MXNPELS*i+ 7]= 6;
i= 1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;
i= 3;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=13;i= 4;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=13;
i= 5;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 0;i= 6;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=11;
i= 7;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;i= 8;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=10;}
               else if(hih==3){
i= 0;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]= 4;nop4[MXNPELS*i+ 7]= 5;
i= 1;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=12;i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=12;
i= 3;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=12;i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=12;
i= 5;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 3;i= 6;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=10;
i= 7;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 1;i= 8;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 9;}
               else if(hih==4){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 2;nop4[MXNPELS*i+ 5]= 3;nop4[MXNPELS*i+ 6]= 7;nop4[MXNPELS*i+ 7]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=19;i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=19;
i= 3;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=19;i= 4;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=19;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 0;i= 6;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 8;
i= 7;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 5;i= 8;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;}
               else {
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 6;nop4[MXNPELS*i+ 6]= 2;nop4[MXNPELS*i+ 7]= 3;
i= 1;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;
i= 3;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 9;i= 4;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 9;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 5;i= 6;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=16;
i= 7;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 0;i= 8;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=12;}
              }
	else if(mid==2){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 6;nop4[MXNPELS*i+ 6]= 7;nop4[MXNPELS*i+ 7]= 4;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=15;i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=15;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=15;i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=15;
i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 2;i= 6;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 9;
i= 7;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;i= 8;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 8;
				   }
    else if(mid==3){if(hih==4){
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]= 6;nop4[MXNPELS*i+ 5]= 5;nop4[MXNPELS*i+ 6]= 1;nop4[MXNPELS*i+ 7]= 2;
i= 1;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 8;i= 2;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 8;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 8;i= 4;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 8;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=19;
i= 7;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]= 3;i= 8;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=15;}
                    else {
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 1;nop4[MXNPELS*i+ 6]= 2;nop4[MXNPELS*i+ 7]= 6;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=10;i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=10;
i= 3;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=10;i= 4;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=10;
i= 5;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 0;i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=12;
i= 7;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 7;i= 8;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=19;}
                   }
	else {if(hih==5){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 2;nop4[MXNPELS*i+ 5]= 3;nop4[MXNPELS*i+ 6]= 7;nop4[MXNPELS*i+ 7]= 6;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=19;i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=19;
i= 3;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=19;i= 4;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=19;
i= 5;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 0;i= 6;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 8;
i= 7;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 5;i= 8;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=13;}
          else {
i= 0;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 2;nop4[MXNPELS*i+ 5]= 6;nop4[MXNPELS*i+ 6]= 5;nop4[MXNPELS*i+ 7]= 1;
i= 1;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=16;i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=16;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=16;i= 4;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=16;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=15;
i= 7;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 0;i= 8;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=11;}
         }
   }
 else if(low==1)
   {if(mid==2){if(hih==3){
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 5;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 7;
i= 1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;
i= 3;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=14;i= 4;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=14;
i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 1;i= 6;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 8;
i= 7;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;i= 8;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=11;}
               else if(hih==5){
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 7;nop4[MXNPELS*i+ 5]= 3;nop4[MXNPELS*i+ 6]= 0;nop4[MXNPELS*i+ 7]= 4;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 8;i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 8;
i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 8;i= 4;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 8;
i= 5;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 2;i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=14;
i= 7;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]= 5;i= 8;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=17;}
               else {
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 8;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]= 3;nop4[MXNPELS*i+ 7]= 0;
i= 1;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=10;i= 2;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=10;
i= 3;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=10;i= 4;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=10;
i= 5;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 6;i= 6;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=17;
i= 7;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 1;i= 8;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=13;}
              }
	else if(mid==4){
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 3;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 2;
i= 1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=17;i= 2;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=17;
i= 3;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=17;i= 4;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=17;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=12;
i= 7;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 1;i= 8;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 8;
                   }
    else {
i= 0;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]=18;nop4[MXNPELS*i+ 4]= 3;nop4[MXNPELS*i+ 5]= 0;nop4[MXNPELS*i+ 6]= 4;nop4[MXNPELS*i+ 7]= 7;
i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=16;i= 2;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=16;
i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=16;i= 4;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=16;
i= 5;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 1;i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 9;
i= 7;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 6;i= 8;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=14;
         }
   }
 else if(low==2)
   {if(mid==3){if(hih==6){
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]=17;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 0;nop4[MXNPELS*i+ 6]= 1;nop4[MXNPELS*i+ 7]= 5;
i= 1;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 9;i= 2;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 9;
i= 3;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 9;i= 4;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 9;
i= 5;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;i= 6;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=15;
i= 7;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 6;i= 8;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=18;}
               else {
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 5;nop4[MXNPELS*i+ 5]= 4;nop4[MXNPELS*i+ 6]= 0;nop4[MXNPELS*i+ 7]= 1;
i= 1;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=11;i= 2;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=11;
i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=11;i= 4;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=11;
i= 5;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=18;
i= 7;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]= 2;i= 8;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=14;}
              }
    else if(mid==5){
i= 0;nop4[MXNPELS*i+ 0]= 1;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]=10;nop4[MXNPELS*i+ 4]= 0;nop4[MXNPELS*i+ 5]= 4;nop4[MXNPELS*i+ 6]= 7;nop4[MXNPELS*i+ 7]= 3;
i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=18;i= 2;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=18;
i= 3;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 1;nop4[MXNPELS*i+ 3]=18;i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=18;
i= 5;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 5;i= 6;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=13;
i= 7;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 2;i= 8;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 9;
                   }
    else {
i= 0;nop4[MXNPELS*i+ 0]= 3;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]=19;nop4[MXNPELS*i+ 4]= 0;nop4[MXNPELS*i+ 5]= 1;nop4[MXNPELS*i+ 6]= 5;nop4[MXNPELS*i+ 7]= 4;
i= 1;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=17;i= 2;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=17;
i= 3;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 3;nop4[MXNPELS*i+ 3]=17;i= 4;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=17;
i= 5;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 2;i= 6;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=10;
i= 7;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 7;i= 8;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=15;
         }
   }
 else if(low==3)
   {if(mid==4){
i= 0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 2;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 5;
i= 1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=18;i= 2;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=18;
i= 3;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 0;nop4[MXNPELS*i+ 3]=18;i= 4;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=18;
i= 5;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 3;i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=11;
i= 7;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;i= 8;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=12;}
	else {
i= 0;nop4[MXNPELS*i+ 0]= 2;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]=11;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 5;nop4[MXNPELS*i+ 6]= 4;nop4[MXNPELS*i+ 7]= 0;
i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=19;i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=19;
i= 3;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]=19;i= 4;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=19;
i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 6;i= 6;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=14;
i= 7;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 3;i= 8;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=10;}
   }
 else if(low==4)
   {if(mid==5){if(hih==6){
i= 0;nop4[MXNPELS*i+ 0]= 7;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]=12;nop4[MXNPELS*i+ 4]= 3;nop4[MXNPELS*i+ 5]= 2;nop4[MXNPELS*i+ 6]= 1;nop4[MXNPELS*i+ 7]= 0;
i= 1;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=13;i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=13;
i= 3;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=13;i= 4;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=13;
i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 6;i= 6;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=18;
i= 7;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 4;i= 8;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=19;}
               else {
i= 0;nop4[MXNPELS*i+ 0]= 6;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]= 2;nop4[MXNPELS*i+ 5]= 1;nop4[MXNPELS*i+ 6]= 0;nop4[MXNPELS*i+ 7]= 3;
i= 1;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=12;i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=12;
i= 3;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=12;i= 4;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=12;
i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 5;i= 6;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=17;
i= 7;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]= 7;i= 8;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=18;}
              }
    else {
i= 0;nop4[MXNPELS*i+ 0]= 5;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]=14;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 0;nop4[MXNPELS*i+ 6]= 3;nop4[MXNPELS*i+ 7]= 2;
i= 1;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=15;i= 2;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=15;
i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]=15;i= 4;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=15;
i= 5;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;i= 6;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=16;
i= 7;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 6;i= 8;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]=17;
		 }
   }
 else {
i= 0;nop4[MXNPELS*i+ 0]= 4;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]=13;nop4[MXNPELS*i+ 4]= 0;nop4[MXNPELS*i+ 5]= 3;nop4[MXNPELS*i+ 6]= 2;nop4[MXNPELS*i+ 7]= 1;
i= 1;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=14;i= 2;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=14;
i= 3;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 4;nop4[MXNPELS*i+ 3]=14;i= 4;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=14;
i= 5;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 7;i= 6;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=19;
i= 7;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]= 5;i= 8;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 6;nop4[MXNPELS*i+ 3]=16;
      }
}
//---------------------------------------------------------------------------
void TForm1::elnum44_d8(int *tnelt,int flagarr[],long nop4[],long tmatno[],long base_m,long sfsect[])
// Global MXNPELS
// Tetra    tmatno[0]=base_matno[ie]-(8-5)*t7-(8-4)*1000; Wedge    tmatno[0]=base_matno[ie]-(8-7)*t7-(8-6)*1000;
{int i=0,icp=0;long t7=10000000;
if(flagarr[0]+flagarr[3]+flagarr[7]+flagarr[4]==0 || flagarr[1]+flagarr[2]+flagarr[6]+flagarr[5]==0)
{*tnelt=2;tmatno[0]=base_m;tmatno[1]=base_m;
 i=0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]=10;nop4[MXNPELS*i+ 6]=18;nop4[MXNPELS*i+ 7]=16;
 i=1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 2;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 5;
 sfsect[0]=5;sfsect[1]=4;}
else if(flagarr[0]+flagarr[4]+flagarr[5]+flagarr[1]==0 || flagarr[3]+flagarr[7]+flagarr[6]+flagarr[2]==0)
{*tnelt=2;tmatno[0]=base_m;tmatno[1]=base_m;
 i=0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=19;nop4[MXNPELS*i+ 6]=17;nop4[MXNPELS*i+ 7]= 9;
 i=1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 3;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 2;
 sfsect[0]=5;sfsect[1]=4;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]==0 || flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0)
{*tnelt=2;tmatno[0]=base_m;tmatno[1]=base_m;
 i=0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]=14;nop4[MXNPELS*i+ 7]=15;
 i=1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 5;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 7;
 sfsect[0]=5;sfsect[1]=4;}
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]==0 || flagarr[2]+flagarr[5]+flagarr[6]+flagarr[7]==0)
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp]=0;}
 i= 0;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 4;i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 1;
 i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 0;i= 3;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 0;
 i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 0;i= 5;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 0;
 i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 3;i= 7;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 2;
 i= 8;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 7;i= 9;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 6;
 i=10;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 6;i=11;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 6;
 i=12;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 6;i=13;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 5;}
else if(flagarr[0]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[6]==0)
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp]=0;}
 i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 7;i= 1;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 5;
 i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 4;i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 4;
 i= 4;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 4;i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 4;
 i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 0;i= 7;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 1;
 i= 8;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 3;i= 9;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 2;
 i=10;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 2;i=11;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 2;
 i=12;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 2;i=13;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 6;}
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]==0 || flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0)
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp]=0;}
 i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 3;i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 6;
 i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 7;i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 7;
 i= 4;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 7;i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 7;
 i= 6;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 4;i= 7;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 5;
 i= 8;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 0;i= 9;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 1;
 i=10;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 1;i=11;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 1;
 i=12;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 1;i=13;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 2;}
else
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp]=0;}
 i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 2;
 i= 2;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 3;i= 3;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 3;
 i= 4;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 3;i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 3;
 i= 6;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 7;i= 7;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 6;
 i= 8;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 4;i= 9;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;
 i=10;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 5;i=11;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;
 i=12;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 5;i=13;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 1;}
}
//---------------------------------------------------------------------------
void TForm1::elnum44c_d8(int *tnelt,int flagarr[],long nop4[],long tmatno[],long base_m,long sfsect[],long nprior,long aprior[],long sectn)
// Global NDF,MXNPELS,MAX_NSECTION
// Tetra    tmatno[0]=base_matno[ie]-(8-5)*t7-(8-4)*1000; Wedge    tmatno[0]=base_matno[ie]-(8-7)*t7-(8-6)*1000;
{int i=0,icp=0;long t7=10000000;
if(flagarr[0]+flagarr[3]+flagarr[7]+flagarr[4]==0 || flagarr[1]+flagarr[2]+flagarr[6]+flagarr[5]==0)
{*tnelt=2;tmatno[0]=base_m;tmatno[1]=base_m;
 i=0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 7;nop4[MXNPELS*i+ 3]= 4;nop4[MXNPELS*i+ 4]= 8;nop4[MXNPELS*i+ 5]=10;nop4[MXNPELS*i+ 6]=18;nop4[MXNPELS*i+ 7]=16;
 sfsect[0]=10*sectn+5;if(nprior)sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,0,4);
 i=1;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]=16;nop4[MXNPELS*i+ 4]= 1;nop4[MXNPELS*i+ 5]= 2;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 5;
 sfsect[1*MAX_NSECTION]=10*sectn+4;
 if(nprior){sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,0,3);sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,5,5);}
 }
else if(flagarr[0]+flagarr[4]+flagarr[5]+flagarr[1]==0 || flagarr[3]+flagarr[7]+flagarr[6]+flagarr[2]==0)
{*tnelt=2;tmatno[0]=base_m;tmatno[1]=base_m;
 i=0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]= 5;nop4[MXNPELS*i+ 3]= 1;nop4[MXNPELS*i+ 4]=11;nop4[MXNPELS*i+ 5]=19;nop4[MXNPELS*i+ 6]=17;nop4[MXNPELS*i+ 7]= 9;
 sfsect[0]=10*sectn+5;if(nprior)sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,0,4);
 i=1;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 9;nop4[MXNPELS*i+ 4]= 3;nop4[MXNPELS*i+ 5]= 7;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 2;
 sfsect[1*MAX_NSECTION]=10*sectn+4;
 if(nprior){sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,0,3);sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,5,5);}
 }
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[3]==0 || flagarr[4]+flagarr[5]+flagarr[6]+flagarr[7]==0)
{*tnelt=2;tmatno[0]=base_m;tmatno[1]=base_m;
 i=0;nop4[MXNPELS*i+ 0]= 0;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]= 2;nop4[MXNPELS*i+ 3]= 3;nop4[MXNPELS*i+ 4]=12;nop4[MXNPELS*i+ 5]=13;nop4[MXNPELS*i+ 6]=14;nop4[MXNPELS*i+ 7]=15;
 sfsect[0]=10*sectn+5;if(nprior)sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,0,4);
 i=1;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]=15;nop4[MXNPELS*i+ 4]= 4;nop4[MXNPELS*i+ 5]= 5;nop4[MXNPELS*i+ 6]= 6;nop4[MXNPELS*i+ 7]= 7;
 sfsect[1*MAX_NSECTION]=10*sectn+4;
 if(nprior){sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,0,3);sfsearch44_d8(i,4,nop4,sfsect,nprior,aprior,5,5);}
 }
else if(flagarr[0]+flagarr[1]+flagarr[3]+flagarr[4]==0 || flagarr[2]+flagarr[5]+flagarr[6]+flagarr[7]==0)
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp*MAX_NSECTION]=10*sectn+0;}
 i= 0;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 4;i= 1;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 1;
 i= 2;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 0;i= 3;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 0;
 i= 4;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 0;i= 5;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 0;
 i= 6;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 0;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 3;i= 7;nop4[MXNPELS*i+ 0]=10;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 2;
 i= 8;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 7;
 i= 9;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 6;i=10;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 6;
 i=11;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 6;i=12;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=16;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 6;
 i=13;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]= 6;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 5;
 if(nprior){icp=0;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=1;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=2;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=4;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
			icp=5;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=6;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
			icp=7;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=8;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=9;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=11;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
            icp=12;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=13;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
		   }
 }
else if(flagarr[0]+flagarr[4]+flagarr[5]+flagarr[7]==0 || flagarr[1]+flagarr[2]+flagarr[3]+flagarr[6]==0)
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp*MAX_NSECTION]=10*sectn+0;}
 i= 0;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 7;i= 1;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 5;
 i= 2;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=15;nop4[MXNPELS*i+ 3]= 4;i= 3;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 4;
 i= 4;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 4;i= 5;nop4[MXNPELS*i+ 0]=13;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 4;
 i= 6;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 4;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 0;i= 7;nop4[MXNPELS*i+ 0]= 8;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 1;
 i= 8;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 3;
 i= 9;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=13;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 2;i=10;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=15;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 2;
 i=11;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=13;nop4[MXNPELS*i+ 3]= 2;i=12;nop4[MXNPELS*i+ 0]=15;nop4[MXNPELS*i+ 1]=18;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 2;
 i=13;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]= 2;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 6;
 if(nprior){icp=0;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=1;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=2;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=4;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
			icp=5;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=6;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=7;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=8;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=9;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=11;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
            icp=12;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=13;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
           }
 }
else if(flagarr[0]+flagarr[1]+flagarr[2]+flagarr[5]==0 || flagarr[3]+flagarr[4]+flagarr[6]+flagarr[7]==0)
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp*MAX_NSECTION]=10*sectn+0;}
 i= 0;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 3;i= 1;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 6;
 i= 2;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=11;nop4[MXNPELS*i+ 3]= 7;i= 3;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 7;
 i= 4;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 7;i= 5;nop4[MXNPELS*i+ 0]=17;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 7;
 i= 6;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]= 7;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 4;i= 7;nop4[MXNPELS*i+ 0]=16;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 5;
 i= 8;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 0;
 i= 9;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=17;nop4[MXNPELS*i+ 2]=16;nop4[MXNPELS*i+ 3]= 1;i=10;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]=11;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 1;
 i=11;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=17;nop4[MXNPELS*i+ 3]= 1;i=12;nop4[MXNPELS*i+ 0]=11;nop4[MXNPELS*i+ 1]=10;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 1;
 i=13;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]= 1;nop4[MXNPELS*i+ 2]=10;nop4[MXNPELS*i+ 3]= 2;
 if(nprior){icp=0;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=1;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
			icp=2;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=4;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
            icp=5;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=6;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=7;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=8;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
			icp=9;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=11;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
            icp=12;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=13;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
           }
 }
else
{*tnelt=14;for(icp=0;icp<14;icp++){tmatno[icp]=base_m-(8-5)*t7-(8-4)*1000;sfsect[icp*MAX_NSECTION]=10*sectn+0;}
 i= 0;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 0;i= 1;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 2;
 i= 2;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]=12;nop4[MXNPELS*i+ 3]= 3;i= 3;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 3;
 i= 4;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 3;i= 5;nop4[MXNPELS*i+ 0]=14;nop4[MXNPELS*i+ 1]=19;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 3;
 i= 6;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]= 3;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 7;i= 7;nop4[MXNPELS*i+ 0]=18;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 6;
 i= 8;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]=19;nop4[MXNPELS*i+ 3]= 4;
 i= 9;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=14;nop4[MXNPELS*i+ 2]=18;nop4[MXNPELS*i+ 3]= 5;i=10;nop4[MXNPELS*i+ 0]=19;nop4[MXNPELS*i+ 1]=12;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;
 i=11;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 9;nop4[MXNPELS*i+ 2]=14;nop4[MXNPELS*i+ 3]= 5;i=12;nop4[MXNPELS*i+ 0]=12;nop4[MXNPELS*i+ 1]= 8;nop4[MXNPELS*i+ 2]= 9;nop4[MXNPELS*i+ 3]= 5;
 i=13;nop4[MXNPELS*i+ 0]= 9;nop4[MXNPELS*i+ 1]= 5;nop4[MXNPELS*i+ 2]= 8;nop4[MXNPELS*i+ 3]= 1;
 if(nprior){icp=0;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=1;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=2;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=4;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
			icp=5;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=6;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=7;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);icp=8;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
            icp=9;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,2,2);icp=11;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,1);
			icp=12;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,3,3);icp=13;sfsearch44_d8(icp,3,nop4,sfsect,nprior,aprior,1,3);
           }
 }
}
//---------------------------------------------------------------------------
void TForm1::sfsearch44_d8(int i,int nvertx,long nop4[],long sfsect[],long nprior,long aprior[],int lowl,int higl)
// Global MXNPELS,MAX_NSECTION
{int in=0,sum=0,nsearch=0,is=0,ilat=0,iv=0;long asect=0,apr=0;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//                 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//                 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata4[12]={0,2,1,
				 1,2,3,
                 2,0,3,
                 3,0,1};
// int sidls8[ 48]={0,1,5,4, 8,13,16,12,
//                  1,2,6,5, 9,14,17,13,
//                  3,2,6,7,10,14,18,15,
//                  0,3,7,4,11,15,19,12,
//                  0,1,2,3, 8, 9,10,11,
//                  4,5,6,7,16,17,18,19};
 int sidls8[ 48]={0,1,5,4, 8,13,16,12,
				  1,2,6,5, 9,14,17,13,
//                  3,2,6,7,10,14,18,15,
				  2,3,7,6,10,15,18,14,
//				  0,3,7,4,11,15,19,12,
				  3,0,4,7,11,12,19,15,
//				  0,1,2,3, 8, 9,10,11,
				  3,2,1,0,10, 9, 8,11,
				  4,5,6,7,16,17,18,19};
 nsearch=8;
 for(in=0;in<nprior;in++)
   {asect=aprior[in]/10;apr=aprior[in]-10*asect;
	if(nvertx==4)
      {for(ilat=lowl;ilat<higl+1;ilat++)  // Economy: 0,1,2,3 & 4 or 5
		{sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<nsearch;is++)if(nop4[MXNPELS*i+gdata8[4*ilat+iv]]==sidls8[8*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
        }
      }
    else
	  {for(ilat=lowl;ilat<higl+1;ilat++)
        {sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<nsearch;is++)if(nop4[MXNPELS*i+gdata4[3*ilat+iv]]==sidls8[8*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
        }
      }
   }
}
//---------------------------------------------------------------------------
void TForm1::sfsearch35_d8(int i,long eltype,long nop4[],long sfsect[],int nsearch,long nprior,long aprior[],int ilat)
// Global MXNPELS,MAX_NSECTION
{int nvertx=0,in=0,sum=0,is=0,iv=0;long asect=0,apr=0;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//                 3,2,6,7,
//                 0,3,7,4,
//				 0,1,2,3,
//                 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
                 2,0,3,5,
                 0,2,1,0,
                 3,4,5,0};
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
                 3,0,1};
// int sidls8[ 48]={0,1,5,4, 8,13,16,12,
//				  1,2,6,5, 9,14,17,13,
//                  3,2,6,7,10,14,18,15,
//				  0,3,7,4,11,15,19,12,
//                  0,1,2,3, 8, 9,10,11,
//                  4,5,6,7,16,17,18,19};
 int sidls8[ 48]={0,1,5,4, 8,13,16,12,
				  1,2,6,5, 9,14,17,13,
//                  3,2,6,7,10,14,18,15,
				  2,3,7,6,10,15,18,14,
//				  0,3,7,4,11,15,19,12,
				  3,0,4,7,11,12,19,15,
//				  0,1,2,3, 8, 9,10,11,
				  3,2,1,0,10, 9, 8,11,
				  4,5,6,7,16,17,18,19};
// nsearch=20;
 for(in=0;in<nprior;in++)
   {asect=aprior[in]/10;apr=aprior[in]-10*asect;
    if(eltype==8)
        {nvertx=4;sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<nsearch;is++)if(nop4[MXNPELS*i+gdata8[4*ilat+iv]]==sidls8[8*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
        }
    else if(eltype==7)
		{if(ilat>2)nvertx=3;else nvertx=4;sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<nsearch;is++)if(nop4[MXNPELS*i+gdata6[4*ilat+iv]]==sidls8[8*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
        }
	else
		{nvertx=3;sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<nsearch;is++)if(nop4[MXNPELS*i+gdata4[3*ilat+iv]]==sidls8[8*apr+is]){sum++;break;}}
		 if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
		}
   }
}
//---------------------------------------------------------------------------
void TForm1::sfsearch_d6(int i,long eltype,long nop4[],long sfsect[],int nsearch,long nprior,long aprior[],int ilat)
// Global MXNPELS,MAX_NSECTION
{int nvertx=0,in=0,sum=0,is=0,iv=0,isearch=0;long asect=0,apr=0;
// int gdata8[24]={0,1,5,4,
//                 1,2,6,5,
//                 3,2,6,7,
//                 0,3,7,4,
//                 0,1,2,3,
//                 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
				 2,0,3,5,
                 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
                 3,0,1};
 int sidls6[ 40]={0,1,4, 3, 6,10,12, 9,
                  1,2,5, 4, 7,11,13,10,
                  2,0,3, 5, 8, 9,14,11,
				  0,1,2, 6, 7, 8,-1,-1,
                  3,4,5,12,13,14,-1,-1};
// nsearch=20;
 for(in=0;in<nprior;in++)
   {asect=aprior[in]/10;apr=aprior[in]-10*asect;if(apr<3)isearch=8;else isearch=6;
    if(eltype==8)
		{nvertx=4;sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<isearch;is++)if(nop4[MXNPELS*i+gdata8[4*ilat+iv]]==sidls6[8*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
		}
	else if(eltype==7)
        {if(ilat>2)nvertx=3;else nvertx=4;sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<isearch;is++)if(nop4[MXNPELS*i+gdata6[4*ilat+iv]]==sidls6[8*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
		}
    else
        {nvertx=3;sum=0;for(iv=0;iv<nvertx;iv++){for(is=0;is<isearch;is++)if(nop4[MXNPELS*i+gdata4[3*ilat+iv]]==sidls6[8*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
        }
   }
}
//---------------------------------------------------------------------------
void TForm1::sfsearch_d4(int i,long eltype,long nop4[],long sfsect[],int nsearch,long nprior,long aprior[],int ilat)
// Global MXNPELS,MAX_NSECTION
{int nvertx=0,in=0,sum=0,is=0,iv=0;long asect=0,apr=0;
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
                 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
				 3,0,1};
 int sidls4[ 24]={0,1,2,4,5,6,
                  1,2,3,5,9,8,
                  2,0,3,6,7,9,
                  0,1,3,4,8,7};
// nsearch=6;
 for(in=0;in<nprior;in++)
   {asect=aprior[in]/10;apr=aprior[in]-10*asect;
    if(eltype==7)
		{if(ilat>2)nvertx=3;else nvertx=4;sum=0;
         for(iv=0;iv<nvertx;iv++){for(is=0;is<nsearch;is++)if(nop4[MXNPELS*i+gdata6[4*ilat+iv]]==sidls4[6*apr+is]){sum++;break;}}
		 if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
		}
    else
        {nvertx=3;sum=0;
		 for(iv=0;iv<nvertx;iv++){for(is=0;is<nsearch;is++)if(nop4[MXNPELS*i+gdata4[3*ilat+iv]]==sidls4[6*apr+is]){sum++;break;}}
         if(sum==nvertx){sfsect[MAX_NSECTION*i+in+1]=10*asect+ilat;break;}
        }
   }
}
//---------------------------------------------------------------------------
void TForm1::psect_outline(int nsect,long indat_nop1[],long indat_matno[],float indat_c1[],float indat_bc1[],long indat_nfsect,long indat_fsect[])
// Global NDF,MXNPEL
// Coincidence search based on indat_c1[] midedge test, since sectioned node numbers have duplication
{int ibsw=0;long ic=0,ics=0,ie=0,ies=0,in=0,ins=0,inp=0,inps=0,iside=0,isides=0,eltype=0,eltypes=0,t7=10000000,act=0,acts=0,stact[4],stacts[4],isect=0,asect=0,asects=0,nside=0,nsides=0;
 float rad=0.,xcen=0.,ycen=0.,zcen=0.,xcens=0.,ycens=0.,zcens=0.,tol=1.e-3,xoo=0.,yoo=0.,zoo=0.;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
				 2,0,3,5,
                 0,2,1,0,
                 3,4,5,0};
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
				 3,0,1};
 for(ic=0;ic<indat_nfsect;ic++)indat_fsect[ic]=indat_fsect[ic]+150;
 if(indat_nfsect>1)
   {for(isect=0;isect<nsect;isect++)
    {for(ic=0;ic<indat_nfsect-1;ic++)
	  {ie=indat_fsect[ic]/10000;iside=indat_fsect[ic]/1000-10*ie;eltype=indat_matno[ie]/t7;asect=indat_fsect[ic]-10*(indat_fsect[ic]/10);
	   if(asect==isect)
         {act=(indat_fsect[ic]-1000*(indat_fsect[ic]/1000))/10;
          if(eltype==8)nside=4;else if(eltype==7){if(iside>2)nside=3;else nside=4;}else nside=3;
		  if(act>7){stact[3]=1;act=act-8;}else stact[3]=0;if(act>3){stact[2]=1;act=act-4;}else stact[2]=0;
		  if(act>1){stact[1]=1;act=act-2;}else stact[1]=0;if(act)stact[0]=1;else stact[0]=0;
          xoo=yoo=zoo=0.;
          for(in=0;in<nside;in++)
            {if(eltype==8){xoo=xoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]  ];
                           yoo=yoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]+1];
                           zoo=zoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]+2];
                          }
             else if(eltype==7){xoo=xoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]  ];
                                yoo=yoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]+1];
                                zoo=zoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]+2];
                               }
			 else {xoo=xoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]  ];
                   yoo=yoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]+1];
				   zoo=zoo+indat_bc1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]+2];
                  }
            }
          for(in=0;in<nside;in++)
            {if(stact[in])
			   {inp=in+1;if(inp>=nside)inp=0;
if(eltype==8){xcen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]  ]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+inp]]  ])/2.;
              ycen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]+1]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+inp]]+1])/2.;
              zcen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]+2]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+inp]]+2])/2.;
             }
else if(eltype==7){xcen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]  ]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+inp]]  ])/2.;
				   ycen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]+1]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+inp]]+1])/2.;
                   zcen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]+2]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+inp]]+2])/2.;
                  }
else {xcen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]  ]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+inp]]  ])/2.;
      ycen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]+1]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+inp]]+1])/2.;
	  zcen=(indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]+2]+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+inp]]+2])/2.;
	 }
                for(ics=ic+1;ics<indat_nfsect;ics++)
                  {ibsw=0;ies=indat_fsect[ics]/10000;isides=indat_fsect[ics]/1000-10*ies;eltypes=indat_matno[ies]/t7;asects=indat_fsect[ics]-10*(indat_fsect[ics]/10);
				   if(asects==isect)
                     {acts=(indat_fsect[ics]-1000*(indat_fsect[ics]/1000))/10;
                      if(eltypes==8)nsides=4;else if(eltypes==7){if(isides>2)nsides=3;else nsides=4;}else nsides=3;
                      if(acts>7){stacts[3]=1;acts=acts-8;}else stacts[3]=0;if(acts>3){stacts[2]=1;acts=acts-4;}else stacts[2]=0;
                      if(acts>1){stacts[1]=1;acts=acts-2;}else stacts[1]=0;if(acts)stacts[0]=1;else stacts[0]=0;
                      for(ins=0;ins<nsides;ins++)
                        {if(stacts[ins])
                          {inps=ins+1;if(inps>=nsides)inps=0;
if(eltypes==8){xcens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata8[4*isides+ins]]  ]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata8[4*isides+inps]]  ])/2.;
               ycens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata8[4*isides+ins]]+1]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata8[4*isides+inps]]+1])/2.;
               zcens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata8[4*isides+ins]]+2]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata8[4*isides+inps]]+2])/2.;
              }
else if(eltypes==7){xcens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata6[4*isides+ins]]  ]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata6[4*isides+inps]]  ])/2.;
                    ycens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata6[4*isides+ins]]+1]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata6[4*isides+inps]]+1])/2.;
					zcens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata6[4*isides+ins]]+2]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata6[4*isides+inps]]+2])/2.;
                   }
else {xcens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata4[3*isides+ins]]  ]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata4[3*isides+inps]]  ])/2.;
      ycens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata4[3*isides+ins]]+1]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata4[3*isides+inps]]+1])/2.;
      zcens=(indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata4[3*isides+ins]]+2]+indat_c1[NDF*indat_nop1[MXNPEL*ies+gdata4[3*isides+inps]]+2])/2.;
	 }
                           rad=(xcen-xcens)*(xcen-xcens)+(ycen-ycens)*(ycen-ycens)+(zcen-zcens)*(zcen-zcens);
						   if(rad<tol*tol){stact[in]=0;stacts[ins]=0;acts=(indat_fsect[ics]-1000*(indat_fsect[ics]/1000))/10;
                                           indat_fsect[ics]=indat_fsect[ics]-(acts-stacts[0]-2*stacts[1]-4*stacts[2]-8*stacts[3])*10;
                                           ibsw=1;break;
                                          }
						  }
                        }
                      if(ibsw)break;
					 }
				  }
			   }
			}
          act=(indat_fsect[ic]-1000*(indat_fsect[ic]/1000))/10;indat_fsect[ic]=indat_fsect[ic]-(act-stact[0]-2*stact[1]-4*stact[2]-8*stact[3])*10;
         }
	  }
    }
   }
}
//---------------------------------------------------------------------------
void TForm1::psect_compact(long othersect,long *cursect,float aval,float bval,float cval,float dval,int isw,long indat_nop1[],long indat_matno[],float indat_c1[],long indat_fsect[])
// Global NDF,MXNPEL
// Coincidence search based on indat_c1[] midedge test, since sectioned node numbers have duplication
{long ic=0,ie=0,in=0,iside=0,eltype=0,nside=0,nfsect=0,t7=10000000;float xave=0.,yave=0.,zave=0.,rsid=0.,tol=1.e-4;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
                 1,2,5,4,
                 2,0,3,5,
                 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
                 1,2,3,
                 2,0,3,
                 3,0,1};
 nfsect=othersect;
 for(ic=othersect;ic< *cursect;ic++)
   {if(indat_fsect[ic]> -1)
      {ie=indat_fsect[ic]/10000;iside=indat_fsect[ic]/1000-10*ie;eltype=indat_matno[ie]/t7;
	   if(eltype==8)nside=4;else if(eltype==7){if(iside>2)nside=3;else nside=4;}else nside=3;
       xave=yave=zave=0.;
	   for(in=0;in<nside;in++)
			{if(eltype==8){xave=xave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]  ];
                           yave=yave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]+1];
                           zave=zave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata8[4*iside+in]]+2];}
			 else if(eltype==7){xave=xave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]  ];
                                yave=yave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]+1];
                                zave=zave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata6[4*iside+in]]+2];}
             else {xave=xave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]  ];
                   yave=yave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]+1];
                   zave=zave+indat_c1[NDF*indat_nop1[MXNPEL*ie+gdata4[3*iside+in]]+2];}
            }
	   xave=xave/float(nside);yave=yave/float(nside);zave=zave/float(nside);
// Add switch (REVERSED....)
       rsid=aval*xave+bval*yave+cval*zave+dval;
       if(isw){if(rsid<=0.+tol){indat_fsect[nfsect]=indat_fsect[ic];nfsect=nfsect+1;}}
       else {if(rsid>0.-tol){indat_fsect[nfsect]=indat_fsect[ic];nfsect=nfsect+1;}}
	  }
   }
 *cursect=nfsect;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Undeform_shapeExecute(TObject *Sender)
{if(base.nop1)
   {if(fl_feres==1 || fl_feres==3 || fl_feres==4)
      {Undeformedmesh1->Checked=true;Deformedshape1->Checked=false;Defshapeundefmesh1->Checked=false;
	   if(ShapeForm){delete ShapeForm;ShapeForm=NULL;}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
	   FDrestore();
      }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get displ.results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"25Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Deform_shapeExecute(TObject *Sender)
{long i=0;float shapeprod=0.,xparam=0.,yparam=0.,zparam=0.,xmx= -1.E20,xmn=1.E20,ymx= -1.E20,ymn=1.E20,zmx= -1.E20,zmn=1.E20,dx= -1.E20,dy= -1.E20,dz= -1.E20;
 if(base.nop1)
   {if(fl_feres==1 || fl_feres==3 || fl_feres==4)
      {Undeformedmesh1->Checked=false;Deformedshape1->Checked=true;Defshapeundefmesh1->Checked=false;
       for(i=0;i<base.npoin;i++)
		 {if(xmx<base.c1[NDF*i  ])xmx=base.c1[NDF*i  ];if(xmn>base.c1[NDF*i  ])xmn=base.c1[NDF*i  ];
          if(ymx<base.c1[NDF*i+1])ymx=base.c1[NDF*i+1];if(ymn>base.c1[NDF*i+1])ymn=base.c1[NDF*i+1];
          if(zmx<base.c1[NDF*i+2])zmx=base.c1[NDF*i+2];if(zmn>base.c1[NDF*i+2])zmn=base.c1[NDF*i+2];
          if(dx<fabs(base.res1[nColRes*i  ]))dx=fabs(base.res1[nColRes*i  ]);
          if(dy<fabs(base.res1[nColRes*i+1]))dy=fabs(base.res1[nColRes*i+1]);
          if(dz<fabs(base.res1[nColRes*i+2]))dz=fabs(base.res1[nColRes*i+2]);
         }
       if(fabs(dx)>1.E-6)xparam=(xmx-xmn)/dx;else xparam=1.E6;
	   if(fabs(dy)>1.E-6)yparam=(ymx-ymn)/dy;else yparam=1.E6;
       if(fabs(dz)>1.E-6)zparam=(zmx-zmn)/dz;else zparam=1.E6;
	   shapeprod=0.35*min(xparam,min(yparam,zparam));
	   if(!ShapeForm){ShapeForm=new TForm8(0,shapeprod,this);
					  ShapeForm->Caption="Deformed shape";
					  ShapeForm->Button3->Caption="Close";ShapeForm->Show();}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Shape selector dialog already exists",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get displ.results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"26Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Def_undef_shapeExecute(TObject *Sender)
{long i=0;float shapeprod=0.,xparam=0.,yparam=0.,zparam=0.,xmx= -1.E20,xmn=1.E20,ymx= -1.E20,ymn=1.E20,zmx= -1.E20,zmn=1.E20,dx= -1.E20,dy= -1.E20,dz= -1.E20;
 if(base.nop1)
   {if(fl_feres==1 || fl_feres==3 || fl_feres==4)
	  {Undeformedmesh1->Checked=false;Deformedshape1->Checked=false;Defshapeundefmesh1->Checked=true;
	   for(i=0;i<base.npoin;i++)
		 {if(xmx<base.c1[NDF*i  ])xmx=base.c1[NDF*i  ];if(xmn>base.c1[NDF*i  ])xmn=base.c1[NDF*i  ];
		  if(ymx<base.c1[NDF*i+1])ymx=base.c1[NDF*i+1];if(ymn>base.c1[NDF*i+1])ymn=base.c1[NDF*i+1];
		  if(zmx<base.c1[NDF*i+2])zmx=base.c1[NDF*i+2];if(zmn>base.c1[NDF*i+2])zmn=base.c1[NDF*i+2];
		  if(dx<fabs(base.res1[nColRes*i  ]))dx=fabs(base.res1[nColRes*i  ]);
		  if(dy<fabs(base.res1[nColRes*i+1]))dy=fabs(base.res1[nColRes*i+1]);
		  if(dz<fabs(base.res1[nColRes*i+2]))dz=fabs(base.res1[nColRes*i+2]);
		 }
	   if(fabs(dx)>1.E-6)xparam=(xmx-xmn)/dx;else xparam=1.E6;
	   if(fabs(dy)>1.E-6)yparam=(ymx-ymn)/dy;else yparam=1.E6;
	   if(fabs(dz)>1.E-6)zparam=(zmx-zmn)/dz;else zparam=1.E6;
	   shapeprod=0.35*min(xparam,min(yparam,zparam));
	   if(!ShapeForm){ShapeForm=new TForm8(0,shapeprod,this);ShapeForm->Show();}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Shape selector dialog already exists",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get displ.results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"27Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ApperGIDExecute(TObject *Sender)
{if(base.nop1){ApperGID->Checked=true;ApperMetal->Checked=false;ApperShade->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   FDrestore();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"28Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ApperMetalExecute(TObject *Sender)
{if(base.nop1){ApperGID->Checked=false;ApperMetal->Checked=true;ApperShade->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   FDrestore();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"29Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ApperShadeExecute(TObject *Sender)
{if(base.nop1){ApperGID->Checked=false;ApperMetal->Checked=false;ApperShade->Checked=true;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   FDrestore();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"30Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ContourAllExecute(TObject *Sender)
{if(base.nop1)
   {if(fl_feres){ContourAll->Checked=true;ContourSection->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
				 FDrestore();}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get displ.results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"31Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ContourSectionExecute(TObject *Sender)
{if(base.nop1)
   {if(fl_feres){ContourAll->Checked=false;ContourSection->Checked=true;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
				 FDrestore();}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get displ.results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"32Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::ShowEdgeExecute(TObject *Sender)
{if(base.nop1){//ShowEdge1->Checked=true;HideEdge->Checked=1-ShowEdge1->Checked;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   FDrestore();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"35Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::HideEdge1Execute(TObject *Sender)
{if(base.nop1){//ShowEdge1->Checked=false;HideEdge->Checked=1-ShowEdge1->Checked;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   FDrestore();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"36Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::Result_scaleExecute(TObject *Sender)
{if(fl_feres){ScaleForm=new TForm8(1,resscale,this);ScaleForm->Caption="Scale results";
			  ScaleForm->Button3->Caption="Not used";
			  ScaleForm->ShowModal();delete ScaleForm;ScaleForm=NULL;
			 }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::FEstatsExecute(TObject *Sender)
{if(base.nop1){FEstatForm=new TForm16(base.npoin,base.nelt,wp.nWeldGroup,wp.nWeldPass,this);
//FEstatForm->Label1->Color=clBlue;
//FEstatForm->Label1->Caption=L"WhoDunnit";
			   FEstatForm->Label1->Caption=L"Hi-Node";
			   FEstatForm->Label2->Caption=L"Tot-elem";
			   FEstatForm->Label3->Caption=L"#WeldGroup";
			   FEstatForm->Label4->Caption=L"#WeldPass";
			   FEstatForm->ShowModal();
			   delete FEstatForm;FEstatForm=NULL;
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"38Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::Result_LinePlotExecute(TObject *Sender)
//{long NINTERV=9,in=0,ic=0,NODEstart=4112-1,NODEend=3146-1;  //Inch05
{long NINTERV=9,in=0,ic=0,NODEstart=4112-1,NODEend=3141-1;  //Inch10
 long ie=0,is=0,kelm=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000;
 float DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],PRST1=0.,PRST2=0.,PRST3=0.,TOLSUB=0.0001,VONMIS=0.,totPRST1=0.,totVONMIS=0.,
	   xloc=0.,yloc=0.,zloc=0.,xdiv=0.,ydiv=0.,zdiv=0.,rn1=0.,rn2=0.,rn3=0.,sum=0.,resval[9],stress[6],
	   tt11=0.,tt12=0.,tt13=0.,tt21=0.,tt22=0.,tt23=0.,tt31=0.,tt32=0.,tt33=0.,tem1=0.,tem2=0.,tem3=0.,
//       xpt1=0.,ypt1= -3.096499919,zpt1=0.718131005,
//       xpt2=0.,ypt2= -9.529999732,zpt2=3.587139844,
	   xpt1=base.c1[NDF*NODEstart+0],ypt1=base.c1[NDF*NODEstart+1],zpt1=base.c1[NDF*NODEstart+2],
	   xpt2=base.c1[NDF*NODEend+0],ypt2=base.c1[NDF*NODEend+1],zpt2=base.c1[NDF*NODEend+2];
///////////////////////////////////////////////////////////
if(fl_feres==4){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported fl_feres=4",L"Terminate",MB_OK);exit(0);}
///////////////////////////////////////////////////////////
 if(base.nop1)
   {if(fl_feres)
	  {
	   xdiv=(xpt2-xpt1)/float(NINTERV-1);ydiv=(ypt2-ypt1)/float(NINTERV-1);zdiv=(zpt2-zpt1)/float(NINTERV-1);xloc=xpt1-xdiv;yloc=ypt1-ydiv;zloc=zpt1-zdiv;totPRST1=totVONMIS=0.;
	   for(is=0;is<NINTERV;is++)
		 {xloc=xloc+xdiv;yloc=yloc+ydiv;zloc=zloc+zdiv;PRST1=VONMIS=0.;
///////////////////////
		  for(ie=0;ie<base.nelt;ie++)
			{eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
			 homsub(ie,xloc,yloc,zloc,&kelm,&rn1,&rn2,&rn3,node,eltype,base.nop1+MXNPEL*ie,base.c1,TOLSUB);
			 if(kelm>=0){
						 if(eltype==8)
						   {STFISO8(1,rn1,rn2,rn3,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*kelm,base.c1);
							if(fl_feres==1)
							  {for(ic=0;ic<3;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];resval[ic]=sum;}
							   for(ic=3;ic<9;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];stress[ic-3]=sum;}
////////////////
FD_PSTRG(stress,&PRST1,&PRST2,&PRST3);VONMIS=sqrt((PRST1+PRST2+PRST3)*(PRST1+PRST2+PRST3)-3.*(PRST1*PRST2+PRST1*PRST3+PRST2*PRST3));
honk<<is+1<<" "<<sqrt(yloc*yloc+zloc*zloc)<<" stress "<<PRST1<<" "<<VONMIS<<"\n";
////////////////
							  }
							else if(fl_feres==3)
							  {for(ic=0;ic<3;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];resval[ic]=sum;}
honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<resval[0]<<" "<<resval[1]<<" "<<resval[2]<<"\n";
							  }
							else {sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]];resval[0]=sum;
honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<resval[0]<<"\n";
								 }
							break;
						   }
						 else if(eltype==7)
						   {STFISO6(1,rn1,rn2,rn3,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*kelm,base.c1);
							if(fl_feres==1)
							  {for(ic=0;ic<3;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];resval[ic]=sum;}
							   for(ic=3;ic<9;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];stress[ic-3]=sum;}
////////////////
FD_PSTRG(stress,&PRST1,&PRST2,&PRST3);VONMIS=sqrt((PRST1+PRST2+PRST3)*(PRST1+PRST2+PRST3)-3.*(PRST1*PRST2+PRST1*PRST3+PRST2*PRST3));
honk<<is+1<<" "<<sqrt(yloc*yloc+zloc*zloc)<<" stress "<<PRST1<<" "<<VONMIS<<"\n";
////////////////
							  }
							else if(fl_feres==3)
							  {for(ic=0;ic<3;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];resval[ic]=sum;}
///////////////////////////////////
							   tem1=tt11*resval[0]+tt21*resval[1]+tt31*resval[2];tem2=tt12*resval[0]+tt22*resval[1]+tt32*resval[2];
							   tem3=tt13*resval[0]+tt23*resval[1]+tt33*resval[2];resval[0]=tem1;resval[1]=tem2;resval[2]=tem3;
////////////////////////////////////
honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<resval[0]<<" "<<resval[1]<<" "<<resval[2]<<"\n";
							  }
							else {sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]];resval[0]=sum;
honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<resval[0]<<"\n";
								 }
							break;
						   }
						 else if(eltype==5)
						   {STFISO4(1,rn1,rn2,rn3,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*kelm,base.c1);
							if(fl_feres==1)
							  {for(ic=0;ic<3;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];resval[ic]=sum;}
							   for(ic=3;ic<9;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];stress[ic-3]=sum;}
////////////////
FD_PSTRG(stress,&PRST1,&PRST2,&PRST3);VONMIS=sqrt((PRST1+PRST2+PRST3)*(PRST1+PRST2+PRST3)-3.*(PRST1*PRST2+PRST1*PRST3+PRST2*PRST3));
honk<<is+1<<" "<<sqrt(yloc*yloc+zloc*zloc)<<" stress "<<PRST1<<" "<<VONMIS<<"\n";
////////////////
							  }
							else if(fl_feres==3)
							  {for(ic=0;ic<3;ic++){sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]+ic];resval[ic]=sum;}
///////////////////////////////////
							   tem1=tt11*resval[0]+tt21*resval[1]+tt31*resval[2];tem2=tt12*resval[0]+tt22*resval[1]+tt32*resval[2];
							   tem3=tt13*resval[0]+tt23*resval[1]+tt33*resval[2];resval[0]=tem1;resval[1]=tem2;resval[2]=tem3;
////////////////////////////////////
honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<resval[0]<<" "<<resval[1]<<" "<<resval[2]<<"\n";
							  }
							else {sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*base.res1[nColRes*base.nop1[MXNPEL*kelm+in]];resval[0]=sum;
honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<resval[0]<<"\n";
								 }
							break;
						   }
						 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elem.type",L"Terminate",MB_OK);exit(0);}
						}
			}
//////////////////
		  if(kelm<0)
			{if     (fl_feres==1)honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<0.<<" "<<0.<<" "<<0.<<" "<<0.<<" "<<0.<<" "<<0.<<" "<<0.<<" "<<0.<<" "<<0.<<"\n";
			 else if(fl_feres==3)honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<0.<<" "<<0.<<" "<<0.<<"\n";
			 else                honk<<xloc<<" "<<yloc<<" "<<zloc<<" "<<0.<<"\n";
			}
//////////////////
totPRST1=totPRST1+PRST1;totVONMIS=totVONMIS+VONMIS;
//////////////////
		 }
/////////////////
honk<<totPRST1/float(NINTERV)<<" Avg PRST1&VONMIS "<<totVONMIS/float(NINTERV)<<"\n";
/////////////////
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"40Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::RotateFreehandExecute(TObject *Sender)
////{if(base.nop1)FD_LButtonstatus=5;
{if(base.nop1)
//   FD_LButtonstatus=8;//Changed from 5->8 to match VFTgen
	{FD_LButtonstatus=8;
	 Screen->Cursor=crSizeAll;
	}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"41Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::GIDselectorExecute(TObject *Sender)
{long is=0,i=0,ie=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,prod=1,aflag=0,GIDspac=long(1+(nGIDmax-1)/16),saflag[(MAX_GID+1)/16];
 if(base.nop1)
   {if(iPaintyesno/10){if(GIDSelForm){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"GID selector already exists.",L"Warning",MB_OK);}
					else {for(is=0;is<GIDspac;is++)saflag[is]=0;
						  for(is=0;is<GIDspac;is++)
							{if(16*is<nGIDmax)
							   {prod=1;aflag=0;
								for(i=16*is;i<min(long(nGIDmax),16*(is+1));i++)
								   {for(ie=0;ie<base.nelt;ie++)
									   {eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
//										ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];
////////////////
										if(i==ieGID){aflag=aflag+prod;break;}
									   }
									prod=2*prod;
								   }
								saflag[is]=aflag;
							   }
							 else break;
							}
						  GIDSelForm=new TForm17(2,nGIDmax,saflag,this);
						  GIDSelForm->Caption="GID";
						  GIDSelForm->Button1->Caption="Redraw";
						  GIDSelForm->Show();
						 }
				   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must paint first->View/Paint",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"42Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::GIDRestore_public()
// Global nGIDmax    Note that unsigned long val & FDcomp_nGID() duplicate the search for GIDs....
{long i=0,is=0,isw=0,cur=0,prod=1,aflag=0,GIDspac=long(1+(nGIDmax-1)/16),val[(MAX_GID+1)/16];
// FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);   // Repopulate arGID[] with original GIDs
 for(is=0;is<GIDspac;is++){GIDSelForm->CheckOX=is;val[is]=GIDSelForm->CheckOX;if(val[is])isw=is+1;}
 if(isw){for(i=0;i<long(nGIDmax);i++)arGID[i]=0;
		 for(is=0;is<isw;is++){cur=val[is];prod=1;aflag=0;
							   if(nGIDmax>1){for(i=16*is;i<min(long(nGIDmax),16*(is+1));i++){aflag=aflag+prod;prod=2*prod;}
											 prod=prod/2;
											}
//                               for(i=min(long(nGIDmax),16*(is+1))-16*is;i>0;i--){aflag=aflag-prod;if(cur>aflag){cur=cur-prod;arGID[i-1]=1;}
							   for(i=min(long(nGIDmax),16*(is+1))-16*is;i>0;i--){aflag=aflag-prod;if(cur>aflag){cur=cur-prod;arGID[i+16*is-1]=1;}
																				 prod=prod/2;
																				}
							  }
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
		 FDrestore();
		}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must check at least one GID to plot.",L"Repeat",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::RotateFixedExecute(TObject *Sender)
{float VV=10.;
 if(base.nop1){if(!RotaFixForm){RotaFixForm=new TForm18(VV,VV,VV,this);RotaFixForm->Show();}
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"RotateFix dialog box exists",L"Halt",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"44Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::QueryCoordinateExecute(TObject *Sender)
{long in=0,ie=0,kelm=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000;
 float DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],TOLSUB=0.0001,rn1=0.,rn2=0.,rn3=0.,sum=0.;
// float xloc=0.,yloc=0.,zloc=0.;
 float xloc=0.,yloc=0.999499976,zloc=0.443421065;
 if(base.nop1)
   {if(fl_feres)
	  {for(ie=0;ie<base.nelt;ie++)
		 {eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
		  homsub(ie,xloc,yloc,zloc,&kelm,&rn1,&rn2,&rn3,node,eltype,base.nop1+MXNPEL*ie,base.c1,TOLSUB);
		  if(kelm>=0){if(eltype==8)STFISO8(1,rn1,rn2,rn3,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*kelm,base.c1);
					  else if(eltype==7)STFISO6(1,rn1,rn2,rn3,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*kelm,base.c1);
					  else if(eltype==5)STFISO4(1,rn1,rn2,rn3,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*kelm,base.c1);
					  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elem.type",L"Terminate",MB_OK);exit(0);}
					  sum=0.;for(in=0;in<node;in++)sum=sum+SN[in]*indat.result[base.nop1[MXNPEL*kelm+in]];
honk<<kelm+1<<" "<<xloc<<" "<<yloc<<" "<<zloc<<" Result found "<<sum<<"\n";
					  break;
					 }
		 }
	   if(kelm<0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Coordinate not found in mesh",L"Failure",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"45Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void __fastcall TForm1::MeshCharacteristicsExecute(TObject *Sender) //TBD Is this OK without test for model (base.nop1)EFP 3/22/2012
// Solver switch ISOLSW not used
// noption=0 --> isothermal; noption=1 --> thermal
{int flag=0,controlfck=0,MXSWAPS=6;
 char analtype[]="ANALYSIS: MeshCharacteristics",soltype0[]="Out-core pc.Conj.Grad iterative",soltype1[]="In-core pc.Conj.Grad iterative",
	  chswps[]="out-core swaps",MBreqd[]="MB RAM required",MBprov[]="MB RAM provided";
// Note: ixunit[6*(MXSWAPS+1)]
 long i=0,nosnod=0,nosband=0,nnsnod=0,nnsband=0,nrangu=0,mxecn=0,nodmxx=0,nsbdwth=0,
   magl=0,mags=0,nprofl=0,nprofle=0,nswaps=0,elnodes=0,*idirv=NULL,*ndestv=NULL,*nnary=NULL,*ndiag=NULL,*nxecn=NULL,NADF=3,
   dummy=0,RAM_AVAIL=0,ixunit[6*(6+1)],intvck=0,totstor=0;
 float oldpro=0.,rnewpr=0.,*temp=NULL,*estf=NULL;
 double dummyD[1];union {float *smat;long *locinde;};MEMORYSTATUS ms;ms.dwLength=sizeof(MEMORYSTATUS);




 if(base.nop1)
  {if(OpenDialog4->Execute())
	 {ifstream ntape(OpenDialog4->FileName.c_str(),ios::nocreate,0);
      if(ntape)
        {
//       while(!ntape.eof()){ntape>>nop0>>nop1>>nop2>>nop3>>nop4>>nop5>>nop6>>nop7;
//                           ntape>>descript0>>descript1>>descript2;ntape>>descript0>>descript1>>descript2;
//                           ntape>>descript0>>descript1>>descript2;ntape>>descript0>>descript1;id++;
//                          }nDefects=id;
		 ntape.close();controlfck=1;
         if(controlfck)
         {
//////////////////
//////////////////
if(!AnalysisProgressForm){AnalysisProgressForm=new TForm19(base.nelt,base.npoin,this);AnalysisProgressForm->Show();
//////////////////
//////////////////
		  if(nColRes)FDdynmem_manage(-3,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
          nColRes=9;FDdynmem_manage(3,base.npoin,dummy,indat.npoin,dummy,nColRes,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
          try
           {temp=new float[NDF*base.npoin];idirv=new long[2*base.npoin];ndestv=new long[NADF*base.npoin];nnary=new long[2*(base.npoin+base.nelt)];
            sloan(base.npoin,base.nelt,base.nop1,base.matno,idirv,&oldpro,&rnewpr,&nosnod,&nosband,&nnsnod,&nnsband,&elnodes,&flag);
			if(flag<0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Sloan renumbering: Topology error",L"Failure",MB_OK);}
			else if(flag==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get/free more RAM",L"Failure",MB_OK);}
			else
			  {
honk<<oldpro<<" Old/new nodal profile "<<rnewpr<<"\n";honk<<nosnod<<" Old/new nodal semiband "<<nosband<<" "<<nnsnod<<" "<<nnsband<<"\n";
// FE analysis
			   renuminp3g(base.npoin,base.nelt,idirv,base.nop1,base.matno,base.c1,temp,dummyD,base.nvfix,base.pload,base.nofix,base.lodpt,0);
			   if(base.nvfix)sortminmx(base.nvfix,base.nofix,base.presc,base.nrfix);nrangu=rangu(base.npoin,base.nvfix,base.nofix,ndestv,NADF);
			   cnsbdwth1(base.npoin,base.nelt,ndestv,base.nop1,base.matno,nnary,&mxecn,&nodmxx,&nsbdwth,NADF);
honk<<mxecn<<" mxecn/DOF semiband "<<nodmxx<<" "<<nsbdwth<<" "<<MXSWAPS<<"\n";




			   try
				 {nxecn=new long[2*NADF*MXNPEL*mxecn];ndiag=new long[2*nrangu];estf=new float[NADF*MXNPEL*(NADF*MXNPEL+1)/2];
				  for(i=0;i<2*NADF*MXNPEL*mxecn;i++)nxecn[i]=0;for(i=0;i<2*nrangu;i++)ndiag[i]=0;
				  for(i=0;i<NADF*MXNPEL*(NADF*MXNPEL+1)/2;i++)estf[i]=0.; // Memory must be used to be "counted."
////////////////
GlobalMemoryStatus(&ms);honk<<ms.dwTotalPhys<<" TPhys "<<ms.dwAvailPhys<<" --> words "<<ms.dwAvailPhys/4<<"\n";
honk<<ms.dwTotalVirtual<<" TVirt "<<ms.dwAvailVirtual<<" --> words "<<ms.dwAvailVirtual/4<<"\n";
//MXIMEM=ms.dwAvailPhys/4;RAM_AVAIL=MXIMEM-2*nrangu-NADF*MXNPEL*(NADF*MXNPEL+1)/2 -(19*base.npoin+2*base.nelt);
RAM_AVAIL=ms.dwAvailPhys/4;
////////////////
				  locindx6e1_mem(1,base.npoin,base.nop1,base.matno,ndestv,&mags,&magl,nnary,base.npoin,nxecn,&flag,mxecn,&nswaps,MXSWAPS,RAM_AVAIL,nrangu,&totstor,NADF);
				  if(flag>0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported solver",L"Failure",MB_OK);}
				  else if(flag== -1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Isolated node in topology",L"Failure",MB_OK);}
				  else if(flag== -2){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Switch to 64 bit version",L"Failure",MB_OK);}
				  else if(flag==0)
					{try  {locinde=new long[magl+mags];nprofl=nprofle=0;
////////////
honk<<nswaps<<" nswaps\n";
///////////
						   if(nswaps){     // Out-of-core iterative
honk<<nswaps<<" Out-core pc.Conj.Grad iterative solver swaps/MB required/provided "<<1+long(float(magl+mags)/float(262144))<<" "<<1+long(float(RAM_AVAIL)/float(262144))<<"\n";
/////////////
									  AnalysisProgressForm->setAnalProgStr(analtype,soltype0,chswps,MBreqd,MBprov);
									  AnalysisProgressForm->setAnalProgLong(nswaps,1+long(float(magl+mags)/float(262144)),1+long(float(RAM_AVAIL)/float(262144)));
									  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Out-core pc.Conj.Grad iterative",L"Solver selected:",MB_OK);
/////////////
honk<<float(totstor)/float(262144)<<" DiskFree3(MB) "<<float(long(DiskFree(0)/1048576))<<"\n";
							if(float(totstor)/float(262144)<float(long(DiskFree(0)/1048576)))
							 {ntapeL.open("fd001.tmp",ios::in|ios::out|ios::trunc);ntapeS.open("fd002.tmp",ios::in|ios::out|ios::trunc);
							  if(ntapeL && ntapeS)
								{
deanloy(1,base.npoin,base.nop1,base.matno,ndestv,locinde,&nprofl,&nprofle,nsbdwth,ndiag,ndiag+nrangu,nnary,base.npoin,RAM_AVAIL-nrangu,nodmxx,nxecn,&flag,mxecn,ixunit,nrangu,NADF);
if(flag== -1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Isolated node in topology",L"Failure",MB_OK);}
else if(flag== -3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Invalid swaps-> Get/free more RAM",L"Failure",MB_OK);}
else{mags=magl-ixunit[7]-nrangu;magl=ixunit[7];formkch7c(base.nelt,base.prop,base.nop1,base.matno,base.c1);
	 delete [] locinde;ntapeL.close();ntapeS.close();DeleteFile("fd001.tmp");DeleteFile("fd002.tmp");
	}
								}
							  else {delete [] locinde;if(ntapeL){ntapeL.close();DeleteFile("fd001.tmp");}if(ntapeS){ntapeS.close();DeleteFile("fd002.tmp");}
									extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"HDD corrupt",L"Failure",MB_OK);
								   }
							 }
							else {delete [] locinde;extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get/free HDD memory",L"Failure",MB_OK);
								 }
                                     }
                           else {     // In-core iterative
honk<<nswaps<<" In-core pc.Conj.Grad iterative solver swaps/MB required/provided "<<1+long(float(magl+mags)/float(262144))<<" "<<1+long(float(RAM_AVAIL)/float(262144))<<"\n";
/////////////
								 AnalysisProgressForm->setAnalProgStr(analtype,soltype1,chswps,MBreqd,MBprov);
                                 AnalysisProgressForm->setAnalProgLong(nswaps,1+long(float(magl+mags)/float(262144)),1+long(float(RAM_AVAIL)/float(262144)));
								 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"In-core pc.Conj.Grad iterative",L"Solver selected:",MB_OK);
/////////////
deanloe(1,base.npoin,base.nop1,base.matno,ndestv,locinde,&nprofl,&nprofle,nsbdwth,ndiag,ndiag+nrangu,nnary,base.npoin,RAM_AVAIL,nodmxx,nxecn,&intvck,&flag,mxecn,NADF);
formkch7c(base.nelt,base.prop,base.nop1,base.matno,base.c1);delete [] locinde;
								}
//
						  }
					 catch (EOutOfMemory &e){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get/free more RAM",L"Failure",MB_OK);}
					}
				  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Mesh corruption",L"Failure",MB_OK);}
				  delete [] nxecn;nxecn=NULL;delete [] ndiag;ndiag=NULL;delete [] estf;
				 }
			   catch (EOutOfMemory &e){if(nxecn){delete [] nxecn;nxecn=NULL;}if(ndiag){delete [] ndiag;ndiag=NULL;}if(estf)delete [] estf;
							  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get/free more RAM",L"Failure",MB_OK);
							 }
			   renuminp3g(base.npoin,base.nelt,idirv+base.npoin,base.nop1,base.matno,base.c1,temp,dummyD,base.nvfix,base.pload,base.nofix,base.lodpt,0);
			   if(base.nvfix)sortminmx(base.nvfix,base.nofix,base.presc,base.nrfix);
			  }
			delete [] temp;delete [] idirv;delete [] ndestv;delete [] nnary;
		   }
		  catch (EOutOfMemory &e){if(temp)delete [] temp;if(idirv){delete [] idirv;idirv=NULL;}if(ndestv){delete [] ndestv;ndestv=NULL;}if(nnary){delete [] nnary;nnary=NULL;}
						 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get/free more RAM",L"Failure",MB_OK);
						}
/////////////////
/////////////////
			   delete AnalysisProgressForm;AnalysisProgressForm=NULL;
			   AnalysisProgressForm=new TForm19(base.nelt,base.npoin,this);AnalysisProgressForm->Color=clGreen;
			   if(nswaps)AnalysisProgressForm->setAnalProgStr(analtype,soltype0,chswps,MBreqd,MBprov);
			   else      AnalysisProgressForm->setAnalProgStr(analtype,soltype1,chswps,MBreqd,MBprov);
			   AnalysisProgressForm->setAnalProgLong(nswaps,1+long(float(magl+mags)/float(262144)),1+long(float(RAM_AVAIL)/float(262144)));
			   AnalysisProgressForm->Show();
			  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Analysis progress box exists--> close",L"Halt",MB_OK);}
/////////////////
/////////////////
         }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Incomplete control file data",L"Failure",MB_OK);}
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open control file",L"Failure",MB_OK);}
	 }
//   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"46Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void TForm1::sloan(long npoin,long nelt,long nop1[],long matno[],long nnn[],float *oldpro,float *rnewpr,long *nosnod,long *nosband,long *nnsnod,long *nnsband,long *elnd,int *flag)
{int flag1=0;long i=0,j=0,k=1,me2=0,t7=10000000,t5=100000,t3=1000,eltype=0,bscode=0,node=0,
      il1=0,il2=0,il3=0,lstnum=0,nsnode=0,nc=0,ie=0,ispac=0,iadj=0,jstrt=0,jstop=0,nldmin=0,newmin=0,*npn=NULL,*nxnpn=NULL,*nadj=NULL,*nxadj=NULL,*iw=NULL;
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;ispac=ispac+node;iadj=iadj+node*(node-1);}
 *elnd=ispac;
 try{npn=new long[ispac];nxnpn=new long[nelt+1];nadj=new long[iadj];nxadj=new long[npoin+1];iw=new long[3*npoin+1];
     for(i=0;i<nelt;i++){nxnpn[i]=k;eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;
                         node=(matno[i]-eltype*t7-bscode*t5)/t3;for(j=0;j<node;j++){npn[k-1]=nop1[MXNPEL*i+j]+1;k++;}
                        }
	 nxnpn[nelt]=k;sloangraph(npoin,nelt,ispac,iadj,npn,nxnpn,nadj,nxadj,&flag1);delete [] npn;delete [] nxnpn;
     if(flag1)*flag= -1;
     else {*flag=1;for(i=0;i<3*npoin+1;i++)iw[i]=0;for(i=0;i<npoin;i++)nnn[i]=0;me2=nxadj[npoin]-1;il1=0;il2=il1+npoin;il3=il2+npoin+1;lstnum=0;
           do {sloandiamtr(npoin,me2,nadj,nxadj,nnn,&iw[il1],&iw[il2],&iw[il3],&nsnode,&nc);sloannumber(nc,nsnode,&lstnum,me2,nadj,nxadj,nnn,&iw[il1],&iw[il2]);}
           while(lstnum<npoin);
// nnn[0 to npoin-1]==transf; nnn[npoin to 2*npoin-1]=reverse
           for(i=0;i<npoin;i++){nnn[i]=nnn[i]-1;nnn[nnn[i]+npoin]=i;}
           for(i=0;i<npoin;i++)
             {jstrt=nxadj[i];jstop=nxadj[i+1]-1;nldmin=nadj[jstrt-1];newmin=nnn[nadj[jstrt-1]-1];
              for(j=jstrt+1;j<jstop+1;j++){nldmin=min(nldmin,nadj[j-1]);newmin=min(newmin,nnn[nadj[j-1]-1]);}
              if(*nosband< i-min(i+1,nldmin)+2){*nosband=i-min(i+1,nldmin)+2;*nosnod=i+1;}
			  if(*nnsband< nnn[i]-min(nnn[i],newmin)+1){*nnsband=nnn[i]-min(nnn[i],newmin)+1;*nnsnod=i+1;}
              *oldpro= *oldpro+float(i+1-min(i+1,nldmin));*rnewpr= *rnewpr+float(nnn[i]-min(nnn[i],newmin));
			 }
		   *oldpro= *oldpro+float(npoin);*rnewpr= *rnewpr+float(npoin);
          }
     delete [] nadj;delete [] nxadj;delete [] iw;
	}
 catch (EOutOfMemory &e){if(npn)delete [] npn;if(nxnpn)delete [] nxnpn;if(nadj)delete [] nadj;if(nxadj)delete [] nxadj;if(iw)delete [] iw;*flag=0;}
}
//---------------------------------------------------------------------------
void TForm1::sloangraph(long npoin,long nelt,long ispac,long iadj,long npn[],long nxnpn[],long nadj[],long nxadj[],int *flag)
{long i=0,j=0,k=0,m=0,l=1,jstrt=0,jstop=0,nen1=0,nodej=0,nodek=0,lstrt=0,lstop=0,mstrt=0,mstop=0,lsum=0,msum=0;
 for(i=0;i<iadj;i++)nadj[i]=0;for(i=0;i<npoin;i++)nxadj[i]=0;
 for(i=0;i<nelt;i++){jstrt=nxnpn[i];jstop=nxnpn[i+1]-1;nen1=jstop-jstrt;for(j=jstrt;j<jstop+1;j++)nxadj[npn[j-1]-1]=nxadj[npn[j-1]-1]+nen1;}
 for(i=0;i<npoin;i++){l=l+nxadj[i];nxadj[i]=l-nxadj[i];}nxadj[npoin]=l;
 for(i=0;i<nelt;i++)
   {jstrt=nxnpn[i];jstop=nxnpn[i+1]-1;
    for(j=jstrt;j<jstop;j++)
	  {nodej=npn[j-1];lstrt=nxadj[nodej-1];lstop=nxadj[nodej]-1;
       for(k=j+1;k<jstop+1;k++)
         {nodek=npn[k-1];lsum=0;
          for(l=lstrt;l<lstop+1;l++)
            {if(nadj[l-1]==nodek)break;
			 if(nadj[l-1])lsum++;
             else {nadj[l-1]=nodek;mstrt=nxadj[nodek-1];mstop=nxadj[nodek]-1;msum=0;
                   for(m=mstrt;m<mstop+1;m++){if(nadj[m-1])msum++;else {nadj[m-1]=nodej;break;}}
                   if(msum==mstop-mstrt+1){*flag= -1;return;}break;
                  }
            }
		  if(lsum==lstop-lstrt+1){*flag= -1;return;}
         }
      }
   }
 k=0;jstrt=1;for(i=0;i<npoin;i++){jstop=nxadj[i+1]-1;for(j=jstrt;j<jstop+1;j++){if(nadj[j-1]){k++;nadj[k-1]=nadj[j-1];}else break;}
								  nxadj[i+1]=k+1;jstrt=jstop+1;
                                 }
}
//---------------------------------------------------------------------------
void TForm1::sloandiamtr(long npoin,long me2,long nadj[],long nxadj[],long mask[],long ls[],long ixls[],long ihlevel[],long *nsnode,long *nc)
{int isw=0;long i=0,j=0,mindeg=npoin,idegree=0,isdepth=0,istrt=0,istop=0,node=0,nt=0,nvalue=0,ihsize=0,iewidth=0,idepth=0,iwidth=0,ienode=0;
 for(i=0;i<npoin;i++){if(mask[i]==0){idegree=nxadj[i+1]-nxadj[i];if(idegree<mindeg){*nsnode=i+1;mindeg=idegree;}}}
 rootls(*nsnode,npoin+1,me2,nadj,nxadj,mask,ls,ixls,&isdepth,&iwidth);*nc=ixls[isdepth]-1;
 do {isw=0;ihsize=0;istrt=ixls[isdepth-1];istop=ixls[isdepth]-1;
     for(i=istrt;i<istop+1;i++){node=ls[i-1];ihsize++;ihlevel[ihsize-1]=node;ixls[node-1]=nxadj[node]-nxadj[node-1];}
     if(ihsize>1){for(i=1;i<ihsize;i++){nt=ihlevel[i];nvalue=ixls[nt-1];
                                        for(j=i-1;j> -1;j--){if(nvalue>=ixls[ihlevel[j]-1]){ihlevel[j+1]=nt;break;}
                                                             else {ihlevel[j+1]=ihlevel[j];if(j==0)ihlevel[0]=nt;}
                                                            }
                                       }
				 }
     istop=ihsize;ihsize=1;idegree=ixls[ihlevel[0]-1];
     for(i=1;i<istop;i++){node=ihlevel[i];if(ixls[node-1]!=idegree){idegree=ixls[node-1];ihsize++;ihlevel[ihsize-1]=node;}}
	 iewidth= *nc+1;for(i=0;i<ihsize;i++){node=ihlevel[i];rootls(node,iewidth,me2,nadj,nxadj,mask,ls,ixls,&idepth,&iwidth);
                                          if(iwidth<iewidth){if(idepth>isdepth){*nsnode=node;isdepth=idepth;isw=1;break;}
                                                             else {ienode=node;iewidth=iwidth;}
                                                            }
										 }
	}
 while (isw);
 if(node!=ienode)rootls(ienode,*nc+1,me2,nadj,nxadj,mask,ls,ixls,&idepth,&iwidth);for(i=0;i<idepth;i++){for(j=ixls[i];j<ixls[i+1];j++)mask[ls[j-1]-1]=i;}
}
//---------------------------------------------------------------------------
void TForm1::rootls(long iroot,long maxwid,long me2,long nadj[],long nxadj[],long mask[],long ls[],long ixls[],long *idepth,long *iwidth)
{long i=0,j=0,lstop=0,lstrt=0,lwdth=1,nc=1,node=0,jstrt=0,jstop=0,nbr=0;mask[iroot-1]=1;ls[0]=iroot;*idepth=0;*iwidth=1;
 do {if(lwdth>0){lstrt=lstop+1;lstop=nc;*idepth= *idepth+1;ixls[*idepth-1]=lstrt;
                 for(i=lstrt;i<lstop+1;i++){node=ls[i-1];jstrt=nxadj[node-1];jstop=nxadj[node]-1;
                                            for(j=jstrt;j<jstop+1;j++){nbr=nadj[j-1];if(mask[nbr-1]==0){nc++;ls[nc-1]=nbr;mask[nbr-1]=1;}}
                                           }
				 lwdth=nc-lstop;*iwidth=max(lwdth,*iwidth);
                }
     else {ixls[*idepth]=lstop+1;break;}
	}
 while (*iwidth<maxwid);
 for(i=0;i<nc;i++)mask[ls[i]-1]=0;
}
//---------------------------------------------------------------------------
void TForm1::sloannumber(long nc,long nsnode,long *lstnum,long me2,long nadj[],long nxadj[],long ms[],long mq[],long mp[])
{long i=0,j=0,node=0,nn=1,jw1=1,jw2=2,iaddres=0,maxprt=0,mprty=0,next=0,istrt=0,istop=0,nbr=0,jstrt=0,jstop=0,nabor=0;
 for(i=0;i<nc;i++){node=mq[i];mp[node-1]=jw1*ms[node-1]-jw2*(nxadj[node]-nxadj[node-1]+1);ms[node-1]= -2;}mq[0]=nsnode;ms[nsnode-1]= -1;
 do {iaddres=1;maxprt=mp[mq[0]-1];for(i=1;i<nn;i++){mprty=mp[mq[i]-1];if(mprty>maxprt){iaddres=i+1;maxprt=mprty;}}
     next=mq[iaddres-1];mq[iaddres-1]=mq[nn-1];nn--;istrt=nxadj[next-1];istop=nxadj[next]-1;
     if(ms[next-1]== -1){for(i=istrt;i<istop+1;i++){nbr=nadj[i-1];mp[nbr-1]=mp[nbr-1]+jw2;if(ms[nbr-1]== -2){nn++;mq[nn-1]=nbr;ms[nbr-1]= -1;}}}
     *lstnum=*lstnum+1;ms[next-1]= *lstnum;
	 for(i=istrt;i<istop+1;i++){nbr=nadj[i-1];
                                if(ms[nbr-1]== -1){mp[nbr-1]=mp[nbr-1]+jw2;ms[nbr-1]=0;jstrt=nxadj[nbr-1];jstop=nxadj[nbr]-1;
                                                   for(j=jstrt;j<jstop+1;j++){nabor=nadj[j-1];mp[nabor-1]=mp[nabor-1]+jw2;if(ms[nabor-1]== -2){nn++;mq[nn-1]=nabor;ms[nabor-1]= -1;}}
												  }
                               }
    }
 while (nn);
}
//---------------------------------------------------------------------------
void TForm1::renuminp3g(long npoin,long nelt,long idirv[],long lnods[],long matno[],float cord[],float temp[],double tempD[],long nvfix,long npload,long nofix[],long lodpt[],int isw)
// To map--> Supply idirv[i]; To map back--> Supply idirv[i+npoin]
{long in=0,ic=0,t7=10000000,t5=100000,t3=1000,eltype=0,bscode=0,node=0;
 if(isw){for(in=0;in<npoin;in++){for(ic=0;ic<NDF;ic++)tempD[NDF*idirv[in]+ic]=double(cord[NDF*in+ic]);}
         for(in=0;in<NDF*npoin;in++)cord[in]=float(tempD[in]);
        }
 else {for(in=0;in<npoin;in++){for(ic=0;ic<NDF;ic++)temp[NDF*idirv[in]+ic]=cord[NDF*in+ic];}
       for(in=0;in<NDF*npoin;in++)cord[in]=temp[in];
      }
 for(in=0;in<nelt;in++){eltype=matno[in]/t7;bscode=(matno[in]-eltype*t7)/t5;node=(matno[in]-eltype*t7-bscode*t5)/t3;
						for(ic=0;ic<node;ic++)lnods[MXNPEL*in+ic]=idirv[lnods[MXNPEL*in+ic]];
                       }
 if(nvfix){for(in=0;in<nvfix;in++)nofix[2*in]=idirv[nofix[2*in]];}if(npload){for(in=0;in<npload;in++)lodpt[in]=idirv[lodpt[in]];}
}
//---------------------------------------------------------------------------
// This version does NOT accommodate constraints
void TForm1::cnsbdwth1(long npoin,long nelt,long ndestv[],long nop1[],long matno[],long nnary[],long *mxecn,long *nodmxx,long *nsbdwth,long NADF)
{long i=0,j=0,in=0,ie=0,ip=0,ipp=0,ic=0,t7=10000000,t5=100000,t3=1000,eltype=0,bscode=0,node=0,istat=0,nmin=0,nmax=0,idmax=0,nlbd=0,ndsum=0;
 for(i=0;i<npoin;i++)nnary[i]=0;
 for(i=0;i<nelt;i++){eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;node=(matno[i]-eltype*t7-bscode*t5)/t3;
                     for(j=0;j<node;j++)nnary[nop1[MXNPEL*i+j]]=nnary[nop1[MXNPEL*i+j]]+1;
                    }
 for(i=0;i<npoin;i++){if(istat<nnary[i])istat=nnary[i];}
 *mxecn=istat;*nodmxx=0;*nsbdwth=0;for(i=0;i<npoin;i++){nnary[2*i]=LONG_INT;nnary[2*i+1]= -1;}
 for(i=0;i<nelt;i++)
   {nmin=LONG_INT;nmax= -1;eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;node=(matno[i]-eltype*t7-bscode*t5)/t3;
    if(*nodmxx<node)*nodmxx=node;
    for(j=0;j<node;j++){if(nnary[2*nop1[MXNPEL*i+j]]>i)nnary[2*nop1[MXNPEL*i+j]]=i;if(nnary[2*nop1[MXNPEL*i+j]+1]<i)nnary[2*nop1[MXNPEL*i+j]+1]=i;
						if(nmin>nop1[MXNPEL*i+j])nmin=nop1[MXNPEL*i+j];if(nmax<nop1[MXNPEL*i+j])nmax=nop1[MXNPEL*i+j];
                       }
    nnary[2*(i+npoin)]=nmin;nnary[2*(i+npoin)+1]=nmax;
   }
 for(in=0;in<npoin;in++)
   {ndsum=0;for(ic=0;ic<NADF;ic++){if(ndestv[NADF*in+ic])ndsum++;}
    if(ndsum)
      {idmax=0;
       for(ie=nnary[2*in];ie<nnary[2*in+1]+1;ie++)
         {if(in>=nnary[2*(ie+npoin)] && in<=nnary[2*(ie+npoin)+1])
            {eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
             for(ip=0;ip<node;ip++)
               {if(nop1[MXNPEL*ie+ip]==in)
				  {for(ipp=0;ipp<node;ipp++){for(ic=0;ic<NADF;ic++)if(idmax<=ndestv[NADF*nop1[MXNPEL*ie+ipp]+ic])idmax=ndestv[NADF*nop1[MXNPEL*ie+ipp]+ic];}
                   break;
                  }
			   }
            }
         }
	   for(ic=0;ic<NADF;ic++){if(ndestv[NADF*in+ic]>0){nlbd=idmax-ndestv[NADF*in+ic]+1;if(*nsbdwth<nlbd)*nsbdwth=nlbd;break;}}
      }
   }
}
//---------------------------------------------------------------------------
void TForm1::locindx6e1_mem(long npst,long npnd,long nop1[],long matno[],long ndestv[],
  long *itpos,long *itpose,long nnary[],long npoin,long nxecn[],int *ifle,long mxecn,long *nswaps,int MXSWAPS,long MXI,long nrangu,long *totstor,long NADF)
// Stiffness matrix smat[] stored horizontally (compressed horz upper skyline)
{long in=0,ipos=0,ie=0,ip=0,ipp=0,ipv=0,iposn=0,nstore=0,idest=0,dofnsbdwc=0,iposmax=0,dofnsbdw=0,
	  t7=10000000,t5=100000,t3=1000,eltype=0,bscode=0,node=0,istart=0,iend=0,iend0=0,ndsum=0;int iswt=0;*ifle=0;*nswaps=0;
 for(in=npst-1;in<npnd;in++)
   {ndsum=0;for(ipv=0;ipv<NADF;ipv++){if(ndestv[NADF*in+ipv])ndsum++;}
	if(ndsum)
	  {ipos=0;
	   for(ie=nnary[2*in];ie<nnary[2*in+1]+1;ie++)
		 {if(in>=nnary[2*(ie+npoin)] && in<=nnary[2*(ie+npoin)+1])
			{eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
			 for(ip=0;ip<node;ip++)
			   {if(nop1[MXNPEL*ie+ip]==in)
				  {for(ipp=0;ipp<node;ipp++){for(ipv=0;ipv<NADF;ipv++){
if(ndestv[NADF*nop1[MXNPEL*ie+ipp]+ipv]){ipos++;nxecn[ipos-1+NADF*mxecn*MXNPEL]=ndestv[NADF*nop1[MXNPEL*ie+ipp]+ipv];
										}
																	  }
											}
				   break;
				  }
			   }
			}
		 }
//// Add constraints.......
	   if(ipos<1){*ifle= -1;return;}
	   else if(ipos>1)
		 {iposn=0;istart=NADF*mxecn*MXNPEL;iend=ipos+NADF*mxecn*MXNPEL;
		  for(ip=0;ip<ipos;ip++)
			{nstore=LONG_INT;for(ipv=istart;ipv<iend;ipv++){if(nstore>nxecn[ipv])nstore=nxecn[ipv];}
			 if(nstore==LONG_INT)break;
			 else {iswt=1;iend0=iend;
				   for(ipv=istart;ipv<iend0;ipv++){if(nxecn[ipv]==nstore)nxecn[ipv]=LONG_INT;
												   else if(nxecn[ipv]!=LONG_INT){iend=ipv+1;if(iswt){istart=ipv;iswt=0;}}
												  }
				   nxecn[iposn]=nstore;iposn++;
				  }
			}
		  ipos=iposn;
		 }
	   if(iposmax<ipos)iposmax=ipos;istart=0;
	   for(ipv=0;ipv<NADF;ipv++)
		 {idest=ndestv[NADF*in+ipv];
		  if(idest>0){if(*itpos+ *itpose<LONG_INT-2*ipos)
						{*itpose= *itpose+ipos;
						 for(ip=istart;ip<ipos;ip++){if(nxecn[ip]==idest)
													   {*itpos= *itpos+ipos-ip;
if(dofnsbdwc<ipos-ip)dofnsbdwc=ipos-ip;
if(dofnsbdw<nxecn[ipos-1]-idest+1)dofnsbdw=nxecn[ipos-1]-idest+1;
														istart=ip+1;break;
													   }
													}
						}
					  else {*ifle= -2;return;}
					 }
		 }
	  }
   }
//
 *totstor= *itpos+ *itpose;
 if( *itpos+ *itpose<=MXI)*nswaps=0;
 else {*nswaps=1+long(float(*itpos+ *itpose-MXI+nrangu)/float(MXI-nrangu-(dofnsbdw-1)*dofnsbdwc));
	   *itpose=MXI; *itpos=0;if(*nswaps>MXSWAPS-1)*ifle=1;
	  }
}
//---------------------------------------------------------------------------
void TForm1::deanloe(long npst,long npnd,long nop1[],long matno[],long ndestv[],long locinde[],long *itpos,long *itpose,long nsbdwth,long ndiag[],long ndiage[],
  long nnary[],long npoin,long mxi,long nodmxx,long nxecn[],long *intvck,int *ifle,long mxecn,long NADF)
{long MDICOT=10000000,itpos0=0,itpose0=0,lfortst=NADF*(81/2 +1),in=0,ipos=0,ie=0,ip=0,ipp=0,ipv=0,ii=0,jj=0,iposn=0,
	  nstore=0,ic=0,isgn=0,idest=0,ihr=0,ihdest=0,idloc0=0,idloc1=0,ihcol=0,lce=0,lde=0,inx=0,idestt=0,
	  t7=10000000,t5=100000,t3=1000,eltype=0,bscode=0,node=0,istart=0,iend=0,iend0=0,ndsum=0;int iswt=0;*ifle=0;itpose0= *itpose;
 for(in=npst-1;in<npnd;in++)
   {ndsum=0;for(ipv=0;ipv<NADF;ipv++){if(ndestv[NADF*in+ipv]>*intvck)ndsum++;}
	if(ndsum)
	  {ipos=0;
	   for(ie=nnary[2*in];ie<nnary[2*in+1]+1;ie++)
		 {if(in>=nnary[2*(ie+npoin)] && in<=nnary[2*(ie+npoin)+1])
			{eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
			 for(ip=0;ip<node;ip++)
			   {if(nop1[MXNPEL*ie+ip]==in)
				  {for(ipp=0;ipp<node;ipp++){for(ipv=0;ipv<NADF;ipv++){if(ndestv[NADF*nop1[MXNPEL*ie+ipp]+ipv]>0){ipos++;nxecn[ipos-1+NADF*mxecn*MXNPEL]=ndestv[NADF*nop1[MXNPEL*ie+ipp]+ipv];}}}
				   break;
				  }
			   }
			}
		 }
//// Add constraints.......
	   if(ipos<1){*ifle= -1;return;}
	   else if(ipos>1)
		 {iposn=0;istart=NADF*mxecn*MXNPEL;iend=ipos+NADF*mxecn*MXNPEL;
		  for(ii=0;ii<ipos;ii++)
			{nstore=LONG_INT;for(jj=istart;jj<iend;jj++){if(nstore>nxecn[jj])nstore=nxecn[jj];}
			 if(nstore==LONG_INT)break;
			 else {iswt=1;iend0=iend;
				   for(jj=istart;jj<iend0;jj++){if(nxecn[jj]==nstore)nxecn[jj]=LONG_INT;else if(nxecn[jj]!=LONG_INT){iend=jj+1;if(iswt){istart=jj;iswt=0;}}}
				   nxecn[iposn]=nstore;iposn++;
				  }
			}
		  ipos=iposn;
		 }
//
	   for(ic=0;ic<NADF;ic++)
		 {idest=ndestv[NADF*in+ic];
		  if(idest>*intvck)
			{isgn= -1;
			 for(ihr=0;ihr<ipos;ihr++)
			   {ihdest=nxecn[ihr];
				if(ihdest>*intvck)break;
				else {idloc0=ndiage[ihdest-1];
					  if(ihdest+1<idest)idloc1=ndiage[ihdest];else idloc1=idloc0+2;
					  if(idloc0+1<=idloc1-1){for(ihcol=idloc0;ihcol<idloc1-1;ihcol++)
											   {lce=locinde[ihcol]/MDICOT;lde=locinde[ihcol]-MDICOT*lce;
												if(lde==idest){*itpose=*itpose+1;locinde[*itpose-1]=(MDICOT*(ihcol-idloc0+2)+ihdest)*isgn;isgn=1;break;}
											   }
											}
					 }
			   }
			 *itpos=*itpos+1;*itpose=*itpose+1;locinde[*itpose-1]=(MDICOT+idest)*isgn;isgn=1;
			 ndiag[idest-1]=*itpos;ndiage[idest-1]=*itpose;*intvck=idest;
			 if(ipos>ihr+1){for(inx=ihr+1;inx<ipos;inx++)
							 {idestt=nxecn[inx];
							  if(idestt>0){*itpos=*itpos+1;*itpose=*itpose+1;locinde[*itpose-1]=MDICOT*(*itpose-ndiage[idest-1]+1)+idestt;}
							 }
						   }
//  Forward memory test(approx) based on current NSBDWTH & 8/20-node elem(ie.42/123)
//  If insufficient, IFLAG=Node# at which to begin new processing
			 if(mxi-*itpose-nsbdwth-lfortst+1<0){*itpos=itpos0;*itpose=itpose0;*ifle= -1;return;}
			}
		 }
	   itpos0=*itpos;itpose0=*itpose;
	  }
   }
}
//---------------------------------------------------------------------------
void TForm1::deanloy(long npst,long npnd,long nop1[],long matno[],long ndestv[],long locinde[],
  long *itpos,long *itpose,long nsbdwth,long ndiag[],long ndiage[],long nnary[],long npoin,long mxi,long nodmxx,long nxecn[],int *ifle,long mxecn,long ixunit[],long nrangu,long NADF)
// IXUNIT: col1->DOF split;col2->LOC split;col3&4->IXLOC1&2;col5&6->el.split
{long MDICOT=10000000,lfortst=NADF*(81/2 +1),in=0,ipos=0,ie=0,ip=0,ipp=0,ipv=0,ii=0,jj=0,iposn=0,
	  nstore=0,ic=0,isgn=0,idest=0,kdest=0,ihr=0,ihdest=0,idloc0=0,idloc1=0,ihcol=0,lce=0,lde=0,inx=0,idestt=0,
	  t7=10000000,t5=100000,t3=1000,eltype=0,bscode=0,node=0,istart=0,iend=0,iend0=0,lshiftp=0,lshift=0,lshifto=0,ishift=0,nswps=0,minel=0,maxel= -1,intvck=0,ndsum=0;
 int iswt=0; *ifle=0;lshift=lshiftp=lshifto= *itpose;ishift= *itpos;minel=MDICOT;
 ixunit[0]=ixunit[1]=ixunit[2]=ixunit[3]=0;ntapeL.seekg(0);
 for(in=npst-1;in<npnd;in++)
   {ndsum=0;for(ipv=0;ipv<NADF;ipv++){if(ndestv[NADF*in+ipv])ndsum++;}
	if(ndsum)
	  {if(minel>nnary[2*in])minel=nnary[2*in];if(maxel<nnary[2*in+1])maxel=nnary[2*in+1];ipos=0;
	   for(ie=nnary[2*in];ie<nnary[2*in+1]+1;ie++)
		 {if(in>=nnary[2*(ie+npoin)] && in<=nnary[2*(ie+npoin)+1])
			{eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
			 for(ip=0;ip<node;ip++)
			   {if(nop1[MXNPEL*ie+ip]==in)
				  {for(ipp=0;ipp<node;ipp++){for(ipv=0;ipv<NADF;ipv++){if(ndestv[NADF*nop1[MXNPEL*ie+ipp]+ipv]>0){ipos++;nxecn[ipos-1+NADF*mxecn*MXNPEL]=ndestv[NADF*nop1[MXNPEL*ie+ipp]+ipv];}}}
				   break;
				  }
			   }
			}
		 }
//// Add constraints.......
	   if(ipos<1){*ifle= -1;return;}
	   else if(ipos>1)
		 {iposn=0;istart=NADF*mxecn*MXNPEL;iend=ipos+NADF*mxecn*MXNPEL;
		  for(ii=0;ii<ipos;ii++)
			{nstore=LONG_INT;for(jj=istart;jj<iend;jj++){if(nstore>nxecn[jj])nstore=nxecn[jj];}
			 if(nstore==LONG_INT)break;
			 else {iswt=1;iend0=iend;
				   for(jj=istart;jj<iend0;jj++){if(nxecn[jj]==nstore)nxecn[jj]=LONG_INT;else if(nxecn[jj]!=LONG_INT){iend=jj+1;if(iswt){istart=jj;iswt=0;}}}
				   nxecn[iposn]=nstore;iposn++;
				  }
			}
		  ipos=iposn;
		 }
//
	   for(ic=0;ic<NADF;ic++)
		 {idest=ndestv[NADF*in+ic];
		  if(idest)
			{isgn= -1;
			 for(ihr=0;ihr<ipos;ihr++)
			   {ihdest=nxecn[ihr];
				if(ihdest>intvck)break;
				else if(ihdest<=ixunit[6*nswps])
// Code uses higher locinde[] memory (i.e. currently unused smat[]) for overlap
					 {idloc0=ndiage[ihdest-1];
					  if(ihdest+1<idest)idloc1=ndiage[ihdest];else idloc1=idloc0+2;
					  if(idloc0+1<=idloc1-1){for(ihcol=idloc0;ihcol<idloc1-1;ihcol++)
											   {lce=locinde[ihcol+lshiftp-lshifto]/MDICOT;lde=locinde[ihcol+lshiftp-lshifto]-MDICOT*lce;
												if(lde==idest){*itpose=*itpose+1;
locinde[*itpose-1-lshift]=(MDICOT*(ihcol-idloc0+2)+ihdest)*isgn;
															   isgn=1;break;
															  }
											   }
											}
					 }
				else {idloc0=ndiage[ihdest-1];
					  if(ihdest+1<idest)idloc1=ndiage[ihdest];else idloc1=idloc0+2;
					  if(idloc0+1<=idloc1-1){for(ihcol=idloc0;ihcol<idloc1-1;ihcol++)
											   {lce=locinde[ihcol-lshift]/MDICOT;lde=locinde[ihcol-lshift]-MDICOT*lce;
												if(lde==idest){*itpose=*itpose+1;
locinde[*itpose-1-lshift]=(MDICOT*(ihcol-idloc0+2)+ihdest)*isgn;
															   isgn=1;break;
															  }
											   }
											}
					 }
			   }
			 *itpos=*itpos+1;*itpose=*itpose+1;locinde[*itpose-1-lshift]=(MDICOT+idest)*isgn;isgn=1;
			 ndiag[idest-1]=*itpos;ndiage[idest-1]=*itpose;intvck=idest;
			 if(ipos>ihr+1){for(inx=ihr+1;inx<ipos;inx++)
							 {idestt=nxecn[inx];
							  if(idestt>0){*itpos=*itpos+1;*itpose=*itpose+1;
locinde[*itpose-1-lshift]=MDICOT*(*itpose-ndiage[idest-1]+1)+idestt;
										  }
							 }
						   }
			 kdest=idest;
			}
		 }
//  Forward memory test(approx) based on current NSBDWTH & 8/20-node elem(ie.42/123)
	   if(mxi-*itpose+lshift-*itpos+ishift-3*lfortst<0 && kdest<nrangu)
		 {ixunit[6*(nswps+1)]=kdest;ixunit[6*(nswps+1)+1]= *itpose;ixunit[6*(nswps+1)+2]=ndiag[kdest+2-nsbdwth-1]-1;
		  ixunit[6*(nswps+1)+3]= *itpos;ixunit[6*nswps+4]=minel;ixunit[6*nswps+5]=maxel;
		  if(nswps>1 && ixunit[6*(nswps+1)]<ixunit[6*nswps]+nsbdwth-1){*ifle= -3;return;}
		  for(inx=lshiftp-lshift;inx<ixunit[6*(nswps+1)+1]-lshift;inx++)ntapeL<<locinde[inx]<<"\n";
	  lshiftp= *itpose;if(kdest+1-nsbdwth<1)lshift=0;else lshift= *itpose;
		  if(kdest+1-nsbdwth<1)lshifto=0;else lshifto=ndiage[kdest-nsbdwth]+ndiag[kdest-nsbdwth+1]-ndiag[kdest-nsbdwth]-1;
	  ishift=ndiag[kdest-nsbdwth+1]-1;
		  for(inx=lshifto;inx<lshiftp;inx++)locinde[inx+lshiftp-lshifto]=locinde[inx];
	  minel=MDICOT;maxel=0;nswps++;
		 }
	  }
   }
 ixunit[6*(nswps+1)]=nrangu;ixunit[6*(nswps+1)+1]= *itpose;ixunit[6*(nswps+1)+2]=ndiag[kdest+2-nsbdwth-1]-1;
 ixunit[6*(nswps+1)+3]= *itpos;ixunit[6*nswps+4]=minel;ixunit[6*nswps+5]=maxel;
 if(nswps>1 && ixunit[6*(nswps+1)]<ixunit[6*nswps]+nsbdwth-1){*ifle= -3;return;}
 for(inx=lshiftp-lshift;inx<ixunit[6*(nswps+1)+1]-lshift;inx++)ntapeL<<locinde[inx]<<"\n";
 nswps++;long MXMAGL=0,MXMAGS=0;
 for(inx=0;inx<nswps;inx++){if(MXMAGL<ixunit[6*(inx+1)+1]-ixunit[6*inx+1])MXMAGL=ixunit[6*(inx+1)+1]-ixunit[6*inx+1];
							if(MXMAGS<ixunit[6*(inx+1)+3]-ixunit[6*inx+2])MXMAGS=ixunit[6*(inx+1)+3]-ixunit[6*inx+2];
						   }
honk<<MXMAGS<<" LLSS "<<MXMAGL<<"\n";
}
//---------------------------------------------------------------------------
long TForm1::rangu(long npoin,long nvfix,long nofix[],long ndestv[],long NADF)
{int ifpre[NDF];long ir=0,ic=0,il=0,is=0,nszf=NADF*npoin,nrangu=NADF*npoin;for(ir=0;ir<nszf;ir++)ndestv[ir]=ir+1;
 if(nvfix){for(ir=0;ir<nvfix;ir++){
if(nofix[2*ir+1]==1 || nofix[2*ir+1]==4 || nofix[2*ir+1]==5 || nofix[2*ir+1]==7)ifpre[0]=1;else ifpre[0]=0;
if(nofix[2*ir+1]==2 || nofix[2*ir+1]==4 || nofix[2*ir+1]==6 || nofix[2*ir+1]==7)ifpre[1]=1;else ifpre[1]=0;
if(nofix[2*ir+1]==3 || nofix[2*ir+1]==5 || nofix[2*ir+1]==6 || nofix[2*ir+1]==7)ifpre[2]=1;else ifpre[2]=0;
for(ic=0;ic<NADF;ic++)
  {if(ifpre[ic]){il=NADF*nofix[2*ir]+ic;if(il<nszf-1){for(is=il+1;is<nszf;is++){if(ndestv[is]>ndestv[il])ndestv[is]=ndestv[is]-1;}}
				 ndestv[il]=0;nrangu=nrangu-1;
				}
  }
								  }
		  }
 return nrangu;
}
//---------------------------------------------------------------------------
void TForm1::sortminmx(long nvfix,long nofix[],float presc[],long nrfix[])
{long ind=0,irv=0,iv=0,isub=0;float psub=0.;
 for(ind=0;ind<nvfix-1;ind++)
   {for(irv=ind+1;irv<nvfix;irv++){iv=ind+nvfix-irv;
								   if(nofix[2*iv-2]>nofix[2*iv]){
isub=nofix[2*iv-2];nofix[2*iv-2]=nofix[2*iv];nofix[2*iv]=isub;
isub=nofix[2*iv-1];nofix[2*iv-1]=nofix[2*iv+1];nofix[2*iv+1]=isub;
isub=nrfix[iv-1];nrfix[iv-1]=nrfix[iv];nrfix[iv]=isub;
psub=presc[NDF*iv-NDF  ];presc[NDF*iv-NDF  ]=presc[NDF*iv  ];presc[NDF*iv  ]=psub;
psub=presc[NDF*iv-NDF+1];presc[NDF*iv-NDF+1]=presc[NDF*iv+1];presc[NDF*iv+1]=psub;
psub=presc[NDF*iv-NDF+2];presc[NDF*iv-NDF+2]=presc[NDF*iv+2];presc[NDF*iv+2]=psub;
																}
								  }
   }
}
//---------------------------------------------------------------------------
void TForm1::formkch7c(long nelt,float props[],long nop1[],long matno[],float cord[])
// Subroutine to compute mesh DET & mass/momemt of inertia/etc - NOT stiffness matrix....
{int ig=0,jg=0,kg=0,mg=0,ngaus8=10,isw=0;
 long ie=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000,ne8=0,ne8d=0,ne6=0,ne6d=0,ne4=0,ne4d=0,iemin=0,iemax=0;
 float DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],DJDLIM=3.E-10,POSGP8[10],WEIGP8[10],RHO=0.,VOLL=0.,VOLLOC=0.,VOLT=0.,TMASS=0.,
   xcen=0.,ycen=0.,zcen=0.,xgcen=0.,ygcen=0.,zgcen=0.,xmgcen=0.,ymgcen=0.,zmgcen=0.,x2gcen=0.,y2gcen=0.,z2gcen=0.,x2mgcen=0.,y2mgcen=0.,z2mgcen=0.,
   pIxx=0.,pIyy=0.,pIzz=0.,pmIxx=0.,pmIyy=0.,pmIzz=0.,G=0.,E=0.,evmin=1.e30,evmax= -1.e30;
 float TETIN[12]={0.5854102,0.1381966,0.1381966,
				  0.1381966,0.5854102,0.1381966,
				  0.1381966,0.1381966,0.5854102,
				  0.1381966,0.1381966,0.1381966};
 if(ngaus8==10){POSGP8[0]= -0.973906528517172;WEIGP8[0]=0.066671344308688;
				POSGP8[1]= -0.865063366688985;WEIGP8[1]=0.149451349150581;
				POSGP8[2]= -0.679409568299024;WEIGP8[2]=0.219086362515982;
				POSGP8[3]= -0.433395394129247;WEIGP8[3]=0.269266719309996;
				POSGP8[4]= -0.148874338981631;WEIGP8[4]=0.295524224714753;
				POSGP8[5]=  0.148874338981631;WEIGP8[5]=0.295524224714753;
				POSGP8[6]=  0.433395394129247;WEIGP8[6]=0.269266719309996;
				POSGP8[7]=  0.679409568299024;WEIGP8[7]=0.219086362515982;
				POSGP8[8]=  0.865063366688985;WEIGP8[8]=0.149451349150581;
				POSGP8[9]=  0.973906528517172;WEIGP8[9]=0.066671344308688;
			   }
 else {POSGP8[0]= -1./sqrt(3.);POSGP8[1]=1./sqrt(3.);WEIGP8[0]=WEIGP8[1]=  1.00000;}
 for(ie=0;ie<nelt;ie++)
   {eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
////	ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];

	RHO=props[MPROP*ieGID+2];
//    RHO=1.;
	isw=0;VOLL=0.;
	if(eltype==8)
	  {if(node==8)
		 {for(ig=0;ig<ngaus8;ig++)
			{for(jg=0;jg<ngaus8;jg++)
			   {for(kg=0;kg<ngaus8;kg++)
				  {xcen=ycen=zcen=0.;STFISO8(1,POSGP8[ig],POSGP8[jg],POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
				   for(mg=0;mg<node;mg++){xcen=xcen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]  ];ycen=ycen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]+1];zcen=zcen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]+2];}
				   STFISO8(2,POSGP8[ig],POSGP8[jg],POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
				   if(DJD<DJDLIM){
//honk<<ie+1<<" "<<node<<" Integ.Pt "<<" "<<ig+1<<" "<<jg+1<<" "<<kg+1<<" "<<DJD<<" Zero DJD "<<DJDLIM<<"\n";
								  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Misshapen element",L"Warning",MB_OK);
								  DJD=DJDLIM;isw=1;
								 }
				   VOLLOC=DJD*WEIGP8[ig]*WEIGP8[jg]*WEIGP8[kg];

//honk<<ig<<" "<<jg<<" "<<kg<<"  IJK "<<xcen<<" "<<ycen<<" "<<zcen<<" DJD "<<DJD<<WEIGP8[ig]<<" "<<WEIGP8[jg]<<" "<<WEIGP8[kg]<<" "<<VOLLOC<<"\n";

				   xgcen=xgcen+xcen*VOLLOC;ygcen=ygcen+ycen*VOLLOC;zgcen=zgcen+zcen*VOLLOC;
				   xmgcen=xmgcen+xcen*VOLLOC*RHO;ymgcen=ymgcen+ycen*VOLLOC*RHO;zmgcen=zmgcen+zcen*VOLLOC*RHO;
				   x2gcen=x2gcen+xcen*xcen*VOLLOC;y2gcen=y2gcen+ycen*ycen*VOLLOC;z2gcen=z2gcen+zcen*zcen*VOLLOC;
				   x2mgcen=x2mgcen+xcen*xcen*VOLLOC*RHO;y2mgcen=y2mgcen+ycen*ycen*VOLLOC*RHO;z2mgcen=z2mgcen+zcen*zcen*VOLLOC*RHO;
				   VOLL=VOLL+VOLLOC;
				  }
			   }
			}
		  ne8++;if(isw)ne8d++;
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element order",L"Warning",MB_OK);}
	  }
	else if(eltype==7)  // 3-point integration
	  {if(node==6)
		 {for(ig=0;ig<3;ig++)
			   {G=(4.-4.*float(ig+1)+float(ig+1)*float(ig+1))/2.;E=(-4.+5.*float(ig+1)-float(ig+1)*float(ig+1))/4.;
				for(kg=0;kg<ngaus8;kg++)
				  {xcen=ycen=zcen=0.;STFISO6(1,G,E,POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
				   for(mg=0;mg<node;mg++){xcen=xcen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]  ];ycen=ycen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]+1];zcen=zcen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]+2];}
				   STFISO6(2,G,E,POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
				   if(DJD<DJDLIM){
//honk<<ie+1<<" "<<node<<" Integ.Pt "<<" "<<ig+1<<" "<<kg+1<<" "<<DJD<<" Zero DJD "<<DJDLIM<<"\n";
								  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Misshapen element",L"Warning",MB_OK);
								  DJD=DJDLIM;isw=1;
								 }
				   VOLLOC=DJD*WEIGP8[kg]/6.;
				   xgcen=xgcen+xcen*VOLLOC;ygcen=ygcen+ycen*VOLLOC;zgcen=zgcen+zcen*VOLLOC;
				   xmgcen=xmgcen+xcen*VOLLOC*RHO;ymgcen=ymgcen+ycen*VOLLOC*RHO;zmgcen=zmgcen+zcen*VOLLOC*RHO;
				   x2gcen=x2gcen+xcen*xcen*VOLLOC;y2gcen=y2gcen+ycen*ycen*VOLLOC;z2gcen=z2gcen+zcen*zcen*VOLLOC;
				   x2mgcen=x2mgcen+xcen*xcen*VOLLOC*RHO;y2mgcen=y2mgcen+ycen*ycen*VOLLOC*RHO;z2mgcen=z2mgcen+zcen*zcen*VOLLOC*RHO;
				   VOLL=VOLL+VOLLOC;
				  }
			   }
		  ne6++;if(isw)ne6d++;
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element order",L"Warning",MB_OK);}
	  }
	else if(eltype==5)  // 4-point integration
	  {if(node==4)
		 {for(ig=0;ig<4;ig++)
			   {xcen=ycen=zcen=0.;STFISO4(1,TETIN[NDF*ig],TETIN[NDF*ig+1],TETIN[NDF*ig+2],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
				for(mg=0;mg<node;mg++){xcen=xcen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]  ];ycen=ycen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]+1];zcen=zcen+SN[mg]*cord[NDF*nop1[MXNPEL*ie+mg]+2];}
				STFISO4(2,TETIN[NDF*ig],TETIN[NDF*ig+1],TETIN[NDF*ig+2],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
				if(DJD<DJDLIM){
//honk<<ie+1<<" "<<node<<" Integ.Pt "<<" "<<ig+1<<" "<<DJD<<" Zero DJD "<<DJDLIM<<"\n";
							   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Misshapen element",L"Warning",MB_OK);
							   DJD=DJDLIM;isw=1;
							  }
				VOLLOC=DJD/4.;
				xgcen=xgcen+xcen*VOLLOC;ygcen=ygcen+ycen*VOLLOC;zgcen=zgcen+zcen*VOLLOC;
				xmgcen=xmgcen+xcen*VOLLOC*RHO;ymgcen=ymgcen+ycen*VOLLOC*RHO;zmgcen=zmgcen+zcen*VOLLOC*RHO;
				x2gcen=x2gcen+xcen*xcen*VOLLOC;y2gcen=y2gcen+ycen*ycen*VOLLOC;z2gcen=z2gcen+zcen*zcen*VOLLOC;
				x2mgcen=x2mgcen+xcen*xcen*VOLLOC*RHO;y2mgcen=y2mgcen+ycen*ycen*VOLLOC*RHO;z2mgcen=z2mgcen+zcen*zcen*VOLLOC*RHO;
				VOLL=VOLL+VOLLOC;
			   }
          ne4++;if(isw)ne4d++;
         }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element order",L"Warning",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element type",L"Warning",MB_OK);}

//honk<<VOLL<<" VOLL "<<RHO<<"\n";

	VOLT=VOLT+VOLL;TMASS=TMASS+VOLL*RHO;if(evmin>VOLL){evmin=VOLL;iemin=ie;}if(evmax<VOLL){evmax=VOLL;iemax=ie;}
//    xgcen=xgcen+xcen*VOLL;ygcen=ygcen+ycen*VOLL;zgcen=zgcen+zcen*VOLL;
//    xmgcen=xmgcen+xcen*VOLL*RHO;ymgcen=ymgcen+ycen*VOLL*RHO;zmgcen=zmgcen+zcen*VOLL*RHO;
//    mrxx=mrxx+VOLL*RHO*sqrt(ycen*ycen+zcen*zcen);mryy=mryy+VOLL*RHO*sqrt(xcen*xcen+zcen*zcen);mrzz=mrzz+VOLL*RHO*sqrt(xcen*xcen+ycen*ycen);
//    pIxx=pIxx+VOLL*(ycen*ycen+zcen*zcen);pIyy=pIyy+VOLL*(xcen*xcen+zcen*zcen);pIzz=pIzz+VOLL*(xcen*xcen+ycen*ycen);
//    pmIxx=pmIxx+VOLL*RHO*(ycen*ycen+zcen*zcen);pmIyy=pmIyy+VOLL*RHO*(xcen*xcen+zcen*zcen);pmIzz=pmIzz+VOLL*RHO*(xcen*xcen+ycen*ycen);
   }
honk<<"\n";
honk<<ne8<<" 8n-bricks/distorted "<<ne8d<<"\n";
honk<<ne6<<" 6n-bricks/distorted "<<ne6d<<"\n";
honk<<ne4<<" 4n-bricks/distorted "<<ne4d<<"\n";
honk<<nelt<<" Total elements.\n";
honk<<"\n";
honk<<iemin+1<<" Min. element volume "<<evmin<<"\n";
honk<<iemax+1<<" Max. element volume "<<evmax<<"\n";
honk<<"\n";
honk<<VOLT<<" VOLT/Centroid "<<xgcen/VOLT<<"  "<<ygcen/VOLT<<"  "<<zgcen/VOLT<<"\n";
honk<<TMASS<<" TMASS/Cen.gravity "<<xmgcen/TMASS<<"  "<<ymgcen/TMASS<<"  "<<zmgcen/TMASS<<"\n";
honk<<"\n";
honk<<" CAUTION: UNIT THICKNESS REQUIRED FOR MOMENTS\n";
honk<<" Raw        moment based on x2,y2,z2 "<<x2gcen<<"  "<<y2gcen<<"  "<<z2gcen<<"\n";
honk<<" Centroidal moment based on x2,y2,z2 "<<x2gcen-VOLT*(xgcen/VOLT)*(xgcen/VOLT)<<"  "<<y2gcen-VOLT*(ygcen/VOLT)*(ygcen/VOLT)<<"  "<<z2gcen-VOLT*(zgcen/VOLT)*(zgcen/VOLT)<<"\n";
honk<<"\n";
honk<<" CAUTION: UNIT THICKNESS REQUIRED FOR MOMENTS OF INERTIA\n";
honk<<" Raw        mass moment based on x2,y2,z2 "<<x2mgcen<<"  "<<y2mgcen<<"  "<<z2mgcen<<"\n";
honk<<" Centroidal mass moment based on x2,y2,z2 "<<x2mgcen-TMASS*(xmgcen/TMASS)*(xmgcen/TMASS)<<"  "<<y2mgcen-TMASS*(ymgcen/TMASS)*(ymgcen/TMASS)<<"  "<<z2mgcen-TMASS*(zmgcen/TMASS)*(zmgcen/TMASS)<<"\n";
honk<<"\n";
honk<<" Raw polar volume moment of inertia (V*r*r) about X/Y/Z axes "<<y2gcen+z2gcen<<"  "<<z2gcen+x2gcen<<"  "<<x2gcen+y2gcen<<"\n";
honk<<" Raw polar mass moment of inertia (mV*r*r) about X/Y/Z axes "<<y2mgcen+z2mgcen<<"  "<<z2mgcen+x2mgcen<<"  "<<x2mgcen+y2mgcen<<"\n";
pIxx=x2gcen-VOLT*(xgcen/VOLT)*(xgcen/VOLT);
pIyy=y2gcen-VOLT*(ygcen/VOLT)*(ygcen/VOLT);
pIzz=z2gcen-VOLT*(zgcen/VOLT)*(zgcen/VOLT);
honk<<"\n";
honk<<" Centroidal polar volume moment of inertia (V*r*r) about X/Y/Z axes "<<pIyy+pIzz<<"  "<<pIzz+pIxx<<"  "<<pIxx+pIyy<<"\n";
pmIxx=x2mgcen-TMASS*(xmgcen/TMASS)*(xmgcen/TMASS);
pmIyy=y2mgcen-TMASS*(ymgcen/TMASS)*(ymgcen/TMASS);
pmIzz=z2mgcen-TMASS*(zmgcen/TMASS)*(zmgcen/TMASS);
honk<<" Centroidal polar mass moment of inertia (mV*r*r) about X/Y/Z axes "<<pmIyy+pmIzz<<"  "<<pmIzz+pmIxx<<"  "<<pmIxx+pmIyy<<"\n";
}
//---------------------------------------------------------------------------
void TForm1::formAVGtem7(long recGID,long nelt,long nop1[],long matno[],float cord[],float pload[],long nCol,float T1[],long *tnelGID,float *tvol)
// Revised with 2x2x2 gaussian integ. nCol results files supported.  EFP 3/15/2010
{int ig=0,jg=0,kg=0,ngaus8=2;long is=0,ie=0,ic=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000;
 float DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],DJDLIM=3.E-10,POSGP8[2],WEIGP8[2],DWR=0.,TEMPGP=0.,G=0.,E=0.,
	   TETIN[12]={0.5854102,0.1381966,0.1381966,
				  0.1381966,0.5854102,0.1381966,
				  0.1381966,0.1381966,0.5854102,
				  0.1381966,0.1381966,0.1381966};
 POSGP8[0]= -1./sqrt(3.);POSGP8[1]=1./sqrt(3.);WEIGP8[0]=WEIGP8[1]=1.00000;
 for(ie=0;ie<nelt;ie++)
   {eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
////    ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];

	if(ieGID==recGID)
      {if(eltype==8)
		 {if(node==8){for(ig=0;ig<ngaus8;ig++)
						{for(jg=0;jg<ngaus8;jg++)
                           {for(kg=0;kg<ngaus8;kg++)
							  {STFISO8(2,POSGP8[ig],POSGP8[jg],POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
							   if(DJD<DJDLIM){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Misshapen element",L"Warning",MB_OK);DJD=DJDLIM;}
							   DWR=DJD*WEIGP8[ig]*WEIGP8[jg]*WEIGP8[kg]; *tvol= *tvol+DWR;
							   STFISO8(1,POSGP8[ig],POSGP8[jg],POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
							   for(ic=0;ic<nCol;ic++){TEMPGP=0.;for(is=0;is<node;is++)TEMPGP=TEMPGP+SN[is]*T1[nCol*nop1[MXNPEL*ie+is]+ic];
													  pload[ic]=pload[ic]+TEMPGP*DWR;
													 }
							  }
						   }
						}
					 }
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element order",L"Warning",MB_OK);}
		 }
	   else if(eltype==7)   // 3-point integration
		 {if(node==6){for(ig=0;ig<3;ig++)
						{G=(4.-4.*float(ig+1)+float(ig+1)*float(ig+1))/2.;E=(-4.+5.*float(ig+1)-float(ig+1)*float(ig+1))/4.;
						 for(kg=0;kg<ngaus8;kg++)
						   {STFISO6(2,G,E,POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
							if(DJD<DJDLIM){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Misshapen element",L"Warning",MB_OK);DJD=DJDLIM;}
							DWR=DJD*WEIGP8[kg]/6.; *tvol= *tvol+DWR;
							STFISO6(1,G,E,POSGP8[kg],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
							for(ic=0;ic<nCol;ic++){TEMPGP=0.;for(is=0;is<node;is++)TEMPGP=TEMPGP+SN[is]*T1[nCol*nop1[MXNPEL*ie+is]+ic];
												   pload[ic]=pload[ic]+TEMPGP*DWR;
												  }
						   }
						}
					 }
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element order",L"Warning",MB_OK);}
		 }
	   else if(eltype==5)  // 4-point integration
		 {if(node==4){for(ig=0;ig<4;ig++)
						{STFISO4(2,TETIN[NDF*ig],TETIN[NDF*ig+1],TETIN[NDF*ig+2],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
						 if(DJD<DJDLIM){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Misshapen element",L"Warning",MB_OK);DJD=DJDLIM;}
						 DWR=DJD/4.; *tvol= *tvol+DWR;
                         STFISO4(1,TETIN[NDF*ig],TETIN[NDF*ig+1],TETIN[NDF*ig+2],&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,cord);
                         for(ic=0;ic<nCol;ic++){TEMPGP=0.;for(is=0;is<node;is++)TEMPGP=TEMPGP+SN[is]*T1[nCol*nop1[MXNPEL*ie+is]+ic];
                                                pload[ic]=pload[ic]+TEMPGP*DWR;
											   }
                        }
                     }
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element order",L"Warning",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element type",L"Warning",MB_OK);}
	   *tnelGID= *tnelGID+1;
	  }
   }
}
//---------------------------------------------------------------------------
int TForm1::WriteGIF()
// COLORS USED
// String       TColor               RGB      0xbbggrr Hex
// clBlack           0         0,  0,  0      0x000000
// clMaroon        128       128,  0,  0      0x000080
// clGreen       32768         0,128,  0      0x008000
// clOlive       32896       128,128,  0      0x008080
// clNavy      8388608         0,  0,128      0x800000
// clPurple    8388736       128,  0,128      0x800080
// clTeal      8421376         0,128,128      0x808000
// clGray      8421504       128,128,128      0x808080
// clSilver   12632256       192,192,192      0xc0c0c0  (formerly LtGray)
// clRed           255       255,  0,  0      0x0000ff  (LtRed)
// clLime        65280         0,255,  0      0x00ff00  (LtGreen)
// clYellow      65535       255,255,  0      0x00ffff  (LtYellow)
// clBlue     16711680         0,  0,255      0xff0000  (LtBlue)
// clFuchsia  16711935       255,  0,255      0xff00ff  (LtMagenta)
// clAqua     16776960         0,255,255      0xffff00  (LtCyan)
// clWhite    16777215       255,255,255      0xffffff
//
// SHADES USED
// 15724527   0xEFEFEF
// 14671839   0xDFDFDF
// 13619151   0xCFCFCF
// 12566463   0xBFBFBF
// 11513775   0xAFAFAF
// 10461087   0x9F9F9F
//  9408399   0x8F8F8F
//  8355711   0x7F7F7F
//  7303023   0x6F6F6F
//  6250335   0x5F5F5F
//  5197647   0x4F4F4F
//  4144959   0x3F3F3F
//  3092271   0x2F2F2F
//  2039583   0x1F1F1F
//   986895   0x0F0F0F
//
//#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
//#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
//#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
//  Interlace=0
{register long fcode=0;register int i=0;register int c=0;register int ent=0;register int disp=0;register int hsize_reg=0;register int hshift=0;
 int jV=0,jH=0,j=0,nc=0,ic=0,ColorMapSize=0,InitCodeSize=0,Background=0xff,BitsPerPixel=0,colorstyle=0,LeftOfs=0,TopOfs=0,
   cur_bits=0,n_bits=0,maxmaxcode=1<<GIF_BITS,free_ent=0,hsize=GIFHSIZE,maxbits=GIF_BITS,clear_flg=0,maxcode=0,g_init_bits=0,ClearCode=0,EOFCode=0,init_bits=0,value=0,div=1;
 int pc2nc[32];byte r1[32],g1[32],b1[32];long ding=0,*htab=NULL;unsigned short *codetab=NULL;
 unsigned long cur_accum=0;char accum[256],string[2],GIFname[13];
//int a_count=0;
 if(GIFcount>9999)return 0;
 GIFname[ 0]='s';GIFname[ 1]='n';GIFname[ 2]='a';GIFname[ 3]='p';GIFname[ 8]='.';GIFname[ 9]='g';GIFname[10]='i';GIFname[11]='f';GIFname[12]='\0';
 for(i=0;i<4;i++){value=(GIFcount-10*div*(GIFcount/(10*div)))/div;div=10*div;itoa(value,string,10);GIFname[7-i]=string[0];}
 GIFfile.open(GIFname,ios::binary|ios::trunc);
 if(GIFfile)
  {try
   {htab=new long[GIFHSIZE];codetab=new unsigned short[GIFHSIZE];
//
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
    Graphics::TBitmap *pBit=GetFormImage();for(i=0;i<32;i++){pc2nc[i]=0;r1[i]=g1[i]=b1[i]=0;}
////////////////////
    nc=31;
// clBlack           0         0,  0,  0      0x000000
    ic=0;b1[ic]=0;g1[ic]=0;r1[ic]=0;
// clMaroon        128       128,  0,  0      0x000080
    ic=1;b1[ic]=0;g1[ic]=0;r1[ic]=0x80;
// clRed           255       255,  0,  0      0x0000ff  (LtRed)
	ic=2;b1[ic]=0;g1[ic]=0;r1[ic]=0xff;
// clGreen       32768         0,128,  0      0x008000
    ic=3;b1[ic]=0;g1[ic]=0x80;r1[ic]=0;
// clOlive       32896       128,128,  0      0x008080
    ic=4;b1[ic]=0;g1[ic]=0x80;r1[ic]=0x80;
// Alternative clGreen       33280         0,128,  0      0x008000
    ic=3;b1[ic]=0;g1[ic]=0x80;r1[ic]=0;
// Alternative clOlive       33412       128,128,  0      0x008080
	ic=4;b1[ic]=0;g1[ic]=0x80;r1[ic]=0x80;
// clLime        65280         0,255,  0      0x00ff00  (LtGreen)
    ic=5;b1[ic]=0;g1[ic]=0xff;r1[ic]=0;
// clYellow      65535       255,255,  0      0x00ffff  (LtYellow)
    ic=6;b1[ic]=0;g1[ic]=0xff;r1[ic]=0xff;
//   986895   0x0F0F0F
    ic=7;b1[ic]=0x0f;g1[ic]=0x0f;r1[ic]=0x0f;
//  2039583   0x1F1F1F
    ic=8;b1[ic]=0x1f;g1[ic]=0x1f;r1[ic]=0x1f;
//  3092271   0x2F2F2F
    ic=9;b1[ic]=0x2f;g1[ic]=0x2f;r1[ic]=0x2f;
//  4144959   0x3F3F3F
    ic=10;b1[ic]=0x3f;g1[ic]=0x3f;r1[ic]=0x3f;
//  5197647   0x4F4F4F
    ic=11;b1[ic]=0x4f;g1[ic]=0x4f;r1[ic]=0x4f;
//  6250335   0x5F5F5F
	ic=12;b1[ic]=0x5f;g1[ic]=0x5f;r1[ic]=0x5f;
//  7303023   0x6F6F6F
    ic=13;b1[ic]=0x6f;g1[ic]=0x6f;r1[ic]=0x6f;
//  8355711   0x7F7F7F
    ic=14;b1[ic]=0x7f;g1[ic]=0x7f;r1[ic]=0x7f;
// clNavy      8388608         0,  0,128      0x800000
    ic=15;b1[ic]=0x80;g1[ic]=0x00;r1[ic]=0x00;
// clPurple    8388736       128,  0,128      0x800080
    ic=16;b1[ic]=0x80;g1[ic]=0x00;r1[ic]=0x80;
// clTeal      8421376         0,128,128      0x808000
	ic=17;b1[ic]=0x80;g1[ic]=0x80;r1[ic]=0x00;
// clGray      8421504       128,128,128      0x808080
    ic=18;b1[ic]=0x80;g1[ic]=0x80;r1[ic]=0x80;
////////// Alternative Navy ????
// clNavy      8650752         0,  0,128      0x800000
	ic=15;b1[ic]=0x80;g1[ic]=0x00;r1[ic]=0x00;
//////////
//  9408399   0x8F8F8F
	ic=19;b1[ic]=0x8f;g1[ic]=0x8f;r1[ic]=0x8f;
// 10461087   0x9F9F9F
    ic=20;b1[ic]=0x9f;g1[ic]=0x9f;r1[ic]=0x9f;
// 11513775   0xAFAFAF
    ic=21;b1[ic]=0xaf;g1[ic]=0xaf;r1[ic]=0xaf;
// 12566463   0xBFBFBF
    ic=22;b1[ic]=0xbf;g1[ic]=0xbf;r1[ic]=0xbf;
// clSilver   12632256       192,192,192      0xc0c0c0  (formerly LtGray)
    ic=23;b1[ic]=0xc0;g1[ic]=0xc0;r1[ic]=0xc0;
// 13619151   0xCFCFCF
    ic=24;b1[ic]=0xcf;g1[ic]=0xcf;r1[ic]=0xcf;
// 14671839   0xDFDFDF
    ic=25;b1[ic]=0xdf;g1[ic]=0xdf;r1[ic]=0xdf;
// 15724527   0xEFEFEF
    ic=26;b1[ic]=0xef;g1[ic]=0xef;r1[ic]=0xef;
// clBlue     16711680         0,  0,255      0xff0000  (LtBlue)
	ic=27;b1[ic]=0xff;g1[ic]=0x00;r1[ic]=0x00;
// clFuchsia  16711935       255,  0,255      0xff00ff  (LtMagenta)
    ic=28;b1[ic]=0xff;g1[ic]=0x00;r1[ic]=0xff;
// clAqua     16776960         0,255,255      0xffff00  (LtCyan)
    ic=29;b1[ic]=0xff;g1[ic]=0xff;r1[ic]=0x00;
// clWhite    16777215       255,255,255      0xffffff
    ic=30;r1[ic]=0xff;g1[ic]=0xff;b1[ic]=0xff;
////////////////////
//honk<<pBit->Height<<" "<<pBit->Width<<" HW\n";
//long *invstor;invstor=new long[pBit->Height*pBit->Width];
////for(jV=0;jV<pBit->Height*pBit->Width;jV++)invstor[jV]=16777215;
//for(jV=0;jV<pBit->Height*pBit->Width;jV++)invstor[jV]=0;
//for(jV=0;jV<pBit->Height/2;jV++){for(jH=0;jH<pBit->Height/2;jH++)invstor[pBit->Width*jH+jV]=long(pBit->Canvas->Pixels[jH][jV]);}
////////////////////
for(jV=0;jV<pBit->Height;jV++)
  {for(jH=0;jH<pBit->Width;jH++)
     {ding=long(pBit->Canvas->Pixels[jH][jV]);
//     {ding=invstor[pBit->Width*jV+jH];
	  if(ding<128/2)pc2nc[0]=1;
      else if(ding>=128/2 && ding<(128+255)/2)pc2nc[1]=1;
      else if(ding>=(128+255)/2 && ding<(255+32768)/2)pc2nc[2]=1;
      else if(ding>=(255+32768)/2 && ding<(32768+32896)/2)pc2nc[3]=1;
//      else if(ding>=(32768+32896)/2 && ding<(32896+65280)/2)pc2nc[4]=1;
//      else if(ding>=(32896+65280)/2 && ding<(65280+65535)/2)pc2nc[5]=1;
      else if(ding>=(32768+32896)/2 && ding<(32896+33280)/2)pc2nc[4]=1;
      else if(ding>=(32896+33280)/2 && ding<(33280+33412)/2)pc2nc[3]=1;
      else if(ding>=(33280+33412)/2 && ding<(33412+65280)/2)pc2nc[4]=1;
      else if(ding>=(33412+65280)/2 && ding<(65280+65535)/2)pc2nc[5]=1;
//
	  else if(ding>=(65280+65535)/2 && ding<(65535+527368)/2)pc2nc[6]=1;
      else if(ding>=(65535+527368)/2 && ding<(527368+1580056)/2)pc2nc[7]=1;
      else if(ding>=(527368+1580056)/2 && ding<(1580056+2698281)/2)pc2nc[8]=1;
      else if(ding>=(1580056+2698281)/2 && ding<(2698281+3750969)/2)pc2nc[9]=1;
      else if(ding>=(2698281+3750969)/2 && ding<(3750969+4869450)/2)pc2nc[10]=1;
	  else if(ding>=(3750969+4869450)/2 && ding<(4869450+5922138)/2)pc2nc[11]=1;
	  else if(ding>=(4869450+5922138)/2 && ding<(5922138+7040363)/2)pc2nc[12]=1;
      else if(ding>=(5922138+7040363)/2 && ding<(7040363+8355711)/2)pc2nc[13]=1;
      else if(ding>=(7040363+8355711)/2 && ding<(8355711+8388608)/2)pc2nc[14]=1;
      else if(ding>=(8355711+8388608)/2 && ding<(8388608+8388736)/2)pc2nc[15]=1;
      else if(ding>=(8388608+8388736)/2 && ding<(8388736+8421376)/2)pc2nc[16]=1;
      else if(ding>=(8388736+8421376)/2 && ding<(8421376+8421504)/2)pc2nc[17]=1;
//
//      else if(ding>=(8421376+8421504)/2 && ding<(8421504+9211532)/2)pc2nc[18]=1;
//      else if(ding>=(8421504+9211532)/2 && ding<(9211532+10264220)/2)pc2nc[19]=1;
	  else if(ding>=(8421376+8421504)/2 && ding<(8421504+8650752)/2)pc2nc[18]=1;
      else if(ding>=(8421504+8650752)/2 && ding<(8650752+9211532)/2)pc2nc[15]=1;
      else if(ding>=(8650752+9211532)/2 && ding<(9211532+10264220)/2)pc2nc[19]=1;
//
	  else if(ding>=(9211532+10264220)/2 && ding<(10264220+11382445)/2)pc2nc[20]=1;
	  else if(ding>=(10264220+11382445)/2 && ding<(11382445+12566463)/2)pc2nc[21]=1;
      else if(ding>=(11382445+12566463)/2 && ding<(12566463+12632256)/2)pc2nc[22]=1;
      else if(ding>=(12566463+12632256)/2 && ding<(12632256+13619151)/2)pc2nc[23]=1;
	  else if(ding>=(12632256+13619151)/2 && ding<(13619151+14671839)/2)pc2nc[24]=1;
      else if(ding>=(13619151+14671839)/2 && ding<(14671839+15724527)/2)pc2nc[25]=1;
      else if(ding>=(14671839+15724527)/2 && ding<(15724527+16711680)/2)pc2nc[26]=1;
      else if(ding>=(15724527+16711680)/2 && ding<(16711680+16711935)/2)pc2nc[27]=1;
      else if(ding>=(16711680+16711935)/2 && ding<(16711935+16776960)/2)pc2nc[28]=1;
      else if(ding>=(16711935+16776960)/2 && ding<(16776960+16777215)/2)pc2nc[29]=1;
      else if(ding>=(16776960+16777215)/2)pc2nc[30]=1;
     }
  }
ic=0;for(jH=0;jH<nc;jH++){if(pc2nc[jH]){pc2nc[jH]=ic;r1[ic]=r1[jH];g1[ic]=g1[jH];b1[ic]=b1[jH];ic++;}}
  for(i=1;i<8;i++)if((1<<i)>=ic)break;BitsPerPixel=i;ColorMapSize=1<<BitsPerPixel;
  if(BitsPerPixel<=1)InitCodeSize=2;else InitCodeSize=BitsPerPixel;
    GIFfile.write("GIF87a",6);GIFfile.put(pBit->Width & 0xff);GIFfile.put((pBit->Width>>8) & 0xff);
    GIFfile.put(pBit->Height & 0xff);GIFfile.put((pBit->Height>>8) & 0xff);i=0x80;i |= (8-1)<<4;i |= (BitsPerPixel-1);
    GIFfile.put(i);GIFfile.put(Background);GIFfile.put(0);
// MONO returns total intensity of r,g,b triple (i = .33R + .5G + .17B)
//#define MONO(rd,gn,bl) ( ((int)(rd)*11 + (int)(gn)*16 + (int)(bl)*5) >> 5)
//                       j = MONO(r1[i], g1[i], b1[i]);
  if(colorstyle==1){for(i=0;i<ColorMapSize;i++){j=(((int)(r1[i])*11+(int)(g1[i])*16+(int)(b1[i])*5)>>5);
                                                GIFfile.put(j);GIFfile.put(j);GIFfile.put(j);
                                               }
                   }
  else for(i=0;i<ColorMapSize;i++){GIFfile.put(r1[i]);GIFfile.put(g1[i]);GIFfile.put(b1[i]);}
    GIFfile.put(',');GIFfile.put(LeftOfs & 0xff);GIFfile.put((LeftOfs>>8)&0xff);
    GIFfile.put(TopOfs & 0xff);GIFfile.put((TopOfs>>8)&0xff);
    GIFfile.put(pBit->Width & 0xff);GIFfile.put((pBit->Width>>8)&0xff);
	GIFfile.put(pBit->Height & 0xff);GIFfile.put((pBit->Height>>8)&0xff);
    GIFfile.put(0x00);GIFfile.put(InitCodeSize);init_bits=InitCodeSize+1;g_init_bits=init_bits;
  xvbzero((char*)htab,sizeof(htab));xvbzero((char*)codetab,sizeof(codetab));
  n_bits=g_init_bits;maxcode=(1<<n_bits)-1;ClearCode=(1<<(init_bits-1));EOFCode=ClearCode+1;free_ent=ClearCode+2;
  a_count=0;hshift=0;for(fcode=(long)hsize;fcode<65536L;fcode *= 2L)hshift++;
  hshift=8-hshift;hsize_reg=hsize;cl_hash((long)hsize_reg,htab);
  output(ClearCode,&cur_accum,accum,&cur_bits,EOFCode,free_ent,maxmaxcode,maxbits,g_init_bits,&clear_flg,&maxcode,&n_bits);
for(jV=0;jV<pBit->Height;jV++)
  {for(jH=0;jH<pBit->Width;jH++)
     {ding=long(pBit->Canvas->Pixels[jH][jV]);
//     {ding=invstor[pBit->Width*jV+jH];
      if(ding<128/2)c=pc2nc[0];
      else if(ding>=128/2 && ding<(128+255)/2)c=pc2nc[1];
      else if(ding>=(128+255)/2 && ding<(255+32768)/2)c=pc2nc[2];
      else if(ding>=(255+32768)/2 && ding<(32768+32896)/2)c=pc2nc[3];
//      else if(ding>=(32768+32896)/2 && ding<(32896+65280)/2)c=pc2nc[4];
//      else if(ding>=(32896+65280)/2 && ding<(65280+65535)/2)c=pc2nc[5];

      else if(ding>=(32768+32896)/2 && ding<(32896+33280)/2)c=pc2nc[4];
	  else if(ding>=(32896+33280)/2 && ding<(33280+33412)/2)c=pc2nc[3];
      else if(ding>=(33280+33412)/2 && ding<(33412+65280)/2)c=pc2nc[4];
      else if(ding>=(33412+65280)/2 && ding<(65280+65535)/2)c=pc2nc[5];
//
      else if(ding>=(65280+65535)/2 && ding<(65535+527368)/2)c=pc2nc[6];
	  else if(ding>=(65535+527368)/2 && ding<(527368+1580056)/2)c=pc2nc[7];
	  else if(ding>=(527368+1580056)/2 && ding<(1580056+2698281)/2)c=pc2nc[8];
      else if(ding>=(1580056+2698281)/2 && ding<(2698281+3750969)/2)c=pc2nc[9];
      else if(ding>=(2698281+3750969)/2 && ding<(3750969+4869450)/2)c=pc2nc[10];
      else if(ding>=(3750969+4869450)/2 && ding<(4869450+5922138)/2)c=pc2nc[11];
      else if(ding>=(4869450+5922138)/2 && ding<(5922138+7040363)/2)c=pc2nc[12];
      else if(ding>=(5922138+7040363)/2 && ding<(7040363+8355711)/2)c=pc2nc[13];
      else if(ding>=(7040363+8355711)/2 && ding<(8355711+8388608)/2)c=pc2nc[14];
      else if(ding>=(8355711+8388608)/2 && ding<(8388608+8388736)/2)c=pc2nc[15];
      else if(ding>=(8388608+8388736)/2 && ding<(8388736+8421376)/2)c=pc2nc[16];
	  else if(ding>=(8388736+8421376)/2 && ding<(8421376+8421504)/2)c=pc2nc[17];
//      else if(ding>=(8421376+8421504)/2 && ding<(8421504+9211532)/2)c=pc2nc[18];
//      else if(ding>=(8421504+9211532)/2 && ding<(9211532+10264220)/2)c=pc2nc[19];
	  else if(ding>=(8421376+8421504)/2 && ding<(8421504+8650752)/2)c=pc2nc[18];
      else if(ding>=(8421504+8650752)/2 && ding<(8650752+9211532)/2)c=pc2nc[15];
	  else if(ding>=(8650752+9211532)/2 && ding<(9211532+10264220)/2)c=pc2nc[19];
//
      else if(ding>=(9211532+10264220)/2 && ding<(10264220+11382445)/2)c=pc2nc[20];
	  else if(ding>=(10264220+11382445)/2 && ding<(11382445+12566463)/2)c=pc2nc[21];
      else if(ding>=(11382445+12566463)/2 && ding<(12566463+12632256)/2)c=pc2nc[22];
      else if(ding>=(12566463+12632256)/2 && ding<(12632256+13619151)/2)c=pc2nc[23];
      else if(ding>=(12632256+13619151)/2 && ding<(13619151+14671839)/2)c=pc2nc[24];
      else if(ding>=(13619151+14671839)/2 && ding<(14671839+15724527)/2)c=pc2nc[25];
      else if(ding>=(14671839+15724527)/2 && ding<(15724527+16711680)/2)c=pc2nc[26];
      else if(ding>=(15724527+16711680)/2 && ding<(16711680+16711935)/2)c=pc2nc[27];
      else if(ding>=(16711680+16711935)/2 && ding<(16711935+16776960)/2)c=pc2nc[28];
      else if(ding>=(16711935+16776960)/2 && ding<(16776960+16777215)/2)c=pc2nc[29];
      else if(ding>=(16776960+16777215)/2)c=pc2nc[30];
if(jV==0 && jH==0)ent=c;
else {
    fcode=(long)(((long)c << maxbits)+ent);i=(((int)c<<hshift) ^ ent);
    if(htab[i]==fcode){ent=codetab[i];continue;}else if((long)htab[i]<0)goto nomatch;
    disp=hsize_reg-i;if(i==0)disp=1;
probe:
	if((i -= disp)<0)i += hsize_reg;if(htab[i]==fcode){ent=codetab[i];continue;}
	if((long)htab[i]>=0)goto probe;
nomatch:
	output(ent,&cur_accum,accum,&cur_bits,EOFCode,free_ent,maxmaxcode,maxbits,g_init_bits,&clear_flg,&maxcode,&n_bits);
	ent=c;if(free_ent<maxmaxcode){codetab[i]=free_ent++;htab[i]=fcode;}
		  else {cl_hash((long)hsize,htab);free_ent=ClearCode+2;clear_flg=1;
				output(ClearCode,&cur_accum,accum,&cur_bits,EOFCode,free_ent,maxmaxcode,maxbits,g_init_bits,&clear_flg,&maxcode,&n_bits);
			   }
	 }
			}}
	output(ent,&cur_accum,accum,&cur_bits,EOFCode,free_ent,maxmaxcode,maxbits,g_init_bits,&clear_flg,&maxcode,&n_bits);
	output(EOFCode,&cur_accum,accum,&cur_bits,EOFCode,free_ent,maxmaxcode,maxbits,g_init_bits,&clear_flg,&maxcode,&n_bits);
	delete pBit;GIFfile.put(0);GIFfile.put(';');GIFfile.close();GIFcount++;
//
//   }
//__finally {
Screen->Cursor=Save_Cursor;
//}
//
	return 1;
   }
   catch (EOutOfMemory &e){if(htab)delete [] htab;if(codetab)delete [] codetab;return 0;}
  }
 else return 0;
}
//---------------------------------------------------------------------------
void TForm1::cl_hash(long hsize,long htab[])          // reset code table
{register long *htab_p = htab+hsize;register long i=0;register long m1 = -1;i = hsize - 16;
 do {*(htab_p-16) = m1; *(htab_p-15) = m1; *(htab_p-14) = m1; *(htab_p-13) = m1;
     *(htab_p-12) = m1; *(htab_p-11) = m1; *(htab_p-10) = m1; *(htab_p- 9) = m1;
     *(htab_p- 8) = m1; *(htab_p- 7) = m1; *(htab_p- 6) = m1; *(htab_p- 5) = m1;
	 *(htab_p- 4) = m1; *(htab_p- 3) = m1; *(htab_p- 2) = m1; *(htab_p- 1) = m1;htab_p -= 16;
    } while ((i -= 16) >= 0);
 for(i += 16;i>0;i--) *--htab_p=m1;
}
//---------------------------------------------------------------------------
void TForm1::xvbzero(char* s,int len){for(;len>0;len--)*s++ =0;}
//---------------------------------------------------------------------------
void TForm1::output(int code,unsigned long *cur_accum,char accum[],int *cur_bits,
  int EOFCode,int free_ent,int maxmaxcode,int maxbits,int g_init_bits,int *clear_flg,int *maxcode,int *n_bits)
{unsigned long masks[]= { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F,
                                  0x001F, 0x003F, 0x007F, 0x00FF,
                                  0x01FF, 0x03FF, 0x07FF, 0x0FFF,
                                  0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };
 *cur_accum &= masks[*cur_bits];
 if(*cur_bits>0) *cur_accum |= ((long)code<< *cur_bits);else *cur_accum=code;
 *cur_bits= *cur_bits+ *n_bits;
 while(*cur_bits>=8){accum[a_count++]=(int)(*cur_accum & 0xff);
// *a_count= *a_count+1;accum[*a_count]=(int)(*cur_accum & 0xff);
					if(a_count>=254){GIFfile.put(a_count);GIFfile.write(accum,a_count);a_count=0;}
                    *cur_accum >>= 8; *cur_bits= *cur_bits-8;
				   }
 if(free_ent>*maxcode || *clear_flg){if(*clear_flg){*n_bits=g_init_bits; *maxcode=(1<< *n_bits)-1;*clear_flg=0;}
                                   else {*n_bits= *n_bits+1;if(*n_bits==maxbits) *maxcode=maxmaxcode;else *maxcode=(1<< *n_bits)-1;}
								  }
 if(code==EOFCode){while(*cur_bits>0){accum[a_count++]=(int)(*cur_accum & 0xff);
// *a_count= *a_count+1;accum[*a_count]=(int)(*cur_accum & 0xff);
                                     if(a_count>=254){GIFfile.put(a_count);GIFfile.write(accum,a_count);a_count=0;}
                                     *cur_accum>>=8; *cur_bits= *cur_bits-8;
                                    }
				   if(a_count>0){GIFfile.put(a_count);GIFfile.write(accum,a_count);a_count=0;}GIFfile.flush();
				  }
}
//---------------------------------------------------------------------------
void __fastcall TForm1::GIFsnapshotExecute(TObject *Sender)
{if(!WriteGIF()){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"*.gif file/dyn.memory unavailable/10000 GIFs",L"Failure",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowFEMeshExecute(TObject *Sender)
{if(base.nop1){ShowFEMesh->Checked=true;NoShowFEMesh->Checked=1-ShowFEMesh->Checked;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   FDrestore();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"47Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::NoShowFEMeshExecute(TObject *Sender)
{if(base.nop1){ShowFEMesh->Checked=false;NoShowFEMesh->Checked=1-ShowFEMesh->Checked;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   FDrestore();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"48Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::homsub(long ie,float XP,float YP,float ZP,long *KELM,float *RN1,float *RN2,float *RN3,long node,long eltype,long nop1[],float c1[],float TOL)
// TBD: n20/15/10 elements  (It may be necessary to increase MNITER for quads)
{long is=0,it=0,MNITER=2,trash[3];
 float DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],ELENG[3],xcen=0.,ycen=0.,zcen=0.,xtip1=0.,ytip1=0.,ztip1=0.,xtip2=0.,ytip2=0.,ztip2=0.,xtip3=0.,ytip3=0.,ztip3=0.,
   xemax= -1.e20,xemin=1.e20,yemax= -1.e20,yemin=1.e20,zemax= -1.e20,zemin=1.e20,eleng1=0.,eleng2=0.,eleng3=0.,
//   xpn=0.,ypn=0.,zpn=0.,xnp=0.,ynp=0.,znp=0.,radius=0.,pnTOL=1.0001; *KELM= -1;*RN1= *RN2= *RN3=0.;
   xpn=0.,ypn=0.,zpn=0.,xnp=0.,ynp=0.,znp=0.,radius=0.,pnTOL=1.001; *KELM= -1;*RN1= *RN2= *RN3=0.;
 for(is=0;is<node;is++){xcen=xcen+c1[NDF*nop1[is]  ];ycen=ycen+c1[NDF*nop1[is]+1];zcen=zcen+c1[NDF*nop1[is]+2];
						if(xemax<c1[NDF*nop1[is]  ])xemax=c1[NDF*nop1[is]  ];if(xemin>c1[NDF*nop1[is]  ])xemin=c1[NDF*nop1[is]  ];
						if(yemax<c1[NDF*nop1[is]+1])yemax=c1[NDF*nop1[is]+1];if(yemin>c1[NDF*nop1[is]+1])yemin=c1[NDF*nop1[is]+1];
						if(zemax<c1[NDF*nop1[is]+2])zemax=c1[NDF*nop1[is]+2];if(zemin>c1[NDF*nop1[is]+2])zemin=c1[NDF*nop1[is]+2];
					   }
 xcen=xcen/float(node);ycen=ycen/float(node);zcen=zcen/float(node);


//honk<<ie+1<<" "<<XP<<" "<<xemax<<" XX1 "<<XP<<" "<<xemin<<"\n";
//if(XP<=xemax && XP>=xemin)honk<<" XXho\n";
//honk<<ie+1<<" "<<YP<<" "<<yemax<<" YY1 "<<YP<<" "<<yemin<<"\n";
//if(YP<=yemax && YP>=yemin)honk<<" YYho\n";
//honk<<ie+1<<" "<<ZP<<" "<<zemax<<" ZZ1 "<<ZP<<" "<<zemin<<"\n";
//if(ZP<=zemax && ZP>=zemin)honk<<" ZZho\n";

if(XP<=xemax && XP>=xemin && YP<=yemax && YP>=yemin && ZP<=zemax && ZP>=zemin){
 if(eltype==8)
   {
//    if(node==8){
	   xtip1=(c1[NDF*nop1[1]  ]+c1[NDF*nop1[2]  ]+c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ])/4.;
	   ytip1=(c1[NDF*nop1[1]+1]+c1[NDF*nop1[2]+1]+c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1])/4.;
	   ztip1=(c1[NDF*nop1[1]+2]+c1[NDF*nop1[2]+2]+c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2])/4.;
	   xtip2=(c1[NDF*nop1[2]  ]+c1[NDF*nop1[3]  ]+c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ])/4.;
	   ytip2=(c1[NDF*nop1[2]+1]+c1[NDF*nop1[3]+1]+c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1])/4.;
	   ztip2=(c1[NDF*nop1[2]+2]+c1[NDF*nop1[3]+2]+c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2])/4.;
	   xtip3=(c1[NDF*nop1[4]  ]+c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ])/4.;
	   ytip3=(c1[NDF*nop1[4]+1]+c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1])/4.;
	   ztip3=(c1[NDF*nop1[4]+2]+c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2])/4.;
	   eleng1=sqrt((xtip1-xcen)*(xtip1-xcen)+(ytip1-ycen)*(ytip1-ycen)+(ztip1-zcen)*(ztip1-zcen));
	   eleng2=sqrt((xtip2-xcen)*(xtip2-xcen)+(ytip2-ycen)*(ytip2-ycen)+(ztip2-zcen)*(ztip2-zcen));
	   eleng3=sqrt((xtip3-xcen)*(xtip3-xcen)+(ytip3-ycen)*(ytip3-ycen)+(ztip3-zcen)*(ztip3-zcen));
	   DJR[0]=(xtip1-xcen)/eleng1;DJR[1]=(xtip2-xcen)/eleng2;DJR[2]=(xtip3-xcen)/eleng3;
	   DJR[3]=(ytip1-ycen)/eleng1;DJR[4]=(ytip2-ycen)/eleng2;DJR[5]=(ytip3-ycen)/eleng3;
	   DJR[6]=(ztip1-zcen)/eleng1;DJR[7]=(ztip2-zcen)/eleng2;DJR[8]=(ztip3-zcen)/eleng3;invdet(3,trash,DJR);
	   xpn=(DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*(ZP-zcen))/eleng1;
	   ypn=(DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*(ZP-zcen))/eleng2;
	   zpn=(DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*(ZP-zcen))/eleng3;
	   for(it=0;it<MNITER;it++)
		 {STFISO8(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+(ZP-znp)*(ZP-znp));


//honk<<ie+1<<" "<<it+1<<" radTOL "<<radius<<" "<<TOL<<"\n";
		  if(radius<TOL){

//honk<<xpn<<" "<<pnTOL<<" WWW "<<ypn<<" "<<pnTOL<<" WWW "<<zpn<<" "<<pnTOL<<"\n";
						 if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL){*KELM=ie;*RN1=xpn;*RN2=ypn;*RN3=zpn;break;}
						}
		  else {STFISO8(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*(ZP-znp);
				ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*(ZP-znp);
				zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*(ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
//               }
//    else     // 20-n HEX
//      {
//       xtip1=(c1[NDF*nop1[1]  ]+c1[NDF*nop1[2]  ]+c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ])/4.;
//       ytip1=(c1[NDF*nop1[1]+1]+c1[NDF*nop1[2]+1]+c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1])/4.;
//       ztip1=(c1[NDF*nop1[1]+2]+c1[NDF*nop1[2]+2]+c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2])/4.;
//       xtip2=(c1[NDF*nop1[2]  ]+c1[NDF*nop1[3]  ]+c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ])/4.;
//       ytip2=(c1[NDF*nop1[2]+1]+c1[NDF*nop1[3]+1]+c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1])/4.;
//       ztip2=(c1[NDF*nop1[2]+2]+c1[NDF*nop1[3]+2]+c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2])/4.;
//       xtip3=(c1[NDF*nop1[4]  ]+c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ])/4.;
//       ytip3=(c1[NDF*nop1[4]+1]+c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1])/4.;
//       ztip3=(c1[NDF*nop1[4]+2]+c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2])/4.;
//       eleng1=sqrt((xtip1-xcen)*(xtip1-xcen)+(ytip1-ycen)*(ytip1-ycen)+(ztip1-zcen)*(ztip1-zcen));
//       eleng2=sqrt((xtip2-xcen)*(xtip2-xcen)+(ytip2-ycen)*(ytip2-ycen)+(ztip2-zcen)*(ztip2-zcen));
//       eleng3=sqrt((xtip3-xcen)*(xtip3-xcen)+(ytip3-ycen)*(ytip3-ycen)+(ztip3-zcen)*(ztip3-zcen));
//       DJR[0]=(xtip1-xcen)/eleng1;DJR[1]=(xtip2-xcen)/eleng2;DJR[2]=(xtip3-xcen)/eleng3;
//       DJR[3]=(ytip1-ycen)/eleng1;DJR[4]=(ytip2-ycen)/eleng2;DJR[5]=(ytip3-ycen)/eleng3;
//       DJR[6]=(ztip1-zcen)/eleng1;DJR[7]=(ztip2-zcen)/eleng2;DJR[8]=(ztip3-zcen)/eleng3;invdet(3,trash,DJR);
//       xpn=(DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*(ZP-zcen))/eleng1;
//       ypn=(DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*(ZP-zcen))/eleng2;
//       zpn=(DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*(ZP-zcen))/eleng3;
//       for(it=0;it<MNITER;it++)
//         {STFISO20(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
//          xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
//          radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+(ZP-znp)*(ZP-znp));
//          if(radius<TOL){if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL){*KELM=ie;*RN1=xpn;*RN2=ypn;*RN3=zpn;break;}}
//          else {STFISO20(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*(ZP-znp);
//                ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*(ZP-znp);
//                zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*(ZP-znp);
////                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
//               }
//         }
//      }
   }
 else if(eltype==7)
   {
//    if(node==6){
	   xpn=1./3.;ypn=1./3.;zpn=0.;STFISO6(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
	   xpn=DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*(ZP-zcen) +1./3.;
	   ypn=DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*(ZP-zcen) +1./3.;
	   zpn=DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*(ZP-zcen);
	   for(it=0;it<MNITER;it++)
		 {STFISO6(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+(ZP-znp)*(ZP-znp));
		  if(radius<TOL){if(xpn<=pnTOL && xpn >=1.-pnTOL && ypn<=pnTOL && ypn>=1.-pnTOL && fabs(zpn)<=pnTOL){*KELM=ie;*RN1=xpn;*RN2=ypn;*RN3=zpn;break;}}
		  else {STFISO6(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*(ZP-znp);
				ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*(ZP-znp);
				zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*(ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
//               }
//    else     // 15-n WEDGE
//      {
//       xpn=1./3.;ypn=1./3.;zpn=0.;STFISO15(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//       xpn=DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*(ZP-zcen) +1./3.;
//       ypn=DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*(ZP-zcen) +1./3.;
//       zpn=DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*(ZP-zcen);
//       for(it=0;it<MNITER;it++)
//         {STFISO15(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
//          xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
//          radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+(ZP-znp)*(ZP-znp));
//          if(radius<TOL){if(xpn<=1.001 && xpn >= -0.001 && ypn<=1.001 && ypn>= -0.001 && fabs(zpn)<=1.001){*KELM=ie;*RN1=xpn;*RN2=ypn;*RN3=zpn;break;}}
//          else {STFISO15(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*(ZP-znp);
//                ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*(ZP-znp);
//                zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*(ZP-znp);
////                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
//               }
//         }
//      }
   }
 else if(eltype==5)
   {
//    if(node==4){
	   xpn=ypn=zpn=0.25;STFISO4(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
	   xpn=DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*(ZP-zcen) +0.25;
	   ypn=DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*(ZP-zcen) +0.25;
	   zpn=DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*(ZP-zcen) +0.25;
	   for(it=0;it<MNITER;it++)
		 {STFISO4(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+(ZP-znp)*(ZP-znp));
		  if(radius<TOL){if(xpn<=pnTOL && xpn >=1.-pnTOL && ypn<=pnTOL && ypn>=1.-pnTOL && zpn<=pnTOL && zpn>=1.-pnTOL){*KELM=ie;*RN1=xpn;*RN2=ypn;*RN3=zpn;break;}}
		  else {STFISO4(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*(ZP-znp);
				ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*(ZP-znp);
				zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*(ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
//               }
//    else     // 10-n TETRA
//      {
//       xpn=ypn=zpn=0.25;STFISO10(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//       xpn=DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*(ZP-zcen) +0.25;
//       ypn=DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*(ZP-zcen) +0.25;
//       zpn=DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*(ZP-zcen) +0.25;
//       for(it=0;it<MNITER;it++)
//         {STFISO10(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
//          xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
//          radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+(ZP-znp)*(ZP-znp));
//          if(radius<TOL){if(xpn<=1.001 && xpn >= -0.001 && ypn<=1.001 && ypn>= -0.001 && zpn<=1.001 && zpn>= -0.001){*KELM=ie;*RN1=xpn;*RN2=ypn;*RN3=zpn;break;}}
//          else {STFISO10(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*(ZP-znp);
//                ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*(ZP-znp);
//                zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*(ZP-znp);
////                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
//               }
//         }
//      }
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"homsub: unsupported eltype",L"Terminate",MB_OK);exit(0);}
																				 }
}
//---------------------------------------------------------------------------
void TForm1::homsubm(long ie,long kside,float XP,float YP,float *ZP,float *RN1,float *RN2,float *RN3,
  float xcens,float ycens,float zcens,long node,long eltype,long nop1[],float c1[],float TOL)
// TBD: n20/15/10 elements  (It may be necessary to increase MNITER for quads)
// eleng1/2/3 not necessary but used for stability of invdet()
// Face-centered natural coords (xpn,ypn,zpn) used for eltype==8 (per side)
// (xcens,ycens,zcens) = centroid of side
// (xcen,ycen,zcen) = centroid of element
// TBD: Limitation--> Code returns centroid of side for wedge/tetras (i.e. no search)
{long is=0,it=0,MNITER=2,trash[3];
 float DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],ELENG[3],xtip1=0.,ytip1=0.,ztip1=0.,xtip2=0.,ytip2=0.,ztip2=0.,xtip3=0.,ytip3=0.,ztip3=0.,
   eleng1=0.,eleng2=0.,eleng3=0.,xpn=0.,ypn=0.,zpn=0.,xnp=0.,ynp=0.,znp=0.,radius=0.,pnTOL=1.001;
 if(eltype==8)
   {if(kside==0){
	   xtip1=0.5*(c1[NDF*nop1[1]  ]+c1[NDF*nop1[5]  ]);ytip1=0.5*(c1[NDF*nop1[1]+1]+c1[NDF*nop1[5]+1]);ztip1=0.5*(c1[NDF*nop1[1]+2]+c1[NDF*nop1[5]+2]);
	   xtip2=0.5*(0.25*(c1[NDF*nop1[2]  ]+c1[NDF*nop1[3]  ]+c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ])-xcens)+xcens;
	   ytip2=0.5*(0.25*(c1[NDF*nop1[2]+1]+c1[NDF*nop1[3]+1]+c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1])-ycens)+ycens;
	   ztip2=0.5*(0.25*(c1[NDF*nop1[2]+2]+c1[NDF*nop1[3]+2]+c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2])-zcens)+zcens;
	   xtip3=0.5*(c1[NDF*nop1[4]  ]+c1[NDF*nop1[5]  ]);ytip3=0.5*(c1[NDF*nop1[4]+1]+c1[NDF*nop1[5]+1]);ztip3=0.5*(c1[NDF*nop1[4]+2]+c1[NDF*nop1[5]+2]);
	   eleng1=sqrt((xtip1-xcens)*(xtip1-xcens)+(ytip1-ycens)*(ytip1-ycens)+(ztip1-zcens)*(ztip1-zcens));
	   eleng2=sqrt((xtip2-xcens)*(xtip2-xcens)+(ytip2-ycens)*(ytip2-ycens)+(ztip2-zcens)*(ztip2-zcens));
	   eleng3=sqrt((xtip3-xcens)*(xtip3-xcens)+(ytip3-ycens)*(ytip3-ycens)+(ztip3-zcens)*(ztip3-zcens));
	   DJR[0]=(xtip1-xcens)/eleng1;DJR[1]=(xtip2-xcens)/eleng2;DJR[2]=(xtip3-xcens)/eleng3;
	   DJR[3]=(ytip1-ycens)/eleng1;DJR[4]=(ytip2-ycens)/eleng2;DJR[5]=(ytip3-ycens)/eleng3;
	   DJR[6]=(ztip1-zcens)/eleng1;DJR[7]=(ztip2-zcens)/eleng2;DJR[8]=(ztip3-zcens)/eleng3;invdet(3,trash,DJR);
	   ypn=0.;if(fabs(DJR[5])>1.e-10) *ZP=(ypn*eleng2-DJR[3]*(XP-xcens)-DJR[4]*(YP-ycens))/DJR[5] +zcens;else *ZP=zcens;
	   xpn=(DJR[0]*(XP-xcens)+DJR[1]*(YP-ycens)+DJR[2]*( *ZP-zcens))/eleng1;zpn=(DJR[6]*(XP-xcens)+DJR[7]*(YP-ycens)+DJR[8]*( *ZP-zcens))/eleng3;
	   for(it=0;it<MNITER;it++)
		 {STFISO8(1,xpn,ypn-1.,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL)break;}
		  else {STFISO8(2,xpn,ypn-1.,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                if(fabs(DJR[5])>1.e-10) *ZP= *ZP+(ypn-DJR[3]*(XP-xnp)-DJR[4]*(YP-ynp))/DJR[5] +znp;else *ZP= *ZP+znp;
				if(fabs(DJR[5])>1.e-10) *ZP= *ZP+(ypn-DJR[3]*(XP-xnp)-DJR[4]*(YP-ynp))/DJR[5];
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*( *ZP-znp);zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
	   *RN1=xpn;*RN2=ypn-1.;*RN3=zpn;
				}
	else if(kside==1){
	   xtip1=0.5*(0.25*(c1[NDF*nop1[0]  ]+c1[NDF*nop1[3]  ]+c1[NDF*nop1[4]  ]+c1[NDF*nop1[7]  ])-xcens)+xcens;
	   ytip1=0.5*(0.25*(c1[NDF*nop1[0]+1]+c1[NDF*nop1[3]+1]+c1[NDF*nop1[4]+1]+c1[NDF*nop1[7]+1])-ycens)+ycens;
	   ztip1=0.5*(0.25*(c1[NDF*nop1[0]+2]+c1[NDF*nop1[3]+2]+c1[NDF*nop1[4]+2]+c1[NDF*nop1[7]+2])-zcens)+zcens;
	   xtip2=0.5*(c1[NDF*nop1[2]  ]+c1[NDF*nop1[6]  ]);ytip2=0.5*(c1[NDF*nop1[2]+1]+c1[NDF*nop1[6]+1]);ztip2=0.5*(c1[NDF*nop1[2]+2]+c1[NDF*nop1[6]+2]);
	   xtip3=0.5*(c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ]);ytip3=0.5*(c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1]);ztip3=0.5*(c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2]);
	   eleng1=sqrt((xtip1-xcens)*(xtip1-xcens)+(ytip1-ycens)*(ytip1-ycens)+(ztip1-zcens)*(ztip1-zcens));
	   eleng2=sqrt((xtip2-xcens)*(xtip2-xcens)+(ytip2-ycens)*(ytip2-ycens)+(ztip2-zcens)*(ztip2-zcens));
	   eleng3=sqrt((xtip3-xcens)*(xtip3-xcens)+(ytip3-ycens)*(ytip3-ycens)+(ztip3-zcens)*(ztip3-zcens));
	   DJR[0]= -(xtip1-xcens)/eleng1;DJR[1]=(xtip2-xcens)/eleng2;DJR[2]=(xtip3-xcens)/eleng3;
	   DJR[3]= -(ytip1-ycens)/eleng1;DJR[4]=(ytip2-ycens)/eleng2;DJR[5]=(ytip3-ycens)/eleng3;
	   DJR[6]= -(ztip1-zcens)/eleng1;DJR[7]=(ztip2-zcens)/eleng2;DJR[8]=(ztip3-zcens)/eleng3;invdet(3,trash,DJR);
	   xpn=0.;if(fabs(DJR[2])>1.e-10)*ZP=(xpn*eleng1-DJR[0]*(XP-xcens)-DJR[1]*(YP-ycens))/DJR[2] +zcens;else *ZP=zcens;
	   ypn=(DJR[3]*(XP-xcens)+DJR[4]*(YP-ycens)+DJR[5]*( *ZP-zcens))/eleng2;zpn=(DJR[6]*(XP-xcens)+DJR[7]*(YP-ycens)+DJR[8]*( *ZP-zcens))/eleng3;
	   for(it=0;it<MNITER;it++)
		 {STFISO8(1,xpn+1.,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL)break;}
		  else {STFISO8(2,xpn+1.,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                if(fabs(DJR[2])>1.e-10)*ZP= *ZP+(xpn-DJR[0]*(XP-xnp)-DJR[1]*(YP-ynp))/DJR[2] +znp;else *ZP= *ZP+znp;
				if(fabs(DJR[2])>1.e-10)*ZP= *ZP+(xpn-DJR[0]*(XP-xnp)-DJR[1]*(YP-ynp))/DJR[2];
				ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*( *ZP-znp);zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
	   *RN1=xpn+1.;*RN2=ypn;*RN3=zpn;
					 }
	else if(kside==2){
	   xtip1=0.5*(c1[NDF*nop1[2]  ]+c1[NDF*nop1[6]  ]);ytip1=0.5*(c1[NDF*nop1[2]+1]+c1[NDF*nop1[6]+1]);ztip1=0.5*(c1[NDF*nop1[2]+2]+c1[NDF*nop1[6]+2]);
	   xtip2=0.5*(0.25*(c1[NDF*nop1[0]  ]+c1[NDF*nop1[1]  ]+c1[NDF*nop1[4]  ]+c1[NDF*nop1[5]  ])-xcens)+xcens;
	   ytip2=0.5*(0.25*(c1[NDF*nop1[0]+1]+c1[NDF*nop1[1]+1]+c1[NDF*nop1[4]+1]+c1[NDF*nop1[5]+1])-ycens)+ycens;
	   ztip2=0.5*(0.25*(c1[NDF*nop1[0]+2]+c1[NDF*nop1[1]+2]+c1[NDF*nop1[4]+2]+c1[NDF*nop1[5]+2])-zcens)+zcens;
	   xtip3=0.5*(c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ]);ytip3=0.5*(c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1]);ztip3=0.5*(c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2]);
	   eleng1=sqrt((xtip1-xcens)*(xtip1-xcens)+(ytip1-ycens)*(ytip1-ycens)+(ztip1-zcens)*(ztip1-zcens));
	   eleng2=sqrt((xtip2-xcens)*(xtip2-xcens)+(ytip2-ycens)*(ytip2-ycens)+(ztip2-zcens)*(ztip2-zcens));
	   eleng3=sqrt((xtip3-xcens)*(xtip3-xcens)+(ytip3-ycens)*(ytip3-ycens)+(ztip3-zcens)*(ztip3-zcens));
	   DJR[0]=(xtip1-xcens)/eleng1;DJR[1]= -(xtip2-xcens)/eleng2;DJR[2]=(xtip3-xcens)/eleng3;
	   DJR[3]=(ytip1-ycens)/eleng1;DJR[4]= -(ytip2-ycens)/eleng2;DJR[5]=(ytip3-ycens)/eleng3;
	   DJR[6]=(ztip1-zcens)/eleng1;DJR[7]= -(ztip2-zcens)/eleng2;DJR[8]=(ztip3-zcens)/eleng3;invdet(3,trash,DJR);
	   ypn=0.;if(fabs(DJR[5])>1.e-10) *ZP=(ypn*eleng2-DJR[3]*(XP-xcens)-DJR[4]*(YP-ycens))/DJR[5] +zcens;else *ZP=zcens;
	   xpn=(DJR[0]*(XP-xcens)+DJR[1]*(YP-ycens)+DJR[2]*( *ZP-zcens))/eleng1;zpn=(DJR[6]*(XP-xcens)+DJR[7]*(YP-ycens)+DJR[8]*( *ZP-zcens))/eleng3;
	   for(it=0;it<MNITER;it++)
		 {STFISO8(1,xpn,ypn+1.,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL)break;}
		  else {STFISO8(2,xpn,ypn+1.,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                if(fabs(DJR[5])>1.e-10) *ZP= *ZP+(ypn-DJR[3]*(XP-xnp)-DJR[4]*(YP-ynp))/DJR[5] +znp;else *ZP= *ZP+znp;
				if(fabs(DJR[5])>1.e-10) *ZP= *ZP+(ypn-DJR[3]*(XP-xnp)-DJR[4]*(YP-ynp))/DJR[5];
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*( *ZP-znp);zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
	   *RN1=xpn;*RN2=ypn+1.;*RN3=zpn;
				}
	else if(kside==3){
	   xtip1=0.5*(0.25*(c1[NDF*nop1[1]  ]+c1[NDF*nop1[2]  ]+c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ])-xcens)+xcens;
	   ytip1=0.5*(0.25*(c1[NDF*nop1[1]+1]+c1[NDF*nop1[2]+1]+c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1])-ycens)+ycens;
	   ztip1=0.5*(0.25*(c1[NDF*nop1[1]+2]+c1[NDF*nop1[2]+2]+c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2])-zcens)+zcens;
	   xtip2=0.5*(c1[NDF*nop1[3]  ]+c1[NDF*nop1[7]  ]);ytip2=0.5*(c1[NDF*nop1[3]+1]+c1[NDF*nop1[7]+1]);ztip2=0.5*(c1[NDF*nop1[3]+2]+c1[NDF*nop1[7]+2]);
	   xtip3=0.5*(c1[NDF*nop1[4]  ]+c1[NDF*nop1[7]  ]);ytip3=0.5*(c1[NDF*nop1[4]+1]+c1[NDF*nop1[7]+1]);ztip3=0.5*(c1[NDF*nop1[4]+2]+c1[NDF*nop1[7]+2]);
	   eleng1=sqrt((xtip1-xcens)*(xtip1-xcens)+(ytip1-ycens)*(ytip1-ycens)+(ztip1-zcens)*(ztip1-zcens));
	   eleng2=sqrt((xtip2-xcens)*(xtip2-xcens)+(ytip2-ycens)*(ytip2-ycens)+(ztip2-zcens)*(ztip2-zcens));
	   eleng3=sqrt((xtip3-xcens)*(xtip3-xcens)+(ytip3-ycens)*(ytip3-ycens)+(ztip3-zcens)*(ztip3-zcens));
	   DJR[0]=(xtip1-xcens)/eleng1;DJR[1]=(xtip2-xcens)/eleng2;DJR[2]=(xtip3-xcens)/eleng3;
	   DJR[3]=(ytip1-ycens)/eleng1;DJR[4]=(ytip2-ycens)/eleng2;DJR[5]=(ytip3-ycens)/eleng3;
	   DJR[6]=(ztip1-zcens)/eleng1;DJR[7]=(ztip2-zcens)/eleng2;DJR[8]=(ztip3-zcens)/eleng3;invdet(3,trash,DJR);
	   xpn=0.;if(fabs(DJR[2])>1.e-10)*ZP=(xpn*eleng1-DJR[0]*(XP-xcens)-DJR[1]*(YP-ycens))/DJR[2] +zcens;else *ZP=zcens;
	   ypn=(DJR[3]*(XP-xcens)+DJR[4]*(YP-ycens)+DJR[5]*( *ZP-zcens))/eleng2;zpn=(DJR[6]*(XP-xcens)+DJR[7]*(YP-ycens)+DJR[8]*( *ZP-zcens))/eleng3;
	   for(it=0;it<MNITER;it++)
		 {STFISO8(1,xpn-1.,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL)break;}
		  else {STFISO8(2,xpn-1.,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                if(fabs(DJR[2])>1.e-10)*ZP= *ZP+(xpn-DJR[0]*(XP-xnp)-DJR[1]*(YP-ynp))/DJR[2] +znp;else *ZP= *ZP+znp;
				if(fabs(DJR[2])>1.e-10)*ZP= *ZP+(xpn-DJR[0]*(XP-xnp)-DJR[1]*(YP-ynp))/DJR[2];
				ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*( *ZP-znp);zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
	   *RN1=xpn-1.;*RN2=ypn;*RN3=zpn;
					 }
	else if(kside==4){
	   xtip1=0.5*(c1[NDF*nop1[1]  ]+c1[NDF*nop1[2]  ]);ytip1=0.5*(c1[NDF*nop1[1]+1]+c1[NDF*nop1[2]+1]);ztip1=0.5*(c1[NDF*nop1[1]+2]+c1[NDF*nop1[2]+2]);
	   xtip2=0.5*(c1[NDF*nop1[2]  ]+c1[NDF*nop1[3]  ]);ytip2=0.5*(c1[NDF*nop1[2]+1]+c1[NDF*nop1[3]+1]);ztip2=0.5*(c1[NDF*nop1[2]+2]+c1[NDF*nop1[3]+2]);
	   xtip3=0.5*(0.25*(c1[NDF*nop1[4]  ]+c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ])-xcens)+xcens;
	   ytip3=0.5*(0.25*(c1[NDF*nop1[4]+1]+c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1])-ycens)+ycens;
	   ztip3=0.5*(0.25*(c1[NDF*nop1[4]+2]+c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2])-zcens)+zcens;
	   eleng1=sqrt((xtip1-xcens)*(xtip1-xcens)+(ytip1-ycens)*(ytip1-ycens)+(ztip1-zcens)*(ztip1-zcens));
	   eleng2=sqrt((xtip2-xcens)*(xtip2-xcens)+(ytip2-ycens)*(ytip2-ycens)+(ztip2-zcens)*(ztip2-zcens));
	   eleng3=sqrt((xtip3-xcens)*(xtip3-xcens)+(ytip3-ycens)*(ytip3-ycens)+(ztip3-zcens)*(ztip3-zcens));
	   DJR[0]=(xtip1-xcens)/eleng1;DJR[1]=(xtip2-xcens)/eleng2;DJR[2]=(xtip3-xcens)/eleng3;
	   DJR[3]=(ytip1-ycens)/eleng1;DJR[4]=(ytip2-ycens)/eleng2;DJR[5]=(ytip3-ycens)/eleng3;
	   DJR[6]=(ztip1-zcens)/eleng1;DJR[7]=(ztip2-zcens)/eleng2;DJR[8]=(ztip3-zcens)/eleng3;invdet(3,trash,DJR);
	   zpn=0.;if(fabs(DJR[8])>1.e-10)*ZP=(zpn*eleng3-DJR[6]*(XP-xcens)-DJR[7]*(YP-ycens))/DJR[8] +zcens;else *ZP=zcens;
	   xpn=(DJR[0]*(XP-xcens)+DJR[1]*(YP-ycens)+DJR[2]*( *ZP-zcens))/eleng1;ypn=(DJR[3]*(XP-xcens)+DJR[4]*(YP-ycens)+DJR[5]*( *ZP-zcens))/eleng2;
	   for(it=0;it<MNITER;it++)
		 {STFISO8(1,xpn,ypn,zpn-1.,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL)break;}
		  else {STFISO8(2,xpn,ypn,zpn-1.,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                if(fabs(DJR[8])>1.e-10)*ZP= *ZP+(zpn-DJR[6]*(XP-xnp)-DJR[7]*(YP-ynp))/DJR[8] +znp;else *ZP= *ZP+znp;
				if(fabs(DJR[8])>1.e-10)*ZP= *ZP+(zpn-DJR[6]*(XP-xnp)-DJR[7]*(YP-ynp))/DJR[8];
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*( *ZP-znp);ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
	   *RN1=xpn;*RN2=ypn;*RN3=zpn-1.;
					 }
	else {
	   xtip1=0.5*(c1[NDF*nop1[5]  ]+c1[NDF*nop1[6]  ]);ytip1=0.5*(c1[NDF*nop1[5]+1]+c1[NDF*nop1[6]+1]);ztip1=0.5*(c1[NDF*nop1[5]+2]+c1[NDF*nop1[6]+2]);
	   xtip2=0.5*(c1[NDF*nop1[6]  ]+c1[NDF*nop1[7]  ]);ytip2=0.5*(c1[NDF*nop1[6]+1]+c1[NDF*nop1[7]+1]);ztip2=0.5*(c1[NDF*nop1[6]+2]+c1[NDF*nop1[7]+2]);
	   xtip3=0.5*(0.25*(c1[NDF*nop1[0]  ]+c1[NDF*nop1[1]  ]+c1[NDF*nop1[2]  ]+c1[NDF*nop1[3]  ])-xcens)+xcens;
	   ytip3=0.5*(0.25*(c1[NDF*nop1[0]+1]+c1[NDF*nop1[1]+1]+c1[NDF*nop1[2]+1]+c1[NDF*nop1[3]+1])-ycens)+ycens;
	   ztip3=0.5*(0.25*(c1[NDF*nop1[0]+2]+c1[NDF*nop1[1]+2]+c1[NDF*nop1[2]+2]+c1[NDF*nop1[3]+2])-zcens)+zcens;
	   eleng1=sqrt((xtip1-xcens)*(xtip1-xcens)+(ytip1-ycens)*(ytip1-ycens)+(ztip1-zcens)*(ztip1-zcens));
	   eleng2=sqrt((xtip2-xcens)*(xtip2-xcens)+(ytip2-ycens)*(ytip2-ycens)+(ztip2-zcens)*(ztip2-zcens));
	   eleng3=sqrt((xtip3-xcens)*(xtip3-xcens)+(ytip3-ycens)*(ytip3-ycens)+(ztip3-zcens)*(ztip3-zcens));
	   DJR[0]=(xtip1-xcens)/eleng1;DJR[1]=(xtip2-xcens)/eleng2;DJR[2]= -(xtip3-xcens)/eleng3;
	   DJR[3]=(ytip1-ycens)/eleng1;DJR[4]=(ytip2-ycens)/eleng2;DJR[5]= -(ytip3-ycens)/eleng3;
	   DJR[6]=(ztip1-zcens)/eleng1;DJR[7]=(ztip2-zcens)/eleng2;DJR[8]= -(ztip3-zcens)/eleng3;invdet(3,trash,DJR);
	   zpn=0.;if(fabs(DJR[8])>1.e-10) *ZP=(zpn*eleng3-DJR[6]*(XP-xcens)-DJR[7]*(YP-ycens))/DJR[8] +zcens;else *ZP=zcens;
	   xpn=(DJR[0]*(XP-xcens)+DJR[1]*(YP-ycens)+DJR[2]*( *ZP-zcens))/eleng1;ypn=(DJR[3]*(XP-xcens)+DJR[4]*(YP-ycens)+DJR[5]*( *ZP-zcens))/eleng2;
	   for(it=0;it<MNITER;it++)
		 {STFISO8(1,xpn,ypn,zpn+1.,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(fabs(xpn)<=pnTOL && fabs(ypn)<=pnTOL && fabs(zpn)<=pnTOL)break;}
		  else {STFISO8(2,xpn,ypn,zpn+1.,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
//                if(fabs(DJR[8])>1.e-10)*ZP= *ZP+(zpn-DJR[6]*(XP-xnp)-DJR[7]*(YP-ynp))/DJR[8] +znp;else *ZP= *ZP+znp;
				if(fabs(DJR[8])>1.e-10)*ZP= *ZP+(zpn-DJR[6]*(XP-xnp)-DJR[7]*(YP-ynp))/DJR[8];
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*( *ZP-znp);ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
	   *RN1=xpn;*RN2=ypn;*RN3=zpn+1.;
		 }
   }
 else if(eltype==7)
   {
/*     xpn=1./3.;ypn=1./3.;zpn=0.;STFISO6(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
	   xpn=DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*( *ZP-zcen) +1./3.;
	   ypn=DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*( *ZP-zcen) +1./3.;
	   zpn=DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*( *ZP-zcen);
	   for(it=0;it<MNITER;it++)
		 {STFISO6(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(xpn<=pnTOL && xpn >=1.-pnTOL && ypn<=pnTOL && ypn>=1.-pnTOL && fabs(zpn)<=pnTOL)break;}
		  else {STFISO6(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*( *ZP-znp);
				ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*( *ZP-znp);
				zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }  */
	if(kside==0){xpn=ypn=0.5;zpn=0.;}else if(kside==1){xpn=0.;ypn=0.5;zpn=0.;}else if(kside==2){xpn=0.5;ypn=0.;zpn=0.;}else if(kside==3){xpn=ypn=1./3.;zpn= -1.;}else {xpn=ypn=1./3.;zpn=1.;}
	STFISO6(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1); *ZP=0.;for(is=0;is<node;is++) *ZP= *ZP+SN[is]*c1[NDF*nop1[is]+2];
	*RN1= xpn;*RN2= ypn;*RN3= zpn;
   }
 else if(eltype==5)
   {
/*     xcen=ycen=zcen=0.;for(is=0;is<node;is++){xcen=xcen+c1[NDF*nop1[is]  ];ycen=ycen+c1[NDF*nop1[is]+1];zcen=zcen+c1[NDF*nop1[is]+2];}
	   xpn=ypn=zpn=0.25;STFISO4(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
	   xpn=DJR[0]*(XP-xcen)+DJR[1]*(YP-ycen)+DJR[2]*( *ZP-zcen) +0.25;
	   ypn=DJR[3]*(XP-xcen)+DJR[4]*(YP-ycen)+DJR[5]*( *ZP-zcen) +0.25;
	   zpn=DJR[6]*(XP-xcen)+DJR[7]*(YP-ycen)+DJR[8]*( *ZP-zcen) +0.25;
	   for(it=0;it<MNITER;it++)
		 {STFISO4(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);
		  xnp=ynp=znp=0.;for(is=0;is<node;is++){xnp=xnp+SN[is]*c1[NDF*nop1[is]  ];ynp=ynp+SN[is]*c1[NDF*nop1[is]+1];znp=znp+SN[is]*c1[NDF*nop1[is]+2];}
		  radius=sqrt((XP-xnp)*(XP-xnp)+(YP-ynp)*(YP-ynp)+( *ZP-znp)*( *ZP-znp));
		  if(radius<TOL){if(xpn<=pnTOL && xpn >=1.-pnTOL && ypn<=pnTOL && ypn>=1.-pnTOL && zpn<=pnTOL && zpn>=1.-pnTOL)break;}
		  else {STFISO4(2,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1,c1);invdet(3,trash,DJR);
				xpn=xpn+DJR[0]*(XP-xnp)+DJR[1]*(YP-ynp)+DJR[2]*( *ZP-znp);
				ypn=ypn+DJR[3]*(XP-xnp)+DJR[4]*(YP-ynp)+DJR[5]*( *ZP-znp);
				zpn=zpn+DJR[6]*(XP-xnp)+DJR[7]*(YP-ynp)+DJR[8]*( *ZP-znp);
//                if(it==MNITER-1)honk<<ie<<" homsub: No elem-search convergence "<<XP<<" "<<YP<<" "<<ZP<<"\n";
			   }
		 }
	   *RN1=xpn;*RN2=ypn;*RN3=zpn;  */
	if(kside==0){xpn=ypn=zpn=1./3.;}else if(kside==1){xpn=0.;ypn=zpn=1./3.;}else if(kside==2){ypn=0.;xpn=zpn=1./3.;}else {xpn=ypn=1./3.;zpn=0.;}
	STFISO4(1,xpn,ypn,zpn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1); *ZP=0.;for(is=0;is<node;is++) *ZP= *ZP+SN[is]*c1[NDF*nop1[is]+2];
	*RN1= xpn;*RN2= ypn;*RN3= zpn;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"homsub: unsupported eltype",L"Terminate",MB_OK);exit(0);}
/////////////////////////////////
}

//---------------------------------------------------------------------------
void __fastcall TForm1::ResultVolAverageExecute(TObject *Sender)
{long totnel=0,tGID=0,tnelGID=0,iGID=0,ic=0;float totvol=0.,tvol=0.,*pload=NULL;
 if(base.nop1)
   {if(fl_feres)
	  {tGID=totnel=0;totvol=0.;pload=new float[2*nColRes];  // No memory test
	   for(ic=0;ic<nColRes;ic++)pload[nColRes+ic]=0.;
	   for(iGID=0;iGID<MAX_GID-1;iGID++)
		 {tnelGID=0;tvol=0.;for(ic=0;ic<nColRes;ic++)pload[ic]=0.;
		  formAVGtem7(iGID,base.nelt,base.nop1,base.matno,base.c1,pload,nColRes,base.res1,&tnelGID,&tvol);
		  totnel=totnel+tnelGID;totvol=totvol+tvol;for(ic=0;ic<nColRes;ic++)pload[nColRes+ic]=pload[nColRes+ic]+pload[ic];
		  if(tnelGID){honk<<"\n";
					  if(tvol>1.e-10){tGID++;honk<<iGID+1<<" GID & #elem & volume "<<tnelGID<<" "<<tvol<<"\n";
									  for(ic=0;ic<nColRes;ic++)honk<<ic+1<<" Result column & GID average "<<pload[ic]/tvol<<"\n";
									 }
					  else honk<<iGID+1<<" GID with degenerate volume\n";
					 }
		  if(totnel==base.nelt)break;
		 }
	   honk<<"\n";honk<<tGID<<" "<<totnel<<" Total nondegenerate GID/el/total vol "<<totvol<<"\n";
	   for(ic=0;ic<nColRes;ic++)honk<<ic+1<<" Result column & Global average "<<pload[nColRes+ic]/totvol<<"\n";
	   delete [] pload;
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Get results file->Post/Analysis",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"50Get geometry file->File/Open",L"Halt",MB_OK);}
}
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
/*
//-----StartTrash---------------------------------------------
  //** Method to import FE Mesh (Solid) from the filename chosen by user
  protected FEMesh importFEMesh(File fname) {
	nwWeldMatSet nwwms;
	isShell=false;
	fem = new FEMesh();
	Node node = null;
	Element8 ele8 = null;

	int id;
	float[] xyz = new float[3];
	int[] corners = new int[8];

	int numOfNodes = 0;
	int numOfEle8s = 0;
	int index =0;
	int vindex=0;
//
// 08/17/2004
// Group generate code
//
	int ngen=0;
//
// set groupsname
//

	try {
	  RandomAccessFile f=new RandomAccessFile(fname, "r");
	  String s = null;
	  StringTokenizer st = null;
	  StringTokenizer stg = null;

	  System.out.println("Reading and parsing Solid FE mesh information ...");
	  if((s = f.readLine()).startsWith("**")) {
		while(!(s = f.readLine()).startsWith("**")) {
				   //* Read and parse node coordinates
		  st = new StringTokenizer(s, ",");
		  id = Integer.parseInt(st.nextToken().trim());
		  for(int j=0; j<3; j++)
			xyz[j] = Float.parseFloat(st.nextToken());
		  node = new Node(id, xyz);
		  fem.nodes.add(node);
		  fem.nodeIndex.put(new Integer(id), new Integer(index));
		  numOfNodes ++;
		  index ++;
		}

		index = 0;
		while(!(s = f.readLine()).startsWith("**")) {
		  //* Read and parse element connetivity
		  st = new StringTokenizer(s, ",");
		  if (st.countTokens()!= 9)
		  {
		  JOptionPane.showMessageDialog(this,"Elements are not SOLID elements","Imported File Error",JOptionPane.ERROR_MESSAGE);
		  return null;
		  }
		  id = Integer.parseInt(st.nextToken().trim());
		  for(int j=0; j<8; j++)
			corners[j] = Integer.parseInt(st.nextToken().trim());
		  ele8 = new Element8(id, corners);
		  fem.ele8s.add(ele8);
		  fem.ele8Index.put(new Integer(id), new Integer(index));
		  numOfEle8s ++;

		  index ++;
		}

	   for (int k=1; k<500;k++)
{
//
// 08/17/2004
// Group generate code
//
	   ngen=0;
	   index=0;
	   fem.groupsallindex.add(String.valueOf(vindex));
//
// 08/17/2004
// Group generate code
//
	   ngen=s.indexOf("GENERATE");
	   if (ngen == -1){ngen=s.indexOf("generate");}
	   if (ngen == -1)
	   {
	   String s2;
	   s2=s.substring(2);
	   s2=s2.trim();
		fem.numberg++;
		 fem.groupsname[k-1]=s2;
		 fem.groupsallname.add(s2);
	   }
	   if (ngen != -1)
	   {
	  ngen=s.indexOf(",");
	  String s2;
	  s2=s.substring(2,ngen);
	   s2=s2.trim();
		fem.numberg++;
		 fem.groupsname[k-1]=s2;
		 fem.groupsallname.add(s2);
	   }
		 while(!(s = f.readLine()).startsWith("**"))
		 {
		  //* Read and parse a group of elements
		  st = new StringTokenizer(s, " ,");
//
// no GENERATE
//
		  if (ngen == -1)
		  {
		  while(st.hasMoreTokens())
		   {
			String ss = st.nextToken();
			fem.groupsall.add(ss);
			fem.groupA.add(Integer.valueOf(ss));
			fem.groups[k-1][index]=Integer.parseInt(ss);
			wEleIndexA.put((Integer)fem.groupA.get(vindex), new Integer(vindex));
			index ++;
			vindex ++;
			fem.groupscount[k-1]=index;
			}
		 }
//
// GENERATE
//
		  if (ngen != -1)
		  {
			String estart = st.nextToken();
			int es = Integer.parseInt(estart);
			String eend = st.nextToken();
			int ee = Integer.parseInt(eend);
			ee=ee+1;
			String einc = st.nextToken();
			int ei = Integer.parseInt(einc);
			for (int jj=es; jj<ee;jj=jj+ei)
			{
			String ss = String.valueOf(jj);
			fem.groupsall.add(ss);
			fem.groupA.add(Integer.valueOf(ss));
			fem.groups[k-1][index]=Integer.parseInt(ss);
 //           wEleIndex.put((Integer)fem.group.get(index), new Integer(index));
			 wEleIndexA.put((Integer)fem.groupA.get(vindex), new Integer(vindex));
			 index ++;
			 vindex ++;
			 fem.groupscount[k-1]=index;
			}
		 }
// while
		 }
	  }
	  }
// if
else {
		System.out.println("Data Format Error at the first line: **");
		System.exit(0);
	  }
//try
} catch (Exception e) {
  }

	  fem.numberg--;

	  for(int j=0; j<fem.groupscount[0]; j++){
	  String s2;
//      s2=Integer.toString(fem.groups[0][j]);
	  s2=(String)fem.groupsall.get(j);
	  fem.group.add(Integer.valueOf(s2));

	 }
	   fem.groupname=fem.groupsname[0];


	return fem;
  }
//-----EndTrash---------------------------------------------
*/
/*
//---------------------------------------------------------------------------
void __fastcall TForm1::MSHgeomVEDopenExecute(TObject *Sender)
// Warning: possible discontinuous node/element numbers in input *.msh
// Observation: It is not necessary to have weld groups, since the user can place weld passes in the base mesh???
// Data card input length=200 below
{int nic=0,nrc=0,filetypesw=0;
// long ip=0,in=0,n8=0,dummy=0,i=0,larr[11],
//	  ipid=0,nodeuplim=0,eluplim=0,filetimepoints=0,activepts=0,
//	  eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,ltrash=0;
 long ip=0,in=0,n8=0,dummy=0,i=0,larr[11],
	  ipid=0,nodeuplim=0,eluplim=0,filetimepoints=0,activepts=0,
	  t3=1000,t7=10000000;
 float timept=0.,darr[11];
 char cht[200];
// wchar_t string0[11];
char string0[11];
 base.mat=base.matsteps=base.ncoorf=1;
 base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.nblod=0;
 if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
 else {OpenDialog1->Filter= "Msh (*.msh)|*.msh;*.MSH";
	   if(OpenDialog1->Execute())
//		{ifstream ntape(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
		{ifstream ntape(OpenDialog1->FileName.c_str(),ios::nocreate|ios::binary,0);
		 if(ntape)
		  {filetypesw=wp.nWeldGroup=0;ntape.getline(cht,200-1);
		   if(!filetypesw){if(cht[0]=='*' && cht[1]=='*')filetypesw=1;
						   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not a *.msh file",L"Halt",MB_OK);
								 return;
								}
						  }
// *.msh format: Assume that the first ** data set is nodes delimited by "," (Do not use Node Coordinates to identify since it is not fixed on line.)
//               Assume that the second ** data set is elements delimited by "," (Do not use Element Connectivity to identify since it is not fixed on line.)
		   do {ntape.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr);
			   base.npoin=base.npoin+1;if(nodeuplim<larr[0])nodeuplim=larr[0];
			  }
		   while (ntape.peek()!= '*');
		   ntape.getline(cht,200-1); // Read ** Elem
		   do {ntape.getline(cht,200-1);parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht));

//honk<<nic<<" "<<larr[0]<<" "<<larr[1]<<" "<<larr[2]<<" "<<larr[3]<<" CHEKKO\n";

			   if(nic-1==4 || nic-1==6 || nic-1==8){
//if(nGIDmax<larr[2])nGIDmax=larr[2];
															if(MXNPEL<nic-1)MXNPEL=nic-1;
														   }
			   else {honk<<"Halt: Unsupported element with #nodes "<<nic-1<<"\n";
//					 for(in=0;in<100;in++)cht[in]=' ';
//					 strcpy(cht,"Unsupported element with #nodes ");
//					 strcat(cht,IntToStr(nic-1).t_str());
//					 extern PACKAGE void __fastcall Beep(void);
//					 Application->MessageBox(cht,L"Halt",MB_OK);

				 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Oops",L"Halt: Unsupported element with #nodes",MB_OK);
				 return;
				}
			   base.nelt=base.nelt+1;if(eluplim<larr[0])eluplim=larr[0];
			  }
		   while (ntape.peek()!= '*');
// Current WSIFrame.java format (Y2005) ----> Read up to MAX_WELDGROUPS=500 weld groups
		   for(in=0;in<MAX_WELDGROUPS+1;in++)
			 {ntape.getline(cht,200-1);
//              if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && cht[4]=='n' && cht[5]=='d')break;
			  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && (cht[4]=='n'||cht[4]=='N') && (cht[5]=='d'||cht[5]=='D'))break;
			  else {if(in<MAX_WELDGROUPS){wp.nWeldGroup=wp.nWeldGroup+1;
										  do ntape.getline(cht,200-1);
										  while (ntape.peek()!= '*');
										 }
					else {honk<<"#weld groups exceeds allowable "<<MAX_WELDGROUPS<<"\n";
//						  for(in=0;in<100;in++)cht[in]=' ';
//						  strcpy(cht,"#weld groups exceeds allowable ");
//						  strcat(cht,IntToStr(MAX_WELDGROUPS).t_str());
//						  extern PACKAGE void __fastcall Beep(void);
//						  Application->MessageBox(cht,L"Halt",MB_OK);

						  extern PACKAGE void __fastcall Beep(void);
						  Application->MessageBox(L"Oops",L"Halt: #weld groups exceeds allowable",MB_OK);
						  return;
						 }
				   }
			 }
		   if(nodeuplim != base.npoin)
			 {honk<<nodeuplim<<" Nonconsecutive node numbers in *.msh "<<base.npoin<<"\n";
//			  for(in=0;in<100;in++)cht[in]=' ';
//			  strcpy(cht,IntToStr(nodeuplim).t_str());
//			  strcat(cht," There are nonconsecutive node numbers in *.msh ");
//			  strcat(cht,IntToStr(base.npoin).t_str());
//			  extern PACKAGE void __fastcall Beep(void);
//			  Application->MessageBox(cht,"Warning",MB_OK);

			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive node numbers in *.msh ",L"Warning",MB_OK);
			 }
		   if(eluplim != base.nelt)
			 {honk<<eluplim<<" Nonconsecutive element numbers in *.msh "<<base.nelt<<"\n";
//			  for(in=0;in<100;in++)cht[in]=' ';
//			  strcpy(cht,IntToStr(eluplim).t_str());
//			  strcat(cht,"There are nonconsecutive element numbers in *.msh ");
//			  strcat(cht,IntToStr(base.nelt).t_str());
//			  extern PACKAGE void __fastcall Beep(void);
//			  Application->MessageBox(cht,"Warning",MB_OK);

			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive element numbers in *.msh ",L"Warning",MB_OK);
			 }
		   if(wp.nWeldGroup==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups found in datafile",L"Terminate",MB_OK);exit(0);}
		   base.npoin=nodeuplim;base.nelt=eluplim;ntape.close();GeomFileName=OpenDialog1->FileName;
		   if(base.nelt> LONG_INT/t3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Excessive #elements in geometry file",L"Terminate",MB_OK);exit(0);}
/////////////// Precaution, until I can fix it   EFP 1/28/2010
//		   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"End of *.msh file must have  ** End  , NOT **End ",L"Advisory",MB_OK);
//////////////////////////////////////////////////////////////
//
//honk<<base.npoin<<" "<<base.nelt<<" proTemp E/n\n";

		   if(base.npoin>0 && base.nelt>0)
			{FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
			 for(in=0;in<NDF*base.npoin;in++)base.c1[in]=0.;
			 ifstream ntape1(OpenDialog1->FileName.c_str(),ios::nocreate|ios::binary,0);
			 if(ntape1)
			  {for(in=0;in<base.nelt;in++)base.el_map[in]= -1;
			   ntape1.getline(cht,200-1);
			   do {ntape1.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr);
				   in=larr[0]-1;base.c1[NDF*in]=darr[0];base.c1[NDF*in+1]=darr[1];base.c1[NDF*in+2]=darr[2];
				  }
			   while (ntape1.peek()!= '*');
			   ntape1.getline(cht,200-1);ipid=1;n8=8;
//               for(in=0;in<base.nelt;in++)base.matno[in]= -1;
			   do {ntape1.getline(cht,200-1);parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht));
				   n8=nic-1;in=larr[0]-1;for(i=0;i<n8;i++)base.nop1[MXNPEL*in+i]=larr[i+1]-1;
				   base.matno[in]=8*t7+n8*t3+ipid-1;base.el_map[in]=in;

//honk<<in+1<<" "<<base.matno[in]<<" PRIMO\n";
				  }
			   while (ntape1.peek()!= '*');
			   for(in=0;in<wp.nWeldGroup;in++)
				 {ntape1.getline(cht,200-1);
////                  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && cht[4]=='n' && cht[5]=='d')break;
				  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && (cht[4]=='n'||cht[4]=='N') && (cht[5]=='d'||cht[5]=='D'))break;
//				  if(cht[0]=='*' && cht[1]=='*' &&
////					 ((cht[2]==' ' && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='N' || cht[4]=='n') && (cht[5]=='D' || cht[5]=='d')) ||
////					  ((cht[2]=='E' || cht[2]=='e') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='D' || cht[4]=='d')))
//////					 (cht[2]==' ' || cht[2]=='E' || cht[2]=='e') &&
//////					 (cht[3]=='E' || cht[3]=='e' || cht[3]=='n' || cht[3]=='N') && (cht[5]=='d'||cht[5]=='D')

////					  (cht[2]=='E' || cht[2]=='e') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='D' || cht[4]=='d')
//					  cht[2]=='E' && cht[3]=='n' && cht[4]=='d'

//					)break;
//				  else {do {ntape1.getline(cht,200-1);parse_cdmQ(cht,11,&nic,&nrc,larr,darr,strlen(cht));
				  else {do {ntape1.getline(cht,200-1);parse_cdmQ(cht,16,&nic,&nrc,larr,darr,strlen(cht));
							for(i=0;i<nic;i++){
//ltrash=base.matno[larr[i]-1];
							base.matno[larr[i]-1]=base.matno[larr[i]-1]+in+1; // FIX THIS. Presumes base ipid=1
//honk<<in+1<<" "<<nic<<" "<<larr[i]<<" MSHckMATNO "<<ltrash<<" "<<base.matno[larr[i]-1]<<"\n";
											  }
						   }
						while (ntape1.peek()!= '*');
					   }
				 }


//for(i=0;i<base.nelt;i++){
//honk<<i+1<<" "<<base.matno[i]<<" SECUNDO\n";
//eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
//node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
////ip=ieGID;
//////eltype=indat.matno[i]/t7;bscode=(indat.matno[i]-eltype*t7)/t5;
//////node=(indat.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=indat.matno[i]-eltype*t7-bscode*t5-node*t3;
////honk<<i+1<<" "<<ip<<" SEC00 test "<<eltype*t7<<" "<<bscode*t5<<" "<<node*t3<<" "<<ieGID<<"\n";
//honk<<base.matno[i]/t7<<"\n";
//						}
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++

			   OpenDialog2->Filter= "dat (*.dat)|*.Dat;*.DAT";
			   if(OpenDialog2->Execute())
				 {ifstream ntape2(OpenDialog2->FileName.c_str(),ios::nocreate|ios::binary,0);
				  if(ntape2)
					{
/////////////////////////////////////////////
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
try {
/////////////////////////////////////////////
					 filetimepoints=0;
					 do {ntape2.getline(cht,200-1);parse_cdm(cht,2,&nic,&nrc,larr,darr);
						 timept=darr[0];activepts=larr[0];
honk<<timept<<" "<<activepts<<" actiev\n";
timeVEDarr[filetimepoints]=timept; //Cats ass coding
						 if(activepts){ntape2.getline(cht,200-1);parse_cdm(cht,activepts,&nic,&nrc,larr,darr);

for(ip=0;ip<activepts;ip++){//honk<<larr[ip]<<"\n";
i=larr[ip]-1;
////eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
////node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//base.matno[i]=base.matno[i]-ieGID+filetimepoints+3; // Cats ass coding
if(base.matno[i]==80008001){base.matno[i]=80008000+filetimepoints+3;
//							honk<<base.matno[i]<<" Newbozo1 "<<i+1<<"\n";
						   }
else if(base.matno[i]==80008002){base.matno[i]=80008000+filetimepoints+3;
//								 honk<<base.matno[i]<<" Newbozo2 "<<i+1<<"\n";
								}
//else honk<<base.matno[i]<<" BOZO "<<i+1<<"\n";
						   }
									   filetimepoints++;
									  }
						}
					 while (!ntape2.eof());
					 wp.VEDsteps=filetimepoints;
/////////////////////////////////////////////
	}
__finally {Screen->Cursor=Save_Cursor;}
/////////////////////////////////////////////
					 ntape2.close();

nGID=nGID+filetimepoints;
honk<<nGID<<" "<<filetimepoints<<" filetimepoints\n";
					}
				  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.dat VED file",L"Failure",MB_OK);}
				 }
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create VED FileOpen selector",L"Failure",MB_OK);}

//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
////###### Renumber elements consecutively (but NOT nodes)
//               eluplim=0;
//               for(in=0;in<base.nelt;in++){if(base.matno[in]<0);
//                                           else {base.matno[eluplim]=base.matno[in];
//                                                 for(i=0;i<8;i++)base.nop1[MXNPEL*eluplim+i]=base.nop1[MXNPEL*in+i];
//                                                 eluplim++;
//                                                }
//                                          }
//               base.nelt=eluplim;
////######
//###### Renumber elements consecutively (but NOT nodes) & establish inverse elem-mapping
			   base.noncon_nelt=base.nelt;
			   eluplim=0;
			   for(in=0;in<base.nelt;in++){if(base.el_map[in]<0);
										   else {base.matno[eluplim]=base.matno[in];base.el_map[eluplim]=base.el_map[in];
												 for(i=0;i<8;i++)base.nop1[MXNPEL*eluplim+i]=base.nop1[MXNPEL*in+i];
												 eluplim++;
												}
										  }
			   base.nelt=eluplim;
//
			   FDdynmem_manage(6,dummy,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   for(in=0;in<MAX_WELDPASSES*base.nelt;in++)wp.eles[in]= -1;
			   for(in=0;in<MAX_WELDPASSES*base.nelt;in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=0;in<MAX_WELDPASSES;in++)wp.stpEle[in]= -1;  // No need for *bnelt
			   for(in=0;in<MAX_WELDPASSES*4;in++)wp.snorm1[in]= -1;
			   for(in=0;in<MAX_WELDPASSES*4;in++)wp.snorm2[in]= -1;
//        wp.firstEle=new long[MAX_WELDPASSES*bnet],
//        wp.nextEle=new long[MAX_WELDPASSES],
//        wp.snorm1=new long[MAX_WELDPASSES*4],
//        wp.snorm2=new long[MAX_WELDPASSES*4],
//        wp.circEles=new long[MAX_WELDPASSES*3],
//        wp.edgeEles=new long[MAX_WELDPASSES*bnelt],
//        wp.edgeNodes=new long[MAX_WELDPASSES*4],
//        wp.sttEleNodes=new long[MAX_WELDPASSES*bnelt*4],
			   for(in=0;in<MAX_WELDPASSES;in++)wp.source[in]=11;
			   for(in=0;in<MAX_WELDPASSES;in++)wp.hp[in]=0;//Lump Pass (1) or Moving Arc (0) Heating Procedure
			   for(in=0;in<MAX_WELDPASSES;in++)wp.nsegs[in]=1;
			   for(in=0;in<MAX_WELDPASSES;in++)wp.iselect[in]=0;
//######
			   old_npoin=new_npoin=base.npoin;new_nelt=base.nelt;new_mat=base.mat;new_ncoorf=base.ncoorf;nGID=wp.nWeldGroup+1;
			   ntape1.close();
//                           FDbase_indat(1,shapecombo);
FDbase_indat(1,shapecombo,iplotflag,nColRes);


//honk<<MXNPEI<<" MXNPEI\n";
// long in=0,i=0,eltype=0,bscode=0,node=0,ieGID=0,tf3=1000,tf5=100000,tf7=10000000;
// for(i=0;i<base.nelt;i++){
//    eltype=base.matno[i]/tf7;bscode=(base.matno[i]-eltype*tf7)/tf5;
//    node=(base.matno[i]-eltype*tf7-bscode*tf5)/tf3;ieGID=base.matno[i]-eltype*tf7-bscode*tf5-node*tf3;
//    if(ieGID!=0)honk<<i+1<<" "<<ieGID<<" HERE\n";
//    honk<<i+1<<" "<<eltype<<" "<<node<<" "<<ieGID<<" MSHel\n";
//    for(in=0;in<node;in++)honk<<base.nop1[MXNPEI*i+in]<<"\n";
//                         }
// if(1==1)exit(0);



//////////////////////////////////////
//for(i=0;i<base.nelt;i++){
//eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
//node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//ip=ieGID;
//eltype=indat.matno[i]/t7;bscode=(indat.matno[i]-eltype*t7)/t5;
//node=(indat.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=indat.matno[i]-eltype*t7-bscode*t5-node*t3;
//honk<<i+1<<" "<<ip<<" SEC test "<<ieGID<<"\n";
//						}



	if(nGID<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No geometry IDs found",L"Halt",MB_OK);return;}
////    else {if(iPaintyesno/10==0){FDelemfacets2();iPaintyesno=10;iCullyesno=0;}iCircleplot=1;Invalidate();}
//	else {if(iPaintyesno/10==0){
////                                    FDcomp_nGID();
//FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
//								FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
//								iPaintyesno=10;iCullyesno=0;
//							   }
//
//		  iplotflag=1;
//
//		  iCircleplot=1;Invalidate();
//		 }
	else {
		  if(iPaintyesno/10==0){if(iPaintyesno-10*(iPaintyesno/10)){
																	FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
																	FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
									  FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
								iCullyesno=0;
							   }
		  iplotflag=1;
		  iCircleplot=1;Invalidate();
		 }
//////////////////////////////////////
//               iplotflag=1;Invalidate();
			  }
			 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}
			}
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Nodes/elements/GID missing from *.UNV datafile",L"Failure",MB_OK);}
		  }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}
		}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
	  }
}
*/
//---------------------------------------------------------------------------
void __fastcall TForm1::VFTweld_analysisExecute(TObject *Sender)
{long nCol=0,ip=0,in=0,filetimepoints=0,activepts=0,activenode=0,dum=0,totActive=0,itot=0;
 float time=0.,activetemp=0.,maxVFTtemp=0.,minVFTtemp=0.;
 if(base.nop1){//               binCAPformatOpen(&nCol,base.npoin,indat.npoin,fl_feres,&nColRes);
			   OpenDialog2->Filter= "Out (*.out)|*.out;*.OUT";
			   if(OpenDialog2->Execute())
				 {ifstream ntape(OpenDialog2->FileName.c_str(),ios::nocreate,0);
//				 {ifstream ntape(OpenDialog2->FileName.c_str(),ios::nocreate|ios::binary,0);
				  if(ntape)
					{totActive=0;maxVFTtemp= -1.e+20;minVFTtemp=1.e+20;
/////////////////////////////////////////////
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
/////////////////////////////////////////////
					 do {ntape>>time>>activepts;

honk<<time<<" timeVFTtemp "<<activepts<<"\n";

						 filetimepoints++;
						 if(activepts){for(ip=0;ip<activepts;ip++){ntape>>activenode>>activetemp;
if(maxVFTtemp<activetemp)maxVFTtemp=activetemp;
if(minVFTtemp>activetemp)minVFTtemp=activetemp;
																  totActive++;
																  }
									  }
						}
					 while (!ntape.eof());
					 wp.VFTresSteps=filetimepoints;
/////////////////////////////////////////////
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
/////////////////////////////////////////////
					 ntape.close();
honk<<filetimepoints<<" xxx_CTSP_temp.out filetimepoints & max/min/preheat "<<maxVFTtemp<<" "<<minVFTtemp<<" "<<25.<<"\n";
// Compare filetimepoints-1 to xxx_CTSP_input.in (first line) 1 nSlices
					 if(filetimepoints){ifstream ntape1(OpenDialog2->FileName.c_str(),ios::nocreate,0);
										if(ntape1)
										  {fl_feres=2;wp.tcuth[0]=25.; // Temporarily use CAPthermal fl_feres=2
										   ResFileName=OpenDialog2->FileName;
										   if(nColRes)FDdynmem_manage(-3,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
										   nCol=nColRes=1;
										   FDdynmem_manage(3,base.npoin,dum,base.npoin,dum,nColRes,dum,dum,dum,dum,dum,dum,dum,dum);
if(wpRes.wIndex){delete [] wpRes.wIndex;wpRes.wIndex=NULL;}
if(wpRes.wActiven){delete [] wpRes.wActiven;wpRes.wActiven=NULL;}
if(wpRes.wActiveR){delete [] wpRes.wActiveR;wpRes.wActiveR=NULL;}
wpRes.wIndex=new long[filetimepoints+1];                          //TBD: Test memory availability
wpRes.wActiven=new long[totActive];
wpRes.wActiveR=new float[totActive];
/////////////////////////////////////////////
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
/////////////////////////////////////////////
										   itot=0;
										   for(ip=0;ip<base.npoin;ip++)base.res1[nColRes*0+ip]=wp.tcuth[0];
//                                           for(in=0;in<filetimepoints;in++)
										   for(in=0;in<filetimepoints-1;in++)
											 {ntape1>>time>>activepts;
timeVFTarr[in]=time; // Cats ass coding
//wpRes.timeVFTarr[in]=time; // Cats ass coding
											  wpRes.wIndex[in]=itot;
											  if(activepts){for(ip=0;ip<activepts;ip++){ntape1>>activenode>>activetemp;
if(base.res1[nColRes*0+activenode-1]<activetemp)base.res1[nColRes*0+activenode-1]=activetemp;
wpRes.wActiven[itot]=activenode-1;wpRes.wActiveR[itot]=activetemp;itot++;
																					   }
														   }
											 }
										   wpRes.wIndex[in]=itot;
/////////////////////////////////////////////
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
/////////////////////////////////////////////
										   ntape1.close();nMultFile=filetimepoints-1;

//for(ip=0;ip<filetimepoints-1;ip++){honk<<ip+1<<" "<<wpRes.wIndex[ip]+1<<" "<<wpRes.wIndex[ip+1]<<" IIINNNDDDEEEXXX\n";
////                                 honk<<wpRes.wActiven[wpRes.wIndex[ip]]<<" "<<wpRes.wActiveR[wpRes.wIndex[ip]]<<"\n";
////                                 honk<<wpRes.wActiven[wpRes.wIndex[ip+1]]<<" "<<wpRes.wActiveR[wpRes.wIndex[ip+1]]<<"\n";
//                                 if(wpRes.wIndex[ip]<wpRes.wIndex[ip+1])
//                                   for(in=wpRes.wIndex[ip];in<wpRes.wIndex[ip+1];in++)
//                                      honk<<wpRes.wActiven[in]+1<<" "<<wpRes.wActiveR[in]<<"\n";
//                                }
////if(1==1)exit(0);

Indig_analysis(nCol,nColRes,fl_feres,shapecombo,section_frame,isectsw,sectdval);
										  }
										else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"*.out result file suddenly unavailable",L"Failure",MB_OK);}
									   }
					 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"ResultFile is empty",L"Failure",MB_OK);}
					}
				  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.out result file",L"Failure",MB_OK);}
				 }
//			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create ResultFileOpen selector",L"Failure",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"51Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Import_VEDExecute(TObject *Sender)
{int nic=0,nrc=0;
 long i=0,ip=0,filetimepoints=0,activepts=0,larr[11],
	  eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
//for(i=0;i<MAX_GID;i++)arGID[i]=0;
// for(i=0;i<indat_nelt;i++)
//	{eltype=indat_matno[i]/t7;bscode=(indat_matno[i]-eltype*t7)/t5;node=(indat_matno[i]-eltype*t7-bscode*t5)/t3;ieGID=indat_matno[i]-eltype*t7-bscode*t5-node*t3;
 float timept=0.,darr[11];char cht[200];
 if(base.nop1){OpenDialog2->Filter= "dat (*.dat)|*.Dat;*.DAT";
			   if(OpenDialog2->Execute())
				 {ifstream ntape(OpenDialog2->FileName.c_str(),ios::nocreate|ios::binary,0);
				  if(ntape)
					{
/////////////////////////////////////////////
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
/////////////////////////////////////////////
					 filetimepoints=0;
					 do {ntape.getline(cht,200-1);parse_cdm(cht,2,&nic,&nrc,larr,darr);
						 timept=darr[0];activepts=larr[0];
honk<<timept<<" "<<activepts<<" actiev\n";
						 if(activepts){ntape.getline(cht,200-1);parse_cdm(cht,activepts,&nic,&nrc,larr,darr);

for(ip=0;ip<activepts;ip++){honk<<larr[ip]<<"\n";
i=larr[ip]-1;eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
////ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
//						else if(base.arrELSET[ base.trackELSET[i+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[i+1]-2 ];
//						else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[i]+base.GIDcol ]; //Prioritize WG
//							  else ieGID=base.arrELSET[ base.trackELSET[i+1]-1 ];                      //Prioritize WP
//							 }
ieGID=base.arrELSET[i];
////////////// but this does not use indat.xxx ?
////base.matno[i]=base.matno[i]-ieGID+filetimepoints+3; // Cats ass coding
//base.arrELSET[ base.trackELSET[i+1]-1 ]=filetimepoints+3;  //Prioritize WP
base.arrELSET[i]=filetimepoints+3;  //Prioritize WP
						   }
									   filetimepoints++;
									  }
						}
					 while (!ntape.eof());
//					 wp.VFTresSteps=filetimepoints;
					 wp.VEDsteps=filetimepoints;
/////////////////////////////////////////////
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
/////////////////////////////////////////////
					 ntape.close();

honk<<filetimepoints<<" filetimepoints\n";
					}
				  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.dat VED file",L"Failure",MB_OK);}
				 }
//			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create VED FileOpen selector",L"Failure",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"52Get geometry file->File/Open.",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::MSHgeomOpenExecute(TObject *Sender)
// Warning: possible discontinuous node/element numbers in input *.msh
// Observation: It is not necessary to have weld groups, since the user can place weld passes in the base mesh???
// Data card input length=200 below
// This version does NOT require   ** End    by means of ntape.peek()== -1 (i.e. no more characters in file)
// nodelolim,nodeuplim,eluplim begin with 1 (not 0)
// Note current convention: *.msh & Simulia/Abaqus *.inp/*.abq files contain weld groups (never weld passes), regardless of name
//     Hence wp.nWeldGroup is incremented but not wp.nWeldPass
// 8n hex elements only
{
 int nic=0,nic1=0,nrc=0,isw=0,jsw=0,iswNode=0,iswElem=0,ksw=0,kswELSET=0;
 long in=0,kn=0,klim=0,inp=0,ip=0,ii=0,ix=0,ie=0,im=0,n8=0,dummy=0,iswELSET2=0,isum=0,
i=0,j=0,k=0,kk=0,kp=0,jrec=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000,larr[10],larr1[10],
ipid=0,nodeuplim=0,nodelolim=0,totNnum=0,eluplim=0,ellolim=0,totEnum=0,sumWG=0,sumlim=0,sumELSETel=0,totBMG=0,totWG=0
, *revnode_map=NULL;
 float fval=0.,darr[10];
 char cht[200],extensChar[]=".msh",chELSET[78+1], *temp_cht=NULL, *fnNeed1=NULL,*fnNeed2=NULL;
 wchar_t string0[11];
////////////////
String *tw_groupsname=NULL;
////////////////
 if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
 else {

 base.matsteps=base.ncoorf=1;
 base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.mat=base.nblod=0;
 base.allGrp=1; //Try insisting on a base group???
 base.ELSETelsum=MXNPEL=wp.nWeldGroup=0; //Establish MXNPEL
 OpenDialog1->Filter= "Msh (*.msh)|*.msh;*.MSH";
/////////////////////////////////////
 if(OpenDialog1->Execute())
   {ifstream ntape2(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
	if(ntape2)
	  {

gWsiAlias=(String)modelName_g; // where char modelName_g[260] in *.h
honk<<gWsiAlias.t_str()<<" gWsiAliasImportAbmmmmmm\n";
// Perhaps the above should be moved within   if(ntape){  ??? EFP 2/27/2012
///////////////////////////// end

	   ofstream tmpfile("record.tmp",ios::binary,0); //Sanitize by writing file without comment/blank lines
	   if(tmpfile)
		 {do {ntape2.getline(cht,200-1);
			  if(cht[0]=='c')continue; // Vague assumption: *.msh comment card begins with c
			  else tmpfile<<cht<<"\n";
			 }
		  while (!ntape2.eof());
		  tmpfile.close();
		  ifstream ntape("record.tmp",ios::nocreate|ios::binary,0);
		  if(ntape)
//
	  {
	   nodeuplim=totNnum=eluplim=totEnum=0;nodelolim=ellolim=LONG_INT;
	   do {ntape.getline(cht,200-1);
		   if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='N' || cht[4]=='n') && (cht[5]=='D' || cht[5]=='d'))break;
		   else if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='O' || cht[4]=='o') && (cht[5]=='D' || cht[5]=='d') && (cht[6]=='E' || cht[6]=='e'))
				  {do {ntape.getline(cht,200-1);
					   parse_cdm3ff(cht,4,&nic,&nrc,larr,darr);
					   if(nodeuplim<larr[0])nodeuplim=larr[0];
					   if(nodelolim>larr[0])nodelolim=larr[0];
					   totNnum++; // This totNum might be +1 wrong.
					  }
				   while (ntape.peek()!= '*');
				  }
		   else if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='L' || cht[4]=='l') && (cht[5]=='E' || cht[5]=='e') && (cht[6]=='M' || cht[6]=='m') && (cht[7]=='E' || cht[7]=='e') && (cht[8]=='N' || cht[8]=='n') && (cht[9]=='T' || cht[9]=='t'))
																			{
																			   do {ntape.getline(cht,200-1); // This might be +1 wrong
																					for(i=0;i<10;i++)larr[i]=0;
																					parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT
															   if(nic-1==8)
																 {totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else break; //Preceding abort does not work???
																				   }
																				while (ntape.peek()!= '*');
																			}
		   else if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='G' || cht[3]=='g')) //Always Group?
				  {base.allGrp=base.allGrp+1;
				   wp.nWeldGroup=wp.nWeldGroup+1;
				  }
		   else {honk<<"WARNING: The following unsupported datacard found in *.msh\n";
				 honk<<cht[0]<<" "<<cht[1]<<" "<<cht[2]<<" "<<cht[3]<<"\n";
				 while (ntape.peek()!= '*')ntape.getline(cht,200-1);
				}
		  }
	   while (!ntape.eof());
	   ntape.close();
honk<<nodeuplim<<" "<<nodelolim<<" "<<totNnum<<" "<<eluplim<<" "<<ellolim<<" "<<totEnum<<" "<<MXNPEL<<" DDDDDDDD\n";
	   if(wp.nWeldGroup==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups (*ELSET, ELSET=...weld...) found in *.abq",L"Terminate",MB_OK);exit(0);}
honk<<base.allGrp<<" "<<wp.nWeldGroup<<" Early A & WG\n";
GeomFileName=OpenDialog1->FileName;
	   base.npoin=totNnum;
	   base.nelt=totEnum; //Policy: Reserve storage for #elements read-in, even if there is duplication  EFP 4/19/2012
	   if(nodeuplim != totNnum)
		 {honk<<nodeuplim<<" Nonconsecutive node numbers in file "<<totNnum<<"\n";
		 }
//////////		                                                                             	}
	   if(eluplim-ellolim+1 != totEnum)
		 {honk<<ellolim<<" "<<eluplim<<" Nonconsecutive/duplicate element numbers in file "<<totEnum<<"\n";
		 }

	   if(base.nelt> LONG_INT/t3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Excessive #elements in geometry file",L"Terminate",MB_OK);exit(0);}
	   if(base.npoin>0 && base.nelt>0)
		 {FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,base.npoin,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
		  FDdynmem_manage(13,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
		  FDdynmem_manage(15,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt);//EFP 8/07/2011
		  ifstream ntape1("record.tmp",ios::nocreate|ios::binary,0);
		  if(ntape1) //seek() can be used with binary-opened files (NOT ascii) so close & reopen file  EFP 12/18/2011
			{
			 ipid=nGID=1;  //Assumption: All elements start with GID=1
			 totNnum=totEnum=sumELSETel=sumlim=0;
			 totBMG=0;totWG=0;//EFP 10/22/2011
			 for(in=0;in<NDF*base.npoin;in++)base.c1[in]=0.;
//vvvvvvvvvvvvvvvvvvv
			 for(in=0;in<2*base.npoin;in++)base.nofix[in]=0;
			 for(in=0;in<base.npoin;in++)base.nrfix[in]=0;
			 for(in=0;in<NDF*base.npoin;in++)base.presc[in]=0.;
//vvvvvvvvvvvvvvvvvvv
			 for(in=0;in<base.nelt;in++)base.arELEM[in]=1;
revnode_map=new long[nodeuplim-nodelolim+1];
			 for(in=0;in<base.npoin;in++)base.arrELSET[in]=0;
////////////
honk<<base.allGrp<<" "<<wp.nWeldGroup<<" EEELate A & WG\n";
honk<<base.npoin<<" "<<base.nelt<<" npoin/nelt\n";
////////////
			 do {ntape1.getline(cht,200-1);
				 if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='N' || cht[4]=='n') && (cht[5]=='D' || cht[5]=='d'))break;
				 else if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='O' || cht[4]=='o') && (cht[5]=='D' || cht[5]=='d') && (cht[6]=='E' || cht[6]=='e'))
					 {do {ntape1.getline(cht,200-1); //parse_cdm(cht,4,&nic,&nrc,larr,darr); // *NODE, stored in same file
						  parse_cdm3ff(cht,4,&nic,&nrc,larr,darr);
						  in=larr[0]-1;base.c1[NDF*totNnum]=darr[0];base.c1[NDF*totNnum+1]=darr[1];base.c1[NDF*totNnum+2]=darr[2];
						  base.node_map[totNnum]=in;  // Check this
						  revnode_map[in-nodelolim+1]=totNnum;
						  totNnum++;
						 }
					  while (ntape1.peek()!= '*');
					 }
		   else if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='L' || cht[4]=='l') && (cht[5]=='E' || cht[5]=='e') && (cht[6]=='M' || cht[6]=='m') && (cht[7]=='E' || cht[7]=='e') && (cht[8]=='N' || cht[8]=='n') && (cht[9]=='T' || cht[9]=='t'))
						{
							do {ntape1.getline(cht,200-1);
								for(i=0;i<10;i++)larr[i]=0;
								parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT, stored in same file
								if(nic-1==8)eltype=8;
								else {honk<<"Halt3: Unsupported element with #nodes "<<nic-1<<"\n";
									  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(_ltow(nic-1,string0,10),L"Halt3: Unsupported element with #nodes in ImportAba_prog()",MB_OK);
									  exit(0);
									 }
								n8=nic-1;in=larr[0]-1;
								for(i=0;i<n8;i++)base.nop1[MXNPEL*totEnum+i]=larr[i+1]-1;
								base.matno[totEnum]=eltype*t7+n8*t3;
								base.el_map[totEnum]=in;
								base.orig_matno[totEnum]=eltype*t7+n8*t3;
								totEnum++;
							   }
							while (ntape1.peek()!= '*');
						}
		   else if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && (cht[3]=='G' || cht[3]=='g')) //Always Group?
				   {

		kp=int(strlen(cht))-3;
		temp_cht=new char[kp+1];
		for(i=0;i<kp;i++)temp_cht[i]=cht[i+3];
		temp_cht[kp]='\0';
		base.groupsname[totWG]=temp_cht; //EFP 3/25/2011
honk<<kp<<" "<<strlen(cht)<<" "<<temp_cht<<" temp_cht\n";
honk<<totWG<<" posteriorWG_NoGEN "<<base.groupsname[totWG].c_str()<<"\n";
		delete [] temp_cht; *temp_cht=NULL;
		totWG++;nGID++;sumWG=0;

					do {ntape1.getline(cht,200-1);
						parse_cdmQ(cht,25,&nic,&nrc,larr,darr,strlen(cht)); //This accommodates comma-end or no-comma EFP 4/15/2011
						for(i=0;i<nic;i++){if(larr[i]) //This accommodates comma-end or no-comma EFOP 4/15/2011
											 {
j= -1;for(kk=0;kk<totEnum;kk++)if(base.el_map[kk]==larr[i]-1){j=kk;break;}  //Correction EFP 4/01/2011
if(j== -1){honk<<"TERMINATE: WG el_map crash in *.abq/*.inp\n";exit(0);}
else {base.arrELSET[j]=totWG;sumWG++;}
											 }
										  }
					   }
					while (ntape1.peek()!= '*');
					if(sumlim<sumWG)sumlim=sumWG;
honk<<totWG<<" guavaACCEPTwg "<<j+1<<"\n";
				   }
				 else {
while (ntape1.peek()!= '*')ntape1.getline(cht,200-1);
					  }
				}
			 while (!ntape1.eof());

//////////////////////////////////////////
// This did not work for *.msh so maybe it should be revised for *.inp/*.abq  EFP 4/06/2011
			 for(j=0;j<totEnum;j++)
			   {eltype=base.matno[j]/t7;bscode=(base.matno[j]-eltype*t7)/t5;node=(base.matno[j]-eltype*t7-bscode*t5)/t3;
				for(in=0;in<node;in++)base.nop1[MXNPEL*j+in]=revnode_map[base.nop1[MXNPEL*j+in]-nodelolim+1];
			   }
//			 delete [] revnode_map; //THIS CAUSES MEMORY CRASH BUT WHY??? NECESSARY!!! EFP 7/31/2014
			 *revnode_map=NULL;
base.allGrp=nGID; //Special restriction to 1 basemetal + WGs
honk<<wp.nWeldGroup<<" Revised nWeldGroup "<<base.nelt+sumELSETel<<"\n";
honk<<base.nelt<<" nelt/allGrp "<<base.allGrp<<"\n";
			 old_npoin=new_npoin=base.npoin;new_nelt=base.nelt;new_mat=base.mat;new_ncoorf=base.ncoorf;nGID=wp.nWeldGroup+1;
			 ntape1.close();DeleteFile("record.tmp");
			 FDbase_indat(1,shapecombo,iplotflag,nColRes);
			   FDdynmem_manage(-17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   FDdynmem_manage(17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt);//EFP 8/07/2011
			   indat.GIDcol=base.GIDcol;
			   for(in=0;in<base.nelt;in++)indat.arrELSET[in]=base.arrELSET[in];
	if(nGID<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No geometry IDs found",L"Halt",MB_OK);return;}
	else {if(iPaintyesno/10==0){
								if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
								else {FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
							          FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
									 }
								iPaintyesno=10+1;iCullyesno=0;
							   }

			 stateVFT=2;FD_LButtonstatus=11;

Form1->Caption=GeomFileName;

////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
//////////
			 wp.memWGa=sumlim;
honk<<sumlim<<" ImpAbq MEM\n";
			 iplotflag=1;iCircleplot=1;
			 Invalidate();
		 }

			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen input file",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);
			 Application->MessageBox(L"Nodes/elements/GID missing from *.msh datafile",L"Failure",MB_OK);
			}
			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen *.tmp file",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.tmp file",L"Failure",MB_OK);}
	   ntape2.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);
		  Application->MessageBox(L"Could not open *.msh file",L"Failure",MB_OK);
		 }
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
	  }
}
//---------------------------------------------------------------------------
//TOTALLY OBSOLETE SUBROUTINE
void __fastcall TForm1::MSHgeomVEDopenExecute(TObject *Sender)
// Warning: possible discontinuous node/element numbers in input *.msh
// Observation: It is not necessary to have weld groups, since the user can place weld passes in the base mesh???
// Data card input length=200 below

/////////////// TBD: Add coding to obviate   ** End.......... EFP 4/01/2011
{
 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unfinished option",L"Halt",MB_OK);
/*
int nic=0,nrc=0,filetypesw=0;
 long ip=0,in=0,ir=0,n8=0,dummy=0,i=0,larr[11],
	  ipid=0,nodeuplim=0,eluplim=0,filetimepoints=0,activepts=0,maxactivepts=0,
	  eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,*larr1=NULL;
 float timept=0.,darr[11],*darr1=NULL;
 char cht[200];
 long totNnum=0,totEnum=0;
 wchar_t string0[11];
 base.mat=base.matsteps=base.ncoorf=1;MXNPEL=8; //Policy: 8n hex in *.msh only
 base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.nblod=0;
 if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
 else {OpenDialog1->Filter= "Msh (*.msh)|*.msh;*.MSH";
	   if(OpenDialog1->Execute())
		{ifstream ntape(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);

//////////////////
///////////////////
//////////////////// The following copied from MSHgeomOpenExecute()  EFP 2/27/2012
char *driveEFP=NULL,*dirEFP=NULL,*extEFP=NULL;
driveEFP=new char[260];dirEFP=new char[260];extEFP=new char[260];
fnsplit(OpenDialog1->FileName.c_str(),driveEFP,dirEFP,modelName_g,extEFP);
honk<< driveEFP<<" driveEFP\n";honk<< dirEFP<<" dirEFP\n";honk<< modelName_g<<" modelName_g\n";honk<< extEFP<<" extEFP\n";
delete [] driveEFP;delete [] dirEFP;delete [] extEFP;

gWsiAlias=(String)modelName_g; // where char modelName_g[260] in *.h
honk<<gWsiAlias.t_str()<<" gWsiAliasMSHgeommmmmmm\n";
// Perhaps the above should be moved within   if(ntape){  ??? EFP 2/27/2012
////////////////////
///////////////////
//////////////////

		 if(ntape)
		  {filetypesw=wp.nWeldGroup=nodeuplim=totNnum=eluplim=totEnum=0;
		   ntape.getline(cht,200-1);
		   if(!filetypesw){if(cht[0]=='*' && cht[1]=='*')filetypesw=1;
						   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not a *.msh file",L"Halt",MB_OK);
								 return;
								}
						  }
// *.msh format: Assume that the first ** data set is nodes delimited by "," (Do not use Node Coordinates to identify since it is not fixed on line.)
//               Assume that the second ** data set is elements delimited by "," (Do not use Element Connectivity to identify since it is not fixed on line.)
		   do {ntape.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr);
			   totNnum++;if(nodeuplim<larr[0])nodeuplim=larr[0];
			  }
		   while (ntape.peek()!= '*');
		   ntape.getline(cht,200-1); // Read ** Elem
		   do {ntape.getline(cht,200-1);parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht));
			   if(nic-1==4 || nic-1==6 || nic-1==8);
			   else {honk<<"Halt: Unsupported element with #nodes "<<nic-1<<"\n";
					 extern PACKAGE void __fastcall Beep(void);
					 Application->MessageBox(_ltow(nic-1,string0,10),L"Halt: Unsupported element with #nodes",MB_OK);
					 return;
					}
			   totEnum++;if(eluplim<larr[0])eluplim=larr[0];
			  }
		   while (ntape.peek()!= '*');
// Current WSIFrame.java format (Y2005) ----> Read up to MAX_WELDGROUPS=500 weld groups
		   for(in=0;in<MAX_WELDGROUPS+1;in++)
			 {ntape.getline(cht,200-1);
			  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && (cht[4]=='n'||cht[4]=='N') && (cht[5]=='d'||cht[5]=='D'))break;
			  else if(cht[0]=='*' && cht[1]=='*' && cht[2]=='E' && (cht[3]=='n'||cht[3]=='N') && (cht[4]=='d'||cht[4]=='D'))break; //Correction EFP 5/21/2010
			  else {if(in<MAX_WELDGROUPS){wp.nWeldGroup=wp.nWeldGroup+1;
										  do ntape.getline(cht,200-1);  //TBD: exclude AllWD, etc
										  while (ntape.peek()!= '*');
										 }
					else {honk<<"#weld groups exceeds allowable "<<MAX_WELDGROUPS<<"\n";
						  extern PACKAGE void __fastcall Beep(void);
						  Application->MessageBox(_ltow(MAX_WELDGROUPS,string0,10),L"Halt: #weld groups exceeds allowable",MB_OK);
						  return;
						 }
				   }
			 }
		   if(nodeuplim != totNnum)
			 {honk<<nodeuplim<<" Nonconsecutive node numbers in *.msh "<<totNnum<<"\n";
////			  for(in=0;in<100;in++)cht[in]=' ';
////			  strcpy(cht,IntToStr(nodeuplim).t_str());
////			  strcat(cht," There are nonconsecutive node numbers in *.msh ");
////			  strcat(cht,IntToStr(base.npoin).t_str());
////			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(cht,"Warning",MB_OK);

//			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive node numbers in *.msh ",L"Warning",MB_OK);
			 }
		   if(eluplim != totEnum)
			 {honk<<eluplim<<" Nonconsecutive element numbers in *.msh "<<totEnum<<"\n";
////			  for(in=0;in<100;in++)cht[in]=' ';
////			  strcpy(cht,IntToStr(eluplim).t_str());
////			  strcat(cht,"There are nonconsecutive element numbers in *.msh ");
////			  strcat(cht,IntToStr(base.nelt).t_str());
////			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(cht,"Warning",MB_OK);

//			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive element numbers in *.msh ",L"Warning",MB_OK);
			 }
		   if(wp.nWeldGroup==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups found in datafile",L"Terminate",MB_OK);exit(0);}
		   base.npoin=nodeuplim;base.nelt=eluplim;ntape.close();
		   GeomFileName=OpenDialog1->FileName;
		   if(base.nelt> LONG_INT/t3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Excessive #elements in geometry file",L"Terminate",MB_OK);exit(0);}
/////////////// Precaution, until I can fix it   EFP 1/28/2010
//		   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"End of *.msh file must have  ** End  , NOT **End ",L"Advisory",MB_OK);
//////////////////////////////////////////////////////////////
		   if(base.npoin>0 && base.nelt>0)
//			{FDdynmem_manageD(1,base.npoin,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
			{FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
			 for(in=0;in<NDF*base.npoin;in++)base.c1[in]=0.;
			 for(in=0;in<base.nelt;in++)base.arELEM[in]=1;
			 ifstream ntape1(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
			 if(ntape1)
			  {for(in=0;in<base.nelt;in++)base.el_map[in]= -1;
			   for(in=0;in<base.npoin;in++)base.node_map[in]= -1;
			   ntape1.getline(cht,200-1);
			   do {ntape1.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr);
				   in=larr[0]-1;base.c1[NDF*in]=darr[0];base.c1[NDF*in+1]=darr[1];base.c1[NDF*in+2]=darr[2];
				   base.node_map[in]=1;
				  }
			   while (ntape1.peek()!= '*');
			   ntape1.getline(cht,200-1);ipid=1;
//               for(in=0;in<base.nelt;in++)base.matno[in]= -1;
			   do {ntape1.getline(cht,200-1);parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht));
				   n8=nic-1;in=larr[0]-1;for(i=0;i<n8;i++)base.nop1[MXNPEL*in+i]=larr[i+1]-1;
				   base.matno[in]=8*t7+n8*t3+ipid-1;base.el_map[in]=in;
/////////// EFP 1/30/2011
base.orig_matno[in]=8*t7+n8*t3+ipid-1;
///////////
				  }
			   while (ntape1.peek()!= '*');
			   for(in=0;in<wp.nWeldGroup;in++)
				 {ntape1.getline(cht,200-1);
				  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && (cht[4]=='n'||cht[4]=='N') && (cht[5]=='d'||cht[5]=='D'))break;
				  else if(cht[0]=='*' && cht[1]=='*' && cht[2]=='E' && (cht[3]=='n'||cht[3]=='N') && (cht[4]=='d'||cht[4]=='D'))break; //Correction EFP 5/21/2010
				  else {do {ntape1.getline(cht,200-1);parse_cdmQ(cht,16,&nic,&nrc,larr,darr,strlen(cht)); //TBD: exclude AllWD, etc
							for(i=0;i<nic;i++)base.matno[larr[i]-1]=base.matno[larr[i]-1]+in+1; // FIX THIS. Presumes base ipid=1
//////////// EFP 1/30/2011
							for(i=0;i<nic;i++)base.orig_matno[larr[i]-1]=base.orig_matno[larr[i]-1]+in+1; // FIX THIS. Presumes base ipid=1
////////////
						   }
						while (ntape1.peek()!= '*');
					   }
				 }
			   wp.memWGa=base.nelt; //Temporary assignment
			   OpenDialog2->Filter= "dat (*.dat)|*.Dat;*.DAT";
			   if(OpenDialog2->Execute())
				 {ifstream ntape2(OpenDialog2->FileName.c_str(),ios::nocreate|ios::binary,0);
				  if(ntape2)
					{
/////////////////////////////////////////////
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
/////////////////////////////////////////////
					 filetimepoints=0;maxactivepts=0;
					 do {ntape2.getline(cht,200-1);parse_cdm(cht,2,&nic,&nrc,larr,darr);
						 activepts=larr[0];if(maxactivepts<activepts)maxactivepts=activepts;
honk<<timept<<" "<<activepts<<" actiev\n";
						 if(activepts){ntape2.getline(cht,200-1);
									   filetimepoints++;
//									   if(filetimepoints+wp.nWeldGroup>MAX_GID-1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"VED filetimepoints exceeds current MAX_GID limit",L"Terminate",MB_OK);exit(0);}
									   if(filetimepoints>64-1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"VED filetimepoints exceeds 64 limit in this code version",L"Terminate",MB_OK);exit(0);}
									  }
						}
					 while (!ntape2.eof());
					 wp.VEDsteps=filetimepoints;
					 ntape2.close();

nGID=nGID+filetimepoints;
honk<<nGID<<" "<<filetimepoints<<" "<<maxactivepts<<" filetimepoints\n";
//FDdynmem_manage(12,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,filetimepoints,dummy);
					 larr1=new long[maxactivepts];darr1=new float[maxactivepts];

					 ifstream ntape3(OpenDialog2->FileName.c_str(),ios::nocreate|ios::binary,0);
					 if(ntape3)
					   {filetimepoints=0;
						do {ntape3.getline(cht,200-1);parse_cdm(cht,2,&nic,&nrc,larr,darr);
							timept=darr[0];activepts=larr[0];
//honk<<timept<<" "<<activepts<<" actiev3\n";
//							wpRes.timeVEDarr[filetimepoints]=timept; //Cats ass coding
							timeVEDarr[filetimepoints]=timept; //Cats ass coding
							if(activepts){ntape3.getline(cht,200-1);
										  parse_cdmQn(cht,activepts,&nic,&nrc,larr1,darr1);
//honk<<activepts<<" ACTV3 "<<wp.nWeldGroup<<"\n";
										  for(ip=0;ip<activepts;ip++){i=larr1[ip]-1;
eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
////ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[i+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[i+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[i]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[i+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[i];

base.matno[i]=base.matno[i]-ieGID+filetimepoints+wp.nWeldGroup+1;
//honk<<i+1<<" "<<ieGID<<" IPPPER3 "<<-ieGID+filetimepoints+wp.nWeldGroup<<" "<<base.matno[i]<<"\n";


																	 }
										  filetimepoints++;
										 }
						   }
						while (!ntape3.eof());
						ntape3.close();
Form1->Caption=GeomFileName;
					   }
					 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file - encore",L"Failure",MB_OK);}
					 delete [] larr1;delete [] darr1;
/////////////////////////////////////////////
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
/////////////////////////////////////////////
					}
				  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.dat VED file",L"Failure",MB_OK);}
				 }
//			   base.noncon_nelt=base.nelt;  //Removed EFP 1/02/2012
			   eluplim=0;
			   for(in=0;in<base.nelt;in++){if(base.el_map[in]<0);
										   else {base.matno[eluplim]=base.matno[in];base.el_map[eluplim]=base.el_map[in];
												 for(i=0;i<8;i++)base.nop1[MXNPEL*eluplim+i]=base.nop1[MXNPEL*in+i];
												 eluplim++;
												}
										  }
			   base.nelt=eluplim;
wp.nWeldPass=filetimepoints;
			   FDdynmem_manage(9,dummy,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   for(in=0;in<wp.nWeldPass*base.nelt;in++)wp.eles[in]= -1;
			   for(in=0;in<wp.nWeldPass*base.nelt;in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=0;in<wp.nWeldPass;in++)wp.stpEle[in]= -1;  // No need for *bnelt
			   for(in=0;in<wp.nWeldPass*4;in++)wp.snorm1[in]= -1;
			   for(in=0;in<wp.nWeldPass*4;in++)wp.snorm2[in]= -1;
			   for(in=0;in<wp.nWeldPass;in++)wp.source[in]=11;//Must be odd
			   for(in=0;in<wp.nWeldPass;in++)wp.hp[in]=0;//Lump Pass (1) or Moving Arc (0) Heating Procedure
			   for(in=0;in<wp.nWeldPass;in++)wp.nsegs[in]=1;
			   for(in=0;in<wp.nWeldPass;in++)wp.iselect[in]=0;
 for(in=0;in<wp.nWeldPass;in++){ir=in-9*(in/9);
								if     (ir==0)wp.WeldColor[in]=clLtGray;else if(ir==1)wp.WeldColor[in]=clBlue;
								else if(ir==2)wp.WeldColor[in]=clGreen ;else if(ir==3)wp.WeldColor[in]=clLime;
								else if(ir==4)wp.WeldColor[in]=clNavy  ;else if(ir==5)wp.WeldColor[in]=clYellow;
								else if(ir==6)wp.WeldColor[in]=clOlive ;else if(ir==7)wp.WeldColor[in]=clMaroon;
								else          wp.WeldColor[in]=clRed;
							   }

			   old_npoin=new_npoin=base.npoin;new_nelt=base.nelt;new_mat=base.mat;new_ncoorf=base.ncoorf;
			   nGID=wp.nWeldPass+wp.nWeldGroup+1;
			   ntape1.close();
			   FDbase_indat(1,shapecombo,iplotflag,nColRes);
//////////////////////////////////////
	if(nGID<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No geometry IDs found",L"Halt",MB_OK);return;}
//    else {if(iPaintyesno/10==0){FDelemfacets2();iPaintyesno=10;iCullyesno=0;}iCircleplot=1;Invalidate();}
	else {if(iPaintyesno/10==0){
//								FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
								if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
//								else {FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);}
//								iPaintyesno=10;iCullyesno=0;

								else {
//								FDcomp_nGID();
FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
								FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);}
								iPaintyesno=10+1;iCullyesno=0;
							   }
			 stateVFT=2;FD_LButtonstatus=11;
		  iplotflag=1;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
		  iCircleplot=1;Invalidate();
		 }
//////////////////////////////////////
//               iplotflag=1;Invalidate();
			  }
			 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}
			}
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Nodes/elements/GID missing from *.UNV datafile",L"Failure",MB_OK);}
		  }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}
		}
//	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
	  }

*/
}
/*
//---------------------------------------------------------------------------
void __fastcall TForm1::MSHgeomVEDopenExecute(TObject *Sender)
// Warning: possible discontinuous node/element numbers in input *.msh
// Observation: It is not necessary to have weld groups, since the user can place weld passes in the base mesh???
// Data card input length=200 below
{int nic=0,nrc=0,filetypesw=0;
// long ip=0,in=0,n8=0,dummy=0,i=0,larr[11],
//	  ipid=0,nodeuplim=0,eluplim=0,filetimepoints=0,activepts=0,
//	  eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,ltrash=0;
 long ip=0,in=0,n8=0,dummy=0,i=0,larr[11],
	  ipid=0,nodeuplim=0,eluplim=0,filetimepoints=0,activepts=0,
	  t3=1000,t7=10000000;
 float timept=0.,darr[11];
 char cht[200];
// wchar_t string0[11];
char string0[11];
 base.mat=base.matsteps=base.ncoorf=1;
 base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.nblod=0;
 if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
 else {OpenDialog1->Filter= "Msh (*.msh)|*.msh;*.MSH";
	   if(OpenDialog1->Execute())
//		{ifstream ntape(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
		{ifstream ntape(OpenDialog1->FileName.c_str(),ios::nocreate|ios::binary,0);
		 if(ntape)
		  {filetypesw=wp.nWeldGroup=0;ntape.getline(cht,200-1);
		   if(!filetypesw){if(cht[0]=='*' && cht[1]=='*')filetypesw=1;
						   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not a *.msh file",L"Halt",MB_OK);
								 return;
								}
						  }
// *.msh format: Assume that the first ** data set is nodes delimited by "," (Do not use Node Coordinates to identify since it is not fixed on line.)
//               Assume that the second ** data set is elements delimited by "," (Do not use Element Connectivity to identify since it is not fixed on line.)
		   do {ntape.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr);
			   base.npoin=base.npoin+1;if(nodeuplim<larr[0])nodeuplim=larr[0];
			  }
		   while (ntape.peek()!= '*');
		   ntape.getline(cht,200-1); // Read ** Elem
		   do {ntape.getline(cht,200-1);parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht));

//honk<<nic<<" "<<larr[0]<<" "<<larr[1]<<" "<<larr[2]<<" "<<larr[3]<<" CHEKKO\n";

			   if(nic-1==4 || nic-1==6 || nic-1==8){
//if(nGIDmax<larr[2])nGIDmax=larr[2];
															if(MXNPEL<nic-1)MXNPEL=nic-1;
														   }
			   else {honk<<"Halt: Unsupported element with #nodes "<<nic-1<<"\n";
//					 for(in=0;in<100;in++)cht[in]=' ';
//					 strcpy(cht,"Unsupported element with #nodes ");
//					 strcat(cht,IntToStr(nic-1).t_str());
//					 extern PACKAGE void __fastcall Beep(void);
//					 Application->MessageBox(cht,L"Halt",MB_OK);

				 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Oops",L"Halt: Unsupported element with #nodes",MB_OK);
				 return;
				}
			   base.nelt=base.nelt+1;if(eluplim<larr[0])eluplim=larr[0];
			  }
		   while (ntape.peek()!= '*');
// Current WSIFrame.java format (Y2005) ----> Read up to MAX_WELDGROUPS=500 weld groups
		   for(in=0;in<MAX_WELDGROUPS+1;in++)
			 {ntape.getline(cht,200-1);
//              if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && cht[4]=='n' && cht[5]=='d')break;
			  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && (cht[4]=='n'||cht[4]=='N') && (cht[5]=='d'||cht[5]=='D'))break;
			  else {if(in<MAX_WELDGROUPS){wp.nWeldGroup=wp.nWeldGroup+1;
										  do ntape.getline(cht,200-1);
										  while (ntape.peek()!= '*');
										 }
					else {honk<<"#weld groups exceeds allowable "<<MAX_WELDGROUPS<<"\n";
//						  for(in=0;in<100;in++)cht[in]=' ';
//						  strcpy(cht,"#weld groups exceeds allowable ");
//						  strcat(cht,IntToStr(MAX_WELDGROUPS).t_str());
//						  extern PACKAGE void __fastcall Beep(void);
//						  Application->MessageBox(cht,L"Halt",MB_OK);

						  extern PACKAGE void __fastcall Beep(void);
						  Application->MessageBox(L"Oops",L"Halt: #weld groups exceeds allowable",MB_OK);
						  return;
						 }
				   }
			 }
		   if(nodeuplim != base.npoin)
			 {honk<<nodeuplim<<" Nonconsecutive node numbers in *.msh "<<base.npoin<<"\n";
//			  for(in=0;in<100;in++)cht[in]=' ';
//			  strcpy(cht,IntToStr(nodeuplim).t_str());
//			  strcat(cht," There are nonconsecutive node numbers in *.msh ");
//			  strcat(cht,IntToStr(base.npoin).t_str());
//			  extern PACKAGE void __fastcall Beep(void);
//			  Application->MessageBox(cht,"Warning",MB_OK);

			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive node numbers in *.msh ",L"Warning",MB_OK);
			 }
		   if(eluplim != base.nelt)
			 {honk<<eluplim<<" Nonconsecutive element numbers in *.msh "<<base.nelt<<"\n";
//			  for(in=0;in<100;in++)cht[in]=' ';
//			  strcpy(cht,IntToStr(eluplim).t_str());
//			  strcat(cht,"There are nonconsecutive element numbers in *.msh ");
//			  strcat(cht,IntToStr(base.nelt).t_str());
//			  extern PACKAGE void __fastcall Beep(void);
//			  Application->MessageBox(cht,"Warning",MB_OK);

			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive element numbers in *.msh ",L"Warning",MB_OK);
			 }
		   if(wp.nWeldGroup==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups found in datafile",L"Terminate",MB_OK);exit(0);}
		   base.npoin=nodeuplim;base.nelt=eluplim;ntape.close();GeomFileName=OpenDialog1->FileName;
		   if(base.nelt> LONG_INT/t3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Excessive #elements in geometry file",L"Terminate",MB_OK);exit(0);}
/////////////// Precaution, until I can fix it   EFP 1/28/2010
//		   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"End of *.msh file must have  ** End  , NOT **End ",L"Advisory",MB_OK);
//////////////////////////////////////////////////////////////
//
//honk<<base.npoin<<" "<<base.nelt<<" proTemp E/n\n";

		   if(base.npoin>0 && base.nelt>0)
			{FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
			 for(in=0;in<NDF*base.npoin;in++)base.c1[in]=0.;
			 ifstream ntape1(OpenDialog1->FileName.c_str(),ios::nocreate|ios::binary,0);
			 if(ntape1)
			  {for(in=0;in<base.nelt;in++)base.el_map[in]= -1;
			   ntape1.getline(cht,200-1);
			   do {ntape1.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr);
				   in=larr[0]-1;base.c1[NDF*in]=darr[0];base.c1[NDF*in+1]=darr[1];base.c1[NDF*in+2]=darr[2];
				  }
			   while (ntape1.peek()!= '*');
			   ntape1.getline(cht,200-1);ipid=1;n8=8;
//               for(in=0;in<base.nelt;in++)base.matno[in]= -1;
			   do {ntape1.getline(cht,200-1);parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht));
				   n8=nic-1;in=larr[0]-1;for(i=0;i<n8;i++)base.nop1[MXNPEL*in+i]=larr[i+1]-1;
				   base.matno[in]=8*t7+n8*t3+ipid-1;base.el_map[in]=in;

//honk<<in+1<<" "<<base.matno[in]<<" PRIMO\n";
				  }
			   while (ntape1.peek()!= '*');
			   for(in=0;in<wp.nWeldGroup;in++)
				 {ntape1.getline(cht,200-1);
////                  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && cht[4]=='n' && cht[5]=='d')break;
				  if(cht[0]=='*' && cht[1]=='*' && cht[2]==' ' && cht[3]=='E' && (cht[4]=='n'||cht[4]=='N') && (cht[5]=='d'||cht[5]=='D'))break;
//				  if(cht[0]=='*' && cht[1]=='*' &&
////					 ((cht[2]==' ' && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='N' || cht[4]=='n') && (cht[5]=='D' || cht[5]=='d')) ||
////					  ((cht[2]=='E' || cht[2]=='e') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='D' || cht[4]=='d')))
//////					 (cht[2]==' ' || cht[2]=='E' || cht[2]=='e') &&
//////					 (cht[3]=='E' || cht[3]=='e' || cht[3]=='n' || cht[3]=='N') && (cht[5]=='d'||cht[5]=='D')

////					  (cht[2]=='E' || cht[2]=='e') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='D' || cht[4]=='d')
//					  cht[2]=='E' && cht[3]=='n' && cht[4]=='d'

//					)break;
//				  else {do {ntape1.getline(cht,200-1);parse_cdmQ(cht,11,&nic,&nrc,larr,darr,strlen(cht));
				  else {do {ntape1.getline(cht,200-1);parse_cdmQ(cht,16,&nic,&nrc,larr,darr,strlen(cht));
							for(i=0;i<nic;i++){
//ltrash=base.matno[larr[i]-1];
							base.matno[larr[i]-1]=base.matno[larr[i]-1]+in+1; // FIX THIS. Presumes base ipid=1
//honk<<in+1<<" "<<nic<<" "<<larr[i]<<" MSHckMATNO "<<ltrash<<" "<<base.matno[larr[i]-1]<<"\n";
											  }
						   }
						while (ntape1.peek()!= '*');
					   }
				 }


//for(i=0;i<base.nelt;i++){
//honk<<i+1<<" "<<base.matno[i]<<" SECUNDO\n";
//eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
//node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
////ip=ieGID;
//////eltype=indat.matno[i]/t7;bscode=(indat.matno[i]-eltype*t7)/t5;
//////node=(indat.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=indat.matno[i]-eltype*t7-bscode*t5-node*t3;
////honk<<i+1<<" "<<ip<<" SEC00 test "<<eltype*t7<<" "<<bscode*t5<<" "<<node*t3<<" "<<ieGID<<"\n";
//honk<<base.matno[i]/t7<<"\n";
//						}
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++

			   OpenDialog2->Filter= "dat (*.dat)|*.Dat;*.DAT";
			   if(OpenDialog2->Execute())
				 {ifstream ntape2(OpenDialog2->FileName.c_str(),ios::nocreate|ios::binary,0);
				  if(ntape2)
					{
/////////////////////////////////////////////
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
try {
/////////////////////////////////////////////
					 filetimepoints=0;
					 do {ntape2.getline(cht,200-1);parse_cdm(cht,2,&nic,&nrc,larr,darr);
						 timept=darr[0];activepts=larr[0];
honk<<timept<<" "<<activepts<<" actiev\n";
timeVEDarr[filetimepoints]=timept; //Cats ass coding
						 if(activepts){ntape2.getline(cht,200-1);parse_cdm(cht,activepts,&nic,&nrc,larr,darr);

for(ip=0;ip<activepts;ip++){//honk<<larr[ip]<<"\n";
i=larr[ip]-1;
////eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
////node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//base.matno[i]=base.matno[i]-ieGID+filetimepoints+3; // Cats ass coding
if(base.matno[i]==80008001){base.matno[i]=80008000+filetimepoints+3;
//							honk<<base.matno[i]<<" Newbozo1 "<<i+1<<"\n";
						   }
else if(base.matno[i]==80008002){base.matno[i]=80008000+filetimepoints+3;
//								 honk<<base.matno[i]<<" Newbozo2 "<<i+1<<"\n";
								}
//else honk<<base.matno[i]<<" BOZO "<<i+1<<"\n";
						   }
									   filetimepoints++;
									  }
						}
					 while (!ntape2.eof());
					 wp.VEDsteps=filetimepoints;
/////////////////////////////////////////////
	}
__finally {Screen->Cursor=Save_Cursor;}
/////////////////////////////////////////////
					 ntape2.close();

nGID=nGID+filetimepoints;
honk<<nGID<<" "<<filetimepoints<<" filetimepoints\n";
					}
				  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.dat VED file",L"Failure",MB_OK);}
				 }
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create VED FileOpen selector",L"Failure",MB_OK);}

//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++
////###### Renumber elements consecutively (but NOT nodes)
//               eluplim=0;
//               for(in=0;in<base.nelt;in++){if(base.matno[in]<0);
//                                           else {base.matno[eluplim]=base.matno[in];
//                                                 for(i=0;i<8;i++)base.nop1[MXNPEL*eluplim+i]=base.nop1[MXNPEL*in+i];
//                                                 eluplim++;
//                                                }
//                                          }
//               base.nelt=eluplim;
////######
//###### Renumber elements consecutively (but NOT nodes) & establish inverse elem-mapping
			   base.noncon_nelt=base.nelt;
			   eluplim=0;
			   for(in=0;in<base.nelt;in++){if(base.el_map[in]<0);
										   else {base.matno[eluplim]=base.matno[in];base.el_map[eluplim]=base.el_map[in];
												 for(i=0;i<8;i++)base.nop1[MXNPEL*eluplim+i]=base.nop1[MXNPEL*in+i];
												 eluplim++;
												}
										  }
			   base.nelt=eluplim;
//
			   FDdynmem_manage(6,dummy,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   for(in=0;in<MAX_WELDPASSES*base.nelt;in++)wp.eles[in]= -1;
			   for(in=0;in<MAX_WELDPASSES*base.nelt;in++)wp.sttEles[in]= -1;// No need for *4 ????
			   for(in=0;in<MAX_WELDPASSES;in++)wp.stpEle[in]= -1;  // No need for *bnelt
			   for(in=0;in<MAX_WELDPASSES*4;in++)wp.snorm1[in]= -1;
			   for(in=0;in<MAX_WELDPASSES*4;in++)wp.snorm2[in]= -1;
//        wp.firstEle=new long[MAX_WELDPASSES*bnet],
//        wp.nextEle=new long[MAX_WELDPASSES],
//        wp.snorm1=new long[MAX_WELDPASSES*4],
//        wp.snorm2=new long[MAX_WELDPASSES*4],
//        wp.circEles=new long[MAX_WELDPASSES*3],
//        wp.edgeEles=new long[MAX_WELDPASSES*bnelt],
//        wp.edgeNodes=new long[MAX_WELDPASSES*4],
//        wp.sttEleNodes=new long[MAX_WELDPASSES*bnelt*4],
			   for(in=0;in<MAX_WELDPASSES;in++)wp.source[in]=11;
			   for(in=0;in<MAX_WELDPASSES;in++)wp.hp[in]=0;//Lump Pass (1) or Moving Arc (0) Heating Procedure
			   for(in=0;in<MAX_WELDPASSES;in++)wp.nsegs[in]=1;
			   for(in=0;in<MAX_WELDPASSES;in++)wp.iselect[in]=0;
//######
			   old_npoin=new_npoin=base.npoin;new_nelt=base.nelt;new_mat=base.mat;new_ncoorf=base.ncoorf;nGID=wp.nWeldGroup+1;
			   ntape1.close();
//                           FDbase_indat(1,shapecombo);
FDbase_indat(1,shapecombo,iplotflag,nColRes);


//honk<<MXNPEI<<" MXNPEI\n";
// long in=0,i=0,eltype=0,bscode=0,node=0,ieGID=0,tf3=1000,tf5=100000,tf7=10000000;
// for(i=0;i<base.nelt;i++){
//    eltype=base.matno[i]/tf7;bscode=(base.matno[i]-eltype*tf7)/tf5;
//    node=(base.matno[i]-eltype*tf7-bscode*tf5)/tf3;ieGID=base.matno[i]-eltype*tf7-bscode*tf5-node*tf3;
//    if(ieGID!=0)honk<<i+1<<" "<<ieGID<<" HERE\n";
//    honk<<i+1<<" "<<eltype<<" "<<node<<" "<<ieGID<<" MSHel\n";
//    for(in=0;in<node;in++)honk<<base.nop1[MXNPEI*i+in]<<"\n";
//                         }
// if(1==1)exit(0);



//////////////////////////////////////
//for(i=0;i<base.nelt;i++){
//eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;
//node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//ip=ieGID;
//eltype=indat.matno[i]/t7;bscode=(indat.matno[i]-eltype*t7)/t5;
//node=(indat.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=indat.matno[i]-eltype*t7-bscode*t5-node*t3;
//honk<<i+1<<" "<<ip<<" SEC test "<<ieGID<<"\n";
//						}



	if(nGID<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No geometry IDs found",L"Halt",MB_OK);return;}
////    else {if(iPaintyesno/10==0){FDelemfacets2();iPaintyesno=10;iCullyesno=0;}iCircleplot=1;Invalidate();}
//	else {if(iPaintyesno/10==0){
////                                    FDcomp_nGID();
//FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
//								FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
//								iPaintyesno=10;iCullyesno=0;
//							   }
//
//		  iplotflag=1;
//
//		  iCircleplot=1;Invalidate();
//		 }
	else {
		  if(iPaintyesno/10==0){if(iPaintyesno-10*(iPaintyesno/10)){
																	FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
																	FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
																	iPaintyesno=10+1;
																   }
								else {FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
									  FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
									  iPaintyesno=10;
									 }
								iCullyesno=0;
							   }
		  iplotflag=1;
		  iCircleplot=1;Invalidate();
		 }
//////////////////////////////////////
//               iplotflag=1;Invalidate();
			  }
			 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}
			}
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Nodes/elements/GID missing from *.UNV datafile",L"Failure",MB_OK);}
		  }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}
		}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
	  }
}
*/
/*
//---------------------------------------------------------------------------
void __fastcall TForm1::ImportAbaABQExecute(TObject *Sender)
{
 int nic=0,nrc=0,isw=0,jsw=0;
 long
// itype=0,
in=0,
//n2=0,n3=0,n4=0,n5=0,n6=0,n7=0,
n8=0,
//dresno=0,sresno=0,
dummy=0,
//ltype=0,
i=0,j=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000,
	  larr[10],
//*GIDarr=NULL,
//ipid=0,MXNPELX=0
ipid=0
//,MUL=1,inpGIDmax= -1,matstep=0
//,nodeuplim=0,totNnum=0,eluplim=0,totEnum=0,nGIDmax=0;
,nodeuplim=0,totNnum=0,eluplim=0,totEnum=0;
// float r1=0.,r2=0.,r3=0.,r4=0.,r5=0.,r6=0.,darr[10];
 float darr[10];
 char cht[200];
 wchar_t string0[11];
 if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
 else {
 base.matsteps=base.ncoorf=1;
// base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.mat=base.nblod=MXNPELX=0;nGIDmax=0;wp.nWeldGroup=0;
 base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.mat=base.nblod=MXNPEL=0;wp.nWeldGroup=0; //Establish MXNPEL
// OpenDialog1->Filter= "SIMULIA_Abq (*.abq)|*.abq;*.ABQ";
 OpenDialog1->Filter= "SIMULIA/ABAQ (*.abq)|*.inp;*.ABQ";
/////////////////////////////////////
 if(OpenDialog1->Execute())
   {ifstream ntape2(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
	if(ntape2)
	  {ofstream tmpfile("record.tmp",ios::binary,0); //Sanitize by writing file without comment/blank lines
	   if(tmpfile)
		 {do {ntape2.getline(cht,200-1);
			  if((cht[0]=='*' && cht[1]=='*') || strlen(cht)<2);else tmpfile<<cht<<"\n";
			 }
		  while (!ntape2.eof());
//		  tmpfile.clear();tmpfile.seekg(0);
		  tmpfile.close();
		  ifstream ntape("record.tmp",ios::nocreate|ios::binary,0);
		  if(ntape)
//
	  {nodeuplim=totNnum=eluplim=totEnum=0;
	   do {ntape.getline(cht,200-1);
		   if(cht[0]=='*' && cht[1]=='*')continue; //Comment ** & ***include & ***ORIENTATION
		   else if(cht[0]=='*' && (cht[1]=='H' || cht[1]=='h'))ntape.getline(cht,99); // *HEADING
		   else if(cht[0]=='*' && (cht[1]=='P' || cht[1]=='p'))continue; // *PREPRINT
		   else if(cht[0]=='*' && (cht[1]=='T' || cht[1]=='t') && (cht[2]=='E' || cht[2]=='e'))ntape.getline(cht,99); // *TEMPERATURE
		   else if(cht[0]=='*' && (cht[1]=='T' || cht[1]=='t') && (cht[2]=='R' || cht[2]=='r'))ntape.getline(cht,99); // *TRANSFORM
		   else if(cht[0]=='*' && (cht[1]=='M' || cht[1]=='m'))continue; // *MATERIAL
		   else if(cht[0]=='*' && (cht[1]=='O' || cht[1]=='o'))continue; // *output
		   else if(cht[0]=='*' && (cht[1]=='I' || cht[1]=='i') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='C' || cht[3]=='c'))continue; // *INCLUDE
		   else if(cht[0]=='*' && (cht[1]=='I' || cht[1]=='i') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='I' || cht[3]=='i')){do {ntape.getline(cht,200-1);} // *INITIAL CONDITIONS
																																while (ntape.peek()!= '*');
																															   }
		   else if(cht[0]=='*' && (cht[1]=='B' || cht[1]=='b')){do {ntape.getline(cht,200-1);} // *BOUNDARY
																while (ntape.peek()!= '*');
															   }
		   else if(cht[0]=='*' && (cht[1]=='C' || cht[1]=='c') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='T' || cht[4]=='t') && (cht[5]=='A' || cht[5]=='a'))continue; // *contact
		   else if(cht[0]=='*' && (cht[1]=='C' || cht[1]=='c') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='T' || cht[4]=='t') && (cht[5]=='O' || cht[5]=='o'))
															   {do {ntape.getline(cht,200-1);} // *contour Integral
																while (ntape.peek()!= '*');
															   }
		   else if(cht[0]=='*' && (cht[1]=='C' || cht[1]=='c') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='T' || cht[4]=='t') && (cht[5]=='R' || cht[5]=='r'))
															   {do {ntape.getline(cht,200-1);} // *controls
																while (ntape.peek()!= '*');
															   }
		   else if(cht[0]=='*' && (cht[1]=='R' || cht[1]=='r'))continue; // *RESTART
		   else if(cht[0]=='*' && (cht[1]=='D' || cht[1]=='d') && (cht[2]=='L' || cht[2]=='l')){do {ntape.getline(cht,200-1);} // *DLOAD
																								while (ntape.peek()!= '*');
																							   }
		   else if(cht[0]=='*' && (cht[1]=='D' || cht[1]=='d') && (cht[2]=='S' || cht[2]=='s')){do {ntape.getline(cht,200-1);} // *DSLOAD
																								while (ntape.peek()!= '*');
																							   }
		   else if(cht[0]=='*' && (cht[1]=='K' || cht[1]=='k')){do {ntape.getline(cht,200-1);} // *Kinematic Coupling
																while (ntape.peek()!= '*');
															   }
///////////////
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='O' || cht[6]=='o') && (cht[7]=='U' || cht[7]=='u') && (cht[8]=='T' || cht[8]=='t') && (cht[9]=='P' || cht[9]=='p'))
				  {do {ntape.getline(cht,200-1);} // *NODE OUTP
				   while (ntape.peek()!= '*');
				  }
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='F' || cht[6]=='f') && (cht[7]=='I' || cht[7]=='i') && (cht[8]=='L' || cht[8]=='l') && (cht[9]=='E' || cht[9]=='e'))
				  {do {ntape.getline(cht,200-1);} // *NODE FILE
				   while (ntape.peek()!= '*');
				  }
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='P' || cht[6]=='p') && (cht[7]=='R' || cht[7]=='r') && (cht[8]=='I' || cht[8]=='i') && (cht[9]=='N' || cht[9]=='n'))
				  {do {ntape.getline(cht,200-1);} // *NODE PRIN
				   while (ntape.peek()!= '*');
				  }
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='R' || cht[6]=='r') && (cht[7]=='E' || cht[7]=='e') && (cht[8]=='S' || cht[8]=='s') && (cht[9]=='P' || cht[9]=='p'))
				  {do {ntape.getline(cht,200-1);} // *NODE RESP
				   while (ntape.peek()!= '*');
				  }
///////////////
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o')){do {ntape.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr); // *NODE
																									totNnum++;if(nodeuplim<larr[0])nodeuplim=larr[0];
																								   }
																								while (ntape.peek()!= '*');
																							   }
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='S' || cht[2]=='s')){do {ntape.getline(cht,200-1);} // *NSET
																								while (ntape.peek()!= '*');
																							   }
		   else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='L' || cht[3]=='l'))continue; // *SOLID SECTION
		   else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='T' || cht[2]=='t') && (cht[3]=='E' || cht[3]=='e'))ntape.getline(cht,99); // *step
		   else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='T' || cht[2]=='t') && (cht[3]=='A' || cht[3]=='a'))ntape.getline(cht,99); // *static
		   else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='U' || cht[2]=='u') && (cht[3]=='R' || cht[3]=='r')){do {ntape.getline(cht,200-1);} // *Surface
																																while (ntape.peek()!= '*');
																															   }
///////////////////////////
		   else if(cht[ 0]=='*' && (cht[ 1]=='E' || cht[ 1]=='e') && (cht[ 2]=='L' || cht[ 2]=='l') && (cht[ 3]=='E' || cht[ 3]=='e') && (cht[ 4]=='M' || cht[ 4]=='m') && (cht[ 5]=='E' || cht[ 5]=='e') && (cht[ 6]=='N' || cht[ 6]=='n') && (cht[ 7]=='T' || cht[ 7]=='t') && cht[ 8]==' ' &&
								   (cht[ 9]=='O' || cht[ 9]=='o') && (cht[10]=='U' || cht[10]=='u') && (cht[11]=='T' || cht[11]=='t') && (cht[12]=='P' || cht[12]=='p') && (cht[13]=='U' || cht[13]=='u') && (cht[14]=='T' || cht[14]=='t'))
				  {do {ntape.getline(cht,200-1);} // *ELEMENT OUTPUT
				   while (ntape.peek()!= '*');
				  }
		   else if(cht[ 0]=='*' && (cht[ 1]=='E' || cht[ 1]=='e') && (cht[ 2]=='L' || cht[ 2]=='l') && (cht[ 3]=='E' || cht[ 3]=='e') && (cht[ 4]=='M' || cht[ 4]=='m') && (cht[ 5]=='E' || cht[ 5]=='e') && (cht[ 6]=='N' || cht[ 6]=='n') && (cht[ 7]=='T' || cht[ 7]=='t') && cht[ 8]==' ' &&
								   (cht[ 9]=='M' || cht[ 9]=='m') && (cht[10]=='A' || cht[10]=='a') && (cht[11]=='T' || cht[11]=='t') && (cht[12]=='R' || cht[12]=='r') && (cht[13]=='I' || cht[13]=='i') && (cht[14]=='X' || cht[14]=='x'))
				  {do {ntape.getline(cht,200-1);} // *ELEMENT MATRIX
				   while (ntape.peek()!= '*');
				  }
		   else if(cht[ 0]=='*' && (cht[ 1]=='E' || cht[ 1]=='e') && (cht[ 2]=='L' || cht[ 2]=='l') && (cht[ 3]=='E' || cht[ 3]=='e') && (cht[ 4]=='M' || cht[ 4]=='m') && (cht[ 5]=='E' || cht[ 5]=='e') && (cht[ 6]=='N' || cht[ 6]=='n') && (cht[ 7]=='T' || cht[ 7]=='t') && cht[ 8]==' ' &&
								   (cht[ 9]=='R' || cht[ 9]=='r') && (cht[10]=='E' || cht[10]=='e') && (cht[11]=='S' || cht[11]=='s') && (cht[12]=='P' || cht[12]=='p') && (cht[13]=='O' || cht[13]=='o') && (cht[14]=='N' || cht[14]=='n'))
				  {do {ntape.getline(cht,200-1);} // *ELEMENT RESPON
				   while (ntape.peek()!= '*');
				  }
///////////////////////////
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='E' || cht[3]=='e'))
																			{do {ntape.getline(cht,200-1);
																				 parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT
																				 if(nic-1==4 || nic-1==6 || nic-1==8);
																				 else {honk<<"Halt: Unsupported element with #nodes "<<nic-1<<"\n";
//					 for(in=0;in<100;in++)cht[in]=' ';
//					 strcpy(cht,"Unsupported element with #nodes ");
//					 strcat(cht,IntToStr(nic-1).t_str());
//					 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(cht,L"Halt",MB_OK);
																					   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(_ltow(nic-1,string0,10),L"Halt: Unsupported element with #nodes",MB_OK);return;
																					  }
																				 totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																				 if(MXNPEL<nic)MXNPEL=nic;
																				}
																			 while (ntape.peek()!= '*');
																			}
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='S' || cht[3]=='s'))
				  {
/////////////////////////
				   for(i=14;i<strlen(cht)-1;i++)if((cht[i  ]=='W' || cht[i  ]=='w') &&
												   (cht[i+1]=='E' || cht[i+1]=='e') &&
												   (cht[i+2]=='L' || cht[i+2]=='l') &&
												   (cht[i+3]=='D' || cht[i+3]=='d'))
												  {jsw=1;
												   for(j=14;j<strlen(cht)-1;j++)if((cht[j]=='A' || cht[j]=='a') && (cht[j+1]=='L' || cht[j+1]=='l') && (cht[j+2]=='L' || cht[j+2]=='l'))
																				  {jsw=0;
honk<<" ImportAbaABQExecute() WARNING: ELSET, ELSET=...allWELD/WELDall... was found in dataset. Current VFT policy --> Ignore because it interferes with WeldGroups.\n";
																				   break;
																				  }
												   if(jsw)wp.nWeldGroup=wp.nWeldGroup+1;
												   break;
												  }
/////////////////////////
				   do {ntape.getline(cht,200-1);} // *ELSET
				   while (ntape.peek()!= '*');
				  }

		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && cht[3]==' ' && (cht[4]=='F' || cht[4]=='f') && (cht[5]=='I' || cht[5]=='i'))continue; // *EL FILE
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && cht[3]==' ' && (cht[4]=='P' || cht[4]=='p') && (cht[5]=='R' || cht[5]=='r'))continue; // *EL PRINT

		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='A' || cht[3]=='a'))ntape.getline(cht,200-1); // *ELASTIC
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='X' || cht[2]=='x') && (cht[3]=='P' || cht[3]=='p'))ntape.getline(cht,200-1); // *EXPANSION
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='D' || cht[3]=='d'))break; // *end step
		   else {honk<<"WARNING: The following unsupported datacard found in *.abq\n";
				 honk<<cht[0]<<" "<<cht[1]<<" "<<cht[2]<<" "<<cht[3]<<"\n";
				 do {ntape.getline(cht,200-1);} // Unknown
				 while (ntape.peek()!= '*');
				}
		  }
	   while (!ntape.eof());
	   ntape.close();
//	   base.matsteps=matstep;
honk<<nodeuplim<<" "<<totNnum<<" "<<eluplim<<" "<<totEnum<<" "<<MXNPEL<<" DDDDDDDD\n";
	   if(wp.nWeldGroup==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups (*ELSET, ELSET=...weld...) found in *.abq",L"Terminate",MB_OK);exit(0);}
	   base.npoin=nodeuplim;base.nelt=eluplim;
	   if(nodeuplim != totNnum)
		 {honk<<nodeuplim<<" Nonconsecutive node numbers in *.abq "<<totNnum<<"\n";
////			  for(in=0;in<100;in++)cht[in]=' ';
////			  strcpy(cht,IntToStr(nodeuplim).t_str());
////			  strcat(cht," There are nonconsecutive node numbers in *.abq ");
////			  strcat(cht,IntToStr(totNnum).t_str());
////			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(cht,"Warning",MB_OK);

//		  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive node numbers in *.abq ",L"Warning",MB_OK);
		 }
	   if(eluplim != totEnum)
		 {honk<<eluplim<<" Nonconsecutive element numbers in *.abq "<<totEnum<<"\n";
////			  for(in=0;in<100;in++)cht[in]=' ';
////			  strcpy(cht,IntToStr(eluplim).t_str());
////			  strcat(cht,"There are nonconsecutive element numbers in *.msh ");
////			  strcat(cht,IntToStr(base.nelt).t_str());
////			  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(cht,"Warning",MB_OK);

//		  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive element numbers in *.abq ",L"Warning",MB_OK);
		 }
	   if(base.nelt> LONG_INT/t3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Excessive #elements in geometry file",L"Terminate",MB_OK);exit(0);}
	   if(base.npoin>0 && base.nelt>0)
//		 {FDdynmem_manageD(1,base.npoin,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
		 {FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
//		  ifstream ntape1(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
		  ifstream ntape1("record.tmp",ios::nocreate|ios::binary,0);
		  if(ntape1)
			{ipid=1;nGID=1;

wp.nWeldGroup=0;

			 for(in=0;in<NDF*base.npoin;in++)base.c1[in]=0.;
			 for(in=0;in<base.nelt;in++)base.arELEM[in]=1;
			 for(in=0;in<base.nelt;in++)base.el_map[in]= -1;
			 for(in=0;in<base.npoin;in++)base.node_map[in]= -1;
			 do {ntape1.getline(cht,200-1);
				 if(cht[0]=='*' && cht[1]=='*')continue; //Comment ** & ***include & ***ORIENTATION
				 else if(cht[0]=='*' && (cht[1]=='H' || cht[1]=='h'))ntape1.getline(cht,99); // *HEADING
				 else if(cht[0]=='*' && (cht[1]=='P' || cht[1]=='p'))continue; // *PREPRINT
				 else if(cht[0]=='*' && (cht[1]=='T' || cht[1]=='t') && (cht[2]=='E' || cht[2]=='e'))ntape1.getline(cht,99); // *TEMPERATURE
				 else if(cht[0]=='*' && (cht[1]=='T' || cht[1]=='t') && (cht[2]=='R' || cht[2]=='r'))ntape1.getline(cht,99); // *TRANSFORM
				 else if(cht[0]=='*' && (cht[1]=='M' || cht[1]=='m'))continue; // *MATERIAL
				 else if(cht[0]=='*' && (cht[1]=='O' || cht[1]=='o'))continue; // *output
//				 else if(cht[0]=='*' && (cht[1]=='I' || cht[1]=='i')){do {ntape1.getline(cht,200-1);} // *INITIAL CONDITIONS
//																	  while (ntape1.peek()!= '*');
//																	 }
				 else if(cht[0]=='*' && (cht[1]=='I' || cht[1]=='i') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='C' || cht[3]=='c'))continue; // *INCLUDE
				 else if(cht[0]=='*' && (cht[1]=='I' || cht[1]=='i') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='I' || cht[3]=='i')){do {ntape1.getline(cht,200-1);} // *INITIAL CONDITIONS
																																	  while (ntape1.peek()!= '*');
																																	 }
				 else if(cht[0]=='*' && (cht[1]=='B' || cht[1]=='b')){do {ntape1.getline(cht,200-1);} // *BOUNDARY
																	  while (ntape1.peek()!= '*');
																	 }
//				 else if(cht[0]=='*' && (cht[1]=='C' || cht[1]=='c')){do {ntape1.getline(cht,200-1);} // *contour Integral
//																	  while (ntape1.peek()!= '*');
//																	 }


		   else if(cht[0]=='*' && (cht[1]=='C' || cht[1]=='c') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='T' || cht[4]=='t') && (cht[5]=='A' || cht[5]=='a'))continue; // *contact
		   else if(cht[0]=='*' && (cht[1]=='C' || cht[1]=='c') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='T' || cht[4]=='t') && (cht[5]=='O' || cht[5]=='o'))
															   {do {ntape1.getline(cht,200-1);} // *contour Integral
																while (ntape1.peek()!= '*');
															   }
		   else if(cht[0]=='*' && (cht[1]=='C' || cht[1]=='c') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='N' || cht[3]=='n') && (cht[4]=='T' || cht[4]=='t') && (cht[5]=='R' || cht[5]=='r'))
															   {do {ntape1.getline(cht,200-1);} // *controls
																while (ntape1.peek()!= '*');
															   }
				 else if(cht[0]=='*' && (cht[1]=='R' || cht[1]=='r'))continue; // *RESTART
//				 else if(cht[0]=='*' && (cht[1]=='D' || cht[1]=='d')){do {ntape1.getline(cht,200-1);} // *DLOAD
//																	  while (ntape1.peek()!= '*');
//																	 }
		   else if(cht[0]=='*' && (cht[1]=='D' || cht[1]=='d') && (cht[2]=='L' || cht[2]=='l')){do {ntape1.getline(cht,200-1);} // *DLOAD
																								while (ntape1.peek()!= '*');
																							   }
		   else if(cht[0]=='*' && (cht[1]=='D' || cht[1]=='d') && (cht[2]=='S' || cht[2]=='s')){do {ntape1.getline(cht,200-1);} // *DSLOAD
																								while (ntape1.peek()!= '*');
																							   }
				 else if(cht[0]=='*' && (cht[1]=='K' || cht[1]=='k')){do {ntape1.getline(cht,200-1);} // *Kinematic Coupling
																	  while (ntape1.peek()!= '*');
																	 }
///////////////
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='O' || cht[6]=='o') && (cht[7]=='U' || cht[7]=='u') && (cht[8]=='T' || cht[8]=='t') && (cht[9]=='P' || cht[9]=='p'))
				  {do {ntape1.getline(cht,200-1);} // *NODE OUTP
				   while (ntape1.peek()!= '*');
				  }
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='F' || cht[6]=='f') && (cht[7]=='I' || cht[7]=='i') && (cht[8]=='L' || cht[8]=='l') && (cht[9]=='E' || cht[9]=='e'))
				  {do {ntape1.getline(cht,200-1);} // *NODE FILE
				   while (ntape1.peek()!= '*');
				  }
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='P' || cht[6]=='p') && (cht[7]=='R' || cht[7]=='r') && (cht[8]=='I' || cht[8]=='i') && (cht[9]=='N' || cht[9]=='n'))
				  {do {ntape1.getline(cht,200-1);} // *NODE PRIN
				   while (ntape1.peek()!= '*');
				  }
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==' ' &&
								  (cht[6]=='R' || cht[6]=='r') && (cht[7]=='E' || cht[7]=='e') && (cht[8]=='S' || cht[8]=='s') && (cht[9]=='P' || cht[9]=='p'))
				  {do {ntape1.getline(cht,200-1);} // *NODE RESP
				   while (ntape1.peek()!= '*');
				  }
///////////////
				 else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o')){do {ntape1.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr); // *NODE
																										  in=larr[0]-1;base.c1[NDF*in]=darr[0];base.c1[NDF*in+1]=darr[1];base.c1[NDF*in+2]=darr[2];
																										  base.node_map[in]=1;
																										 }
																									  while (ntape1.peek()!= '*');
																									 }
				 else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='S' || cht[2]=='s')){do {ntape1.getline(cht,200-1);} // *NSET
																									  while (ntape1.peek()!= '*');
																									 }
				 else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='L' || cht[3]=='l'))continue; // *SOLID SECTION
				 else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='T' || cht[2]=='t') && (cht[3]=='E' || cht[3]=='e'))ntape1.getline(cht,99); // *step
				 else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='T' || cht[2]=='t') && (cht[3]=='A' || cht[3]=='a'))ntape1.getline(cht,99); // *static
				 else if(cht[0]=='*' && (cht[1]=='S' || cht[1]=='s') && (cht[2]=='U' || cht[2]=='u') && (cht[3]=='R' || cht[3]=='r')){do {ntape1.getline(cht,200-1);} // *Surface
																																	  while (ntape1.peek()!= '*');
																																	 }
///////////////////////////
		   else if(cht[ 0]=='*' && (cht[ 1]=='E' || cht[ 1]=='e') && (cht[ 2]=='L' || cht[ 2]=='l') && (cht[ 3]=='E' || cht[ 3]=='e') && (cht[ 4]=='M' || cht[ 4]=='m') && (cht[ 5]=='E' || cht[ 5]=='e') && (cht[ 6]=='N' || cht[ 6]=='n') && (cht[ 7]=='T' || cht[ 7]=='t') && cht[ 8]==' ' &&
								   (cht[ 9]=='O' || cht[ 9]=='o') && (cht[10]=='U' || cht[10]=='u') && (cht[11]=='T' || cht[11]=='t') && (cht[12]=='P' || cht[12]=='p') && (cht[13]=='U' || cht[13]=='u') && (cht[14]=='T' || cht[14]=='t'))
				  {do {ntape1.getline(cht,200-1);} // *ELEMENT OUTPUT
				   while (ntape1.peek()!= '*');
				  }
		   else if(cht[ 0]=='*' && (cht[ 1]=='E' || cht[ 1]=='e') && (cht[ 2]=='L' || cht[ 2]=='l') && (cht[ 3]=='E' || cht[ 3]=='e') && (cht[ 4]=='M' || cht[ 4]=='m') && (cht[ 5]=='E' || cht[ 5]=='e') && (cht[ 6]=='N' || cht[ 6]=='n') && (cht[ 7]=='T' || cht[ 7]=='t') && cht[ 8]==' ' &&
								   (cht[ 9]=='M' || cht[ 9]=='m') && (cht[10]=='A' || cht[10]=='a') && (cht[11]=='T' || cht[11]=='t') && (cht[12]=='R' || cht[12]=='r') && (cht[13]=='I' || cht[13]=='i') && (cht[14]=='X' || cht[14]=='x'))
				  {do {ntape1.getline(cht,200-1);} // *ELEMENT MATRIX
				   while (ntape1.peek()!= '*');
				  }
		   else if(cht[ 0]=='*' && (cht[ 1]=='E' || cht[ 1]=='e') && (cht[ 2]=='L' || cht[ 2]=='l') && (cht[ 3]=='E' || cht[ 3]=='e') && (cht[ 4]=='M' || cht[ 4]=='m') && (cht[ 5]=='E' || cht[ 5]=='e') && (cht[ 6]=='N' || cht[ 6]=='n') && (cht[ 7]=='T' || cht[ 7]=='t') && cht[ 8]==' ' &&
								   (cht[ 9]=='R' || cht[ 9]=='r') && (cht[10]=='E' || cht[10]=='e') && (cht[11]=='S' || cht[11]=='s') && (cht[12]=='P' || cht[12]=='p') && (cht[13]=='O' || cht[13]=='o') && (cht[14]=='N' || cht[14]=='n'))
				  {do {ntape1.getline(cht,200-1);} // *ELEMENT RESPON
				   while (ntape1.peek()!= '*');
				  }
///////////////////////////
				 else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='E' || cht[3]=='e'))
																				  {do {ntape1.getline(cht,200-1);parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT
																					   if(nic-1==4)eltype=5;
																					   else if(nic-1==6)eltype=7;
																					   else if(nic-1==8)eltype=8;
																					   else {honk<<"Halt: Unsupported element with #nodes "<<nic-1<<"\n";
//					 for(in=0;in<100;in++)cht[in]=' ';
//					 strcpy(cht,"Unsupported element with #nodes ");
//					 strcat(cht,IntToStr(nic-1).t_str());
//					 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(cht,L"Halt",MB_OK);
																							 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(_ltow(nic-1,string0,10),L"Halt: Unsupported element with #nodes",MB_OK);return;
																							}
																					   n8=nic-1;in=larr[0]-1;for(i=0;i<n8;i++)base.nop1[MXNPEL*in+i]=larr[i+1]-1;
																					   base.matno[in]=eltype*t7+n8*t3+ipid-1;base.el_map[in]=in;
																					  }
																				   while (ntape1.peek()!= '*');
																				  }
				 else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='S' || cht[3]=='s')) // *ELSET
				   {in=isw=jsw=0;for(i=0;i<strlen(cht)-1;i++)if(cht[i]==',')in++;
/////////////////////////
					for(i=14;i<strlen(cht)-1;i++)if((cht[i  ]=='W' || cht[i  ]=='w') &&
													(cht[i+1]=='E' || cht[i+1]=='e') &&
													(cht[i+2]=='L' || cht[i+2]=='l') &&
													(cht[i+3]=='D' || cht[i+3]=='d'))
												   {jsw=1;
													for(j=14;j<strlen(cht)-1;j++)if((cht[j]=='A' || cht[j]=='a') && (cht[j+1]=='L' || cht[j+1]=='l') && (cht[j+2]=='L' || cht[j+2]=='l'))
																				   {jsw=0;
//honk<<" WARNING: ELSET, ELSET=...allWELD/WELDall... was found in dataset. Current VFT policy --> Ignore because it interferes with WeldGroups.\n";
																					break;
																				   }
													break;
												   }

/////////////////////////
					if(in==2){do {ntape1.getline(cht,200-1);
								  if(jsw){parse_cdm(cht,3,&nic,&nrc,larr,darr);
//honk<<in<<" "<<larr[0]<<" "<<larr[1]<<" "<<larr[2]<<" ELSET "<<nGID<<" "<<strlen(cht)<<" "<<base.nelt-(larr[1]-larr[0]+1)<<"\n";
										  if(larr[1]-larr[0]+1<base.nelt)for(i=larr[0]-1;i<larr[1];i=i+larr[2])
																		   {
eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
																			if(ieGID==0){isw=1;base.matno[i]=base.matno[i]+nGID;}
																		   }
										 }
								 }
							  while (ntape1.peek()!= '*');
							  if(jsw && isw && larr[1]-larr[0]+1<base.nelt){nGID++;wp.nWeldGroup=wp.nWeldGroup+1;}
							 }
					else {do {ntape1.getline(cht,200-1);if(jsw){parse_cdmQ(cht,8,&nic,&nrc,larr,darr,strlen(cht));
																if(nic>8)nic=8;
																for(i=0;i<nic;i++){
eltype=base.matno[larr[i]-1]/t7;bscode=(base.matno[larr[i]-1]-eltype*t7)/t5;node=(base.matno[larr[i]-1]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[larr[i]-1]-eltype*t7-bscode*t5-node*t3;
																				   if(ieGID==0){isw=1;base.matno[larr[i]-1]=base.matno[larr[i]-1]+nGID;}
//honk<<i+1<<" "<<nGID<<" ELSET_II "<<larr[i]<<"\n";
																				  }
															   }
							 }
						  while (ntape1.peek()!= '*');
						  if(jsw && isw){nGID++;wp.nWeldGroup=wp.nWeldGroup+1;}
						 }
				   }
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && cht[3]==' ' && (cht[4]=='F' || cht[4]=='f') && (cht[5]=='I' || cht[5]=='i'))continue; // *EL FILE
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && cht[3]==' ' && (cht[4]=='P' || cht[4]=='p') && (cht[5]=='R' || cht[5]=='r'))continue; // *EL PRINT

				 else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='A' || cht[3]=='a'))ntape1.getline(cht,200-1); // *ELASTIC
				 else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='X' || cht[2]=='x') && (cht[3]=='P' || cht[3]=='p'))ntape1.getline(cht,200-1); // *EXPANSION
				 else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='D' || cht[3]=='d'))break; // *end step
				 else {do {ntape1.getline(cht,200-1);} // Unknown
					   while (ntape1.peek()!= '*');
					  }
				}
			 while (!ntape1.eof());
			 old_npoin=new_npoin=base.npoin;new_nelt=base.nelt;new_mat=base.mat;new_ncoorf=base.ncoorf;nGID=wp.nWeldGroup+1;
			 ntape1.close();DeleteFile("record.tmp");
//			 FDbase_indat(1,shapecombo);
			 FDbase_indat(1,shapecombo,iplotflag,nColRes);
//////////////////////////////////////
	if(nGID<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No geometry IDs found",L"Halt",MB_OK);return;}
//    else {if(iPaintyesno/10==0){FDelemfacets2();iPaintyesno=10;iCullyesno=0;}iCircleplot=1;Invalidate();}
	else {if(iPaintyesno/10==0){
//								FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
								if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
//								else {FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);}
//								iPaintyesno=10;iCullyesno=0;
								else {
//								FDcomp_nGID();
FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
								FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);}
								iPaintyesno=10+1;iCullyesno=0;
							   }

//			 stateVFT=0;FD_LButtonstatus=11;
			 stateVFT=2;FD_LButtonstatus=11;

// SpeedButton1->Down=false;
// SpeedButton2->Down=true;

			 iplotflag=1;
			 iCircleplot=1;Invalidate();
		 }



			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen input file",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Nodes/elements/GID missing from *.abq datafile",L"Failure",MB_OK);}
//	  }
//	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}



//			 ntape.close();
//			 DeleteFile("record.tmp");// Need to destroy
			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen *.tmp file",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.tmp file",L"Failure",MB_OK);}
	   ntape2.close();GeomFileName=OpenDialog1->FileName;
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.abq file",L"Failure",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
////////////////////////////////////
//   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
////////////////////////////////////
	  }
}
*/
//---------------------------------------------------------------------------
void __fastcall TForm1::ImportAbaInpExecute(TObject *Sender){ImportAba_prog(0);
//long ig=ProcessAllWG(base.nelt,base.nop1,base.matno,wp.nWeldGroup,base.groupsname);
//wp.nWeldGroup=ig;
//			 Invalidate();
															}
//---------------------------------------------------------------------------
void __fastcall TForm1::ImportAbaABQExecute(TObject *Sender){ImportAba_prog(1);
//long ig=ProcessAllWG(base.nelt,base.nop1,base.matno,wp.nWeldGroup,base.groupsname);
//wp.nWeldGroup=ig;
//			 Invalidate();
															}
//---------------------------------------------------------------------------
void TForm1::ImportAba_prog(int iswtype)
{
// Note#1: When reading XXX_ABA.inp files, this subroutine does NOT read "INCLUDEd" XXX_bc.inp files below
//********** Boundary Condition Definition **********
//*INCLUDE, INPUT=testingVFT_bc.inp
//
// Note#2: Node cards must precede element cards in this version
//*NODE, SYSTEM=R, NSET=NDALL, INPUT=testingVDT_node.inp
//*ELEMENT,TYPE=C3D8R,ELSET=ALLEL, INPUT=testingVDT_element.inp
//
// Note#3: iswtype=0->Abaqus *.inp;1->Abaqus *.abq
// Multiple node & element INCLUDEs are accommodated.
// nodelolim,nodeuplim,eluplim begin with 1 (not 0)
// DIRE WARNING: "Node Prin/Node Out/etc" cards MUST PRECEDE "Node" card below, because of "No" detection
//               Ditto for Ele & Material, etc
// Note current convention: *.msh & Simulia/Abaqus *.inp/*.abq files contain weld groups (never weld passes), regardless of name
//     Hence wp.nWeldGroup is incremented but not wp.nWeldPass.
//
// ProcessAllWG() above was an attempt to accommodate "multiple base metal material ELSETS" but
//   it crashes large Abaqus models??? EFP 6/19/2014
 int nic=0,nic1=0,nrc=0,isw=0,jsw=0,iswNode=0,iswElem=0,ksw=0,kswELSET=0,
   *attendEl=NULL;
 long
// itype=0,
in=0,kn=0,klim=0,inp=0,ip=0,ii=0,ix=0,ie=0,im=0,
//n2=0,n3=0,n4=0,n5=0,n6=0,n7=0,
n8=0,
//dresno=0,sresno=0,
dummy=0,iswELSET2=0,isum=0,
//ltype=0,
i=0,j=0,k=0,kk=0,kp=0,jrec=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000,larr[10],larr1[10],
//*GIDarr=NULL,
//ipid=0,MXNPELX=0
ipid=0
//,MUL=1,inpGIDmax= -1,matstep=0
//,nodeuplim=0,totNnum=0,eluplim=0,totEnum=0,nGIDmax=0;
,nodeuplim=0,nodelolim=0,totNnum=0,eluplim=0,ellolim=0,totEnum=0,sumWG=0,sumlim=0,sumELSETel=0,totBMG=0,totWG=0
, *revnode_map=NULL;
// float r1=0.,r2=0.,r3=0.,r4=0.,r5=0.,r6=0.,darr[10];
 float fval=0.,darr[10];
 char cht[200],extensChar[]=".inp",chELSET[78+1], *temp_cht=NULL, *fnNeed1=NULL,*fnNeed2=NULL,
	  ch_I='I',ch_i='i',ch_N='N',ch_n='n',ch_P='P',ch_p='p',ch_U='U',ch_u='u',ch_T='T',ch_t='t',ch_eq='=',chNULL=' ';
 wchar_t string0[11];
////////////////
String *tw_groupsname=NULL;
////////////////
 if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
 else {

/////////////////////////////
/////////////////////////////
/////////////////////////////
/////////////////////////////
/////////////////////////////
//if(strstr(sortie1,sortie2))honk<<sortie2<<"\n";else honk<<"NULL\n";
//if(1==1)exit(0);
/////////////////////////////
/////////////////////////////
/////////////////////////////
/////////////////////////////
/////////////////////////////

 base.matsteps=base.ncoorf=1;
 base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.mat=base.nblod=0;
 base.allGrp=1; //Try insisting on a base group???
 base.ELSETelsum=MXNPEL=wp.nWeldGroup=0; //Establish MXNPEL
// OpenDialog1->Filter= "SIMULIA/ABAQ (*.abq)|*.inp;*.ABQ";

// if(iswtype)OpenDialog1->Filter= "SIMULIA_Abq (*.abq)|*.abq;*.ABQ|SIMULIA_Abq (*.inp)|*.inp;*.INP";
// else       OpenDialog1->Filter= "SIMULIA_Abq (*.inp)|*.inp;*.INP|SIMULIA_Abq (*.abq)|*.abq;*.ABQ";
 if(iswtype)OpenDialog1->Filter= "SIMULIA_Abq (*.abq)|*.abq;*.ABQ";
 else       OpenDialog1->Filter= "SIMULIA_Abq (*.inp)|*.inp;*.INP";
/////////////////////////////////////
 if(OpenDialog1->Execute())
   {ifstream ntape2(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
	if(ntape2)
	  {

gWsiAlias=(String)modelName_g; // where char modelName_g[260] in *.h
honk<<gWsiAlias.t_str()<<" gWsiAliasImportAbmmmmmm\n";
// Perhaps the above should be moved within   if(ntape){  ??? EFP 2/27/2012
///////////////////////////// end

	   ofstream tmpfile("record.tmp",ios::binary,0); //Sanitize by writing file without comment/blank lines
	   if(tmpfile)
		 {do {ntape2.getline(cht,200-1);
			  if((cht[0]=='*' && cht[1]=='*') || strlen(cht)<2)continue;
			  else tmpfile<<cht<<"\n";
			 }
		  while (!ntape2.eof());
		  tmpfile.close();
		  ifstream ntape("record.tmp",ios::nocreate|ios::binary,0);
		  if(ntape)
//
	  {
//////////////////////////////////////////////////////////////
//TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//////////////////////////////////////////////////////////////
	   nodeuplim=totNnum=eluplim=totEnum=0;nodelolim=ellolim=LONG_INT;
	   do {ntape.getline(cht,200-1);
		   if(cht[0]=='*' && cht[1]=='*')continue; //Comment ** & ***include & ***ORIENTATION
//		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o'))
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==',')
				  {iswNode=0;
int ck_INPUT=0;
for(j=8;j<int(strlen(cht))-4;j++){


							 ck_INPUT=0;
							 if(cht[j-5]==ch_I || cht[j-5]==ch_i)ck_INPUT++;
							 if(cht[j-4]==ch_N || cht[j-4]==ch_n)ck_INPUT++;
							 if(cht[j-3]==ch_P || cht[j-3]==ch_p)ck_INPUT++;
							 if(cht[j-2]==ch_U || cht[j-2]==ch_u)ck_INPUT++;
							 if(cht[j-1]==ch_T || cht[j-1]==ch_t)ck_INPUT++;
							 if(cht[j]==ch_eq)ck_INPUT++;
							 if(ck_INPUT==6)
											{iswNode=1;
											 for(in=j+1;in<int(strlen(cht))-1;in++)if(cht[in]=='.')break;
											 fnNeed1=new char[in-j-1+strlen(extensChar)+1];
											 for(kk=j+1;kk<in;kk++)fnNeed1[kk-j-1]=cht[kk];
//											 StringCchCat(fnNeed1,in-j-1+strlen(extensChar)+1,extensChar);

////for(k=0;k<in-j-1+strlen(extensChar)+1;k++)honk<<fnNeed1[k]<<" fnNeed1\n";
////if(k> -1)exit(0);
											 fnNeed1[in+0-j-1]='.';fnNeed1[in+1-j-1]='i';fnNeed1[in+2-j-1]='n';fnNeed1[in+3-j-1]='p';fnNeed1[in+4-j-1]='\0';
											 ifstream viewfile1(fnNeed1,ios::nocreate);
											 if(viewfile1){
honk<<" starting to read NODE file\n";
														   do {viewfile1.getline(cht,200-1);
//															   parse_cdm(cht,4,&nic,&nrc,larr,darr); // *NODE
															   if(strlen(cht))
																 {parse_cdm3ff(cht,4,&nic,&nrc,larr,darr);
/////////////////////
//honk<<larr[0]<<" velaq "<<darr[0]<<" "<<darr[1]<<" "<<darr[2]<<"\n";
//if(1==1)exit(0);
/////////////////////
																  if(nodeuplim<larr[0])nodeuplim=larr[0];
																  if(nodelolim>larr[0])nodelolim=larr[0];
																  totNnum++;
																 }
															  }
//														   while (viewfile1.peek()!= '*');
														   while (!viewfile1.eof());
honk<<" finished to read NODE file\n";
														   viewfile1.close();
//totNnum--;
//honk<<totNnum<<" First totNnum from node coord file\n";
														  }
											 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Node *.inp file not found",L"Terminate",MB_OK);exit(0);}
											 delete [] fnNeed1; *fnNeed1=NULL; // NODE, stored in fnNeed1 file
											 break;
											}
							}
				   if(!iswNode)
					 {do {ntape.getline(cht,200-1);
////						  parse_cdm(cht,4,&nic,&nrc,larr,darr); // *NODE
//						  parse_cdm3f(cht,4,&nic,&nrc,larr,darr);
						  parse_cdm3ff(cht,4,&nic,&nrc,larr,darr);
						  if(nodeuplim<larr[0])nodeuplim=larr[0];
						  if(nodelolim>larr[0])nodelolim=larr[0];
						  totNnum++; // This totNum might be +1 wrong.
//honk<<nodeuplim<<" "<<nodelolim<<" "<<totNnum<<" "<<cht<<" Node-1st pass\n";

						 }
					  while (ntape.peek()!= '*');
					 }
				  }


//		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='E' || cht[3]=='e'))
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='M' || cht[4]=='m') && (cht[5]=='E' || cht[5]=='e') && (cht[6]=='N' || cht[6]=='n') && (cht[7]=='T' || cht[7]=='t') && cht[8]==',')
																			{iswElem=0;
for(j=8;j<int(strlen(cht))-1;j++)if((cht[j-5]=='I' || cht[j-5]=='i') &&
							   (cht[j-4]=='N' || cht[j-4]=='n') &&
							   (cht[j-3]=='P' || cht[j-3]=='p') &&
							   (cht[j-2]=='U' || cht[j-2]=='u') &&
							   (cht[j-1]=='T' || cht[j-1]=='t') &&
								cht[j]=='='){
											 iswElem=1;
											 for(in=j+1;in<int(strlen(cht))-1;in++)if(cht[in]=='.')break;
											 fnNeed2=new char[in-j-1+strlen(extensChar)+1];
											 for(kk=j+1;kk<in;kk++)fnNeed2[kk-j-1]=cht[kk]; //StringCchCat(fnNeed2,in-j-1+strlen(extensChar)+1,extensChar);
											 fnNeed2[in+0-j-1]='.';fnNeed2[in+1-j-1]='i';fnNeed2[in+2-j-1]='n';fnNeed2[in+3-j-1]='p';fnNeed2[in+4-j-1]='\0';
											 ifstream viewfile2(fnNeed2,ios::nocreate);
											 if(viewfile2){
honk<<" starting to read ELEM file\n";
														   do {viewfile2.getline(cht,200-1);
															   for(i=0;i<10;i++)larr[i]=0;
															   parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT, stored in fnNeed2 file
//honk<<larr[0]<<" trackEfile "<<nic<<" "<<nrc<<" "<<strlen(cht)<<"\n";
//honk<<larr[1]<<" "<<larr[2]<<" "<<larr[3]<<" "<<larr[4]<<" "<<larr[5]<<" "<<larr[6]<<" "<<larr[7]<<" "<<larr[8]<<"\n";
//if(1==1)exit(0);
															   if(nic-1==4) //Caution: eluplim & ellolim begin with 1
																 {totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Correction EFP 6/28/2011
																 }
															   else if(nic-1==5)
																 {nic=5;totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==6)
																 {totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==7)
																 {nic=7;totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==8)
																 {totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(!larr[8])viewfile2.getline(cht,200-1); //Read extra line but assume NX 8-n  EFP 4/05/2012
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==9)
																 {nic=9;totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else break; //Preceding abort does not work???
															  }
														   while (!viewfile2.eof());
honk<<" finished to read ELEM file\n";
														   viewfile2.close();
														  }
											 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Element *.inp file not found",L"Terminate",MB_OK);exit(0);}
											 delete [] fnNeed2; *fnNeed2=NULL; // NODE, stored in fnNeed2 file
											 break;
											}
//////////
																			 if(!iswElem)
																			   {do {ntape.getline(cht,200-1); // This might be +1 wrong
																					for(i=0;i<10;i++)larr[i]=0;
																					parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT
//honk<<larr[0]+1<<" trackE "<<nic<<"\n";
															   if(nic-1==4)
																 {totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Correction EFP 6/28/2011
																 }
															   else if(nic-1==5)
																 {nic=5;totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==6)
																 {totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==7)
																 {nic=7;totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==8)
																 {totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(!larr[8])ntape.getline(cht,200-1); //Read extra line but assume NX 8-n  EFP 4/05/2012
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
															   else if(nic-1==9)
																 {nic=9;totEnum++;if(eluplim<larr[0])eluplim=larr[0];
																  if(ellolim>larr[0])ellolim=larr[0];
																  if(MXNPEL<nic-1)MXNPEL=nic-1;//Allow for possible trailing comma EFP 6/28/2011
																 }
//															   else {honk<<"Halt1: Unsupported element with #nodes "<<nic-1<<"\n";
//																	 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(_ltow(nic-1,string0,10),L"Halt1: Unsupported element with #nodes",MB_OK);
//																	 exit(0);
//																	}
															   else break; //Preceding abort does not work???



																				   }
																				while (ntape.peek()!= '*');
																			   }
																			}
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='S' || cht[3]=='s'))
				  {
//Caution: Remember that strlen() already excludes end-of-line, so check that the following is correct. EFP 6/19/2014
				   for(i=7;i<int(strlen(cht))-1;i++)if(cht[i]=='=')break;
				   for(jrec=i+1;jrec<int(strlen(cht))-1;jrec++)if(cht[jrec]!=' ')break;
				   k=0;
				   jsw=0;
				   if(k==0){base.allGrp=base.allGrp+1;
							for(i=jrec;i<int(strlen(cht))-1;i++){if(cht[i  ]=='W' || cht[i  ]=='w')
														   {if(i+1<int(strlen(cht))){if(cht[i+1]=='D' || cht[i+1]=='d'){jsw=1;break;}
																				else if(cht[i+1]=='P' || cht[i+1]=='p'){jsw=1;break;}
																				else if(cht[i+1]=='G' || cht[i+1]=='g'){jsw=1;break;}
																				else if(cht[i+1]=='E' || cht[i+1]=='e')
																					   {if(i+3<int(strlen(cht)))
																						  {if((cht[i+2]=='L' || cht[i+2]=='l') &&
																							  (cht[i+3]=='D' || cht[i+3]=='d')){jsw=1;break;}
																						  }
																						else break;
																					   }
																				else break;
																			   }
															else break;
														   }  // Accept WD, WP, WG and WELD
																}
							if(jsw)wp.nWeldGroup=wp.nWeldGroup+1;
						   }
////////////////////////
				   do {ntape.getline(cht,200-1);
///////////////// Start EMERGENCY check to exclude ELSET alphabetic data  EFP 4/23/2011
					   for(i=0;i<int(strlen(cht))-1;i++)
						 {if(cht[i]==',' || cht[i]==' ' || cht[i]=='0' || cht[i]=='1' || cht[i]=='2' || cht[i]=='3' || cht[i]=='4' ||
														   cht[i]=='5' || cht[i]=='6' || cht[i]=='7' || cht[i]=='8' || cht[i]=='9')continue;
						  else {
//						        extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Please remove unsupported *ELSET card with non-numeric data from *.abq/*.inp",L"Terminate",MB_OK);exit(0);
honk<<"\n"<<cht<<" Warning: ELSET of ELSETs datacard found\n";break;
							   }
						 }
///////////////// End
					  } // *ELSET
				   while (ntape.peek()!= '*');
				  }
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='D' || cht[3]=='d'))
				  {if(ntape.peek()!= '*')break; // multiple use for *End/*End Part/*End Assembly/*End Instance/*End Step  EFP 4/22/2011
				   else continue;
				  }
				   // *end step CORRECTED EFP 10/22/2010
		   else {if(iswtype)honk<<"WARNING: The following unsupported datacard found in *.abq\n";
				 else       honk<<"WARNING: The following unsupported datacard found in *.inp\n";
				 honk<<cht[0]<<" "<<cht[1]<<" "<<cht[2]<<" "<<cht[3]<<"\n";
				 while (ntape.peek()!= '*')ntape.getline(cht,200-1);
				}
		  }
	   while (!ntape.eof());
///////////////////////////
//Screen->Cursor=Save_Cursor;
///////////////////////////
	   ntape.close();
//	   base.matsteps=matstep;
honk<<nodeuplim<<" "<<nodelolim<<" "<<totNnum<<" "<<eluplim<<" "<<ellolim<<" "<<totEnum<<" "<<MXNPEL<<" DDDDDDDD\n";
//if(1==1)exit(0);

	   if(wp.nWeldGroup==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups (*ELSET, ELSET=...weld...) found in *.abq",L"Terminate",MB_OK);exit(0);}
honk<<base.allGrp<<" "<<wp.nWeldGroup<<" Early A & WG\n";
//if(1==1)exit(0);

GeomFileName=OpenDialog1->FileName;
//	   base.npoin=nodeuplim;
	   base.npoin=totNnum;
//	   base.nelt=eluplim;
	   base.nelt=totEnum; //Policy: Reserve storage for #elements read-in, even if there is duplication  EFP 4/19/2012
	   if(nodeuplim != totNnum)
		 {honk<<nodeuplim<<" Nonconsecutive node numbers in file "<<totNnum<<"\n";
//		  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive node numbers in file ",L"Warning",MB_OK);
		 }
//////////		                                                                             	}
	   if(eluplim-ellolim+1 != totEnum)
		 {honk<<ellolim<<" "<<eluplim<<" Nonconsecutive/duplicate element numbers in file "<<totEnum<<"\n";
//		  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There are nonconsecutive element numbers in file ",L"Warning",MB_OK);
		 }

	   if(base.nelt> LONG_INT/t3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Excessive #elements in geometry file",L"Terminate",MB_OK);exit(0);}
	   if(base.npoin>0 && base.nelt>0)
		 {FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,base.npoin,dummy,dummy,dummy,dummy,dummy,dummy,MXNPEL);
		  FDdynmem_manage(13,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
		  FDdynmem_manage(15,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt);//EFP 8/07/2011
//		  base.groupsname[0]=L"ElAll"; //EFP 10/23/2011
//		  base.groupsname[base.allGrp-wp.nWeldGroup-1]=L"AllWeld"; //EFP 10/23/2011
////		  ifstream ntape1(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
		  ifstream ntape1("record.tmp",ios::nocreate|ios::binary,0);
		  if(ntape1) //seek() can be used with binary-opened files (NOT ascii) so close & reopen file  EFP 12/18/2011
			{
//////////////////////////////////////////////////////////////
//TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//////////////////////////////////////////////////////////////
			 ipid=nGID=1;  //Assumption: All elements start with GID=1
//			 wp.nWeldGroup=0;
			 totNnum=totEnum=sumELSETel=sumlim=0;
//			 totBMG=0;totWG= -1;//EFP 10/22/2011
			 totBMG=0;totWG=0;//EFP 10/22/2011
			 for(in=0;in<NDF*base.npoin;in++)base.c1[in]=0.;
//vvvvvvvvvvvvvvvvvvv
			 for(in=0;in<2*base.npoin;in++)base.nofix[in]=0;
			 for(in=0;in<base.npoin;in++)base.nrfix[in]=0;
			 for(in=0;in<NDF*base.npoin;in++)base.presc[in]=0.;
//vvvvvvvvvvvvvvvvvvv
			 for(in=0;in<base.nelt;in++)base.arELEM[in]=1;
//			 for(in=0;in<base.nelt;in++)base.el_map[in]= -1;
//			 for(in=0;in<base.npoin;in++)base.node_map[in]= -1;
//////////// EFP 4/01/2011
revnode_map=new long[nodeuplim-nodelolim+1];
//			 temp_allGID=new int[base.allGrp*base.nelt]; //No WP in ImportAba()
////			   temp_orgGID=new int[base.allGrp]; //EFP 3/11/2012
//			 for(in=0;in<base.allGrp*base.nelt;in++)temp_allGID[in]=0;
//			 for(in=0;in<base.nelt;in++)temp_allGID[in]=1;
////			   for(in=0;in<base.allGrp;in++)temp_orgGID[in]=0;
			 attendEl=new int[eluplim-ellolim+1];
			 for(in=0;in<eluplim-ellolim+1;in++)attendEl[in]=0;
			 for(in=0;in<base.npoin;in++)base.arrELSET[in]=0;
////////////

honk<<base.allGrp<<" "<<wp.nWeldGroup<<" EEELate A & WG\n";
honk<<base.npoin<<" "<<base.nelt<<" npoin/nelt\n";

//if(1==1)exit(0);
////////////
			 do {ntape1.getline(cht,200-1);

				 if(cht[0]=='*' && cht[1]=='*')continue; //Comment ** & ***include & ***ORIENTATION
//		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o'))
		   else if(cht[0]=='*' && (cht[1]=='N' || cht[1]=='n') && (cht[2]=='O' || cht[2]=='o') && (cht[3]=='D' || cht[3]=='d') && (cht[4]=='E' || cht[4]=='e') && cht[5]==',')
//// Dire warning: Never have a space between number & trailing comma, or an extra 0. will be inferred, as follows:
//*NODE,
//           1,   0.0000000E+00,   0.0000000E+00,   0.0000000E+00
//           2,   0.5000000    ,   0.0000000E+00,   0.0000000E+00
//           3,    1.000000    ,   0.0000000E+00,   0.0000000E+00
//           4,    1.500000    ,   0.0000000E+00,   0.0000000E+00
//           5,    2.000000    ,   0.0000000E+00,   0.0000000E+00
//// This must be corrected to
//*NODE,
//           1,   0.0000000E+00,   0.0000000E+00,   0.0000000E+00
//           2,   0.5000000,   0.0000000E+00,   0.0000000E+00
//           3,    1.000000,   0.0000000E+00,   0.0000000E+00
//           4,    1.500000,   0.0000000E+00,   0.0000000E+00
//           5,    2.000000,   0.0000000E+00,   0.0000000E+00
						{iswNode=0;
int ck_INPUT=0;
for(j=8;j<int(strlen(cht))-4;j++){


							 ck_INPUT=0;
							 if(cht[j-5]==ch_I || cht[j-5]==ch_i)ck_INPUT++;
							 if(cht[j-4]==ch_N || cht[j-4]==ch_n)ck_INPUT++;
							 if(cht[j-3]==ch_P || cht[j-3]==ch_p)ck_INPUT++;
							 if(cht[j-2]==ch_U || cht[j-2]==ch_u)ck_INPUT++;
							 if(cht[j-1]==ch_T || cht[j-1]==ch_t)ck_INPUT++;
							 if(cht[j]==ch_eq)ck_INPUT++;
							 if(ck_INPUT==6)
											{iswNode=1;
											 for(in=j+1;in<int(strlen(cht))-1;in++)if(cht[in]=='.')break;
											 fnNeed1=new char[in-j-1+strlen(extensChar)+1];
											 for(kk=j+1;kk<in;kk++)fnNeed1[kk-j-1]=cht[kk]; //StringCchCat(fnNeed1,in-j-1+strlen(extensChar)+1,extensChar);
											 fnNeed1[in+0-j-1]='.';fnNeed1[in+1-j-1]='i';fnNeed1[in+2-j-1]='n';fnNeed1[in+3-j-1]='p';fnNeed1[in+4-j-1]='\0';
											 ifstream viewfile3(fnNeed1,ios::nocreate);
											 if(viewfile3){
honk<<" reenter NODEfile\n";
														   do {viewfile3.getline(cht,200-1); //parse_cdm(cht,4,&nic,&nrc,larr,darr); // *NODE
															   if(strlen(cht))
																{parse_cdm3ff(cht,4,&nic,&nrc,larr,darr);
																 in=larr[0]-1;base.c1[NDF*totNnum]=darr[0];base.c1[NDF*totNnum+1]=darr[1];base.c1[NDF*totNnum+2]=darr[2];
																 base.node_map[totNnum]=in;
																 revnode_map[in-nodelolim+1]=totNnum;
																 totNnum++;
																}
															   else break;
															  }
//														   while (viewfile1.peek()!= '*');
														   while (!viewfile3.eof());
honk<<" releave NODEfile\n";
														   viewfile3.close();
														  }
											 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Node *.inp file not found",L"Terminate",MB_OK);exit(0);}
											 delete [] fnNeed1; *fnNeed1=NULL; // NODE, stored in fnNeed1 file
											 break;
											}
							}
				   if(!iswNode)
					 {do {ntape1.getline(cht,200-1); //parse_cdm(cht,4,&nic,&nrc,larr,darr); // *NODE, stored in same file
						  parse_cdm3ff(cht,4,&nic,&nrc,larr,darr);
						  in=larr[0]-1;base.c1[NDF*totNnum]=darr[0];base.c1[NDF*totNnum+1]=darr[1];base.c1[NDF*totNnum+2]=darr[2];
						  base.node_map[totNnum]=in;  // Check this
						  revnode_map[in-nodelolim+1]=totNnum;

///////////////// start trash
//honk<<totNnum+1<<" "<<in+1<<" "<<in-nodelolim+1<<" ReadNODE "<<base.c1[NDF*totNnum]<<" "<<base.c1[NDF*totNnum+1]<<" "<<base.c1[NDF*totNnum+2]<<"\n";
///////////////// end trash

						  totNnum++;
						 }
					  while (ntape1.peek()!= '*');
					 }
						}
//		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='E' || cht[3]=='e'))
		   else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='E' || cht[3]=='e') && (cht[4]=='M' || cht[4]=='m') && (cht[5]=='E' || cht[5]=='e') && (cht[6]=='N' || cht[6]=='n') && (cht[7]=='T' || cht[7]=='t') && cht[8]==',')
						{


																			iswElem=0;
for(j=8;j<int(strlen(cht))-1;j++)if((cht[j-5]=='I' || cht[j-5]=='i') &&
							   (cht[j-4]=='N' || cht[j-4]=='n') &&
							   (cht[j-3]=='P' || cht[j-3]=='p') &&
							   (cht[j-2]=='U' || cht[j-2]=='u') &&
							   (cht[j-1]=='T' || cht[j-1]=='t') &&
								cht[j]=='='){
								iswElem=1;
											 for(in=j+1;in<int(strlen(cht))-1;in++)if(cht[in]=='.')break;
											 fnNeed2=new char[in-j-1+strlen(extensChar)+1];
											 for(kk=j+1;kk<in;kk++)fnNeed2[kk-j-1]=cht[kk]; //StringCchCat(fnNeed2,in-j-1+strlen(extensChar)+1,extensChar);
											 fnNeed2[in+0-j-1]='.';fnNeed2[in+1-j-1]='i';fnNeed2[in+2-j-1]='n';fnNeed2[in+3-j-1]='p';fnNeed2[in+4-j-1]='\0';
											 ifstream viewfile4(fnNeed2,ios::nocreate);
											 if(viewfile4){
honk<<" reenter ELEMfile\n";
														   do {viewfile4.getline(cht,200-1);
															   if(strlen(cht))
																{
																 for(i=0;i<10;i++)larr[i]=0;
//																 parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT, stored in fnNeed2 file
																 parse_cdmQn(cht,25,&nic,&nrc,larr,darr);
//honk<<larr[0]<<" track2Efile "<<nic<<"\n";
															   if(nic-1==4)eltype=5;
															   else if(nic-1==5){nic=5;eltype=5;}
															   else if(nic-1==6)eltype=7;
															   else if(nic-1==7){nic=7;eltype=7;}
															   else if(nic-1==8)
																 {eltype=8;
																  if(!larr[8]){viewfile4.getline(cht,200-1); //Read extra line but assume NX 8-n  EFP 4/05/2012
																			   parse_cdmQn(cht,25,&nic1,&nrc,larr1,darr);
																			   larr[8]=larr1[0];
																			  }
																 }
															   else if(nic-1==9){nic=9;eltype=8;}
															   else {honk<<"Halt2: Unsupported element with #nodes "<<nic-1<<"\n";
																	 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(_ltow(nic-1,string0,10),L"Halt2: Unsupported element with #nodes in ImportAba_prog()",MB_OK);
																	 exit(0);
																	}

																 n8=nic-1;in=larr[0]-1;
/////////////// start New code to manage element duplication  EFP 4/19/2012
if(attendEl[in-ellolim+1])attendEl[in-ellolim+1]= -1;
else {attendEl[in-ellolim+1]=1;

//if(n8==8) //EFP 12/19/2011
//  {if(larr[0+1]==larr[4+1] && larr[3+1]==larr[7+1])
///////////////////////////// Coding to accommodate "degenerate hex" wedges  EFP 4/14/2011
////17619, 23561, 23562, 23592, 23591, 19210, 19211, 19241, 19240
////17620, 23562, 22301, 22302, 23592, 19211, 17950, 17951, 19241
////17621,   571, 23563, 22311,    82,   571, 19212, 17960,    82   This one in *.inp & *.abq
////17622, 23563, 23564, 22310, 22311, 19212, 19213, 17959, 17960
////17623, 23564, 23565, 22309, 22310, 19213, 19214, 17958, 17959
//	{eltype=7;n8=6;
//	 larr[4+1]=larr[6+1];i=larr[1+1];larr[1+1]=larr[5+1];larr[5+1]=larr[2+1];larr[2+1]=i;//larr[6+1]=larr[7+1]=0;
//honk<<in+1<<" degenerate hex as wedge\n";
//	}
//   else if(larr[4+1]==larr[5+1] && larr[4+1]==larr[6+1] && larr[4+1]==larr[7+1])
///////////////////////////// Coding to accommodate tetras presented as 8-n  EFP 12/19/2011
////20000,20259,20260,20261,20262,1,1,1,1
////20001,20263,20264,20265,20266,1,1,1,1
////20002,20265,20267,20266,20268,1,1,1,1
//	{eltype=5;n8=4;//for(i=4+1;i<8+1;i++)larr[i]=0;
//honk<<in+1<<" tetra presented as 8-n\n";
//	}
//  }
if(n8==8)degen8_test(&eltype,&n8,larr);
																 for(i=0;i<n8;i++)base.nop1[MXNPEL*totEnum+i]=larr[i+1]-1;
//if(n8==8)
//  {if(larr[0+1]==larr[4+1] && larr[3+1]==larr[7+1])
///////////////////////////// Coding to accommodate "degenerate hex" wedges  EFP 4/14/2011
////17619, 23561, 23562, 23592, 23591, 19210, 19211, 19241, 19240
////17620, 23562, 22301, 22302, 23592, 19211, 17950, 17951, 19241
////17621,   571, 23563, 22311,    82,   571, 19212, 17960,    82   This one in *.inp & *.abq
////17622, 23563, 23564, 22310, 22311, 19212, 19213, 17959, 17960
////17623, 23564, 23565, 22309, 22310, 19213, 19214, 17958, 17959
//	{eltype=7;n8=6;
//	 base.nop1[MXNPEL*totEnum+0]=larr[0+1]-1;
//	 base.nop1[MXNPEL*totEnum+1]=larr[5+1]-1;
//	 base.nop1[MXNPEL*totEnum+2]=larr[1+1]-1;
//	 base.nop1[MXNPEL*totEnum+3]=larr[3+1]-1;
//	 base.nop1[MXNPEL*totEnum+4]=larr[6+1]-1;
//	 base.nop1[MXNPEL*totEnum+5]=larr[2+1]-1;
//	 base.nop1[MXNPEL*totEnum+6]=base.nop1[MXNPEL*totEnum+7]= -1;
//	}
//   else if(larr[4+1]==larr[5+1] && larr[4+1]==larr[6+1] && larr[4+1]==larr[7+1] && larr[4+1]==larr[8+1])
///////////////////////////// Coding to accommodate tetras presented as 8-n  EFP 12/19/2011
////20000,20259,20260,20261,20262,1,1,1,1
////20001,20263,20264,20265,20266,1,1,1,1
////20002,20265,20267,20266,20268,1,1,1,1
//	{eltype=5;n8=4;for(i=4;i<8;i++)base.nop1[MXNPEL*totEnum+i]= -1;
//	}
//  }
/////////////////////////////
//																 base.matno[totEnum]=eltype*t7+n8*t3+ipid-1;
																 base.matno[totEnum]=eltype*t7+n8*t3;
																 base.el_map[totEnum]=in;
//////////// EFP 1/30/2011
//base.orig_matno[totEnum]=eltype*t7+n8*t3+ipid-1;
base.orig_matno[totEnum]=eltype*t7+n8*t3;
////////////
																 totEnum++;
	 }
/////////////// end
																}
															   else break;

															  }
														   while (!viewfile4.eof());
honk<<" releave ELEMfile\n";
														   viewfile4.close();
														  }
											 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Element *.inp file not found",L"Terminate",MB_OK);exit(0);}
											 delete [] fnNeed2; *fnNeed2=NULL; // NODE, stored in fnNeed2 file
											 break;
											}
//////////
																			 if(!iswElem)
																			   {
							do {ntape1.getline(cht,200-1);
//honk<<" NonINPUTFILEelem "<<cht<<"\n";
								for(i=0;i<10;i++)larr[i]=0;
								parse_cdmQ(cht,9,&nic,&nrc,larr,darr,strlen(cht)); // *ELEMENT, stored in same file
//honk<<larr[0]<<" track2E "<<nic<<"\n";

															   if(nic-1==4)eltype=5;
															   else if(nic-1==5){nic=5;eltype=5;}
															   else if(nic-1==6){eltype=7;
//honk<<larr[0]<<" C3D6 "<<larr[1]<<" "<<larr[2]<<" "<<larr[3]<<" "<<larr[4]<<" "<<larr[5]<<" "<<larr[6]<<"\n";
																				}
															   else if(nic-1==7){nic=7;eltype=7;}
															   else if(nic-1==8)
																 {eltype=8;
																  if(!larr[8]){ntape1.getline(cht,200-1); //Read extra line but assume NX 8-n  EFP 4/05/2012
																			   parse_cdmQn(cht,25,&nic1,&nrc,larr1,darr);
																			   larr[8]=larr1[0];
																			  }
																 }
															   else if(nic-1==9){nic=9;eltype=8;}
															   else {honk<<"Halt3: Unsupported element with #nodes "<<nic-1<<"\n";
																	 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(_ltow(nic-1,string0,10),L"Halt3: Unsupported element with #nodes in ImportAba_prog()",MB_OK);
																	 exit(0);
																	}



								n8=nic-1;in=larr[0]-1;
/////////////// start New code to manage element duplication  EFP 4/19/2012
if(attendEl[in-ellolim+1])attendEl[in-ellolim+1]= -1;
else {attendEl[in-ellolim+1]=1;

//if(n8==8) //EFP 12/19/2011
//  {if(larr[0+1]==larr[4+1] && larr[3+1]==larr[7+1])
///////////////////////////// Coding to accommodate "degenerate hex" wedges  EFP 4/14/2011
////17619, 23561, 23562, 23592, 23591, 19210, 19211, 19241, 19240
////17620, 23562, 22301, 22302, 23592, 19211, 17950, 17951, 19241
////17621,   571, 23563, 22311,    82,   571, 19212, 17960,    82   This one in *.inp & *.abq
////17622, 23563, 23564, 22310, 22311, 19212, 19213, 17959, 17960
////17623, 23564, 23565, 22309, 22310, 19213, 19214, 17958, 17959
//	{eltype=7;n8=6;
//	 larr[4+1]=larr[6+1];i=larr[1+1];larr[1+1]=larr[5+1];larr[5+1]=larr[2+1];larr[2+1]=i;//larr[6+1]=larr[7+1]=0;
//	}
//   else if(larr[4+1]==larr[5+1] && larr[4+1]==larr[6+1] && larr[4+1]==larr[7+1] && larr[4+1]==larr[8+1])
///////////////////////////// Coding to accommodate tetras presented as 8-n  EFP 12/19/2011
////20000,20259,20260,20261,20262,1,1,1,1
////20001,20263,20264,20265,20266,1,1,1,1
////20002,20265,20267,20266,20268,1,1,1,1
//	{
////honk<<totEnum+1<<" "<<in+1<<" bingoB "<<larr[4+1]<<" "<<larr[5+1]<<" "<<larr[6+1]<<" "<<larr[7+1]<<"\n";
//	 eltype=5;n8=4;//for(i=4+1;i<8+1;i++)larr[i]=0;
//	}
//  }
if(n8==8){degen8_test(&eltype,&n8,larr);
//		  if(n8!=8)honk<<totEnum+1<<" degen "<<eltype<<" "<<n8<<"\n";
		 }
								for(i=0;i<n8;i++)base.nop1[MXNPEL*totEnum+i]=larr[i+1]-1;

//								base.matno[totEnum]=eltype*t7+n8*t3+ipid-1;
								base.matno[totEnum]=eltype*t7+n8*t3;
								base.el_map[totEnum]=in;
//////////// EFP 1/30/2011
//base.orig_matno[totEnum]=eltype*t7+n8*t3+ipid-1;
base.orig_matno[totEnum]=eltype*t7+n8*t3;
////////////
//honk<<totEnum+1<<" "<<in+1<<" ElemB "<<n8<<" "<<ipid<<"\n";
								totEnum++;
	 }
/////////////// end
							   }
							while (ntape1.peek()!= '*');


																			   }

//honk<<" end of elem2nd read\n";
//if(1==1)exit(0);

						}
				 else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='L' || cht[2]=='l') && (cht[3]=='S' || cht[3]=='s')) // *ELSET
				   {
///////////
/////////////
///////////////
/////////////////
/////////////////// start disconn
//					in=isw=jsw=kn=0;
//					for(i=0;i<int(strlen(cht))-1;i++)if(cht[i]==','){kn++;jrec=i;}  // Code to handle "generate" EFP 4/22/2011
//					if(kn>1 && int(strlen(cht))-1-jrec >=8)
//					  {for(i=jrec+1;i<int(strlen(cht))-8;i++)
//						 {if((cht[i  ]=='G' || cht[i  ]=='g') &&
//							 (cht[i+1]=='E' || cht[i+1]=='e') &&
//							 (cht[i+2]=='N' || cht[i+2]=='n') &&
//							 (cht[i+3]=='E' || cht[i+3]=='e') &&
//							 (cht[i+4]=='R' || cht[i+4]=='r') &&
//							 (cht[i+5]=='A' || cht[i+5]=='a') &&
//							 (cht[i+6]=='T' || cht[i+6]=='t') &&
//							 (cht[i+7]=='E' || cht[i+7]=='e')){in=2;break;} //Note:in=2 signifies GENERATE, not #commas
//						 }
//					  }
//
//				   for(i=7;i<int(strlen(cht))-1;i++)if(cht[i]=='=')break; //Coding to accommodate *ELSET,ELSET= & *ELSET, ELSET=
//				   for(jrec=i+1;jrec<int(strlen(cht))-1;jrec++)if(cht[jrec]!=' ')break;
//				   klim=int(strlen(cht))-1;
//				   for(i=jrec;i<int(strlen(cht))-1;i++)if(cht[i]==','){klim=i;break;}
//
////honk<<int(strlen(cht))-1<<" "<<klim<<" Stazi\n";
//
//				   k=0;
//				   jsw=0;
//				   if(k==0){for(i=jrec;i<klim;i++){if(cht[i  ]=='W' || cht[i  ]=='w')
//														   {if(i+1<klim+1){if(cht[i+1]=='D' || cht[i+1]=='d'){jsw=1;break;}
//																		   else if(cht[i+1]=='P' || cht[i+1]=='p'){jsw=1;break;}
//																		   else if(cht[i+1]=='G' || cht[i+1]=='g'){jsw=1;break;}
//																		   else if(cht[i+1]=='E' || cht[i+1]=='e')
//																					   {if(i+3<klim+1)
//																						  {if((cht[i+2]=='L' || cht[i+2]=='l') &&
//																							  (cht[i+3]=='D' || cht[i+3]=='d')){jsw=1;break;}
// 																						  }
//																						else break;
//																					   }
//																		   else break;
//																		  }
//															else break;
//														   }  // Accept WDx, WPx, WGx and WELDx
//												  }
//							if(jsw)totWG++;
//							else totBMG++;
////////////////////////// start Code to store ELSET=name  EFP 3/25/2011
////if(jsw){
////		k=0;for(i=jrec;i<int(strlen(cht))-1;i++){
//		kp=0;for(i=jrec;i<int(strlen(cht))-1;i++){
//
//honk<<i<<" "<<int(strlen(cht))-1<<" "<<kp<<" Monitor "<<cht[i]<<"\n";
//
//												 if(cht[i]==',')break;
////												 else k++;
//												 else kp++;
//												}
////		temp_cht=new char[k+1];
////		for(i=0;i<k;i++)temp_cht[i]=cht[i+jrec];
//
////if(temp_cht){delete [] temp_cht; *temp_cht=NULL;}
//		temp_cht=new char[kp+1];
//		for(i=0;i<kp;i++)temp_cht[i]=cht[i+jrec];
//temp_cht[kp]='\0';
//
////		base.groupsname[wp.nWeldGroup]=temp_cht; //EFP 3/25/2011
////		delete [] temp_cht; *temp_cht=NULL;
////honk<<jrec<<" "<<int(strlen(cht))-1<<" "<<k<<" "<<temp_cht<<" StillInContention here under temp\n";
////	   }
////////////////////////// end
//						   }
//					sumWG=0;
//////////////
////temp_orgGID[base.allGrp-wp.nWeldGroup+totWG]=1;
////honk<<totWG<<" "<<totBMG<<" used "<<base.allGrp-wp.nWeldGroup+totWG<<"\n";
//////////////
//					if(in==2){
////*ELSET, ELSET=PTBOT, GENERATE
////   33049,   33057,       1
////   33085,   33093,       1
////   33121,   33129,       1
//							  do {ntape1.getline(cht,200-1);  // ELSET.... GENERATE
////								  if(jsw){parse_cdm(cht,3,&nic,&nrc,larr,darr);
//								  if(!k ){parse_cdm(cht,3,&nic,&nrc,larr,darr);
//										  if(larr[1]-larr[0]+1<base.nelt){for(i=larr[0]-1;i<larr[1];i=i+larr[2])
//																		   {
//j= -1;for(kk=0;kk<totEnum;kk++)if(base.el_map[kk]==i){j=kk;break;}
//if(j== -1){honk<<"TERMINATE: WG el_map crash in *.abq/*.inp\n";exit(0);}
//else {
////eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//eltype=base.matno[j]/t7;bscode=(base.matno[j]-eltype*t7)/t5;node=(base.matno[j]-eltype*t7-bscode*t5)/t3;
////ieGID=base.matno[j]-eltype*t7-bscode*t5-node*t3; //This is not used now EFP 8/25/2013
////																			if(ieGID==0){
//																						 isw=1;
//////																			             base.matno[i]=base.matno[i]+nGID;
////																						 base.matno[j]=base.matno[j]+nGID;
////																						 base.orig_matno[j]=base.orig_matno[j]+nGID;// Correction EFP 2/05/2011
//																			if(jsw){
//																						 sumWG++;
////temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup-1)+j]=1;
//temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup+totWG)+j]=1;
////temp_orgGID[base.allGrp-wp.nWeldGroup+totWG]=1;
////honk<<i<<" "<<j<<" Elset GEN\n";
//																				   }
//																			else temp_allGID[base.nelt*totBMG+j]=1;
//sumELSETel++;//Add coding for basemetal&weldgroup SHOULD BE base.allGrp
////																						}
//	 }
//																		   }
//																		 }
//										 }
//								 }
//							  while (ntape1.peek()!= '*');
//
////honk<<jsw<<" "<<isw<<" "<<larr[1]-larr[0]+1<<" "<<base.nelt<<" Tonton\n";
//
////							  if(jsw && isw && larr[1]-larr[0]+1<base.nelt){
//							  if(isw && larr[1]-larr[0]+1<base.nelt){
//																	if(jsw){
//////////////////
//honk<<nGID<<" "<<int(strlen(temp_cht))<<" "<<temp_cht<<"      Accepted WG-GEN\n";
//
//////base.groupsname[wp.nWeldGroup]=temp_cht; //EFP 4/09/2011
////base.groupsname[base.allGrp-wp.nWeldGroup+totWG]=temp_cht; //EFP 4/09/2011
//base.groupsname[totWG]=temp_cht; //EFP 4/09/2011
////for(i=0;i<k;i++)temp_cht[i]=chNULL;
////delete [] temp_cht; *temp_cht=NULL;
//honk<<totWG<<" posteriorWG_GEN "<<base.groupsname[totWG].c_str()<<"\n";
//////////////////
//																			nGID++;
////																			wp.nWeldGroup=wp.nWeldGroup+1;
//																			if(sumlim<sumWG)sumlim=sumWG;
//																		   }
////																	 else base.groupsname[totBMG]=temp_cht; //EFP 4/09/2011
//																	}
//							 }
//					else {
////honk<<cht<<" 2ndReadElset "<<in<<"\n";
////if(1==1)exit(0);
//						  iswELSET2= -1;
//						  do {ntape1.getline(cht,200-1);ksw=0;
//							  for(i=0;i<int(strlen(cht))-1;i++)
//								{if(cht[i]!=' ' || cht[i]!=','){ksw=checkAlphabetic(cht[i]);
//																if(ksw)break;
//															   }
//								}
//							  if(ksw){isw=0; //"ELSET of ELSETs" datacard  EFP 12/19/23011
//									  ip=0;
//									  for(inp=0;inp<strlen(cht)-1;inp++) //dummy loop  EFP 7/17/2012
//										{kn=parse_ch1(ip, &im,cht,chELSET);
////honk<<ip<<" "<<kn<<" "<<strlen(cht)-1<<" "<<im<<" ip/kn/len/im\n";
//										 if(kn<strlen(cht) && kn>ip && im){
//for(i=0;i<totWG;i++){
////honk<<i<<" "<<totWG<<" "<<chELSET<<" OOITSMAGIC "<<base.groupsname[i].c_str()<<"\n";
////					 if(strstr(cht,base.groupsname[i].c_str()))
//					 if(stricmp(chELSET,base.groupsname[i].c_str())==0)
//															   {if(iswELSET2<0){iswELSET2=i;
//kswELSET=1;
//////base.groupsname[iswELSET2]=chELSET;
////base.groupsname[iswELSET2]=base.groupsname[totWG-1];
//base.groupsname[iswELSET2]=temp_cht;
////honk<<base.groupsname[i].c_str()<<" nnNNnn "<<chELSET<<"\n";
//																			   }
//																else {
//for(kk=0;kk<base.nelt;kk++){temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup+iswELSET2)+kk]=max(
//							temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup+iswELSET2)+kk],
//							temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup+        i)+kk]);
//							temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup+        i)+kk]=0;
//						   }
//																	 }
//																honk<<i<<" "<<iswELSET2<<" Potato\n";
//																break;
//															   }
//					 else if(stricmp(chELSET,base.groupsname[i].c_str())<0)honk<<" negPotato\n";
//					 else honk<<" posPotato\n";
//					}
/////////////
/////////////
//																			 ip=kn;
//																			}
//										 else break;
//										}
//
//
//									 }
//							  else {
//////*ELSET, ELSET=PTTOP
//////   52369,   52370,   52371,   52372,   52373,   52374,   52375,   52376,
//////   52401,   52402,   52403,   52404,   52405,   52406,   52407,   52408,
//////   52433,   52434,   52435,   52436,   52437,   52438,   52439,   52440,
////honk<<k<<" kkkkkkkkk\n";if(1==1)exit(0);
////														if(jsw){
//														if(!k ){
//																parse_cdmQ(cht,25,&nic,&nrc,larr,darr,strlen(cht)); //This accommodates comma-end or no-comma EFP 4/15/2011
//																for(i=0;i<nic;i++){if(larr[i]) //This accommodates comma-end or no-comma EFOP 4/15/2011
//																					 {
////honk<<i<<" LARR "<<larr[i]<<"\n";
////if(1==1)exit(0);
////in= -1;for(j=0;j<totEnum;j++)if(base.el_map[j]==larr[i]-1){in=j;break;}
////if(in== -1){honk<<in<<" "<<larr[i]<<" Crash in ELSET\n";extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Crash in ELSET",L"Terminate",MB_OK);exit(0);}
//j= -1;for(kk=0;kk<totEnum;kk++)if(base.el_map[kk]==larr[i]-1){j=kk;break;}  //Correction EFP 4/01/2011
//if(j== -1){honk<<"TERMINATE: WG el_map crash in *.abq/*.inp\n";exit(0);}
//else {
////eltype=base.matno[larr[i]-1]/t7;bscode=(base.matno[larr[i]-1]-eltype*t7)/t5;node=(base.matno[larr[i]-1]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[larr[i]-1]-eltype*t7-bscode*t5-node*t3;
////																				   if(ieGID==0){isw=1;base.matno[larr[i]-1]=base.matno[larr[i]-1]+nGID;}
//eltype=base.matno[j]/t7;bscode=(base.matno[j]-eltype*t7)/t5;node=(base.matno[j]-eltype*t7-bscode*t5)/t3;
////ieGID=base.matno[j]-eltype*t7-bscode*t5-node*t3; //Not used anymore
////																				   if(ieGID==0){
//																								isw=1;
////																								base.matno[j]=base.matno[j]+nGID;
////																								base.orig_matno[j]=base.orig_matno[j]+nGID;// Correction EFP 2/05/2011
//																			if(jsw){
//																								sumWG++;
////temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup-1)+j]=1;
//temp_allGID[base.nelt*(base.allGrp-wp.nWeldGroup+totWG)+j]=1;
////sumELSETel++;
////temp_orgGID[base.allGrp-wp.nWeldGroup+totWG]=1;
//																				   }
//																			else {
//temp_allGID[base.nelt*totBMG+j]=1;//Add coding for basemetal&weldgrop SHOULD BE base.allGrp
////sumELSETel++;
//																				 }
//sumELSETel++;
////																							   }
//	 }
//																					 }
//																				  }
//															   }
//								   }
//							 }
//						  while (ntape1.peek()!= '*');
////if(1==1)exit(0);
////						  if(jsw && isw){
//						  if(isw){
//								 if(jsw){
//////////////////
//honk<<nGID<<" "<<strlen(temp_cht)<<" "<<temp_cht<<"     Accepted WG_NoGEN\n";
//
//////		base.groupsname[wp.nWeldGroup]=temp_cht; //EFP 4/09/2011
////		base.groupsname[base.allGrp-wp.nWeldGroup+totWG]=temp_cht; //EFP 4/09/2011
//		base.groupsname[totWG]=temp_cht; //EFP 4/09/2011
////		delete [] temp_cht; *temp_cht=NULL;
//honk<<totWG<<" posteriorWG_NoGEN "<<base.groupsname[totWG].c_str()<<"\n";
//////////////////
//										 nGID++;
////										 wp.nWeldGroup=wp.nWeldGroup+1;
//										 if(sumlim<sumWG)sumlim=sumWG;
//										}
////								  else base.groupsname[totBMG]=temp_cht; //EFP 4/09/2011
//								 }
//						 }
////for(i=0;i<kp;i++)temp_cht[i]=chNULL;
//delete [] temp_cht;
//////// *temp_cht=NULL;
//
//////////////////// end disconn
//////////////////
////////////////
//////////////
////////////

///////////
/////////////
///////////////
/////////////////
/////////////////// start attempted reconn
					in=isw=jsw=kn=0;
					for(i=0;i<int(strlen(cht))-1;i++)if(cht[i]==','){kn++;jrec=i;
                                                                     break; //Find first comma
																	}  // Code to handle "generate" EFP 4/22/2011
honk<<kn<<" "<<jrec<<" locCOMMA\n";
//					if(kn>1 && int(strlen(cht))-1-jrec >=8)
					if(kn>0 && int(strlen(cht))-1-jrec >=3)
//					  {for(i=jrec+1;i<int(strlen(cht))-8;i++)
					  {for(i=jrec+1;i<int(strlen(cht))-3;i++)
						 {if((cht[i  ]=='G' || cht[i  ]=='g') &&
							 (cht[i+1]=='E' || cht[i+1]=='e') &&
							 (cht[i+2]=='N' || cht[i+2]=='n')  //GENERATE can be shortened to GEN
//							  &&(cht[i+3]=='E' || cht[i+3]=='e') &&
//							 (cht[i+4]=='R' || cht[i+4]=='r') &&
//							 (cht[i+5]=='A' || cht[i+5]=='a') &&
//							 (cht[i+6]=='T' || cht[i+6]=='t') &&
//							 (cht[i+7]=='E' || cht[i+7]=='e')
															 ){in=2;
honk<<i<<" "<<jrec<<" ELSETfoundGEN\n";
																	break;} //Note:in=2 signifies GENERATE, not #commas
						 }
					  }
				   for(i=7;i<int(strlen(cht))-1;i++)if(cht[i]=='=')break; //Coding to accommodate *ELSET,ELSET= & *ELSET, ELSET=
				   for(jrec=i+1;jrec<int(strlen(cht))-1;jrec++)if(cht[jrec]!=' ')break;
				   klim=int(strlen(cht))-1;
				   for(i=jrec;i<int(strlen(cht))-1;i++)if(cht[i]==','){klim=i;break;}
//
////honk<<int(strlen(cht))-1<<" "<<klim<<" Stazi\n";
//
				   k=0;
				   jsw=0;
				   if(k==0){for(i=jrec;i<klim;i++){if(cht[i  ]=='W' || cht[i  ]=='w')
														   {if(i+1<klim+1){if(cht[i+1]=='D' || cht[i+1]=='d'){jsw=1;break;}
																		   else if(cht[i+1]=='P' || cht[i+1]=='p'){jsw=1;break;}
																		   else if(cht[i+1]=='G' || cht[i+1]=='g'){jsw=1;break;}
																		   else if(cht[i+1]=='E' || cht[i+1]=='e')
																					   {if(i+3<klim+1)
																						  {if((cht[i+2]=='L' || cht[i+2]=='l') &&
																							  (cht[i+3]=='D' || cht[i+3]=='d')){jsw=1;break;}
																						  }
																						else break;
																					   }
																		   else break;
																		  }
															else break;
														   }  // Accept WDx, WPx, WGx and WELDx
												  }
////							if(jsw)totWG++;
////							else totBMG++;
if(jsw){
		kp=0;for(i=jrec;i<int(strlen(cht))-1;i++){
//honk<<i<<" "<<int(strlen(cht))-1<<" "<<kp<<" Monitor "<<cht[i]<<"\n";
												 if(cht[i]==',')break;
												 else kp++;
												}
		temp_cht=new char[kp+1];
		for(i=0;i<kp;i++)temp_cht[i]=cht[i+jrec];
		temp_cht[kp]='\0';
		base.groupsname[totWG]=temp_cht; //EFP 3/25/2011
honk<<kp<<" "<<strlen(cht)<<" "<<temp_cht<<" temp_cht\n";
honk<<totWG<<" posteriorWG_NoGEN "<<base.groupsname[totWG].c_str()<<"\n";
		delete [] temp_cht; *temp_cht=NULL;
		totWG++;nGID++;sumWG=0;
					if(in==2){
//*ELSET, ELSET=PTBOT, GENERATE
//   33049,   33057,       1
//   33085,   33093,       1
//   33121,   33129,       1
							  do {ntape1.getline(cht,200-1);  // ELSET.... GENERATE
////								  if(jsw){parse_cdm(cht,3,&nic,&nrc,larr,darr);
//								  if(!kp){parse_cdm(cht,3,&nic,&nrc,larr,darr);
								  if( kp){parse_cdm(cht,3,&nic,&nrc,larr,darr); //TBD: Unnecessary test??
										  if(larr[1]-larr[0]+1<base.nelt){for(i=larr[0]-1;i<larr[1];i=i+larr[2])
																		   {
j= -1;for(kk=0;kk<totEnum;kk++)if(base.el_map[kk]==i){j=kk;break;}
if(j== -1){honk<<"TERMINATE: GENERATED WG el_map crash in *.abq/*.inp\n";exit(0);}
else {base.arrELSET[j]=totWG;sumWG++;}
																		   }
																		 }
										 }
								 }
							  while (ntape1.peek()!= '*');
							 }
					else {
//*ELSET, ELSET=PTTOP
//   52369,   52370,   52371,   52372,   52373,   52374,   52375,   52376,
//   52401,   52402,   52403,   52404,   52405,   52406,   52407,   52408,
//   52433,   52434,   52435,   52436,   52437,   52438,   52439,   52440,
//					base.groupsname[totWG]="WG"; //EFP 4/09/2011
					do {ntape1.getline(cht,200-1);
						parse_cdmQ(cht,25,&nic,&nrc,larr,darr,strlen(cht)); //This accommodates comma-end or no-comma EFP 4/15/2011
						for(i=0;i<nic;i++){if(larr[i]) //This accommodates comma-end or no-comma EFOP 4/15/2011
											 {
j= -1;for(kk=0;kk<totEnum;kk++)if(base.el_map[kk]==larr[i]-1){j=kk;break;}  //Correction EFP 4/01/2011
if(j== -1){honk<<"TERMINATE: WG el_map crash in *.abq/*.inp\n";exit(0);}
else {base.arrELSET[j]=totWG;sumWG++;}
											 }
										  }
					   }
					while (ntape1.peek()!= '*');
						 }
					if(sumlim<sumWG)sumlim=sumWG;
honk<<totWG<<" guavaACCEPTwg "<<j+1<<"\n";
	   }
else {do {ntape1.getline(cht,200-1);
		 }
	  while (ntape1.peek()!= '*');
	  totBMG++;
	 }
						   }
//////////////////// end attempted reconn
//////////////////
////////////////
//////////////
////////////



///////////
/////////////
///////////////
/////////////////
/////////////////// default coding used during disconn
//				   for(i=7;i<int(strlen(cht))-1;i++)if(cht[i]=='=')break; //Coding to accommodate *ELSET,ELSET= & *ELSET, ELSET=
//				   for(jrec=i+1;jrec<int(strlen(cht))-1;jrec++)if(cht[jrec]!=' ')break;
//				   klim=int(strlen(cht))-1;
//				   for(i=jrec;i<int(strlen(cht))-1;i++)if(cht[i]==','){klim=i;break;}
////honk<<int(strlen(cht))-1<<" "<<klim<<" Stazi\n";
////////////////////////// start Code to store ELSET=name  EFP 3/25/2011
//		kp=0;for(i=jrec;i<int(strlen(cht))-1;i++){
//honk<<i<<" "<<int(strlen(cht))-1<<" "<<kp<<" Monitor "<<cht[i]<<"\n";
//												 if(cht[i]==',')break;
//												 else kp++;
//												}
//		temp_cht=new char[kp+1];
//		for(i=0;i<kp;i++)temp_cht[i]=cht[i+jrec];
//		temp_cht[kp]='\0';
////		base.groupsname[wp.nWeldGroup]=temp_cht; //EFP 3/25/2011
//		base.groupsname[totWG]=temp_cht; //EFP 2/30/2014
////		wp.name[totWG]=temp_cht; //EFP 2/30/2014
//		delete [] temp_cht; *temp_cht=NULL;
//honk<<totWG<<" posteriorWG_NoGEN "<<base.groupsname[totWG].c_str()<<"\n";
//					totWG++;nGID++;sumWG=0;
////					base.groupsname[totWG]="WG"; //EFP 4/09/2011
//					do {ntape1.getline(cht,200-1);
//						parse_cdmQ(cht,25,&nic,&nrc,larr,darr,strlen(cht)); //This accommodates comma-end or no-comma EFP 4/15/2011
//						for(i=0;i<nic;i++){if(larr[i]) //This accommodates comma-end or no-comma EFOP 4/15/2011
//											 {
//j= -1;for(kk=0;kk<totEnum;kk++)if(base.el_map[kk]==larr[i]-1){j=kk;break;}  //Correction EFP 4/01/2011
//if(j== -1){honk<<"TERMINATE: WG el_map crash in *.abq/*.inp\n";exit(0);}
//else {base.arrELSET[j]=totWG;sumWG++;}
//											 }
//										  }
//					   }
//					while (ntape1.peek()!= '*');
//					if(sumlim<sumWG)sumlim=sumWG;
//honk<<totWG<<" guava "<<j+1<<"\n";
//////////////////// end default coding used during disconn
//////////////////
////////////////
//////////////
////////////






				   }
				 else if(cht[0]=='*' && (cht[1]=='E' || cht[1]=='e') && (cht[2]=='N' || cht[2]=='n') && (cht[3]=='D' || cht[3]=='d'))
				  {
////				   if(ntape1.peek()!= '*')break; // multiple use for *End/*End Part/*End Assembly/*End Instance  EFP 4/22/2011
////				   else continue;
honk<<" *END found\n";break;
//honk<<" *END found\n";if(1==1)exit(0);
				  }
							// *end step CORRECTED EFP 10/22/2010
				 else {
while (ntape1.peek()!= '*')ntape1.getline(cht,200-1);
					  }



				}
			 while (!ntape1.eof());

//////////////////////////////////////////
// This did not work for *.msh so maybe it should be revised for *.inp/*.abq  EFP 4/06/2011
			 for(j=0;j<totEnum;j++)
			   {eltype=base.matno[j]/t7;bscode=(base.matno[j]-eltype*t7)/t5;node=(base.matno[j]-eltype*t7-bscode*t5)/t3;
				for(in=0;in<node;in++)base.nop1[MXNPEL*j+in]=revnode_map[base.nop1[MXNPEL*j+in]-nodelolim+1];
			   }


//			 delete [] revnode_map; //THIS CAUSES MEMORY CRASH BUT WHY??? NECESSARY!!! EFP 7/31/2014
			 *revnode_map=NULL;


//////////////////////////// start NRC-DMW rpv-3d-ren code to delineate repair weld arcs  EFP 6/20/2014
//float xcen=0.,ycen=0.;
//for(i=18-1;i<34;i++)
//  {honk<<i+1<<" RepairGID\n";kk=0;
//   for(j=0;j<totEnum;j++)
//	 {if(base.arrELSET[j]==i)
//		{eltype=base.matno[j]/t7;bscode=(base.matno[j]-eltype*t7)/t5;node=(base.matno[j]-eltype*t7-bscode*t5)/t3;
//		 xcen=ycen=0.;for(in=0;in<node;in++){xcen=xcen+base.c1[NDF*base.nop1[MXNPEL*j+in]+0];ycen=ycen+base.c1[NDF*base.nop1[MXNPEL*j+in]+1];}
//		 xcen=xcen/float(node);ycen=ycen/float(node);
////		 if(ycen<0. && xcen> -0.5){kk++;honk<<base.el_map[j]+1<<" "<<xcen<<" "<<ycen<<"\n";} //96deg
//		 if(ycen<0. && xcen>271.90761-0.5){kk++;honk<<base.el_map[j]+1<<" "<<xcen<<" "<<ycen<<"\n";} //48deg
//		}
//	 }
//   honk<<kk<<" counted\n";honk<<"\n";
//  }
//////////////////////////// end

base.allGrp=nGID; //Special restriction to 1 basemetal + WGs
honk<<wp.nWeldGroup<<" Revised nWeldGroup "<<base.nelt+sumELSETel<<"\n";
honk<<base.nelt<<" nelt/allGrp "<<base.allGrp<<"\n";
//////			   FDdynmem_manage(14,dummy,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);//EFP 8/07/2011
////			   FDdynmem_manage(15,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,
////							   base.nelt+2*sumELSETel);//EFP 8/07/2011
//			   FDdynmem_manage(15,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt);//EFP 8/07/2011
///////////////////////////
//Screen->Cursor=Save_Cursor;
///////////////////////////
			 old_npoin=new_npoin=base.npoin;new_nelt=base.nelt;new_mat=base.mat;new_ncoorf=base.ncoorf;nGID=wp.nWeldGroup+1;
			 ntape1.close();DeleteFile("record.tmp");

//aaaaaaaaaaaaa
//aaaaaaaaaaaaaaa
//aaaaaaaaaaaaaaaaa
ifstream ntape3(OpenDialog1->FileName.t_str(),ios::nocreate|ios::binary,0);
if(ntape3){ofstream tmpfile1("omnibusAba.inp",ios::binary,0);
		   ofstream tmpfile3("scratchAba3.tmp",ios::binary,0);
		   if(tmpfile1 && tmpfile3)
			 {jsw=0;
			  do {ntape3.getline(cht,200-1);
				  if(cht[0]=='*' && (cht[1]=='e' || cht[1]=='E') && (cht[2]=='n' || cht[2]=='N') &&
									(cht[3]=='d' || cht[3]=='D')){tmpfile3.close();break;}
				  else if(cht[0]=='*' && (cht[1]=='e' || cht[1]=='E') && (cht[2]=='l' || cht[2]=='L') &&
										 (cht[3]=='s' || cht[3]=='S') && (cht[4]=='e' || cht[4]=='E') &&
										 (cht[5]=='t' || cht[5]=='T')){if(!jsw)tmpfile1.close();jsw=1;}
				  if(jsw){tmpfile3.write(cht,strlen(cht));tmpfile3.put('\n');}
				  else   {tmpfile1.write(cht,strlen(cht));tmpfile1.put('\n');}
				 }
			  while (!ntape3.eof());
			 }
		   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open Aba scratch files",L"Terminate",MB_OK);exit(0);}
		   ntape3.close();
		  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen input file",L"Terminate",MB_OK);exit(0);}
//bbbbbbbbbbbbbbbbb
//bbbbbbbbbbbbbbb
//bbbbbbbbbbbbb

			 FDbase_indat(1,shapecombo,iplotflag,nColRes);
//			   FDdynmem_manage(-16,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   FDdynmem_manage(-17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
////			   FDdynmem_manage(16,dummy,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);//EFP 8/07/2011
//			   FDdynmem_manage(17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt+2*sumELSETel);//EFP 8/07/2011
			   FDdynmem_manage(17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt);//EFP 8/07/2011
			   indat.GIDcol=base.GIDcol;
////			   for(in=0;in<base.nelt+1;in++)indat.trackELSET[in]=base.trackELSET[in];
//			   for(in=0;in<base.nelt+2*sumELSETel;in++)indat.arrELSET[in]=base.arrELSET[in];
			   for(in=0;in<base.nelt;in++)indat.arrELSET[in]=base.arrELSET[in];
////			   for(in=0;in<base.nelt+2*sumELSETel;in++)indat.orig_arrELSET[in]=base.arrELSET[in];
////

//if(1==1)exit(0);
//////////////////////////////////////
	if(nGID<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No geometry IDs found",L"Halt",MB_OK);return;}
	else {if(iPaintyesno/10==0){
								if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
								else {
FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
							FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
									 }
								iPaintyesno=10+1;iCullyesno=0;
							   }

			 stateVFT=2;FD_LButtonstatus=11;

Form1->Caption=GeomFileName;

////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
//////////
			 wp.memWGa=sumlim;
//			 wp.memWGa=base.nelt; //Temporary assignment EFP 3/26/2011
honk<<sumlim<<" ImpAbq MEM\n";
			 iplotflag=1;iCircleplot=1;
			 Invalidate();
		 }

			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen input file",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);
			 if(iswtype)Application->MessageBox(L"Nodes/elements/GID missing from *.abq datafile",L"Failure",MB_OK);
			 else       Application->MessageBox(L"Nodes/elements/GID missing from *.inp datafile",L"Failure",MB_OK);
			}
			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen *.tmp file",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.tmp file",L"Failure",MB_OK);}
	   ntape2.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);
		  if(iswtype)Application->MessageBox(L"Could not open *.abq file",L"Failure",MB_OK);
		  else       Application->MessageBox(L"Could not open *.inp file",L"Failure",MB_OK);
		 }
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
	  }
}

//---------------------------------------------------------------------------
void TForm1::degen8_test(long* eltype,long* n8,long larr[])// Convert degenerate hex to wedge/tetra  EFP 8/30/2014
{long n0=0,n1=0,n2=0,n3=0,n4=0,n5=0,n6=0,n7=0;
 if     (larr[5]==larr[6] && larr[5]==larr[7] && larr[5]==larr[8])
   {*eltype=5; *n8=4;n1=larr[2];n2=larr[3];n3=larr[4];larr[4]=larr[5];
//	if     (n2==n3)continue;
//	else if(n0==n3)continue;
	if     (n1==n2){larr[2]=n1;larr[3]=n3;}
	else if(n0==n1){larr[2]=n2;larr[3]=n3;}
	else {Application->MessageBox(L"Unusual degenerate tet-to-hex in *.abq file",L"Terminate",MB_OK);exit(0);}
	larr[5]=larr[6]=larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[2] && larr[1]==larr[3] && larr[1]==larr[4])
   {*eltype=5; *n8=4;n4=larr[5];n5=larr[6];n6=larr[7];n7=larr[8];larr[4]=larr[1];larr[1]=n4;
	if     (n5==n6){larr[2]=n7;larr[3]=n5;}
	else if(n6==n7){larr[2]=n6;larr[3]=n5;}
	else if(n4==n5){larr[2]=n7;larr[3]=n6;}
	else if(n4==n7){larr[2]=n6;larr[3]=n5;}
	else {Application->MessageBox(L"Unusual degenerate tet-to-hex in *.abq file",L"Terminate",MB_OK);exit(0);}
	larr[5]=larr[6]=larr[7]=larr[8]= -1;
   }
 else if(larr[3]==larr[4] && larr[3]==larr[7] && larr[3]==larr[8])
   {*eltype=5; *n8=4;n1=larr[2];n2=larr[3];larr[4]=n2;
	if     (larr[5]==larr[6]){larr[2]=larr[5];larr[3]=n1;}
	else if(n1==larr[6]){larr[2]=larr[5];larr[3]=n1;}
	else if(larr[1]==larr[5]){larr[2]=larr[6];larr[3]=n1;}
	else if(larr[1]==n1){larr[2]=larr[5];larr[3]=larr[6];}
	else {Application->MessageBox(L"Unusual degenerate tet-to-hex in *.abq file",L"Terminate",MB_OK);exit(0);}
	larr[5]=larr[6]=larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[2] && larr[1]==larr[5] && larr[1]==larr[6])
   {*eltype=5; *n8=4;n0=larr[1];n2=larr[3];n3=larr[4];larr[4]=n0;larr[1]=n2;
	if     (n3==larr[8]){larr[2]=larr[7];larr[3]=n3;}
	else if(larr[7]==larr[8]){larr[2]=larr[7];larr[3]=n3;}
	else if(n2==larr[7]){larr[2]=larr[8];larr[3]=n3;}
	else if(n2==n3){larr[2]=larr[7];larr[3]=larr[8];}
	else {Application->MessageBox(L"Unusual degenerate tet-to-hex in *.abq file",L"Terminate",MB_OK);exit(0);}
	larr[5]=larr[6]=larr[7]=larr[8]= -1;
   }
 else if(larr[2]==larr[3] && larr[2]==larr[6] && larr[2]==larr[7])
   {*eltype=5; *n8=4;n1=larr[2];n2=larr[3];n3=larr[4];
	if     (larr[5]==larr[8]){larr[2]=n3;larr[3]=larr[5];larr[4]=n1;}
	else if(n3==larr[8]){larr[2]=n3;larr[3]=larr[5];larr[4]=n1;}
	else if(larr[1]==larr[5]){larr[2]=n3;larr[3]=larr[8];larr[4]=n1;}
	else if(larr[1]==n3){larr[2]=larr[8];larr[3]=larr[5];larr[4]=n2;}
	else {Application->MessageBox(L"Unusual degenerate tet-to-hex in *.abq file",L"Terminate",MB_OK);exit(0);}
	larr[5]=larr[6]=larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[4] && larr[1]==larr[5] && larr[1]==larr[8])
   {*eltype=5; *n8=4;n0=larr[1];n1=larr[2];n2=larr[3];larr[4]=n0;larr[1]=n1;
	if     (n2==larr[7])larr[1]=larr[6];
	else if(larr[6]==larr[7])larr[2]=larr[6];
	else if(n1==larr[6])larr[2]=larr[7];
	else if(n1==n2){larr[2]=larr[6];larr[3]=larr[7];}
	else {Application->MessageBox(L"Unusual degenerate tet-to-hex in *.abq file",L"Terminate",MB_OK);exit(0);}
	larr[5]=larr[6]=larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[4] && larr[2]==larr[3])
   {*eltype=7; *n8=6;n0=larr[1];n1=larr[2];n4=larr[5];n5=larr[6];larr[1]=n1;larr[2]=n5;larr[3]=larr[7];larr[4]=n0;larr[6]=larr[8];larr[7]=larr[8]= -1;
   }
 else if((larr[5]==larr[8] && larr[6]==larr[7]) || (larr[3]==larr[7] && larr[4]==larr[8]))
   {*eltype=7; *n8=6;n0=larr[1];n1=larr[2];n3=larr[4];n5=larr[6];larr[1]=n1;larr[2]=n5;larr[4]=n0;larr[6]=n3;larr[7]=larr[8]= -1;
   }
 else if(larr[5]==larr[6] && larr[7]==larr[8])
   {*eltype=7; *n8=6;n1=larr[2];n2=larr[3];n4=larr[5];larr[2]=n4;larr[3]=n1;larr[5]=larr[7];larr[6]=n2;larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[2] && larr[3]==larr[4])
   {*eltype=7; *n8=6;n2=larr[3];n4=larr[5];n5=larr[6];larr[2]=n4;larr[3]=n5;larr[4]=n2;larr[5]=larr[8];larr[6]=larr[7];larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[5] && larr[4]==larr[8])
   {*eltype=7; *n8=6;n1=larr[2];n2=larr[3];n3=larr[4];n4=larr[5];n5=larr[6];larr[2]=n5;larr[3]=n1;larr[5]=larr[7];larr[6]=n2;larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[5] && larr[2]==larr[6])
   {*eltype=7; *n8=6;n0=larr[1];n1=larr[2];n3=larr[4];larr[1]=n1;larr[2]=larr[7];larr[4]=n0;larr[5]=larr[8];larr[6]=n3;larr[7]=larr[8]= -1;
   }
 else if(larr[2]==larr[6] && larr[3]==larr[7])
   {*eltype=7; *n8=6;n1=larr[2];n2=larr[3];n3=larr[4];n4=larr[5];larr[2]=n4;larr[3]=n1;larr[5]=larr[8];larr[6]=n2;larr[7]=larr[8]= -1;
   }
 else if(larr[1]==larr[2] && larr[5]==larr[6])
   {*eltype=7; *n8=6;n2=larr[3];n3=larr[4];n4=larr[5];larr[2]=n2;larr[3]=n3;larr[4]=n4;larr[5]=larr[7];larr[6]=larr[8];larr[7]=larr[8]= -1;
   }
 else if(larr[2]==larr[3] && larr[6]==larr[7])
   {*eltype=7; *n8=6;n3=larr[4];n4=larr[5];n5=larr[6];larr[3]=n3;larr[4]=n4;larr[5]=n5;larr[6]=larr[8];larr[7]=larr[8]= -1;
   }
 else if((larr[3]==larr[4] && larr[7]==larr[8]) || (larr[1]==larr[4] && larr[5]==larr[8]))
   {*eltype=7; *n8=6;n4=larr[5];n5=larr[6];larr[4]=n4;larr[5]=n5;larr[6]=larr[7];larr[7]=larr[8]= -1;
   }
}
////---------------------------------------------------------------------------
//void __fastcall TForm1::ImportAbaInpExecute(TObject *Sender)
//{extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported input file option",L"Failure",MB_OK);
//}
/*
//---------------------------------------------------------------------------
long TForm1::ProcessAllWG(long nelt,long nop1[],long matno[],long nWeldGroup,String groupsname[],int flg)
// Routine to discern multiple weld groups bundled into (e.g.) ELSET=WG_ALL
// flg=0 --> compute new #WGsplit;1 --> fill arrays with new WGsplit
{long ie=0,ig=0,ig1=nWeldGroup,is=0,ip=0,ic=0,is1=0,ip1=0,icount=0,nipismin=0,nipismax=0,numdum=0,eltype=0,bscode=0,node=0,ieGID=0,
	  t3=1000,t5=100000,t7=10000000, *dumarr=NULL, *duminv=NULL, *dummap=NULL;
 int isw=0, *dumloc=NULL;
 int gdata8[24]={0,1,5,4,
				 1,2,6,5,
				 3,2,6,7,
				 0,3,7,4,
				 0,1,2,3,
				 4,5,6,7};
 wchar_t curMess2[]=L"WGsplit_",curMess3[]=L"_",string0[32],string1[32];
//   if(wp.nWeldGroup!=ii){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(wp.nWeldGroup)).w_str());
//						 StringCchCatW(string0,32,curMess3);StringCchCatW(string0,32,IntToStr(__int64(ii)).w_str());
//						 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Warning: #WG reduced by WP coincidence",MB_OK);
 for(ig=0;ig<nWeldGroup;ig++)
   {numdum=0;for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
									if(ieGID==ig+1)numdum++;
								   }
	if(numdum)
	  {dumarr=new long[numdum];duminv=new long[nelt];for(ip=0;ip<nelt;ip++)duminv[ip]= -1;
	   is=0;for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
								   if(ieGID==ig+1){dumarr[is]=ie;duminv[ie]=is;is++;}
								  }
	   dummap=new long[6*numdum];for(ip=0;ip<6*numdum;ip++)dummap[ip]= -1;
	   for(ip=0;ip<numdum-1;ip++){for(is=0;is<6;is++) // Assumes contiguous nodal numbering
									{if(dummap[6*ip+is]<0) //Search forward for facet coincidence by max/min opposite corners
									   {nipismin=min(nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
										nipismax=max(nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
										isw=0;
										for(ip1=ip+1;ip1<numdum;ip1++){for(is1=0;is1<6;is1++)
																		 if(dummap[6*ip1+is1]<0){
if((nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]) &&
   (nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]))
  {dummap[6*ip+is]=10*dumarr[ip1]+is1;dummap[6*ip1+is1]=10*dumarr[ip]+is;isw=1;break;}
																								}
																	   if(isw)break;
																	  }
									   }
									}
								 }
	   dumloc=new int[numdum];for(is=0;is<numdum;is++)dumloc[is]=0;
	   ip=0;dumloc[ip]=1;for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;
	   for(ip1=1;ip1<numdum;ip1++) //TBD Improve efficiency here...
		 {for(ip=1;ip<numdum;ip++)
			{if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;}
			}
		 }
	   icount=0;for(ip=0;ip<numdum;ip++)if(dumloc[ip])icount++;
	   if(icount!=numdum)
		 {
/////////////////
		  if(flg){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(ig)).w_str());
//   if(wp.nWeldGroup!=ii){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(wp.nWeldGroup)).w_str());
//						 StringCchCatW(string0,32,curMess3);StringCchCatW(string0,32,IntToStr(__int64(ii)).w_str());
				  groupsname[ig]=string0;
				 }
/////////////////
		  ic=0;for(ip1=0;ip1<numdum;ip1++){if(!dumloc[ip1]){dumarr[ic]=dumarr[ip1];duminv[dumarr[ic]]=ic;
															for(is1=0;is1<6;is1++)dummap[6*ic+is1]=dummap[6*ip1+is1];
															ic++;
														   }
										  }
		  numdum=ic;
		  do {for(is=0;is<numdum;is++)dumloc[is]=0;
			  ip=0;dumloc[ip]=1;for(is=0;is<6;is++){if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;}
			  for(ip1=1;ip1<numdum;ip1++)  //TBD Improve efficiency here...
				{for(ip=1;ip<numdum;ip++)
				   {if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[duminv[dummap[6*ip+is]/10]]=1;}
				   }
				}
//			  if(flg)groupsname[ig1]=L"Bananas"; //TBD Fix this name to include #........
			  if(flg){StringCchCopyW(string1,32,curMess2);StringCchCatW(string1,32,IntToStr(__int64(ig)).w_str());
					  StringCchCatW(string1,32,curMess3);StringCchCatW(string1,32,IntToStr(__int64(ig1-ig)).w_str());
//					  groupsname[ig1]=L"Bananas"; //TBD Fix this name to include #........
					  groupsname[ig1]=string1; //TBD Fix this name to include #........
					 }
			  icount=0;
			  for(ip=0;ip<numdum;ip++){if(dumloc[ip]){if(flg){matno[duminv[ip]]=matno[duminv[ip]]-ig+ig1;

//honk<<ip<<" "<<duminv[ip]<<" "<<matno[duminv[ip]]<<"IGGchange\n";
															 }
													  icount++;
													 }
									  }
			  ic=0;if(icount!=numdum){for(ip1=0;ip1<numdum;ip1++){if(!dumloc[ip1]){dumarr[ic]=dumarr[ip1];duminv[dumarr[ic]]=ic;
																				   for(is1=0;is1<6;is1++)dummap[6*ic+is1]=dummap[6*ip1+is1];
																				   ic++;
																				  }
																 }
									 }
			  numdum=ic;ig1++;
			 }
		  while (numdum);
		 }
	   delete [] dumloc;delete [] dummap;delete [] duminv;delete [] dumarr;
	  }
   }
// TBD: "Bananas" WG is written to Model.VFTr with 0 elements
//      WP_ALL still has all WG elements (1 to 1920)

//honk<<ig1<<" IGGGY\n";
 return ig1;
}
*/
/*
//---------------------------------------------------------------------------
long TForm1::ProcessAllWG1(long nelt,long nop1[],long matno[],long nWeldGroup,String groupsname[],long allGrp,int t_allGID[],int flg)
// Routine to discern multiple weld groups bundled into (e.g.) ELSET=WG_ALL
// flg=0 --> compute new #WGsplit;1 --> fill arrays with new WGsplit
{long ie=0,ig=0,ig1=nWeldGroup,is=0,ip=0,ic=0,is1=0,ip1=0,icount=0,nipismin=0,nipismax=0,numdum=0,eltype=0,bscode=0,node=0,ieGID=0,
	  t3=1000,t5=100000,t7=10000000, *dumarr=NULL, *duminv=NULL, *dummap=NULL;
 int isw=0, *dumloc=NULL;
 int gdata8[24]={0,1,5,4,
				 1,2,6,5,
				 3,2,6,7,
				 0,3,7,4,
				 0,1,2,3,
				 4,5,6,7};
 wchar_t curMess2[]=L"WGsplit_",curMess3[]=L"_",string0[32],string1[32];
//   if(wp.nWeldGroup!=ii){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(wp.nWeldGroup)).w_str());
//						 StringCchCatW(string0,32,curMess3);StringCchCatW(string0,32,IntToStr(__int64(ii)).w_str());
//						 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Warning: #WG reduced by WP coincidence",MB_OK);
 for(ig=0;ig<nWeldGroup;ig++)
   {numdum=0;for(ie=0;ie<nelt;ie++){
									eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
									ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;

honk<<ig<<" "<<ie+1<<" preSts "<<ieGID<<"\n";
//									if(ieGID==ig+1)numdum++;
									if(t_allGID[nelt*(allGrp-nWeldGroup+ig)+ie])numdum++;
								   }

honk<<numdum<<" "<<nelt<<"  numdummmmmmmmmmmm\n";
	if(numdum)
	  {dumarr=new long[numdum];duminv=new long[nelt];for(ip=0;ip<nelt;ip++)duminv[ip]= -1;
	   is=0;for(ie=0;ie<nelt;ie++){
//	                               eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
//								   ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//								   if(ieGID==ig+1){dumarr[is]=ie;duminv[ie]=is;is++;}
								   if(t_allGID[nelt*(allGrp-nWeldGroup+ig)+ie]){dumarr[is]=ie;duminv[ie]=is;is++;}
								  }
	   dummap=new long[6*numdum];for(ip=0;ip<6*numdum;ip++)dummap[ip]= -1;
	   for(ip=0;ip<numdum-1;ip++){for(is=0;is<6;is++) // Assumes contiguous nodal numbering
									{if(dummap[6*ip+is]<0) //Search forward for facet coincidence by max/min opposite corners
									   {nipismin=min(nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
										nipismax=max(nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
										isw=0;
										for(ip1=ip+1;ip1<numdum;ip1++){for(is1=0;is1<6;is1++)
																		 if(dummap[6*ip1+is1]<0){
if((nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]) &&
   (nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]))
  {dummap[6*ip+is]=10*dumarr[ip1]+is1;dummap[6*ip1+is1]=10*dumarr[ip]+is;isw=1;break;}
																								}
																	   if(isw)break;
																	  }
									   }
									}
								 }
	   dumloc=new int[numdum];for(is=0;is<numdum;is++)dumloc[is]=0;
	   ip=0;dumloc[ip]=1;for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;
	   for(ip1=1;ip1<numdum;ip1++) //TBD Improve efficiency here...
		 {for(ip=1;ip<numdum;ip++)
			{if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;}
			}
		 }
	   icount=0;for(ip=0;ip<numdum;ip++)if(dumloc[ip])icount++;
	   if(icount!=numdum)
		 {
/////////////////
		  if(flg){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(ig)).w_str());
//   if(wp.nWeldGroup!=ii){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(wp.nWeldGroup)).w_str());
//						 StringCchCatW(string0,32,curMess3);StringCchCatW(string0,32,IntToStr(__int64(ii)).w_str());
				  groupsname[ig]=string0;
				 }
/////////////////
		  ic=0;for(ip1=0;ip1<numdum;ip1++){if(!dumloc[ip1]){dumarr[ic]=dumarr[ip1];duminv[dumarr[ic]]=ic;
															for(is1=0;is1<6;is1++)dummap[6*ic+is1]=dummap[6*ip1+is1];
															ic++;
														   }
										  }
		  numdum=ic;
		  do {for(is=0;is<numdum;is++)dumloc[is]=0;
			  ip=0;dumloc[ip]=1;for(is=0;is<6;is++){if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;}
			  for(ip1=1;ip1<numdum;ip1++)  //TBD Improve efficiency here...
				{for(ip=1;ip<numdum;ip++)
				   {if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[duminv[dummap[6*ip+is]/10]]=1;}
				   }
				}
//			  if(flg)groupsname[ig1]=L"Bananas"; //TBD Fix this name to include #........
			  if(flg){StringCchCopyW(string1,32,curMess2);StringCchCatW(string1,32,IntToStr(__int64(ig)).w_str());
					  StringCchCatW(string1,32,curMess3);StringCchCatW(string1,32,IntToStr(__int64(ig1-ig)).w_str());
//					  groupsname[ig1]=L"Bananas"; //TBD Fix this name to include #........
					  groupsname[ig1]=string1; //TBD Fix this name to include #........
					 }
			  icount=0;
			  for(ip=0;ip<numdum;ip++){if(dumloc[ip]){if(flg){matno[duminv[ip]]=matno[duminv[ip]]-ig+ig1;

honk<<ip<<" "<<duminv[ip]<<" "<<matno[duminv[ip]]<<" IGGchange "<<ig<<" "<<ig1<<"\n";
/////////////////////////// start EFP 2/26/2012
															  t_allGID[nelt*(allGrp-nWeldGroup+ig )+duminv[ip]]=0;
															  t_allGID[nelt*(allGrp-nWeldGroup+ig1)+duminv[ip]]=1;
///////////////////////////
															 }
													  icount++;
													 }
									  }
			  ic=0;if(icount!=numdum){for(ip1=0;ip1<numdum;ip1++){if(!dumloc[ip1]){dumarr[ic]=dumarr[ip1];duminv[dumarr[ic]]=ic;
																				   for(is1=0;is1<6;is1++)dummap[6*ic+is1]=dummap[6*ip1+is1];
																				   ic++;
																				  }
																 }
									 }
			  numdum=ic;ig1++;
			 }
		  while (numdum);
		 }
	   delete [] dumloc;delete [] dummap;delete [] duminv;delete [] dumarr;
	  }
   }
// TBD: "Bananas" WG is written to Model.VFTr with 0 elements
//      WP_ALL still has all WG elements (1 to 1920)

//honk<<ig1<<" IGGGY\n";
 return ig1;
}
*/
//---------------------------------------------------------------------------
long TForm1::ProcessAllWG2(long nelt,long nop1[],long nWeldGroup,String groupsname[],long allGrp,int t_allGID[],int flg)
// Routine to discern multiple weld groups bundled into (e.g.) ELSET=WG_ALL
//8-n elements in WG
// flg=0 --> compute new #WGsplit;1 --> fill arrays with new WGsplit
{long ie=0,ig=0,ig1=nWeldGroup,is=0,ip=0,ic=0,is1=0,ip1=0,icount=0,nipismin=0,nipismax=0,numdum=0,eltype=0,bscode=0,node=0,ieGID=0,
	  totwgel=0,t3=1000,t5=100000,t7=10000000, *dumarr=NULL, *duminv=NULL, *dummap=NULL;
 int isw=0, *dumloc=NULL,
//     gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
	 gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 wchar_t curMess2[]=L"WGsplit_",curMess3[]=L"_",string0[32],string1[32];
//   if(wp.nWeldGroup!=ii){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(wp.nWeldGroup)).w_str());
//						 StringCchCatW(string0,32,curMess3);StringCchCatW(string0,32,IntToStr(__int64(ii)).w_str());
//						 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Warning: #WG reduced by WP coincidence",MB_OK);

///////////////////////// trash
//float xave=0.,yave=0.,zave=0.;
honk<<"\n";
//if(!flg){
//for(ig=0;ig<nelt;ig++){honk<<ig<<" Cel "<<base.nop1[MXNPEL*ig+0]<<" "<<base.nop1[MXNPEL*ig+1]<<" "<<base.nop1[MXNPEL*ig+2]<<" "<<base.nop1[MXNPEL*ig+3]
//								   <<" "<<base.nop1[MXNPEL*ig+4]<<" "<<base.nop1[MXNPEL*ig+5]<<" "<<base.nop1[MXNPEL*ig+6]<<" "<<base.nop1[MXNPEL*ig+7]<<"\n";
//xave=yave=zave=0.;for(ip=0;ip<8;ip++){xave=xave+base.c1[NDF*base.nop1[MXNPEL*ig+ip]+0];
//									  yave=yave+base.c1[NDF*base.nop1[MXNPEL*ig+ip]+1];
//									  zave=zave+base.c1[NDF*base.nop1[MXNPEL*ig+ip]+2];
//									 }
//xave=xave/8.;yave=yave/8.;zave=zave/8.;
//					   honk<<xave<<" "<<yave<<" "<<zave<<"\n";
//					  }
//		}
//if(flg)honk<<allGrp<<" AllGrp/nWG2 "<<nWeldGroup<<"\n";
/////////////////////////
 for(ig=0;ig<nWeldGroup;ig++)
   {numdum=0;for(ie=0;ie<nelt;ie++)if(t_allGID[nelt*(allGrp-nWeldGroup+ig)+ie])numdum++; //8-n assumed in this
//honk<<ig+1<<" WG has raw #elem/out of "<<numdum<<" "<<nelt<<" flag "<<flg<<"\n";
	if(numdum)
	  {dumarr=new long[numdum];duminv=new long[nelt];for(ip=0;ip<nelt;ip++)duminv[ip]= -1; // 8-n assumed in the following
	   is=0;for(ie=0;ie<nelt;ie++)if(t_allGID[nelt*(allGrp-nWeldGroup+ig)+ie]){dumarr[is]=ie;duminv[ie]=is;is++;}
	   dummap=new long[6*numdum];for(ip=0;ip<6*numdum;ip++)dummap[ip]= -1;
	   for(ip=0;ip<numdum-1;ip++){for(is=0;is<6;is++) // Assumes contiguous nodal numbering
									{if(dummap[6*ip+is]<0) //Search forward for facet coincidence by max/min opposite corners
									   {nipismin=min(nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
										nipismax=max(nop1[MXNPEL*dumarr[ip]+gdata8[4*is+0]],nop1[MXNPEL*dumarr[ip]+gdata8[4*is+2]]);
										isw=0;
										for(ip1=ip+1;ip1<numdum;ip1++){for(is1=0;is1<6;is1++)
																		 if(dummap[6*ip1+is1]<0){
if((nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismin==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]) &&
   (nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+0]] || nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+1]] ||
	nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+2]] || nipismax==nop1[MXNPEL*dumarr[ip1]+gdata8[4*is1+3]]))
  {dummap[6*ip+is]=10*dumarr[ip1]+is1;dummap[6*ip1+is1]=10*dumarr[ip]+is;isw=1;break;}
																								}
																	   if(isw)break;
																	  }
									   }
									}
								 }
///////////////
//for(ip=0;ip<numdum;ip++)honk<<ip<<" dummap "<<dummap[6*ip+0]<<" "<<dummap[6*ip+1]<<" "<<dummap[6*ip+2]<<" "<<dummap[6*ip+3]<<" "<<dummap[6*ip+4]<<" "<<dummap[6*ip+5]<<"\n";
///////////////
	   dumloc=new int[numdum];for(is=0;is<numdum;is++)dumloc[is]=0;
	   ip=0;dumloc[ip]=1;for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;
//	   for(ip1=1;ip1<numdum;ip1++) //TBD Improve efficiency here...
//		 {for(ip=1;ip<numdum;ip++)
//			{if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;}
//			}
//		 }
	   for(ip1=0;ip1<numdum;ip1++) //TBD Improve efficiency here...
		 {isw=0;
		  for(ip=1;ip<numdum;ip++)
			{if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0 && !dumloc[ duminv[dummap[6*ip+is]/10] ])
												 {dumloc[ duminv[dummap[6*ip+is]/10] ]=1;
												  isw=1;
												 }
						   }
			}
		  if(!isw)break;
		 }
	   icount=0;for(ip=0;ip<numdum;ip++)if(dumloc[ip])icount++;
	   if(icount!=numdum)
		 {if(flg){StringCchCopyW(string0,32,curMess2);StringCchCatW(string0,32,IntToStr(__int64(ig)).w_str());
				  groupsname[ig]=string0;
				 }
		  ic=0;for(ip1=0;ip1<numdum;ip1++){if(!dumloc[ip1]){
//if(flg)honk<<ip1<<" "<<icount<<" "<<dumarr[ip1]<<" Outlaw\n";
															dumarr[ic]=dumarr[ip1];duminv[dumarr[ic]]=ic;
															for(is1=0;is1<6;is1++)dummap[6*ic+is1]=dummap[6*ip1+is1];
															ic++;
														   }
//else {if(flg){honk<<ip1<<" "<<icount<<" "<<dumarr[ip1]<<" In-law\n";
//			 }
//	 }
										  }
//if(!flg){honk<<ig+1<<" "<<0<<" "<<numdum-ic<<" Original/new WG & #elements\n";
if(!flg){honk<<"WGsplit-"<<ig<<" "<<numdum-ic<<" Original/new WG & #elements\n";
		 totwgel=totwgel+numdum-ic;
		}
		  numdum=ic;
		  do {for(is=0;is<numdum;is++)dumloc[is]=0;
///////////////
//honk<<" He do be\n";
			  ip=0;dumloc[ip]=1;for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[ duminv[dummap[6*ip+is]/10] ]=1;
//			  for(ip1=1;ip1<numdum;ip1++)  //TBD Improve efficiency here...
//				{for(ip=1;ip<numdum;ip++)
//				   {if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0)dumloc[duminv[dummap[6*ip+is]/10]]=1;}
//				   }
//				}
			  for(ip1=0;ip1<numdum;ip1++)  //TBD Improve efficiency here...
				{isw=0;
				 for(ip=1;ip<numdum;ip++)
				   {if(dumloc[ip]){for(is=0;is<6;is++)if(dummap[6*ip+is]>=0 && !dumloc[ duminv[dummap[6*ip+is]/10] ])
														{dumloc[duminv[dummap[6*ip+is]/10]]=1;
														 isw=1;
														}
								  }
				   }
				 if(!isw)break;
				}
			  if(flg){StringCchCopyW(string1,32,curMess2);StringCchCatW(string1,32,IntToStr(__int64(ig)).w_str());
					  StringCchCatW(string1,32,curMess3);StringCchCatW(string1,32,IntToStr(__int64(ig1-ig)).w_str());
					  groupsname[ig1]=string1; //TBD Fix this name to include #........
					 }
			  icount=0;
//			  for(ip=0;ip<numdum;ip++){if(dumloc[ip]){if(flg){t_allGID[nelt*(allGrp-nWeldGroup+ig )+duminv[ip]]=0;
			  for(ip=0;ip<numdum;ip++){if(dumloc[ip]){if(flg){t_allGID[nelt*(allGrp-nWeldGroup+ig )+dumarr[ip]]=0;

////honk<<ip<<" "<<allGrp-nWeldGroup+ig<<" decepticon "<<allGrp-nWeldGroup+ig1<<" "<<duminv[ip]<<"\n";
//honk<<ip<<" "<<allGrp-nWeldGroup+ig<<" decepticon "<<allGrp-nWeldGroup+ig1<<" "<<dumarr[ip]<<"\n";

//															  t_allGID[nelt*(allGrp-nWeldGroup+ig1)+duminv[ip]]=1;
															  t_allGID[nelt*(allGrp-nWeldGroup+ig1)+dumarr[ip]]=1;
															 }
													  icount++;
													 }
									  }
			  ic=0;if(icount!=numdum){for(ip1=0;ip1<numdum;ip1++){if(!dumloc[ip1]){
//if(flg)honk<<ip1<<" "<<icount<<" "<<dumarr[ip1]<<" OutlawN\n";
																				   dumarr[ic]=dumarr[ip1];duminv[dumarr[ic]]=ic;
																				   for(is1=0;is1<6;is1++)dummap[6*ic+is1]=dummap[6*ip1+is1];
																				   ic++;
																				  }
//else {if(flg)honk<<ip1<<" "<<icount<<" "<<dumarr[ip1]<<" In-lawN\n";
//	 }
																 }
									 }
//honk<<numdum<<" "<<ig1<<" "<<flg<<" new WG\n";
if(!flg){honk<<"WGsplit-"<<ig<<"-"<<ig1<<" "<<numdum-ic<<" new WG\n";
		 totwgel=totwgel+numdum-ic;
		}
			  numdum=ic;ig1++;
			 }
		  while (numdum);
if(!flg)honk<<totwgel<<" TotalWG elements\n";
		 }
	   delete [] dumloc;delete [] dummap;delete [] duminv;delete [] dumarr;
	  }
   }
 return ig1;
}
//---------------------------------------------------------------------------
void TForm1::FDelemfacets_arE3(long npoin,long nelt,long nop1[],long matno[],int arELE[])
// Version using huge memory for speed (Code allows for quadratic elements)  Global LONG_INT,MXNPEL,MAX_GID,nGIDmax
// Corrected 2008/08/15 for several erroneous "isw=1;break;".
// Version with log search throughout
{int isw=0,side_arr8[26]={16,0,0,0,0,16,1,1,0,0,8,2,2,8,0,0,4,4,0,0,32,0,0,0,0,32},
	 side_arr6[10]={8,1,4,2,0,0,0,0,0,16},side_arr4[4]={1,8,4,2};
 long ie=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,
	  ip=0,in=0,iv=0,ivp=0,nside=0,in0=0,in0p=0,in0pp=0,inx=0,inxp=0,inxpp=0,oppn0=0,oppn1=0,oppn3=0,prod=0,
	  iex=0,eltypex=0,bscodex=0,nodex=0,ieGIDx=0,mxnelvertex=0,accum=0,
	  lows=0,mids=0,tops=0,istx=0,lowsp=0,midsp=0,topsp=0,istxp=0,corruptf[4],*arr1=NULL,*arr3=NULL;
// Note: matno[i]=8*10000000+nodes*1000+ipid -1; Also bscodex=1+2+4+8+16+32......
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
//
 arr1=new long[npoin+1];for(ip=0;ip<npoin+1;ip++) *(arr1+ip)=0;
 for(ip=0;ip<4;ip++)corruptf[ip]=0; //EFP 8/01/2014
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
////						ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012  Note that matno[] here is indat.matno[]
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[ie];
//////////////
						if(arELE[ie]){if(eltype==8){bscodex=63;nodex=8;}
									  else if(eltype==7){bscodex=31;nodex=6;}
									  else {bscodex=15;nodex=4;}
									  for(in=0;in<nodex;in++) *(arr1+nop1[MXNPEL*ie+in])= *(arr1+nop1[MXNPEL*ie+in])+1;
									 }
						else bscodex=0;
						matno[ie]=matno[ie]-(bscode-bscodex)*t5;
					   }
 mxnelvertex=accum=0;for(ip=0;ip<npoin;ip++){if(mxnelvertex< *(arr1+ip))mxnelvertex= *(arr1+ip);accum=accum+ *(arr1+ip); *(arr1+ip)=accum;}
 for(ip=npoin;ip>0;ip--) *(arr1+ip)= *(arr1+ip-1); *arr1=0;
// try {arr3=new long[accum];}catch (xalloc){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient facet dynamic memory",L"Exit",MB_OK);exit(0);}
 arr3=new long[accum];if(arr3==NULL){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient facet dynamic memory",L"Exit",MB_OK);exit(0);}
// honk<<mxnelvertex<<" MxNelVert "<<accum<<" "<<npoin<<"\n";
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
////						ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[ie];
//////////////
						if(arELE[ie]){if(eltype==8)nodex=8;else if(eltype==7)nodex=6;else nodex=4;
									  for(in=0;in<nodex;in++){ip=nop1[MXNPEL*ie+in]; *(arr3+ *(arr1+ip))=10*ie+in; *(arr1+ip)= *(arr1+ip)+1;}
									 }
					   }
 for(ip=npoin;ip>0;ip--) *(arr1+ip)= *(arr1+ip-1); *arr1=0;
//
 for(ie=0;ie<nelt-1;ie++)
   {eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
////	ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[ie];
//////////////
	if(arELE[ie])
	  {if(eltype==8)
		 {nside=6;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0){oppn0=nop1[MXNPEL*ie+0];oppn3=nop1[MXNPEL*ie+5];}
				else if(iv==1){oppn0=nop1[MXNPEL*ie+1];oppn3=nop1[MXNPEL*ie+6];}
				else if(iv==2){oppn0=nop1[MXNPEL*ie+2];oppn3=nop1[MXNPEL*ie+7];}
				else if(iv==3){oppn0=nop1[MXNPEL*ie+3];oppn3=nop1[MXNPEL*ie+4];}
				else if(iv==4){oppn0=nop1[MXNPEL*ie+0];oppn3=nop1[MXNPEL*ie+2];}
				else {oppn0=nop1[MXNPEL*ie+4];oppn3=nop1[MXNPEL*ie+6];}
				isw=0;istx= *(arr1+oppn3);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
////							  ieGIDx=matno[iex]-eltypex*t7-bscodex*t5-nodex*t3;
//////////////// EFP 2/20/2012
//						if(indat.trackELSET[iex+1]-indat.trackELSET[iex]==1)ieGIDx=0;
//						else if(indat.arrELSET[ indat.trackELSET[iex+1]-1 ]<0)ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-2 ];
//						else {if(indat.GIDcol==1)ieGIDx=indat.arrELSET[ indat.trackELSET[iex]+indat.GIDcol ]; //Prioritize WG
//							  else ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-1 ];                      //Prioritize WP
//							 }
ieGIDx=indat.arrELSET[iex];
//////////////
							  if(ieGIDx==ieGID)
								{lows=istx;tops= *(arr1+oppn3+1) -1;
								 if(eltypex==8)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {matno[ie]=matno[ie]-prod*t5;in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;
										  ivp=side_arr8[3*min(in0,in0p)+2*max(in0,in0p)-4];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 else if(eltypex==7)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {matno[ie]=matno[ie]-prod*t5;
										  in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;ivp=side_arr6[in0+in0p-3];
//										  if(ivp>0 && ivp<8){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//										  else {extern PACKAGE void __fastcall Beep(void);
////												Application->MessageBox(L"Corrupt hex-wedge mesh",L"Terminate",MB_OK);
//												Application->MessageBox(L"Ignoring corrupt hex-wedge mesh",L"Warning",MB_OK);
////												exit(0);
//												break;
//											   }
										  if(ivp>0 && ivp<8)matno[iex]=matno[iex]-ivp*t5;
										  else corruptf[0]=corruptf[0]+1;
										  isw=1;break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 if(isw)break;
								}
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
//
	   else if(eltype==7)
		 {nside=5;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0){oppn0=nop1[MXNPEL*ie+0];oppn3=nop1[MXNPEL*ie+4];}
				else if(iv==1){oppn0=nop1[MXNPEL*ie+1];oppn3=nop1[MXNPEL*ie+5];}
				else if(iv==2){oppn0=nop1[MXNPEL*ie+2];oppn3=nop1[MXNPEL*ie+3];}
				else if(iv==3){oppn0=nop1[MXNPEL*ie+0];oppn1=nop1[MXNPEL*ie+1];oppn3=nop1[MXNPEL*ie+2];istxp= *(arr1+oppn1);}
				else {oppn0=nop1[MXNPEL*ie+3];oppn1=nop1[MXNPEL*ie+4];oppn3=nop1[MXNPEL*ie+5];istxp= *(arr1+oppn1);}
				isw=0;istx= *(arr1+oppn3);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
////							  ieGIDx=matno[iex]-eltypex*t7-bscodex*t5-nodex*t3;
//////////////// EFP 2/20/2012
//						if(indat.trackELSET[iex+1]-indat.trackELSET[iex]==1)ieGIDx=0;
//						else if(indat.arrELSET[ indat.trackELSET[iex+1]-1 ]<0)ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-2 ];
//						else {if(indat.GIDcol==1)ieGIDx=indat.arrELSET[ indat.trackELSET[iex]+indat.GIDcol ]; //Prioritize WG
//							  else ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-1 ];                      //Prioritize WP
//							 }
ieGIDx=indat.arrELSET[iex];
//////////////
							  if(ieGIDx==ieGID)
								{
								 lows=istx;tops= *(arr1+oppn3+1) -1; //Correction??? Moved to here... EFP 4/14/2011
								 if(iv<3)
								   {
//								    lows=istx;tops= *(arr1+oppn3+1) -1; //Correction??? Moved above... EFP 4/14/2011
									if(eltypex==8)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{matno[ie]=matno[ie]-prod*t5;in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;
											 ivp=side_arr8[3*min(in0,in0p)+2*max(in0,in0p)-4];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
									else if(eltypex==7)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{matno[ie]=matno[ie]-prod*t5;
											 in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;ivp=side_arr6[in0+in0p-3];
//											 if(ivp>0 && ivp<8){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//											 else {extern PACKAGE void __fastcall Beep(void);
////												   Application->MessageBox(L"Corrupt hex-wedge mesh",L"Terminate",MB_OK);
//												   Application->MessageBox(L"Ignoring corrupt hex-wedge mesh",L"Notice",MB_OK);
////												   exit(0);
//												   break;
//												  }
											 if(ivp>0 && ivp<8)matno[iex]=matno[iex]-ivp*t5;
											 else corruptf[0]=corruptf[0]+1;
											 isw=1;break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
								   }
								 else
								   {if(eltypex==7)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
											 for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											   {midsp=(lowsp+topsp)/2;
												if( *(arr3+midsp)/10==iex)
												  {matno[ie]=matno[ie]-prod*t5;
												   in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												   ivp=side_arr6[in0+in0p+in0pp-3];
//												   if(ivp>4){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//												   else {
//honk<<ie<<" "<<eltype<<" "<<iv<<" Har Meggido1 "<<iex<<" "<<eltypex<<" "<<inxp<<" "<<inxpp<<" "<<ivp<<"\n";
//														 extern PACKAGE void __fastcall Beep(void);
////														 Application->MessageBox(L"Corrupt wedge-wedge mesh",L"Terminate",MB_OK);
//														 Application->MessageBox(L"Ignoring corrupt wedge-wedge mesh",L"Warning",MB_OK);
////														 exit(0);
//														 break;
//														}
												   if(ivp>4)matno[iex]=matno[iex]-ivp*t5;
												   else corruptf[1]=corruptf[1]+1;
												   isw=1;break;
												  }
												else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
												else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											   }
											 break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
									else if(eltypex==5)
									  {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
										 {mids=(lows+tops)/2;
										  if( *(arr3+mids)/10==iex)
											{istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
											 for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											   {midsp=(lowsp+topsp)/2;
												if( *(arr3+midsp)/10==iex)
												  {matno[ie]=matno[ie]-prod*t5;
												   in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												   ivp=side_arr4[in0+in0p+in0pp-3];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
												  }
												else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
												else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											   }
											 break;
											}
										  else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
										  else {istx=mids;if(lows==tops)break;else lows=mids+1;}
										 }
									  }
								   }
								 if(isw)break;
								}
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
//
	   else if(eltype==5)
		 {nside=4;prod=1;
		  for(iv=0;iv<nside;iv++)
			{if(bscode && prod)
			   {if(iv==0){oppn0=nop1[MXNPEL*ie+0];oppn1=nop1[MXNPEL*ie+2];oppn3=nop1[MXNPEL*ie+1];}
				else if(iv==1){oppn0=nop1[MXNPEL*ie+1];oppn1=nop1[MXNPEL*ie+2];oppn3=nop1[MXNPEL*ie+3];}
				else if(iv==2){oppn0=nop1[MXNPEL*ie+2];oppn1=nop1[MXNPEL*ie+0];oppn3=nop1[MXNPEL*ie+3];}
				else {oppn0=nop1[MXNPEL*ie+3];oppn1=nop1[MXNPEL*ie+0];oppn3=nop1[MXNPEL*ie+1];}
				isw=0;istx= *(arr1+oppn3);istxp= *(arr1+oppn1);
				for(inx= *(arr1+oppn0);inx< *(arr1+oppn0+1);inx++)
				  {iex= *(arr3+inx)/10;
				   if(iex>ie){eltypex=matno[iex]/t7;bscodex=(matno[iex]-eltypex*t7)/t5;nodex=(matno[iex]-eltypex*t7-bscodex*t5)/t3;
////				              ieGIDx=matno[iex]-eltypex*t7-bscodex*t5-nodex*t3;
///////////////// EFP 2/20/2012
//						if(indat.trackELSET[iex+1]-indat.trackELSET[iex]==1)ieGIDx=0;
//						else if(indat.arrELSET[ indat.trackELSET[iex+1]-1 ]<0)ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-2 ];
//						else {if(indat.GIDcol==1)ieGIDx=indat.arrELSET[ indat.trackELSET[iex]+indat.GIDcol ]; //Prioritize WG
//							  else ieGIDx=indat.arrELSET[ indat.trackELSET[iex+1]-1 ];                      //Prioritize WP
//							 }
ieGIDx=indat.arrELSET[iex];
//////////////
							  if(ieGIDx==ieGID)
								{
								 lows=istx;tops= *(arr1+oppn3+1) -1; //Correction??? Added to here... EFP 4/14/2011
								 if(eltypex==7)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
										  for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											{midsp=(lowsp+topsp)/2;
											 if( *(arr3+midsp)/10==iex)
											   {matno[ie]=matno[ie]-prod*t5;
												in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												ivp=side_arr6[in0+in0p+in0pp-3];
//												if(ivp>4){matno[iex]=matno[iex]-ivp*t5;isw=1;break;}
//												else {extern PACKAGE void __fastcall Beep(void);
////													  Application->MessageBox(L"Corrupt tetra-wedge mesh",L"Terminate",MB_OK);
//													  Application->MessageBox(L"Ignoring corrupt tetra-wedge mesh",L"Warning",MB_OK);
////													  exit(0);
//													  break;
//													 }
												if(ivp>4)matno[iex]=matno[iex]-ivp*t5;
												else corruptf[2]=corruptf[2]+1;
												isw=1;break;
											   }
											 else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
											 else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											}
										  break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 else if(eltypex==5)
								   {for(inxp=istx;inxp< *(arr1+oppn3+1);inxp++)
									  {mids=(lows+tops)/2;
									   if( *(arr3+mids)/10==iex)
										 {istx=mids+1;lowsp=istxp;topsp= *(arr1+oppn1+1) -1;
										  for(inxpp=istxp;inxpp< *(arr1+oppn1+1);inxpp++)
											{midsp=(lowsp+topsp)/2;
											 if( *(arr3+midsp)/10==iex)
											   {matno[ie]=matno[ie]-prod*t5;
												in0= *(arr3+inx)-10*iex;in0p= *(arr3+mids)-10*iex;in0pp= *(arr3+midsp)-10*iex;
												ivp=side_arr4[in0+in0p+in0pp-3];matno[iex]=matno[iex]-ivp*t5;isw=1;break;
											   }
											 else if( *(arr3+midsp)/10>iex){if(lowsp==topsp)break;else topsp=midsp-1;}
											 else {istxp=midsp;if(lowsp==topsp)break;else lowsp=midsp+1;}
											}
										  break;
										 }
									   else if( *(arr3+mids)/10>iex){if(lows==tops)break;else tops=mids-1;}
									   else {istx=mids;if(lows==tops)break;else lows=mids+1;}
									  }
								   }
								 if(isw)break;
								}
							 }
				  }
			   }
			 prod=prod*2;
			}
		 }
	   else {
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
honk<<ie<<" "<<eltype<<" "<<bscode<<" "<<node<<" "<<ieGID<<" "<<" FDelemfacets_arE3()\n";
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
//			 extern PACKAGE void __fastcall Beep(void);
////			 Application->MessageBox(L"Unsupported elements found in FDelemfacets_arE3()",L"Terminate",MB_OK);
//			 Application->MessageBox(L"Unsupported elements found in FDelemfacets_arE3()",L"Warning",MB_OK);
////			 exit(0); //Speculative intervention EFP 7/31/2014
			 corruptf[3]=corruptf[3]+1;
			}
	  }
   }
 delete [] arr1;delete [] arr3;
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
 if(corruptf[3]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported elements found in FDelemfacets_arE3()",L"Warning",MB_OK);}
 if     (corruptf[0] && corruptf[1] && corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/wedge/hex found in FDelemfacets_arE3()",L"Warning",MB_OK);}
 else if(corruptf[0] && corruptf[1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge/hex found in FDelemfacets_arE3()",L"Warning",MB_OK);}
 else if(corruptf[1] && corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/wedge found in FDelemfacets_arE3()",L"Warning",MB_OK);}
 else if(corruptf[2] && corruptf[0]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet/hex found in FDelemfacets_arE3()",L"Warning",MB_OK);}
 else if(corruptf[0]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge-hex found in FDelemfacets_arE3()",L"Warning",MB_OK);}
 else if(corruptf[1]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt wedge-wedge found in FDelemfacets_arE3()",L"Warning",MB_OK);}
 else if(corruptf[2]){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt tet-wedge found in FDelemfacets_arE3()",L"Warning",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn1Click(TObject *Sender)// Selection mode of graphics
{if(base.nop1){if(CreateLinWeldPass){FD_LButtonstatus=17;stateVFT=1;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
									}
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No dialog box open.",L"Halt",MB_OK);}
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"53Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn2Click(TObject *Sender)// View mode
{if(base.nop1){FD_LButtonstatus=11; // stateVFT=2 for pivot, 3 for pan
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"54Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn3Click(TObject *Sender)// 3DMasterSuiteHelp (not used)
//{if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"3DMasterSuiteHelp (not used)",L"Halt",MB_OK);}
{if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"(unfinished) Graphics Help",L"Halt",MB_OK);}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"55Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn4Click(TObject *Sender)// Set current view as home view
{if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"(unfinished) Set current view as home view",L"Halt",MB_OK);}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"56Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn5Click(TObject *Sender)// Return to this home view
//{if(base.nop1){iplotflag=1;iCullyesno=1;Invalidate();}
{if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"(unfinished) Return to this home view",L"Halt",MB_OK);}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"57Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn6Click(TObject *Sender)// View all regions of model AKA Center
//{if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"(unfinished) Return to this home view",L"Halt",MB_OK);}
{if(base.nop1){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////

			   iplotflag=1;iCullyesno=1;Invalidate();}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"58Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn7Click(TObject *Sender)// Target zoom
{if(base.nop1){FD_LBrec=FD_LButtonstatus;stateVFTrec=stateVFT;
			   FD_LButtonstatus=13;stateVFT=4;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
			  }
//{if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"(unfinished) Target zoom",L"Halt",MB_OK);}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"59Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn8Click(TObject *Sender)// ZOOM BOX
{if(base.nop1){FD_LBrec=FD_LButtonstatus;
			   stateVFTrec=stateVFT;
			   FD_LButtonstatus=1;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"60Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn9Click(TObject *Sender)
//Same as RestoreExecute()
{long in=0;
 if(base.nop1){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   for(in=0;in<base.nelt;in++)base.arELEM[in]=1;//Correction EFP 2/04/2011 (Not used when iplotType != 2 but it is necessary to reset for next polygon)

			   iplotType=0;FDrestore();
//               FD_LButtonstatus=11; // stateVFT=2 for pivot, 3 for pan
//			   SpeedButton1->Down=false;
//			   SpeedButton2->Down=true;
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"61Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn10Click(TObject *Sender)
// Same as MaskElem0()
{if(base.nop1){iplotType=2;FD_LButtonstatus=16;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
			  }  // Include elements within poly
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"62Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BitBtn11Click(TObject *Sender)
{if(base.nop1)
  {if(wp.nWeldPass){FD_LButtonstatus=22;
					if(QNode){delete QNode;QNode=NULL;}
					if(QElem){delete QElem;QElem=NULL;} //EFP 3/29/2012
					if(QNDist){delete QNDist;QNDist=NULL;}
					TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crDefault;
				   }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"None or one weld pass found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::WeldParam_public() //TBD Test these
{int missing=0,isel=CreateWeldingParamSet->CheckISEL;long i=wp.PRECORD;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
//FDrestore();
///////////
 if(isel){wps.name[i]=CreateWeldingParamSet->CheckEdit1;wps.curr[i]=CreateWeldingParamSet->CheckEdit2;
		  wps.volt[i]=CreateWeldingParamSet->CheckEdit3;wps.eff[i]=CreateWeldingParamSet->CheckEdit4;
		  wps.speed[i]=CreateWeldingParamSet->CheckEdit5;
		  FD_LButtonstatus=11;stateVFT=2;
		  delete CreateWeldingParamSet; //Created with Show()
//	CreateWeldingParamSet=NULL;// because it was created with Show()
		 }
 else {if(CreateWeldingParamSet->CheckEdit1=="****")
		 {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to enter weld parameter name",L"Repeat",MB_OK);
		  missing++;
		 }
	   else wps.name[wps.nWeldParamSet]=CreateWeldingParamSet->CheckEdit1;
	   wps.curr[wps.nWeldParamSet]=CreateWeldingParamSet->CheckEdit2;
	   wps.volt[wps.nWeldParamSet]=CreateWeldingParamSet->CheckEdit3;
	   wps.eff[wps.nWeldParamSet]=CreateWeldingParamSet->CheckEdit4;
	   wps.speed[wps.nWeldParamSet]=CreateWeldingParamSet->CheckEdit5;
	   if(!missing){
//MaterialProperties1->Enabled=true;
////CreateNewFulllinWeldPass1=0;
////CreateNewLinearWeldPass1=0;
////WeldPassEditingandSequencing1=0;
////ShowWeldSequence1=0;
					wps.nWeldParamSet=wps.nWeldParamSet+1;
					wps.highest=wps.highest+1;
				   }
// delete CreateWeldingParamSet;
	   CreateWeldingParamSet->Close(); //Created with ShowModal()
	  }
 CreateWeldingParamSet=NULL;
/////////// Cursor EFP 1/21/2011
//Screen->Cursor=crSizeAll;
//FDrestore();
///////////
}
//---------------------------------------------------------------------------
void TForm1::MatProperties_public()
{int missing=0,ip=CreateMatPropSet->CheckRadioGroup1,isel=CreateMatPropSet->CheckISEL;
 long i=wp.PRECORD;
//////////////////////////////// Convention  EFP 3/13/2012
//wms.mcr  CheckRadioGroup1  Model        RadioButton  ip
//0           0          Iso(multilin)        1        0
//1           3          CombineH(lin)        4        3
//2           1          CombineH(multilin)   2        1
//3           4          EPC(Iso,multilin)    5        4
//other(6)    5          CompletePhT          6        5
//5           2          SinglePhTransf       3        2
////////////////////////////////

honk<<isel<<" "<<ip<<" IPPPPPP "<<CreateMatPropSet->CheckCheckBox1<<"\n";

 if(isel){wms.cond[i]=CreateMatPropSet->CheckEdit2;
		  wms.heat[i]=CreateMatPropSet->CheckEdit3;
		  wms.den[i]=CreateMatPropSet->CheckEdit4;
		  if(ip==0){wms.mcr[i]=0;
					if(CreateMatPropSet->CheckCheckBox1){wms.hetjd[i]= -1;wms.switc[i]=true;
//														 wms.nprops[i]=wms.nprops[i]+1;
														 wms.Steps[i]=CreateMatPropSet->CheckEdit5a;
														}
					else {wms.hetjd[i]=0;
						  wms.switc[i]=false;
						 }
				   }
////		  else if(ip==1)wms.mcr[i]=1;
////		  else if(ip==2)wms.mcr[i]=2;
////		  else if(ip==3)wms.mcr[i]=3;
////		  else if(ip==4)wms.mcr[i]=5;
//		  else if(ip==1)wms.mcr[i]=2; // Correction  BBrust 3/25/2011
//		  else if(ip==2)wms.mcr[i]=5;
//		  else if(ip==3)wms.mcr[i]=1;
//		  else if(ip==4)wms.mcr[i]=3;
//		  else wms.mcr[i]=6;
		  else if(ip==1){wms.mcr[i]=2;wms.hetjd[i]=0;wms.switc[i]=false;}
		  else if(ip==2){wms.mcr[i]=5;wms.hetjd[i]=0;wms.switc[i]=false;}
		  else if(ip==3){wms.mcr[i]=1;wms.hetjd[i]=0;wms.switc[i]=false;}
		  else if(ip==4){wms.mcr[i]=3;  //Creep added to EPC  EFP 3/14/2012
//						 wms.hetjd[i]=0;wms.switc[i]=false;
					if(CreateMatPropSet->CheckCheckBox1){wms.hetjd[i]= -1;wms.switc[i]=true;
//														 wms.nprops[i]=wms.nprops[i]+1;
														 wms.Steps[i]=CreateMatPropSet->CheckEdit5a;
														}
					else {wms.hetjd[i]=0;
						  wms.switc[i]=false;
						 }
						}//Elas=Plas-Creep
		  else          {wms.mcr[i]=6;wms.hetjd[i]=0;wms.switc[i]=false;} // Correction  BBrust 3/25/2011 & EFP 3/27/2011

//VFT convention: wms.annjd[]= -1 is ON (read & use Ti/Ta/Tm);=0 is OFF (use pre-loaded 750/1500/1500)
		  if(CreateMatPropSet->CheckGroupBox3)wms.annjd[i]= -1; //Correction#2 EFP 3/15/2012
//		  if(!CreateMatPropSet->CheckGroupBox3)wms.annjd[i]= -1;//Correction  EFP 9/09/2011
		  else {wms.annjd[i]=0;
//				CreateMatPropSet->CheckEdit5=750.; //Correction 9/09/2011
//				CreateMatPropSet->CheckEdit6=1500.;
//				CreateMatPropSet->CheckEdit7=1500.;
			   }
		  wms.Ti[i]=CreateMatPropSet->CheckEdit5; //This assumes that 750/1500/1500 have been loaded into Form21
		  wms.Ta[i]=CreateMatPropSet->CheckEdit6;
		  wms.Tm[i]=CreateMatPropSet->CheckEdit7;

//VFT convention: wms.ved= -1 is ON;=0 is OFF
		  if(CreateMatPropSet->CheckGroupBox4)wms.ved[i]= -1; //Correction#2 EFP 3/15/2012
//		  if(!CreateMatPropSet->CheckGroupBox4)wms.ved[i]= -1;//Correction  EFP 9/09/2011
		  else wms.ved[i]=0;

// No coding yet for bool wms.switc/wms.hetjd/wms.Steps EFP 4/01/2010
		  wms.name[i]=CreateMatPropSet->CheckEdit1;
/////////// trash
//honk<<wms.name[i].c_str()<<" MatProperties_public\n";
/////////////////
		  wms.matFileName[i]=CreateMatPropSet->CheckEdit8;




//wchar_t *driveEFP=new wchar_t[260];
//wchar_t *dirEFP=new wchar_t[260];
//wchar_t *extEFP=new wchar_t[260];
//wchar_t *matFN=new wchar_t[260];
////driveEFP=new char[260];dirEFP=new char[260];extEFP=new char[260];
//////fnsplit(OpenDialog1->FileName.c_str(),driveEFP,dirEFP,modelName_g,extEFP);
//_wfnsplit((wchar_t)OpenDialog1->FileName,driveEFP,dirEFP,matFN,extEFP);
//honk<< driveEFP<<" driveEFP\n";honk<< dirEFP<<" dirEFP\n";honk<< matFN<<" modelName_g\n";honk<< extEFP<<" extEFP\n";
//delete [] driveEFP;delete [] dirEFP;delete [] extEFP;

/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
		  delete CreateMatPropSet; //Created with Show()
		 }
 else {
 wms.cond[wms.nMatPropSet]=CreateMatPropSet->CheckEdit2;
 wms.heat[wms.nMatPropSet]=CreateMatPropSet->CheckEdit3;
 wms.den[wms.nMatPropSet]=CreateMatPropSet->CheckEdit4;
 if(ip==0){wms.mcr[wms.nMatPropSet]=0;
		   if(CreateMatPropSet->CheckCheckBox1){wms.hetjd[wms.nMatPropSet]= -1;wms.switc[wms.nMatPropSet]=true;
//												wms.nprops[wms.nMatPropSet]=wms.nprops[wms.nMatPropSet]+1;
												wms.Steps[wms.nMatPropSet]=CreateMatPropSet->CheckEdit5a;
											   }
		   else {wms.hetjd[wms.nMatPropSet]=0;
				 wms.switc[wms.nMatPropSet]=false;
				}
		  }
//// else if(ip==1)wms.mcr[wms.nMatPropSet]=1;
//// else if(ip==2)wms.mcr[wms.nMatPropSet]=2;
//// else if(ip==3)wms.mcr[wms.nMatPropSet]=3;
//// else if(ip==4)wms.mcr[wms.nMatPropSet]=5;
// else if(ip==1)wms.mcr[wms.nMatPropSet]=2; // Correction BBrust 3/25/2011
// else if(ip==2)wms.mcr[wms.nMatPropSet]=5;
// else if(ip==3)wms.mcr[wms.nMatPropSet]=1;
// else if(ip==4)wms.mcr[wms.nMatPropSet]=3;
// else wms.mcr[wms.nMatPropSet]=6;
 else if(ip==1){wms.mcr[wms.nMatPropSet]=2;wms.hetjd[wms.nMatPropSet]=0;wms.switc[wms.nMatPropSet]=false;}
 else if(ip==2){wms.mcr[wms.nMatPropSet]=5;wms.hetjd[wms.nMatPropSet]=0;wms.switc[wms.nMatPropSet]=false;}
 else if(ip==3){wms.mcr[wms.nMatPropSet]=1;wms.hetjd[wms.nMatPropSet]=0;wms.switc[wms.nMatPropSet]=false;}
 else if(ip==4){wms.mcr[wms.nMatPropSet]=3;
//                wms.hetjd[wms.nMatPropSet]=0;wms.switc[wms.nMatPropSet]=false;
		   if(CreateMatPropSet->CheckCheckBox1){wms.hetjd[wms.nMatPropSet]= -1;wms.switc[wms.nMatPropSet]=true;
//												wms.nprops[wms.nMatPropSet]=wms.nprops[wms.nMatPropSet]+1;
												wms.Steps[wms.nMatPropSet]=CreateMatPropSet->CheckEdit5a;
											   }
		   else {wms.hetjd[wms.nMatPropSet]=0;
				 wms.switc[wms.nMatPropSet]=false;
				}
			   }
 else          {wms.mcr[wms.nMatPropSet]=6;wms.hetjd[wms.nMatPropSet]=0;wms.switc[wms.nMatPropSet]=false;} // Correction BBrust 3/25/2011

//VFT convention: wms.annjd[]= -1 is ON (read & use Ti/Ta/Tm);=0 is OFF (use pre-loaded 750/1500/1500)
 if(CreateMatPropSet->CheckGroupBox3)wms.annjd[wms.nMatPropSet]= -1;
// if(!CreateMatPropSet->CheckGroupBox3)wms.annjd[wms.nMatPropSet]= -1;//Correction  EFP 9/09/2011
 else {wms.annjd[wms.nMatPropSet]=0;      //Correction#2 EFP 3/15/2012
//	   CreateMatPropSet->CheckEdit5=750.; //Correction  EFP 9/09/2011
//	   CreateMatPropSet->CheckEdit6=1500.;
//	   CreateMatPropSet->CheckEdit7=1500.;
	  }
 wms.Ti[wms.nMatPropSet]=CreateMatPropSet->CheckEdit5;
 wms.Ta[wms.nMatPropSet]=CreateMatPropSet->CheckEdit6;
 wms.Tm[wms.nMatPropSet]=CreateMatPropSet->CheckEdit7;

//VFT convention: wms.ved= -1 is ON;=0 is OFF
 if(CreateMatPropSet->CheckGroupBox4)wms.ved[wms.nMatPropSet]= -1;   //Correction#2 EFP 3/15/2012
// if(!CreateMatPropSet->CheckGroupBox4)wms.ved[wms.nMatPropSet]= -1;//Correction  EFP 9/09/2011
 else wms.ved[wms.nMatPropSet]=0;
// No coding yet for bool wms.switc/wms.hetjd/wms.Steps EFP 4/01/2010
//honk<<CreateMatPropSet->CheckEdit1.c_str()<<" MatPropSet name\n";
//honk<<CreateMatPropSet->CheckEdit8.c_str()<<" MechPropSet name\n";

if(CreateMatPropSet->CheckEdit1=="****")
  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to enter material property set name",L"Repeat",MB_OK);
   missing++;
  }
else wms.name[wms.nMatPropSet]=CreateMatPropSet->CheckEdit1;
if(CreateMatPropSet->CheckEdit8=="****")
  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to enter mechanical property file name",L"Repeat",MB_OK);
   missing++;
  }
else wms.matFileName[wms.nMatPropSet]=CreateMatPropSet->CheckEdit8;



////int ip=0;
////for(ip=0;ip< strlen(wms.matFileName[i].as_string());ip++)honk<< wms.matFileName[i].t_str() <<"\n";
////if(1==1)exit(0);
//honk<< wms.matFileName[i].t_str() <<"\n";
//honk<< wms.matFileName[i][0].t_str() <<"\n";
//honk<< wms.matFileName[i][1].t_str() <<"\n";
//if(1==1)exit(0);

 if(!missing){
//CreateaNewFulllinWeldPass1->Enabled=true;
//CreateaNewLinearWeldPass1->Enabled=true;
////WeldPassEditingandSequencing1=0;
////ShowWeldSequence1=0;
			  wms.nMatPropSet=wms.nMatPropSet+1;
			  wms.highest=wms.highest+1;
			 }
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
	   CreateMatPropSet->Close(); //Created with ShowModal()
	  }
 CreateMatPropSet=NULL;
}

//---------------------------------------------------------------------------
void TForm1::WeldPassEditSeqn1_public() //Animate weld seq+dir  EFP 12/31/2011
{long eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,i=0,ip=0,in=0,ie=0,ic=0;
 Screen->Cursor=crHourGlass; //Arrow is restored in PanGo1Execute() animation termination
 ip=iPersistVFT/10;iPersistVFT=10*ip+0;
 for(i=0;i<base.nelt;i++)base.arELEM[i]=1;
 iplotType=2;iplotflag=2;iPaintyesno=0;
 if(iPaintyesno/10==0){if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
					   else {FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
							 FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
							}
					   iPaintyesno=10;iCullyesno=0;
					  }
 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
////						  ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
////////////// EFP 2/20/2012
//						if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
//						else if(base.arrELSET[ base.trackELSET[i+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[i+1]-2 ];
//						else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[i]+base.GIDcol ]; //Prioritize WG
//							  else ieGID=base.arrELSET[ base.trackELSET[i+1]-1 ];                      //Prioritize WP
//							 }
ieGID=base.arrELSET[i];
////////////
						  if(ieGID>0)base.arELEM[i]=0;
						 }
 iCircleplot=1;Invalidate();
/////////// Cursor EFP 1/21/2011
//Screen->Cursor=crSizeAll;
///////////
//Convention: icTimer5=a+1000b, where a=current WP sequence & b=current slice  EFP 1/01/2012
 icTimer5=0;FD_LBrec=FD_LButtonstatus;stateVFTrec=stateVFT;FD_LButtonstatus=19;
 Timer2->Interval=WeldPassEditSeqn->CheckEdit1;
///////////////////////
honk<<Timer2->Interval<<" Timer2->Interval\n";
///////////////////////
 Timer2->Enabled=true;
}

//---------------------------------------------------------------------------
void TForm1::WeldPassEditSeqn2_public() //Enter
{long ip=0,ipp=0;
 for(ip=0;ip<wp.nWeldPass;ip++){WeldPassEditSeqn->CheckSeq=ip;
								wp.seqNum[ip]=WeldPassEditSeqn->CheckSeq;
//								if(!WeldPassEditSeqn->CheckDir)// Change direction of weld pass
								if(WeldPassEditSeqn->CheckDir != wp.reset[ip]-10*(wp.reset[ip]/10))//EFP 3/28/2012 Change direction of weld pass
								  {RevProg0(ip);
								   ipp=wp.reset[ip]-10*(wp.reset[ip]/10);//EFP 3/28/2012
								   wp.reset[ip]=10*(wp.reset[ip]/10)+1-ipp;
								  }
							   }
 delete WeldPassEditSeqn;WeldPassEditSeqn=NULL;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 Invalidate();
}
//---------------------------------------------------------------------------
void TForm1::WeldPassEditSeqn3_public(){Screen->Cursor=crSizeAll;delete WeldPassEditSeqn;WeldPassEditSeqn=NULL;}//Cancel EFP 3/29/2012
//---------------------------------------------------------------------------
void TForm1::FDpaintplot1(int isel,long startFacet,long endFacet)
//{int gdata20[48]={0, 8,1,13,5,16,4,12,
//				  1, 9,2,14,6,17,5,13,
//				  3,10,2,14,6,18,7,15,
//				  0,11,3,15,7,19,4,12,
//				  0, 8,1, 9,2,10,3,11,
//				  4,16,5,17,6,18,7,19};
{int gdata20[48]={0, 8,1,13,5,16,4,12,
				  1, 9,2,14,6,17,5,13,
				  2,10,3,15,7,18,6,14,
				  3,11,0,12,4,19,7,15,
				  1, 8,0,11,3,10,2,9,
				  4,16,5,17,6,18,7,19};
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
//  These are IDEAS conventions (NOT CAP)
//	  .      JOINT6/1, 2, 3, 1, 4, 0,
//	  .             2, 3, 1, 3, 5, 0,
//	  .             5, 6, 4, 2, 6, 0,
//	  .             4, 5, 6, 0, 0, 0/
 int gdata15[40]={0, 6,1,10,4,12,3, 9,
				  1, 7,2,11,5,13,4,10,
				  2, 8,0, 9,3,14,5,11,
				  0, 8,2, 7,1, 6,0, 0,
				  3,12,4,13,5,14,0, 0};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata10[24]={0,6,2,5,1,4,
				  1,5,2,9,3,8,
				  2,6,0,7,3,9,
				  3,7,0,4,1,8};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
// int npts=0,rcolor=0,gcolor=0,bcolor=0;
 int npts=0;
 long ic=0,ie=0,fType=0,iside=0,ip=0,ipp=0,ir=0,is=0,plotpts=16,plotst=0,ij=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
// long ic=0,ie=0,fType=0,iside=0,ip=0,ipp=0,ir=0,is=0,plotpts=3,plotst=0,ij=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
// long ic=0,ie=0,fType=0,iside=0,ip=0,ipp=0,ir=0,is=0,plotpts=2,plotst=0,ij=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 double plotinc=0.,plotcd=0.,plot1e=0.,plot1d=0.,plot2e=0.,plot2d=0.,plot3d=0.,val=0.;plotinc=2./double(plotpts);
 TPoint ptDraw[MAXPOINTS],ptDraw1[4];          // arbFacet[nFacets]=ies*t3+fType*10+5;
 if(isel)tBitmap->Canvas->Pen->Width=1;
 else Canvas->Pen->Width=1;
 for(ic=startFacet;ic<endFacet+1;ic++)
  {ie=arbFacet[ic]/t3;
   if(base.arELEM[ie])
   {fType=(arbFacet[ic]-ie*t3)/10;iside=arbFacet[ic]-ie*t3-fType*10;
	eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
////	ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[ie];
//////////////
//    if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;

	  if(isel){
	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clWhite;
	if(fType==1)tBitmap->Canvas->Brush->Color=clLtGray;
	else {

/*
		  ir=ieGID-9*(ieGID/9);
//		  if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
//		  else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen ;else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
//		  else if(ir==4)tBitmap->Canvas->Brush->Color=clNavy  ;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
//		  else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive ;else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
//		  else          tBitmap->Canvas->Brush->Color=clRed;
		  if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;
//		  else tBitmap->Canvas->Brush->Color=clRed; //Per Bud's request, all welds in red. EFP 4/03/2010
		  else tBitmap->Canvas->Brush->Color=clYellow; //Per Bud's request, all welds in red. EFP 4/03/2010
*/

if(ieGID==0 || ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;
//else if(ieGID==1 || ieGID==2)tBitmap->Canvas->Pen->Color=clRed;
//else tBitmap->Canvas->Pen->Color=wp.WeldColor[ieGID-3];
else if(ieGID<wp.nWeldGroup+1)tBitmap->Canvas->Pen->Color=clRed;
else {
//	  honk<<ieGID-wp.nWeldGroup-1<<" "<<wp.WeldColor[ieGID-wp.nWeldGroup-1]<<" AAAAWeldColor\n";
	  tBitmap->Canvas->Pen->Color=wp.WeldColor[ieGID-wp.nWeldGroup-1];
	 }


		 }
			  }
	  else    {
	if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clWhite;
	if(fType==1)Canvas->Brush->Color=clLtGray;
	else {


/*
		  ir=ieGID-9*(ieGID/9);
//		  if     (ir==0)tBitmap->Canvas->Brush->Color=clLtGray;else if(ir==1)tBitmap->Canvas->Brush->Color=clBlue;
//		  else if(ir==2)tBitmap->Canvas->Brush->Color=clGreen ;else if(ir==3)tBitmap->Canvas->Brush->Color=clLime;
//		  else if(ir==4)tBitmap->Canvas->Brush->Color=clNavy  ;else if(ir==5)tBitmap->Canvas->Brush->Color=clYellow;
//		  else if(ir==6)tBitmap->Canvas->Brush->Color=clOlive ;else if(ir==7)tBitmap->Canvas->Brush->Color=clMaroon;
//		  else          tBitmap->Canvas->Brush->Color=clRed;
		  if     (ir==0)Canvas->Brush->Color=clLtGray;
//		  else Canvas->Brush->Color=clRed; //Per Bud's request, all welds in red. EFP 4/03/2010
		  else Canvas->Brush->Color=clYellow; //Per Bud's request, all welds in red. EFP 4/03/2010
*/


if(ieGID==0 || ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;
//else if(ieGID==1 || ieGID==2)tBitmap->Canvas->Pen->Color=clRed;
//else tBitmap->Canvas->Pen->Color=wp.WeldColor[ieGID-3];
else if(ieGID<wp.nWeldGroup+1)Canvas->Pen->Color=clRed;
else {
//	  honk<<ieGID-wp.nWeldGroup-1<<" "<<wp.WeldColor[ieGID-wp.nWeldGroup-1]<<" AAAAWeldColor\n";
	  Canvas->Pen->Color=wp.WeldColor[ieGID-wp.nWeldGroup-1];
//	  tBitmap->Canvas->Brush->Color=wp.WeldColor[ieGID-wp.nWeldGroup-1];
	 }


		 }
			  }
////////////////////////////////////
//tBitmap->Canvas->Brush->Style = bsDiagCross;
////////////////////////////////////
/////////////
//honk<<ic+1<<" "<<ie<<" "<<fType<<" PPLOT "<<ieGID<<" "<<Canvas->Brush->Color<<"\n";
/////////////

	if(eltype==5)
	  {if(node==4){for(ip=0;ip<3;ip++){ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata4[3*iside+ip]]]+0.5);
									   ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata4[3*iside+ip]]+1]+0.5);
									  }
					 if(isel){
				   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,2);else tBitmap->Canvas->Polygon(ptDraw,2);
							 }
					 else    {
				   if(ieGID==MAX_GID-1)Canvas->Polyline(ptDraw,2);else Canvas->Polygon(ptDraw,2);
							 }
				  }
	   else
//////////////////////////////////////////////////////////
				{plot1e= -plotinc/2.;      // L1=plot1e, L2=plot1d, L0=1.-plot1d-plot1e
				 for(is=0;is<plotpts;is++)
				   {plot1e=plot1e+plotinc/2.;plot2e=plot1e+plotinc/2.;if(is==plotpts-1)plot2e=1.;
					plot1d=0.;plot2d=plot1d+plotinc/2.;plot3d=plot2d+plotinc/2.;
val=(1.-2.*plot1e-2.*plot1d)*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot1e*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot1d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot1d*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[0].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot1d)*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot1e*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot1d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot1d*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[0].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[1].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[1].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[2].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[2].y=ClientHeight-int(val+0.5);
					  if(isel){
					tBitmap->Canvas->Polygon(ptDraw1,2);
					if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
					tBitmap->Canvas->Polygon(ptDraw,3*plotpts-1);
							  }
					  else    {
					Canvas->Polygon(ptDraw1,2);
					if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlack;
					Canvas->Polygon(ptDraw,3*plotpts-1);
							  }
//
					if(is<plotpts-1){for(ij=1;ij<plotpts-is;ij++)
									   {if(ij==plotpts-1)plot3d=1.;
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[0].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[0].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[1].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[1].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[2].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[2].y=ClientHeight-int(val+0.5);
										  if(isel){
										tBitmap->Canvas->Polygon(ptDraw1,2);
										if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
										tBitmap->Canvas->Polygon(ptDraw,3*plotpts-1);
												  }
										  else    {
										Canvas->Polygon(ptDraw1,2);
										if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlack;
										Canvas->Polygon(ptDraw,3*plotpts-1);
												  }
//
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[0].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[0].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[1].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[1].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot1e-2.*plot3d)*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]]+
				   4.*plot1e*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]]+
							   4.*plot3d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]]+
						  plot3d*(2.*plot3d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]]+
				   4.*plot3d*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]];
						ptDraw1[2].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot3d)*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside  ]]+1]+
				   4.*plot1e*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+2]]+1]+
							   4.*plot3d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+3]]+1]+
						  plot3d*(2.*plot3d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+4]]+1]+
				   4.*plot3d*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata10[6*iside+5]]+1];
						ptDraw1[2].y=ClientHeight-int(val+0.5);
										  if(isel){
										tBitmap->Canvas->Polygon(ptDraw1,2);
										if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
										tBitmap->Canvas->Polygon(ptDraw,3*plotpts-1);
												  }
										  else    {
										Canvas->Polygon(ptDraw1,2);
										if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlack;
										Canvas->Polygon(ptDraw,3*plotpts-1);
												  }
//
										plot1d=plot1d+plotinc/2.;plot2d=plot1d+plotinc/2.;plot3d=plot2d+plotinc/2.;
									   }
									}
				   }
				}
///////////////////////////////////////////////////////
	  }
	else if(eltype==7)
	  {if(iside>2)npts=3;else npts=4;
	   if(node==6){for(ip=0;ip<npts;ip++){ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata6[4*iside+ip]]]+0.5);
										  ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata6[4*iside+ip]]+1]+0.5);
										 }
					 if(isel){
				   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,npts-1);else tBitmap->Canvas->Polygon(ptDraw,npts-1);
							 }
					 else    {
				   if(ieGID==MAX_GID-1)Canvas->Polyline(ptDraw,npts-1);else Canvas->Polygon(ptDraw,npts-1);
							 }
				  }
	   else
///////////////////////////////////////////////////////
		 {plotst=0;
		  for(ip=0;ip<npts;ip++)
			{plotcd= -plotinc-1.;ipp=ip+1;if(ipp>npts-1)ipp=0;
			 for(is=0;is<plotpts;is++){plotcd=plotcd+plotinc;
				val=0.5*plotcd*(plotcd-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2*ip  ]]]
					   +(1.-plotcd*plotcd)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2*ip+1]]]
				   +0.5*plotcd*(plotcd+1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2*ipp]]];
				ptDraw[plotst].x=int(val+0.5);
				val=0.5*plotcd*(plotcd-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2*ip  ]]+1]
					   +(1.-plotcd*plotcd)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2*ip+1]]+1]
				   +0.5*plotcd*(plotcd+1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2*ipp]]+1];
				ptDraw[plotst].y=ClientHeight-int(val+0.5);plotst++;
			   }
			}
		  if(ieGID==MAX_GID-1){if(isel)tBitmap->Canvas->Polyline(ptDraw,npts*plotpts-1);
							   else    Canvas->Polyline(ptDraw,npts*plotpts-1);
							  }
		  else
			{
////             Canvas->Polygon(ptDraw,4*plotpts-1);
////
//			 if     (ir==0)tBitmap->Canvas->Pen->Color=clLtGray;else if(ir==1)tBitmap->Canvas->Pen->Color=clBlue;
//			 else if(ir==2)tBitmap->Canvas->Pen->Color=clGreen ;else if(ir==3)tBitmap->Canvas->Pen->Color=clLime;
//			 else if(ir==4)tBitmap->Canvas->Pen->Color=clNavy  ;else if(ir==5)tBitmap->Canvas->Pen->Color=clYellow;
//			 else if(ir==6)tBitmap->Canvas->Pen->Color=clOlive ;else if(ir==7)tBitmap->Canvas->Pen->Color=clMaroon;
//			 else          tBitmap->Canvas->Pen->Color=clRed;
			   if(isel){
			 if     (ir==0)tBitmap->Canvas->Pen->Color=clLtGray;
			 else tBitmap->Canvas->Pen->Color=clRed; //Per Bud's request, all welds in red. EFP 4/03/2010
					   }
			   else    {
			 if     (ir==0)Canvas->Pen->Color=clLtGray;
			 else Canvas->Pen->Color=clRed; //Per Bud's request, all welds in red. EFP 4/03/2010
					   }
//
			 if(iside<3)
				{plot1d= -plotinc-1.;
				 for(is=0;is<plotpts;is++)
				   {plot1d=plot1d+plotinc;plot2d=plot1d+plotinc;plot1e= -plotinc-1.;
					for(ij=0;ij<plotpts;ij++)
					   {plot1e=plot1e+plotinc;plot2e=plot1e+plotinc;
val=0.25*(1.-plot1e)*(1.-plot1d)*(-plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				  0.5*(1.-plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
	0.25*(1.+plot1e)*(1.-plot1d)*( plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
				  0.5*(1.+plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
	0.25*(1.+plot1e)*(1.+plot1d)*( plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				  0.5*(1.+plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]]+
	0.25*(1.-plot1e)*(1.+plot1d)*(-plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]]+
				  0.5*(1.-plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]];
						ptDraw1[0].x=int(val+0.5);
val=0.25*(1.-plot1e)*(1.-plot1d)*(-plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				  0.5*(1.-plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
	0.25*(1.+plot1e)*(1.-plot1d)*( plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
				  0.5*(1.+plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
	0.25*(1.+plot1e)*(1.+plot1d)*( plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				  0.5*(1.+plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1]+
	0.25*(1.-plot1e)*(1.+plot1d)*(-plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]+1]+
				  0.5*(1.-plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]+1];
						ptDraw1[0].y=ClientHeight-int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot1d)*(-plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				  0.5*(1.-plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
	0.25*(1.+plot2e)*(1.-plot1d)*( plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
				  0.5*(1.+plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
	0.25*(1.+plot2e)*(1.+plot1d)*( plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				  0.5*(1.+plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]]+
	0.25*(1.-plot2e)*(1.+plot1d)*(-plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]]+
				  0.5*(1.-plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]];
						ptDraw1[1].x=int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot1d)*(-plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				  0.5*(1.-plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
	0.25*(1.+plot2e)*(1.-plot1d)*( plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
				  0.5*(1.+plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
	0.25*(1.+plot2e)*(1.+plot1d)*( plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				  0.5*(1.+plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1]+
	0.25*(1.-plot2e)*(1.+plot1d)*(-plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]+1]+
				  0.5*(1.-plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]+1];
						ptDraw1[1].y=ClientHeight-int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot2d)*(-plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				  0.5*(1.-plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
	0.25*(1.+plot2e)*(1.-plot2d)*( plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
				  0.5*(1.+plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
	0.25*(1.+plot2e)*(1.+plot2d)*( plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				  0.5*(1.+plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]]+
	0.25*(1.-plot2e)*(1.+plot2d)*(-plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]]+
				  0.5*(1.-plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]];
						ptDraw1[2].x=int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot2d)*(-plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				  0.5*(1.-plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
	0.25*(1.+plot2e)*(1.-plot2d)*( plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
				  0.5*(1.+plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
	0.25*(1.+plot2e)*(1.+plot2d)*( plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				  0.5*(1.+plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1]+
	0.25*(1.-plot2e)*(1.+plot2d)*(-plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]+1]+
				  0.5*(1.-plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]+1];
						ptDraw1[2].y=ClientHeight-int(val+0.5);
val=0.25*(1.-plot1e)*(1.-plot2d)*(-plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				  0.5*(1.-plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
	0.25*(1.+plot1e)*(1.-plot2d)*( plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
				  0.5*(1.+plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
	0.25*(1.+plot1e)*(1.+plot2d)*( plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				  0.5*(1.+plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]]+
	0.25*(1.-plot1e)*(1.+plot2d)*(-plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]]+
				  0.5*(1.-plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]];
						ptDraw1[3].x=int(val+0.5);
val=0.25*(1.-plot1e)*(1.-plot2d)*(-plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				  0.5*(1.-plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
	0.25*(1.+plot1e)*(1.-plot2d)*( plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
				  0.5*(1.+plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
	0.25*(1.+plot1e)*(1.+plot2d)*( plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				  0.5*(1.+plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1]+
	0.25*(1.-plot1e)*(1.+plot2d)*(-plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+6]]+1]+
				  0.5*(1.-plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+7]]+1];
						ptDraw1[3].y=ClientHeight-int(val+0.5);
						  if(isel){
						tBitmap->Canvas->Polygon(ptDraw1,npts-1);
						if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
						tBitmap->Canvas->Polygon(ptDraw,npts*plotpts-1);
								  }
						  else    {
						Canvas->Polygon(ptDraw1,npts-1);
						if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlack;
						Canvas->Polygon(ptDraw,npts*plotpts-1);
								  }
//
					   }
				   }
				}
			 else
				{plot1e= -plotinc/2.;      // L1=plot1e, L2=plot1d, L0=1.-plot1d-plot1e
				 for(is=0;is<plotpts;is++)
				   {plot1e=plot1e+plotinc/2.;plot2e=plot1e+plotinc/2.;if(is==plotpts-1)plot2e=1.;
					plot1d=0.;plot2d=plot1d+plotinc/2.;plot3d=plot2d+plotinc/2.;
val=(1.-2.*plot1e-2.*plot1d)*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot1e*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot1d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot1d*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[0].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot1d)*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot1e*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot1d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot1d*(1.-plot1d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[0].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[1].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[1].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[2].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[2].y=ClientHeight-int(val+0.5);
					  if(isel){
					tBitmap->Canvas->Polygon(ptDraw1,npts-1);
					if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
					tBitmap->Canvas->Polygon(ptDraw,npts*plotpts-1);
							  }
					  else    {
					Canvas->Polygon(ptDraw1,npts-1);
					if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlack;
					Canvas->Polygon(ptDraw,npts*plotpts-1);
							  }
//
					if(is<plotpts-1){for(ij=1;ij<plotpts-is;ij++)
									   {if(ij==plotpts-1)plot3d=1.;
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[0].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[0].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[1].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot1d)*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot2e*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot1d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot1d*(2.*plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot1d*(1.-plot1d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[1].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[2].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[2].y=ClientHeight-int(val+0.5);
										  if(isel){
										tBitmap->Canvas->Polygon(ptDraw1,npts-1);
										if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
										tBitmap->Canvas->Polygon(ptDraw,npts*plotpts-1);
												  }
										  else    {
										Canvas->Polygon(ptDraw1,npts-1);
										if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlack;
										Canvas->Polygon(ptDraw,npts*plotpts-1);
												  }
//
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[0].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot2d)*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot1e*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot2d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[0].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[1].x=int(val+0.5);
val=(1.-2.*plot2e-2.*plot2d)*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot2e*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot2e*(2.*plot2e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot2d*plot2e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot2d*(2.*plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot2d*(1.-plot2d-plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[1].y=ClientHeight-int(val+0.5);

val=(1.-2.*plot1e-2.*plot3d)*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]]+
				   4.*plot1e*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]]+
							   4.*plot3d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]]+
						  plot3d*(2.*plot3d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]]+
				   4.*plot3d*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]];
						ptDraw1[2].x=int(val+0.5);
val=(1.-2.*plot1e-2.*plot3d)*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside  ]]+1]+
				   4.*plot1e*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+1]]+1]+
						  plot1e*(2.*plot1e-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+2]]+1]+
							   4.*plot3d*plot1e*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+3]]+1]+
						  plot3d*(2.*plot3d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+4]]+1]+
				   4.*plot3d*(1.-plot3d-plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata15[8*iside+5]]+1];
						ptDraw1[2].y=ClientHeight-int(val+0.5);
										  if(isel){
										tBitmap->Canvas->Polygon(ptDraw1,npts-1);
										if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
										tBitmap->Canvas->Polygon(ptDraw,npts*plotpts-1);
												  }
										  else    {
										Canvas->Polygon(ptDraw1,npts-1);
										if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlack;
										Canvas->Polygon(ptDraw,npts*plotpts-1);
												  }
//
										plot1d=plot1d+plotinc/2.;plot2d=plot1d+plotinc/2.;plot3d=plot2d+plotinc/2.;
									   }
									}
				   }
				}
			}
		 }
///////////////////////////////////////////////////////
	  }
	else
	  {if(node==8){for(ip=0;ip<4;ip++)
					 {ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]]+0.5);
					  ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+1]+0.5);
					 }
					 if(isel){
				   if(ieGID==MAX_GID-1)tBitmap->Canvas->Polyline(ptDraw,3);else tBitmap->Canvas->Polygon(ptDraw,3);
							 }
					 else    {
				   if(ieGID==MAX_GID-1)Canvas->Polyline(ptDraw,3);else Canvas->Polygon(ptDraw,3);
							 }
				  }
	   else
		 {plotst=0;
		  for(ip=0;ip<4;ip++)
			{plotcd= -plotinc-1.;ipp=ip+1;if(ipp>3)ipp=0;
			 for(is=0;is<plotpts;is++){plotcd=plotcd+plotinc;
				val=0.5*plotcd*(plotcd-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2*ip  ]]]
					   +(1.-plotcd*plotcd)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2*ip+1]]]
				   +0.5*plotcd*(plotcd+1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2*ipp]]];
				ptDraw[plotst].x=int(val+0.5);
				val=0.5*plotcd*(plotcd-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2*ip  ]]+1]
					   +(1.-plotcd*plotcd)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2*ip+1]]+1]
				   +0.5*plotcd*(plotcd+1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2*ipp]]+1];
				ptDraw[plotst].y=ClientHeight-int(val+0.5);plotst++;
			   }
			}
		  if(ieGID==MAX_GID-1){if(isel)tBitmap->Canvas->Polyline(ptDraw,4*plotpts-1);
							   else    Canvas->Polyline(ptDraw,4*plotpts-1);
							  }
		  else
			{
//             tBitmap->Canvas->Polygon(ptDraw,4*plotpts-1);
//
			 if(isel){
		  if     (ir==0)tBitmap->Canvas->Pen->Color=clLtGray;else if(ir==1)tBitmap->Canvas->Pen->Color=clBlue;
		  else if(ir==2)tBitmap->Canvas->Pen->Color=clGreen ;else if(ir==3)tBitmap->Canvas->Pen->Color=clLime;
		  else if(ir==4)tBitmap->Canvas->Pen->Color=clNavy  ;else if(ir==5)tBitmap->Canvas->Pen->Color=clYellow;
		  else if(ir==6)tBitmap->Canvas->Pen->Color=clOlive ;else if(ir==7)tBitmap->Canvas->Pen->Color=clMaroon;
		  else          tBitmap->Canvas->Pen->Color=clRed;
					 }
			 else    {
		  if     (ir==0)Canvas->Pen->Color=clLtGray;else if(ir==1)Canvas->Pen->Color=clBlue;
		  else if(ir==2)Canvas->Pen->Color=clGreen ;else if(ir==3)Canvas->Pen->Color=clLime;
		  else if(ir==4)Canvas->Pen->Color=clNavy  ;else if(ir==5)Canvas->Pen->Color=clYellow;
		  else if(ir==6)Canvas->Pen->Color=clOlive ;else if(ir==7)Canvas->Pen->Color=clMaroon;
		  else          Canvas->Pen->Color=clRed;
					 }
//
			 plot1d= -plotinc-1.;
			 for(is=0;is<plotpts;is++)
			   {plot1d=plot1d+plotinc;plot2d=plot1d+plotinc;
				plot1e= -plotinc-1.;
				for(ij=0;ij<plotpts;ij++)
				   {plot1e=plot1e+plotinc;plot2e=plot1e+plotinc;
val=0.25*(1.-plot1e)*(1.-plot1d)*(-plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]]+
				  0.5*(1.-plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]]+
	0.25*(1.+plot1e)*(1.-plot1d)*( plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]]+
				  0.5*(1.+plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]]+
	0.25*(1.+plot1e)*(1.+plot1d)*( plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]]+
				  0.5*(1.+plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]]+
	0.25*(1.-plot1e)*(1.+plot1d)*(-plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]]+
				  0.5*(1.-plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]];
					ptDraw1[0].x=int(val+0.5);
val=0.25*(1.-plot1e)*(1.-plot1d)*(-plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]+1]+
				  0.5*(1.-plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]+1]+
	0.25*(1.+plot1e)*(1.-plot1d)*( plot1e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]+1]+
				  0.5*(1.+plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]+1]+
	0.25*(1.+plot1e)*(1.+plot1d)*( plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]+1]+
				  0.5*(1.+plot1d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]+1]+
	0.25*(1.-plot1e)*(1.+plot1d)*(-plot1e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]+1]+
				  0.5*(1.-plot1e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]+1];
					ptDraw1[0].y=ClientHeight-int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot1d)*(-plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]]+
				  0.5*(1.-plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]]+
	0.25*(1.+plot2e)*(1.-plot1d)*( plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]]+
				  0.5*(1.+plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]]+
	0.25*(1.+plot2e)*(1.+plot1d)*( plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]]+
				  0.5*(1.+plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]]+
	0.25*(1.-plot2e)*(1.+plot1d)*(-plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]]+
				  0.5*(1.-plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]];
					ptDraw1[1].x=int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot1d)*(-plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]+1]+
				  0.5*(1.-plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]+1]+
	0.25*(1.+plot2e)*(1.-plot1d)*( plot2e-plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]+1]+
				  0.5*(1.+plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]+1]+
	0.25*(1.+plot2e)*(1.+plot1d)*( plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]+1]+
				  0.5*(1.+plot1d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]+1]+
	0.25*(1.-plot2e)*(1.+plot1d)*(-plot2e+plot1d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]+1]+
				  0.5*(1.-plot2e)*(1.-plot1d*plot1d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]+1];
					ptDraw1[1].y=ClientHeight-int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot2d)*(-plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]]+
				  0.5*(1.-plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]]+
	0.25*(1.+plot2e)*(1.-plot2d)*( plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]]+
				  0.5*(1.+plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]]+
	0.25*(1.+plot2e)*(1.+plot2d)*( plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]]+
				  0.5*(1.+plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]]+
	0.25*(1.-plot2e)*(1.+plot2d)*(-plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]]+
				  0.5*(1.-plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]];
					ptDraw1[2].x=int(val+0.5);
val=0.25*(1.-plot2e)*(1.-plot2d)*(-plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]+1]+
				  0.5*(1.-plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]+1]+
	0.25*(1.+plot2e)*(1.-plot2d)*( plot2e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]+1]+
				  0.5*(1.+plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]+1]+
	0.25*(1.+plot2e)*(1.+plot2d)*( plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]+1]+
				  0.5*(1.+plot2d)*(1.-plot2e*plot2e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]+1]+
	0.25*(1.-plot2e)*(1.+plot2d)*(-plot2e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]+1]+
				  0.5*(1.-plot2e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]+1];
					ptDraw1[2].y=ClientHeight-int(val+0.5);
val=0.25*(1.-plot1e)*(1.-plot2d)*(-plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]]+
				  0.5*(1.-plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]]+
	0.25*(1.+plot1e)*(1.-plot2d)*( plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]]+
				  0.5*(1.+plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]]+
	0.25*(1.+plot1e)*(1.+plot2d)*( plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]]+
				  0.5*(1.+plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]]+
	0.25*(1.-plot1e)*(1.+plot2d)*(-plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]]+
				  0.5*(1.-plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]];
					ptDraw1[3].x=int(val+0.5);
val=0.25*(1.-plot1e)*(1.-plot2d)*(-plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside  ]]+1]+
				  0.5*(1.-plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+1]]+1]+
	0.25*(1.+plot1e)*(1.-plot2d)*( plot1e-plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+2]]+1]+
				  0.5*(1.+plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+3]]+1]+
	0.25*(1.+plot1e)*(1.+plot2d)*( plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+4]]+1]+
				  0.5*(1.+plot2d)*(1.-plot1e*plot1e)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+5]]+1]+
	0.25*(1.-plot1e)*(1.+plot2d)*(-plot1e+plot2d-1.)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+6]]+1]+
				  0.5*(1.-plot1e)*(1.-plot2d*plot2d)*indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata20[8*iside+7]]+1];
					ptDraw1[3].y=ClientHeight-int(val+0.5);
////////////////					tBitmap->Canvas->Polygon(ptDraw1,3);
//
//    if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlack;
	  if(isel){
					tBitmap->Canvas->Polygon(ptDraw1,3);
	if(ieGID==MAX_GID-1)tBitmap->Canvas->Pen->Color=clLtGray;else tBitmap->Canvas->Pen->Color=clBlue;
	tBitmap->Canvas->Polygon(ptDraw,4*plotpts-1);
			  }
	  else    {
					Canvas->Polygon(ptDraw1,3);
	if(ieGID==MAX_GID-1)Canvas->Pen->Color=clLtGray;else Canvas->Pen->Color=clBlue;
	Canvas->Polygon(ptDraw,4*plotpts-1);
			  }
//
				   }
			   }
			}
		 }
	  }
   }
  }
 if(isel)tBitmap->Canvas->Pen->Color=clBlack;
 else    Canvas->Pen->Color=clBlack;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::WeldParamExecute(TObject *Sender)
{long dum=0;
 wchar_t string0[40],curMess0[]=L"WeldParam",string1[15];
 if(base.nop1)
//   {if(wps.nWeldParamSet<MAX_WELDPARSET)
   {if(!CreateWeldingParamSet)
	  {
honk<<wps.nWeldParamSet<<" Enter WeldParamExecute()\n";
//	   CreateWeldingParamSet=new TForm17(this);
//honk<<CreateWeldingParamSet<<" YO wps.nWeldParamSet "<<NULL<<"\n";
//honk<<wps.nWeldParamSet<<" YO wps.nWeldParamSet\n";
//	   CreateWeldingParamSet->Caption="Create a Welding Parameter Set";
//	   if(1==1)exit(0);

//SSSSSSSSSSSSSSSSSSSSSSSSSSS
//SSSSSSSSSSSSSSSSSSSSSSSSSSS
//SSSSSSSSSSSSSSSSSSSSSSSSSSS
//SSSSSSSSSSSSSSSSSSSSSSSSSSS
	   FDdynmem_manage(8,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
//SSSSSSSSSSSSSSSSSSSSSSSSSSS
//SSSSSSSSSSSSSSSSSSSSSSSSSSS
//SSSSSSSSSSSSSSSSSSSSSSSSSSS
//SSSSSSSSSSSSSSSSSSSSSSSSSSS
	   if(wps.nWeldParamSet>0){
			 wps.curr[wps.nWeldParamSet]=wps.curr[wps.nWeldParamSet-1];
			 wps.volt[wps.nWeldParamSet]=wps.volt[wps.nWeldParamSet-1];
			 wps.eff[wps.nWeldParamSet]=wps.eff[wps.nWeldParamSet-1];
			 wps.speed[wps.nWeldParamSet]=wps.speed[wps.nWeldParamSet-1];
							  }
	   else {
// CreateLinWeldPass->CheckEdit1=curMess0;
			 wps.curr[wps.nWeldParamSet]=350.;
			 wps.volt[wps.nWeldParamSet]=25.;
			 wps.eff[wps.nWeldParamSet]=0.75;
			 wps.speed[wps.nWeldParamSet]=5.;
			}
// _ltow(wps.nWeldParamSet+1,string1,10);
 _ltow(wps.highest+1,string1,10);
// honk<<string1[].t_str()<<" string1\n";
// honk<<curMess0.t_str()<<" curMess0\n";
 StringCchCatW(curMess0,39+1,string1); //Length of destination curMess0 is provided.
 wps.name[wps.nWeldParamSet]=curMess0;
//honk<<curMess0.t_str()<<" curMess0AFT\n";
//honk<<wps.curr[wps.nWeldParamSet]<<" "<<wps.curr[wps.nWeldParamSet-1]<<" KLM\n";
//honk<<wps.nWeldParamSet<<" DO wps.nWeldParamSet\n";
//honk<<CreateWeldingParamSet<<" DO wps.nWeldParamSet "<<NULL<<"\n";
//delete CreateWeldingParamSet;CreateWeldingParamSet=NULL;

//	   CreateWeldingParamSet=new TForm17(this);
	   CreateWeldingParamSet=new TForm22(0,this);

//honk<<CreateWeldingParamSet<<" YO wps.nWeldParamSet "<<NULL<<"\n";
//honk<<wps.nWeldParamSet<<" YO wps.nWeldParamSet\n";
//	   CreateWeldingParamSet->ShowModal();
//for(i=0;i<wps.nWeldParamSet+1;i++){honk<<i<<" "<<wps.name[i].t_str()<<" CIA\n";
//								 honk<<wps.curr[i]<<"\n";
//								 honk<<wps.volt[i]<<"\n";
//								 honk<<wps.eff[i]<<"\n";
//								 honk<<wps.speed[i]<<"\n";
//								}
//if(1==1)exit(0);


	   CreateWeldingParamSet->Caption="Create a Welding Parameter Set";
	   CreateWeldingParamSet->Label1->Caption="Welding Parameter Set Name";
	   CreateWeldingParamSet->Label2->Caption="Welding Current (Amp):";
	   CreateWeldingParamSet->Label3->Caption="Welding Voltage (Volt):";
	   CreateWeldingParamSet->Label4->Caption="Arc Efficiency:";
	   CreateWeldingParamSet->Label5->Caption="Torch Traveling Speed:";
	   CreateWeldingParamSet->Button1->Caption="Create";
	   CreateWeldingParamSet->Button2->Caption="Cancel";

////	   CreateWeldingParamSet->CheckEdit1=L"****";
//	   CreateWeldingParamSet->CheckEdit1=wps.name[wps.nWeldParamSet];
//	   CreateWeldingParamSet->CheckEdit1=wps.name[wps.nWeldParamSet].c_str();
	   CreateWeldingParamSet->CheckEdit1=wps.name[wps.nWeldParamSet].t_str();
	   CreateWeldingParamSet->CheckEdit2=wps.curr[wps.nWeldParamSet];
	   CreateWeldingParamSet->CheckEdit3=wps.volt[wps.nWeldParamSet];
	   CreateWeldingParamSet->CheckEdit4=wps.eff[wps.nWeldParamSet];
	   CreateWeldingParamSet->CheckEdit5=wps.speed[wps.nWeldParamSet];
	   CreateWeldingParamSet->ShowModal();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Close existing Create/Edit box first",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"63Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::MatPropertiesExecute(TObject *Sender)
{long dum=0;
 wchar_t string0[40],curMess0[]=L"MatProp",string1[15];
 if(base.nop1)
   {if(wps.nWeldParamSet)
	  {FDdynmem_manage(7,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	   if(wms.nMatPropSet>0){
			 wms.cond[wms.nMatPropSet]=wms.cond[wms.nMatPropSet-1];
			 wms.heat[wms.nMatPropSet]=wms.heat[wms.nMatPropSet-1];
			 wms.den[wms.nMatPropSet]=wms.den[wms.nMatPropSet-1];
			 wms.mcr[wms.nMatPropSet]=wms.mcr[wms.nMatPropSet-1];
//			 wms.mcr[wms.nMatPropSet]=1;
//			 wms.mcr[wms.nMatPropSet]=2;
			 wms.ved[wms.nMatPropSet]=wms.ved[wms.nMatPropSet-1];
			 wms.annjd[wms.nMatPropSet]=wms.annjd[wms.nMatPropSet-1];
			 wms.Ti[wms.nMatPropSet]=wms.Ti[wms.nMatPropSet-1];
			 wms.Ta[wms.nMatPropSet]=wms.Ta[wms.nMatPropSet-1];
			 wms.Tm[wms.nMatPropSet]=wms.Tm[wms.nMatPropSet-1];
			 wms.switc[wms.nMatPropSet]=wms.switc[wms.nMatPropSet-1];
			 wms.hetjd[wms.nMatPropSet]=wms.hetjd[wms.nMatPropSet-1];
			 wms.nprops[wms.nMatPropSet]=wms.nprops[wms.nMatPropSet-1];
//			 wms.matFileName[wms.nMatPropSet]=wms.matFileName[wms.nMatPropSet-1];
			 wms.Steps[wms.nMatPropSet]=wms.Steps[wms.nMatPropSet-1];
							}
	   else {
			 wms.cond[wms.nMatPropSet]=0.045;
			 wms.heat[wms.nMatPropSet]=580.;
			 wms.den[wms.nMatPropSet]=0.00000785;
			 wms.mcr[wms.nMatPropSet]=0;
////			 wms.mcr[wms.nMatPropSet]=1;
////			 wms.mcr[wms.nMatPropSet]=2;
////			 wms.ved[wms.nMatPropSet]= -1; //Default Annealing=OFF
////			 wms.annjd[wms.nMatPropSet]= -1; //Default VED=OFF
//			 wms.ved[wms.nMatPropSet]=0; //Default Annealing=ON (per William Ulrich request 2/27/2012)
//			 wms.annjd[wms.nMatPropSet]=0; //Default VED=ON (per William Ulrich request 2/27/2012)
			 wms.annjd[wms.nMatPropSet]= -1; //Default Anneal=ON (per William Ulrich request 2/27/2012)
			 wms.ved[wms.nMatPropSet]= -1; //Default VED=ON (per William Ulrich request 2/27/2012)
			 wms.Ti[wms.nMatPropSet]=750.;
			 wms.Ta[wms.nMatPropSet]=1500.;
			 wms.Tm[wms.nMatPropSet]=1500.;
//			 wms.Steps[wms.nMatPropSet]="Steps".c_str();
			 wms.nprops[wms.nMatPropSet]=8;
			 wms.switc[wms.nMatPropSet]=false;
//			 if(wms.switc[wms.nMatPropSet]){wms.hetjd[wms.nMatPropSet]= -1;
//											wms.nprops[wms.nMatPropSet]=wms.nprops[wms.nMatPropSet]+1;
//										   }
//			 else wms.hetjd[wms.nMatPropSet]=0;
			 wms.hetjd[wms.nMatPropSet]=0;
//			 wms.Steps[wms.nMatPropSet]=L"0";
			 wms.Steps[wms.nMatPropSet]=L"****";//EFP 9/23/2011
			}
// _ltow(wms.nMatPropSet+1,string1,10);
 _ltow(wms.highest+1,string1,10);
 StringCchCatW(curMess0,39+1,string1);
 wms.name[wms.nMatPropSet]=curMess0;
 //	   CreateMatPropSet=new TForm16(this);
	   CreateMatPropSet=new TForm21(0,this);

//honk<<" LaVidaLoco\n";if(1==1)exit(0);

	   CreateMatPropSet->Caption="Create a Material Property Set";
	   CreateMatPropSet->Label1->Caption="Material Property Set Name";
	   CreateMatPropSet->Label2->Caption="Thermal Conductivity:";
	   CreateMatPropSet->Label3->Caption="Specific Heat:";
	   CreateMatPropSet->Label4->Caption="Density:";
	   CreateMatPropSet->Label6->Caption="Steps for Creep Input (comma separated)";
	   CreateMatPropSet->CheckBox1->Caption="Switch between Isotropic/Creep";
	   CreateMatPropSet->Label7->Caption="Annealing Initiation Temperature";
	   CreateMatPropSet->Label8->Caption="Annealing Temperature";
	   CreateMatPropSet->Label9->Caption="Material Melting Temperature";
	   CreateMatPropSet->Label10->Caption="Mechanical Property File Path/Name:";
	   CreateMatPropSet->RadioButton1->Caption="Isotropic (multi-linear)";
	   CreateMatPropSet->RadioButton2->Caption="Combined Hardening (multi-linear)";
	   CreateMatPropSet->RadioButton3->Caption="Simple Phase Transformation";
	   CreateMatPropSet->RadioButton4->Caption="Combined Hardening (linear)";
	   CreateMatPropSet->RadioButton5->Caption="Elastic-Plastic-Creep(Isotropic,multi-linear)";
	   CreateMatPropSet->RadioButton6->Caption="Complete Phase Transformation";
	   CreateMatPropSet->RadioButton9->Caption="No";
	   CreateMatPropSet->RadioButton10->Caption="Yes";
	   CreateMatPropSet->RadioButton7->Caption="No";
	   CreateMatPropSet->RadioButton8->Caption="Yes";
//	   CreateMatPropSet->Button1->Caption="Choose Mechanical Property File...";
	   CreateMatPropSet->Button2->Caption="Create";
	   CreateMatPropSet->Button3->Caption="Cancel";
	   CreateMatPropSet->GroupBox1->Caption="Physical Properties";
	   CreateMatPropSet->RadioGroup1->Caption="Material Constitutive Relation (Double-click Isotropic or EPC to get Creep)";
//// TBD: Find out why the following causes duplicate RadioButtons on RadioGroup1??? EFP 3/30/2010
//	CreateMatPropSet->RadioGroup1->Items->Add(CreateMatPropSet->RadioButton1->Caption);
//	CreateMatPropSet->RadioGroup1->Items->Add(CreateMatPropSet->RadioButton2->Caption);
//	CreateMatPropSet->RadioGroup1->Items->Add(CreateMatPropSet->RadioButton3->Caption);
//	CreateMatPropSet->RadioGroup1->Items->Add(CreateMatPropSet->RadioButton4->Caption);
//	CreateMatPropSet->RadioGroup1->Items->Add(CreateMatPropSet->RadioButton5->Caption);
//	CreateMatPropSet->RadioGroup1->Items->Add(CreateMatPropSet->RadioButton6->Caption);
////	   CreateMatPropSet->GroupBox2->Caption="ABAQUS Material Inputs";
	   CreateMatPropSet->Label5->Caption="ABAQUS Material Inputs";
//	   CreateMatPropSet->GroupBox3->Caption="Annealing";
//	   CreateMatPropSet->GroupBox2->Caption="VED";
	   CreateMatPropSet->GroupBox2->Caption="Annealing";
	   CreateMatPropSet->GroupBox3->Caption="VED";
	   CreateMatPropSet->GroupBox4->Caption="Mechanical Properties";
//	   CreateMatPropSet->CheckCheckBox1=false;
	   CreateMatPropSet->CheckCheckBox1=wms.switc[wms.nMatPropSet];//EFP 9/23/2011
//	   CreateMatPropSet->CheckEdit5a=L"****";//	   CreateMatPropSet->CheckEdit5a=L"0";
	   CreateMatPropSet->CheckEdit5a=wms.Steps[wms.nMatPropSet].t_str(); //Correction??? EFP 10/03/2011
//
////	   CreateMatPropSet->CheckEdit1=L"****";
//	   CreateMatPropSet->CheckEdit1=wms.name[wms.nMatPropSet];
//	   CreateMatPropSet->CheckEdit1=wms.name[wms.nMatPropSet].c_str();
	   CreateMatPropSet->CheckEdit1=wms.name[wms.nMatPropSet].t_str();
	   CreateMatPropSet->CheckEdit2=wms.cond[wms.nMatPropSet];
	   CreateMatPropSet->CheckEdit3=wms.heat[wms.nMatPropSet];
	   CreateMatPropSet->CheckEdit4=wms.den[wms.nMatPropSet];
	   CreateMatPropSet->CheckEdit5=wms.Ti[wms.nMatPropSet];
	   CreateMatPropSet->CheckEdit6=wms.Ta[wms.nMatPropSet];
	   CreateMatPropSet->CheckEdit7=wms.Tm[wms.nMatPropSet];

//honk<<wms.name[wms.nMatPropSet].c_str()<<" NPS1\n";
//honk<<wms.matFileName[wms.nMatPropSet].c_str()<<" NPS2\n";
//if(wms.nMatPropSet>0){
//honk<<wms.name[wms.nMatPropSet-1].c_str()<<" TNPS1\n";
//honk<<wms.matFileName[wms.nMatPropSet-1].c_str()<<" TNPS2\n";
//					 }

//	   if(wms.nMatPropSet>0)CreateMatPropSet->CheckEdit8=wms.matFileName[wms.nMatPropSet-1].c_str();
	   if(wms.nMatPropSet>0)CreateMatPropSet->CheckEdit8=wms.matFileName[wms.nMatPropSet-1].t_str();
	   else CreateMatPropSet->CheckEdit8=L"****";
//	   CreateMatPropSet->CheckEdit8= *p;

	   if(wms.mcr[wms.nMatPropSet]==0)CreateMatPropSet->CheckRadioGroup1=0;
//	   else if(wms.mcr[wms.nMatPropSet]==1)CreateMatPropSet->CheckRadioGroup1=1;
//	   else if(wms.mcr[wms.nMatPropSet]==2)CreateMatPropSet->CheckRadioGroup1=2;
//	   else if(wms.mcr[wms.nMatPropSet]==3)CreateMatPropSet->CheckRadioGroup1=3;
//	   else if(wms.mcr[wms.nMatPropSet]==5)CreateMatPropSet->CheckRadioGroup1=4;
	   else if(wms.mcr[wms.nMatPropSet]==1)CreateMatPropSet->CheckRadioGroup1=3; //Correction BBrust 3/25/2011
	   else if(wms.mcr[wms.nMatPropSet]==2)CreateMatPropSet->CheckRadioGroup1=1;
	   else if(wms.mcr[wms.nMatPropSet]==3)CreateMatPropSet->CheckRadioGroup1=4;
	   else if(wms.mcr[wms.nMatPropSet]==5)CreateMatPropSet->CheckRadioGroup1=2;
	   else CreateMatPropSet->CheckRadioGroup1=5;

//	   if(wms.annjd[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox3=false;
//	   else CreateMatPropSet->CheckGroupBox3=true;
//	   if(wms.ved[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox4=false;
//	   else CreateMatPropSet->CheckGroupBox4=true;

//	   if(wms.annjd[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox4=false;
//	   else CreateMatPropSet->CheckGroupBox4=true;
//	   if(wms.ved[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox3=false;
//	   else CreateMatPropSet->CheckGroupBox3=true;

//	   if(wms.annjd[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox3=true;//Correction EFP 9/09/2011
//	   else CreateMatPropSet->CheckGroupBox3=false;
//	   if(wms.ved[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox4=true;
//	   else CreateMatPropSet->CheckGroupBox4=false;
	   if(wms.annjd[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox3=false;//This seems to be correct EFP 8/31/2012
	   else CreateMatPropSet->CheckGroupBox3=true;
	   if(wms.ved[wms.nMatPropSet]==0)CreateMatPropSet->CheckGroupBox4=false;
	   else CreateMatPropSet->CheckGroupBox4=true;

//	   CreateMatPropSet->Label6->Enabled=true;
//	   CreateMatPropSet->CheckBox1->Enabled=false;
//	   CreateMatPropSet->Edit5->Enabled=false;
//	   CreateMatPropSet->Label6->Visible=false;
//	   CreateMatPropSet->CheckBox1->Visible=false;
//	   CreateMatPropSet->Edit5->Visible=false;

	   if(wms.switc[wms.nMatPropSet]){//EFP 9/23/2011
	   CreateMatPropSet->Label6->Enabled=true;
	   CreateMatPropSet->CheckBox1->Enabled=true;
	   CreateMatPropSet->Edit5->Enabled=true;
	   CreateMatPropSet->Label6->Visible=true;
	   CreateMatPropSet->CheckBox1->Visible=true;
	   CreateMatPropSet->Edit5->Visible=true;
	   CreateMatPropSet->Button4->Enabled=true;
	   CreateMatPropSet->Button4->Visible=true;
 CreateMatPropSet->RadioButton2->Enabled=false;
 CreateMatPropSet->RadioButton3->Enabled=false;
 CreateMatPropSet->RadioButton4->Enabled=false;
 CreateMatPropSet->RadioButton5->Enabled=false;
 CreateMatPropSet->RadioButton6->Enabled=false;
 CreateMatPropSet->RadioButton2->Visible=false;
 CreateMatPropSet->RadioButton3->Visible=false;
 CreateMatPropSet->RadioButton4->Visible=false;
 CreateMatPropSet->RadioButton5->Visible=false;
 CreateMatPropSet->RadioButton6->Visible=false;
									 }
	   else {
	   CreateMatPropSet->Label6->Enabled=true;
	   CreateMatPropSet->CheckBox1->Enabled=true;
	   CreateMatPropSet->Edit5->Enabled=false;
	   CreateMatPropSet->Label6->Visible=false;
	   CreateMatPropSet->CheckBox1->Visible=false;
	   CreateMatPropSet->Edit5->Visible=false;
	   CreateMatPropSet->Button4->Enabled=false;
	   CreateMatPropSet->Button4->Visible=false;
 CreateMatPropSet->RadioButton2->Enabled=true;
 CreateMatPropSet->RadioButton3->Enabled=true;
 CreateMatPropSet->RadioButton4->Enabled=true;
 CreateMatPropSet->RadioButton5->Enabled=true;
 CreateMatPropSet->RadioButton6->Enabled=true;
 CreateMatPropSet->RadioButton2->Visible=true;
 CreateMatPropSet->RadioButton3->Visible=true;
 CreateMatPropSet->RadioButton4->Visible=true;
 CreateMatPropSet->RadioButton5->Visible=true;
 CreateMatPropSet->RadioButton6->Visible=true;
			}
	   CreateMatPropSet->ShowModal();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must enter Weld Parameter Set first.",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"64Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::WeldPassEditingandSequencing1Execute(TObject *Sender)
{if(base.nop1)
   {if(wp.nWeldPass>0)
//	  {WeldPassEditSeqn=new TForm18(wp.nWeldPass,wp.name,this);
	  {
//for(int i=0;i<wp.nWeldPass;i++)honk<<i<<" CKSEQ "<<wp.seqNum[i]<<"\n";if(1==1)exit(0);
//extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unfinished",L"Halt",MB_OK);
	   Screen->Cursor=crDefault; //EFP 4/27/2013
	   WeldPassEditSeqn=new TForm30(wp.nWeldPass,wp.name,wp.WeldColor,wp.seqNum,wp.reset,this);
	   WeldPassEditSeqn->Caption="Weld Pass Sequencing";
	   WeldPassEditSeqn->Label1->Caption="Current direction/seq.";
	   WeldPassEditSeqn->Label2->Caption="Proposed direction/seq.";
	   WeldPassEditSeqn->Label3->Caption="Check to reverse direction";
	   WeldPassEditSeqn->Label4->Caption="Animation time";
	   WeldPassEditSeqn->Button1->Caption="Enter";
	   WeldPassEditSeqn->Button2->Caption="Animate seq.";
	   WeldPassEditSeqn->Button3->Caption="Move up";
	   WeldPassEditSeqn->Button4->Caption="Move down";
//	   WeldPassEditSeqn->Button5->Caption="Restore original dir.";
//	   WeldPassEditSeqn->Button6->Caption="Restore original seq";
//	   WeldPassEditSeqn->Button7->Caption="Reverse direct.-all";
	   WeldPassEditSeqn->Button5->Caption="Restore current dir.";
	   WeldPassEditSeqn->Button6->Caption="Restore curr.seq+dir"; //EFP 3/29/2012
	   WeldPassEditSeqn->Button7->Caption="Reverse direct. all";
	   WeldPassEditSeqn->Button8->Caption="Cancel";
	   WeldPassEditSeqn->CheckEdit1=1000;
	   WeldPassEditSeqn->Button2->Enabled=false; //Temporary EFP 3/29/2012
	   WeldPassEditSeqn->Show();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must create weld pass first.",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"66Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::CreateNewPartialLengthWeldPassExecute(TObject *Sender){create_new_weld(1);}
//---------------------------------------------------------------------------
void __fastcall TForm1::CreateFullLengthFullSectionExecute(TObject *Sender){create_new_weld(2);}
//---------------------------------------------------------------------------
void __fastcall TForm1::CreateNewFullLenghtWeldPassExecute(TObject *Sender){create_new_weld(0);}
//---------------------------------------------------------------------------
void __fastcall TForm1::CreatPartLengthFullSectionExecute(TObject *Sender){create_new_weld(3);}

//---------------------------------------------------------------------------
void TForm1::create_new_weld(int isw)//TBD: Move base.nop1/etc tests to above calling routines  EFP 3/22/2012
{long dum=0
,ir=0
;
// char string0[40],currMess[]=" MAX_WELDPASSES exceeded.";
 wchar_t string0[40],curMess0[]=L"weldpass",string1[11];  //TEST FOR EXISTING FORM
 wp.CreateWPassMode=1;
 wp.PRECORD=wp.nWeldPass;
 if(base.nop1)
   {if(wps.nWeldParamSet)
	  {if(wms.nMatPropSet)
		 {if(CreateLinWeldPass==NULL)
			  {if(iPaintyesno/10)
//				 {if(wp.nWeldPass<MAX_WELDPASSES)
												 {VFTon=1;wp.count_curr_sttEl=0;
////												  FDdynmem_manage(6,dum,base.nelt,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
//												  FDdynmem_manage(6,dum,wp.memWGa,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
												  FDdynmem_manage(6,dum,wp.memWGa,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,1);
										 wp.seqNum[wp.nWeldPass]=wp.nWeldPass+1;
////wp.timeInterval[0]=1000.;wp.timeInterval[1]=500.;for(i=2;i<MAX_WELDPASSES;i++)wp.timeInterval[i]=1000.;
//for(i=0;i<wp.nWeldPass;i++)wp.timeInterval[i]=500.;
////wp.stepInterval[0]=5;wp.stepInterval[1]=50;for(i=2;i<MAX_WELDPASSES;i++)wp.stepInterval[i]=5;
//for(i=2;i<wp.nWeldPass;i++)wp.stepInterval[i]=5;
										 if(wp.nWeldPass){
												  wp.tcuth[wp.nWeldPass]=wp.tcuth[wp.nWeldPass-1];
												  wp.wpTimes[wp.nWeldPass]=wp.wpTimes[wp.nWeldPass-1];
												  wp.timeInterval[wp.nWeldPass]=wp.timeInterval[wp.nWeldPass-1];
												  wp.stepInterval[wp.nWeldPass]=wp.stepInterval[wp.nWeldPass-1];
										  wp.troom[wp.nWeldPass]=wp.troom[wp.nWeldPass-1];
										  wp.tmelt[wp.nWeldPass]=wp.tmelt[wp.nWeldPass-1];
										  wp.tcutl[wp.nWeldPass]=wp.tcutl[wp.nWeldPass-1];
										  wp.source[wp.nWeldPass]=wp.source[wp.nWeldPass-1];
										  wp.maxiHeatStep[wp.nWeldPass]=wp.maxiHeatStep[wp.nWeldPass-1];
										  wp.miniHeatStep[wp.nWeldPass]=wp.miniHeatStep[wp.nWeldPass-1];
												  wp.type[wp.nWeldPass]=wp.type[wp.nWeldPass-1];
												  wp.shape[wp.nWeldPass]=wp.shape[wp.nWeldPass-1];
												  wp.thk1[wp.nWeldPass]=wp.thk1[wp.nWeldPass-1];
												  wp.thk2[wp.nWeldPass]=wp.thk2[wp.nWeldPass-1];
//												  wp.thk1[wp.nWeldPass]=0.;
//												  wp.thk2[wp.nWeldPass]=0.;
//										  wp.curr[wp.nWeldPass]=wp.curr[wp.nWeldPass-1]; // Unknown
//										  wp.volt[wp.nWeldPass]=wp.volt[wp.nWeldPass-1]; // Unknown but curr*volt=8750
//										  wp.eff[wp.nWeldPass]=wp.eff[wp.nWeldPass-1];
//										  wp.speed[wp.nWeldPass]=wp.speed[wp.nWeldPass-1];
										  wp.boolFlags[wp.nWeldPass]=wp.boolFlags[wp.nWeldPass-1];
										  wp.hp[wp.nWeldPass]=wp.hp[wp.nWeldPass-1];// Moving Arc
										  wp.nsegs[wp.nWeldPass]=wp.nsegs[wp.nWeldPass-1];
										  wp.mcr[wp.nWeldPass]=wp.mcr[wp.nWeldPass-1];
///////////////////// Start coding to repeat Plate#1/2 normals  EFP 5/04/2011
for(ir=0;ir<4;ir++)wp.snorm1[4*wp.nWeldPass+ir]=wp.snorm1[4*(wp.nWeldPass-1)+ir];
for(ir=0;ir<4;ir++)wp.snorm2[4*wp.nWeldPass+ir]=wp.snorm2[4*(wp.nWeldPass-1)+ir];
for(ir=0;ir<NDF;ir++)wp.arrows[NDF*3*wp.nWeldPass+NDF*1+ir]=wp.arrows[NDF*3*(wp.nWeldPass-1)+NDF*1+ir];
for(ir=0;ir<NDF;ir++)wp.arrows[NDF*3*wp.nWeldPass+NDF*2+ir]=wp.arrows[NDF*3*(wp.nWeldPass-1)+NDF*2+ir];
///////////////////// End
												  wp.lstart[wp.nWeldPass]=wp.lstart[wp.nWeldPass-1]; //EFP9/02/2012
												  wp.lend[wp.nWeldPass]=wp.lend[wp.nWeldPass-1];
														 }
										 else            {
												  wp.tcuth[wp.nWeldPass]=25.;
												  wp.wpTimes[wp.nWeldPass]=457.20;
//												  wp.timeInterval[wp.nWeldPass]=600.0;
												  wp.timeInterval[wp.nWeldPass]=450.0;
												  wp.stepInterval[wp.nWeldPass]=5;
										  wp.troom[wp.nWeldPass]=25.;
										  wp.tmelt[wp.nWeldPass]=1500.;
										  wp.tcutl[wp.nWeldPass]=50.;
										  wp.source[wp.nWeldPass]=11;//Must be odd
										  wp.maxiHeatStep[wp.nWeldPass]=1000.;
										  wp.miniHeatStep[wp.nWeldPass]=0.001;
												  wp.type[wp.nWeldPass]=0;
												  wp.shape[wp.nWeldPass]=0;
//												  wp.thk1[wp.nWeldPass]=12.7;
//												  wp.thk2[wp.nWeldPass]=12.7;
												  wp.thk1[wp.nWeldPass]=0.;
												  wp.thk2[wp.nWeldPass]=0.;
//										  wp.curr[wp.nWeldPass]=350.; // Unknown
//										  wp.volt[wp.nWeldPass]=25.; // Unknown but curr*volt=8750
//										  wp.eff[wp.nWeldPass]=0.75;
//										  wp.speed[wp.nWeldPass]=5.;
										  wp.boolFlags[wp.nWeldPass]=0;
										  wp.hp[wp.nWeldPass]=0;// Moving Arc
										  wp.nsegs[wp.nWeldPass]=1;
										  wp.mcr[wp.nWeldPass]=0;
for(ir=0;ir<4;ir++)wp.snorm1[4*wp.nWeldPass+ir]= -1;
for(ir=0;ir<4;ir++)wp.snorm2[4*wp.nWeldPass+ir]= -1;
//
												  wp.lstart[wp.nWeldPass]=double(60.*60.); //seconds We will just use wp.lstart[0] EFP9/02/2012
												  wp.lend[wp.nWeldPass]=0.;
														  }
												  wp.reset[wp.nWeldPass]=0; //EFP 4/08/2013
///////////////////////////////////////////////////////////////////////
												  FD_LButtonstatus=17;
//												  iPersistVFT=1;
												  ir=iPersistVFT/10;
												  iPersistVFT=10*ir+1;
// NOTE: Test for wms existence...
												  CreateLinWeldPass=new TForm15(isw,wp.nWeldPass+1,wp.seqNum[wp.nWeldPass],0,0,
																				wp.snorm1[4*wp.nWeldPass+0],wp.snorm2[4*wp.nWeldPass+0],
																				wms.nMatPropSet,wms.name,
																				wps.nWeldParamSet,wps.name,
																				this); // (weldpass#,weldseq#,...)
CreateLinWeldPass->CheckBox1->Enabled=false;//Disconnect weld direction CheckBox1 EFP 4/03/2011

if(isw==1)
  {
CreateLinWeldPass->Caption="Create partial length/partial section weld pass";
CreateLinWeldPass->Label3->Caption="All start elements";
CreateLinWeldPass->Label4->Caption="One stop element";
  }
else if(isw==2)
  {
CreateLinWeldPass->Caption="Create weld pass to end run/full section";
CreateLinWeldPass->Label3->Caption="One start element";
CreateLinWeldPass->Label4->Caption="Auto-gen to end run (click for direction)";
  }
else if(isw==3)
  {
CreateLinWeldPass->Caption="Create partial length/full section weld pass";
CreateLinWeldPass->Label3->Caption="One start element";
CreateLinWeldPass->Label4->Caption="One stop element";
  }
else { //isw==0
CreateLinWeldPass->Caption="Create weld pass to end run/partial section";
CreateLinWeldPass->Label3->Caption="All start elements";
CreateLinWeldPass->Label4->Caption="Auto-gen to end run (click for direction)";
	 }
CreateLinWeldPass->Label7->Caption="Plate1 normal";
CreateLinWeldPass->Label8->Caption="Plate2 normal";
//CreateLinWeldPass->CheckEdit1=L"****";
// _ltow(wp.nWeldPass+1,string1,10);
 _ltow(wp.highest+1,string1,10);
StringCchCatW(curMess0,11,string1);CreateLinWeldPass->CheckEdit1=curMess0;

CreateLinWeldPass->PageControl1->TabIndex=2;
/////////////////////// EFP 1/03/2011
CreateLinWeldPass->RadioGroup1->Enabled=False;
CreateLinWeldPass->RadioGroup1->Visible=False;
///////////////////////
CreateLinWeldPass->CheckEdit9=0.;
CreateLinWeldPass->CheckEdit10=0.;
CreateLinWeldPass->CheckEdit11=0.;
CreateLinWeldPass->CheckEdit12=0.;

CreateLinWeldPass->CheckEdit13=wp.troom[wp.nWeldPass];
CreateLinWeldPass->CheckEdit14=wp.tmelt[wp.nWeldPass];
CreateLinWeldPass->CheckEdit15=wp.tcutl[wp.nWeldPass];
CreateLinWeldPass->CheckEdit16=wp.tcuth[wp.nWeldPass];
CreateLinWeldPass->CheckEdit17=wp.timeInterval[wp.nWeldPass]; // Interpass cooling time???
CreateLinWeldPass->CheckEdit19=wp.stepInterval[wp.nWeldPass]; // Interpass cooling steps???
CreateLinWeldPass->CheckEdit18=wp.maxiHeatStep[wp.nWeldPass]; // Max heating time(output)???
CreateLinWeldPass->CheckEdit20=wp.miniHeatStep[wp.nWeldPass]; // Min heating time(output)???
CreateLinWeldPass->CheckEdit21=wp.thk1[wp.nWeldPass]; // Plate1 thickness???
CreateLinWeldPass->CheckEdit22=wp.thk2[wp.nWeldPass]; // Plate2 thickness???
//CreateLinWeldPass->CheckEditXXX=wp.hp[wp.nWeldPass]; // Moving Arc only (hp=0) at present (and this must be selected by TForm15 RadioButton5&6)
CreateLinWeldPass->CheckEdit23=wp.nsegs[wp.nWeldPass]; // Lumped pass heating procedure: Number of lumped segments
CreateLinWeldPass->CheckEdit24=1; // Near-edge effect: Number of required edges???
//CreateLinWeldPass->ComboBox1->ItemIndex = 0;
//CreateLinWeldPass->ComboBox2->ItemIndex = 0;
CreateLinWeldPass->CheckType=wp.type[wp.nWeldPass];
CreateLinWeldPass->CheckShape=wp.shape[wp.nWeldPass];
/////////////

//		  ir=wp.nWeldPass-9*(wp.nWeldPass/9);
//		  if     (ir==0)CreateLinWeldPass->CheckWeldColor=clRed;
//		  else if(ir==1)CreateLinWeldPass->CheckWeldColor=clLtGray; // Coding for color contrast
//		  else if(ir==2)CreateLinWeldPass->CheckWeldColor=clBlue;
//		  else if(ir==3)CreateLinWeldPass->CheckWeldColor=clGreen;
//		  else if(ir==4)CreateLinWeldPass->CheckWeldColor=clLime;
//		  else if(ir==5)CreateLinWeldPass->CheckWeldColor=clNavy;
//		  else if(ir==6)CreateLinWeldPass->CheckWeldColor=clYellow;
//		  else if(ir==7)CreateLinWeldPass->CheckWeldColor=clOlive;
//		  else          CreateLinWeldPass->CheckWeldColor=clMaroon;

CreateLinWeldPass->CheckWeldColor=clOlive;

CreateLinWeldPass->Edit2->Enabled=false;

/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
/////////////
//CreateLinWeldPass->PageControl1->ActivePage=0;
												  CreateLinWeldPass->Show();

//honk<<CreateLinWeldPass->CheckEdit9<<" FullLinCk0\n";
												 }
//				  else {
//		//				ltoa(MAX_WELDPASSES,string0,10);
//		//				strcat(string0,currMess);
//		//				extern PACKAGE void __fastcall Beep(void);
//		//				Application->MessageBox(string0,L"Halt",MB_OK);
//
//						extern PACKAGE void __fastcall Beep(void);
//						Application->MessageBox(_ltow(MAX_WELDPASSES,string0,10),L"Halt: MAX_WELDPASSES exceeded",MB_OK);
//					   }
//				 }
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Use VIEW/PAINT to paint",L"Halt",MB_OK);}
			  }
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Weld creation dialog already exists",L"Notice",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First create material property set.",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First create weld parameter set.",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"70Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::wpCreate_public(){
int missing=0;//long j=0;
//int ccc=CreateLinWeldPass->CheckISEL;
//long ccL=CreateLinWeldPass->CheckEdit23;
//honk<<ccc<<" ccc\n";
//honk<<ccL<<" ccL\n";
//double ccD=CreateLinWeldPass->CheckEdit9;
///////////////////////////////////////////// EFP 03/04/2010
//honk<<ccD<<" CreateLinWeldPass\n";
if(CreateLinWeldPass->CheckEdit1=="****")
  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to enter weld pass name",L"Repeat",MB_OK);
   missing++;
  }
else wp.name[wp.nWeldPass]=CreateLinWeldPass->CheckEdit1;
wp.seqNum[wp.nWeldPass]=CreateLinWeldPass->CheckEdit2; // User-input disabled
//wp.curr[wp.nWeldPass]=CreateLinWeldPass->CheckEdit9;
//wp.volt[wp.nWeldPass]=CreateLinWeldPass->CheckEdit10;
//wp.eff[wp.nWeldPass]=CreateLinWeldPass->CheckEdit11;
//wp.speed[wp.nWeldPass]=CreateLinWeldPass->CheckEdit12;
wp.troom[wp.nWeldPass]=CreateLinWeldPass->CheckEdit13;
wp.tmelt[wp.nWeldPass]=CreateLinWeldPass->CheckEdit14;
wp.tcutl[wp.nWeldPass]=CreateLinWeldPass->CheckEdit15;
wp.tcuth[wp.nWeldPass]=CreateLinWeldPass->CheckEdit16;
wp.type[wp.nWeldPass]=CreateLinWeldPass->CheckType;
wp.shape[wp.nWeldPass]=CreateLinWeldPass->CheckShape;
wp.timeInterval[wp.nWeldPass]=CreateLinWeldPass->CheckEdit17; // Interpass cooling time???
wp.stepInterval[wp.nWeldPass]=CreateLinWeldPass->CheckEdit19; // Interpass cooling steps???
wp.maxiHeatStep[wp.nWeldPass]=CreateLinWeldPass->CheckEdit18; // Max heating time(output)???
wp.miniHeatStep[wp.nWeldPass]=CreateLinWeldPass->CheckEdit20; // Min heating time(output)???
if(CreateLinWeldPass->CheckEdit21>0.0001 && CreateLinWeldPass->CheckEdit22>0.0001)
  {wp.thk1[wp.nWeldPass]=CreateLinWeldPass->CheckEdit21; // Plate1 thickness???
   wp.thk2[wp.nWeldPass]=CreateLinWeldPass->CheckEdit22; // Plate2 thickness???
  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to enter plate thicknesses",L"Repeat",MB_OK);
	  missing++;
	 }
wp.hp[wp.nWeldPass]=0;// Moving arc only at present (selected by TForm15 RadioButton5&6)
wp.nsegs[wp.nWeldPass]=CreateLinWeldPass->CheckEdit23; // Lumped pass heating procedure: Number of lumped segments
//wp.XXX[wp.nWeldPass]=CreateLinWeldPass->CheckEdit24; // Near-edge effect: Number of required edges??? (Which array should this be???)

//if(CreateLinWeldPass->CheckMatName>=0)wp.matName[wp.nWeldPass]=wms.matFileName[CreateLinWeldPass->CheckMatName]; // Need to test this INCORRECT
//else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Material Property Set Name",L"Repeat",MB_OK);
//	  missing++;
//	 }
if(CreateLinWeldPass->CheckMatName>=0){wp.matName[wp.nWeldPass]=wms.name[CreateLinWeldPass->CheckMatName];
									   wp.mcr[wp.nWeldPass]=wms.mcr[CreateLinWeldPass->CheckMatName];
									  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Material Property Set Name",L"Repeat",MB_OK);
	  missing++;
	 }
if(CreateLinWeldPass->CheckWeldParName>=0)
  {wp.curr[wp.nWeldPass]=wps.curr[CreateLinWeldPass->CheckWeldParName]; // Need to test this
   wp.volt[wp.nWeldPass]=wps.volt[CreateLinWeldPass->CheckWeldParName];
   wp.eff[wp.nWeldPass]=wps.eff[CreateLinWeldPass->CheckWeldParName];
   wp.speed[wp.nWeldPass]=wps.speed[CreateLinWeldPass->CheckWeldParName];
  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Weld Parameter Set Name",L"Repeat",MB_OK);
	  missing++;
	 }

////////////////////////  EFP 5/24/2011
//if(wp.snorm1[4*wp.nWeldPass+0]<0 && wp.snorm2[4*wp.nWeldPass+0]<0)
//  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Plate#1 & Plate#2 normals",L"Repeat",MB_OK);
//   missing++;
//  }
//else if(wp.snorm1[4*wp.nWeldPass+0]<0)
//  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Plate#1 normal",L"Repeat",MB_OK);
//   missing++;
//  }
//else if(wp.snorm2[4*wp.nWeldPass+0]<0)
//  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Plate#2 normal",L"Repeat",MB_OK);
//   missing++;
//  }
//////////////////////

//honk<<wp.matName[wp.nWeldPass].c_str()<<" WeldPassMatFileName\n";
//honk<<wp.matName[wp.nWeldPass].t_str()<<" WeldPassMatFileName\n";
/////////////////////////////////////////////
							   if(!missing){
//CreateNewFulllinWeldPass1=0;
//CreateNewLinearWeldPass1=0;
WeldPassEditingandSequencing1->Enabled=true;
//ShowWeldSequence1=0;
											wp.nWeldPass=wp.nWeldPass+1;
											wp.highest=wp.highest+1;
										   }
honk<<wp.nWeldPass<<" WeldPassCreated "<<base.node_map[0]<<"\n";

FD_LButtonstatus=11;stateVFT=2;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////

							   delete CreateLinWeldPass;CreateLinWeldPass=NULL;// because it was created with Show()?

//iplotflag=1;iCircleplot=1;

/////////////////////////
////for(long ii=0;ii<wp.nWeldPass;ii++)
////  {for(long in=0;in<base.nelt;in++)honk<<ii+1<<" "<<in+1<<" wpCREATE "<<wp.sttEles[base.nelt*ii+in]<<"\n";
////  }
//long ii=0,jj=0;
//for(ii=0;ii<base.nelt;ii++)
//  {honk<<ii<<" PrtEl\n";
//   if(base.trackELSET[ii]+1==base.trackELSET[ii+1])
//	 for(jj=base.trackELSET[ii];jj<base.trackELSET[ii+1];jj++)
//	   honk<<base.arrELSET[jj]<<" basemetal\n"; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
//   else if(base.trackELSET[ii]+2==base.trackELSET[ii+1])
//	 for(jj=base.trackELSET[ii];jj<base.trackELSET[ii+1];jj++)
//	   honk<<base.arrELSET[jj]<<" met+WG\n"; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
//   else
//	 for(jj=base.trackELSET[ii];jj<base.trackELSET[ii+1];jj++)
//	   honk<<base.arrELSET[jj]<<" met+WG+WP\n"; //Presumes VFTsolid (only one GID per el) EFP 2/18/2012
//  }
/////////////////////////

////////////////////////
//for(j=0;j<base.nelt;j++){
//	 if(base.trackELSET[j+1]-base.trackELSET[j]==1)honk<<indat.matno[j]<<" BaseM_C\n";
//	 else honk<<indat.matno[j]<<" WGggg_C "<<base.arrELSET[ base.trackELSET[j+1]-2 ]<<" "<<base.arrELSET[ base.trackELSET[j+1]-1 ]<<"\n";
//						}
//honk<<wp.nWeldGroup<<" "<<wp.nWeldPass<<" Crash diveC\n";
////////////////////////
							   iCullyesno=0;Invalidate();
							  }
//---------------------------------------------------------------------------
void TForm1::wpCreate1_public()
{CreateLinWeldPass->CheckEdit9=wps.curr[CreateLinWeldPass->CheckWeldParName];
 CreateLinWeldPass->CheckEdit10=wps.volt[CreateLinWeldPass->CheckWeldParName];
 CreateLinWeldPass->CheckEdit11=wps.eff[CreateLinWeldPass->CheckWeldParName];
 CreateLinWeldPass->CheckEdit12=wps.speed[CreateLinWeldPass->CheckWeldParName];
}
//---------------------------------------------------------------------------
void TForm1::wpCreate2_public()
{FD_LButtonstatus=11;stateVFT=2;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 delete CreateLinWeldPass;CreateLinWeldPass=NULL;// because it was created with Show()?
}

//---------------------------------------------------------------------------
void __fastcall TForm1::exportCTSPExecute(TObject *Sender)
{long in=0;float iptmax=0.;
//honk<<gWsiAlias<<" gWsiAlias here0\n";
 if(base.nop1)
   {if(wp.nWeldPass)
////	  {ABAQnames=new TForm19(2,this);
//	  {ABAQnames=new TForm25(2,this);
	  {CTSPnames=new TForm29(0,wp.nWeldPass,this);
	   CTSPnames->Caption="Enter file name for CTSP(TM) input deck.";
	   CTSPnames->Label1->Caption="CTSP main file";
	   CTSPnames->Label2->Caption="CTSP node file";
	   CTSPnames->Label3->Caption="CTSP element file";
	   CTSPnames->Label8->Caption="CTSP param file";
//	   CTSPnames->Label4->Caption="Subdivide CTSP into # multitasks:";
	   CTSPnames->Label4->Caption="Subdivide CTSP into # multicores:";
	   CTSPnames->Label5->Caption="_CTSP_input.in";
	   CTSPnames->Label6->Caption="_CTSP_node.in";
	   CTSPnames->Label7->Caption="_CTSP_element.in";
	   CTSPnames->Label9->Caption="_CTSP_param.in";
	   CTSPnames->Label10->Caption="Suggested core-to-core overlap time";
	   CTSPnames->Button1->Caption="OK";
//	   CTSPnames->Button2->Caption="Inoperative";
	   CTSPnames->Button2->Caption="Cancel";
	   CTSPnames->Label2->Enabled=false;
	   CTSPnames->Label3->Enabled=false;
	   CTSPnames->Label6->Enabled=false;
	   CTSPnames->Label7->Enabled=false;
	   CTSPnames->Label8->Enabled=false;
	   CTSPnames->Label9->Enabled=false;
	   CTSPnames->Label10->Enabled=false;
	   CTSPnames->Label2->Visible=false;
	   CTSPnames->Label3->Visible=false;
	   CTSPnames->Label6->Visible=false;
	   CTSPnames->Label7->Visible=false;
	   CTSPnames->Label8->Visible=false;
	   CTSPnames->Label9->Visible=false;
	   CTSPnames->Label10->Visible=false;

	   CTSPnames->Edit1->Enabled=true;
	   CTSPnames->Edit2->Enabled=false;
	   CTSPnames->Edit3->Enabled=false;
	   CTSPnames->Edit5->Enabled=false;
	   CTSPnames->Edit4->Enabled=true;
	   CTSPnames->Edit6->Enabled=false;
	   CTSPnames->Edit1->Visible=true;
	   CTSPnames->Edit2->Visible=false;
	   CTSPnames->Edit3->Visible=false;
	   CTSPnames->Edit5->Visible=false;
	   CTSPnames->Edit4->Visible=true;
	   CTSPnames->Edit6->Visible=false;
	   CTSPnames->CheckEdit1=gWsiAlias;
	   CTSPnames->CheckEdit4=1;
	   if(wp.nWeldPass>1){iptmax=0.;for(in=0;in<wp.nWeldPass-1;in++)if(iptmax<wp.timeInterval[in])iptmax=wp.timeInterval[in];
						  CTSPnames->CheckEdit6=3.5*iptmax; // Policy: core-to-core default= 3.5x max IPtime interval
						 }
	   else CTSPnames->CheckEdit6=float(3600);
	   CTSPnames->ShowModal();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must create weld passes->Weld",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"72Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::exportABAQUSExecute(TObject *Sender)
{if(base.nop1)
   {if(wp.nWeldPass)
//	  {ABAQnames=new TForm19(0,this);
	  {ABAQnames=new TForm25(0,this);
	   ABAQnames->Caption="Enter file names for SIMULIA(TM) input deck.";
	   ABAQnames->Label1->Caption="S/ABAQUS main file";
	   ABAQnames->Label2->Caption="S/ABAQUS node file";
	   ABAQnames->Label3->Caption="S/ABAQUS element file";
	   ABAQnames->Label4->Caption="S/ABAQUS VED file";
	   ABAQnames->Label5->Caption="S/ABAQUS ufield file";
	   ABAQnames->Label6->Caption="Directory where S/ABAQUS will run";
	   ABAQnames->Label7->Caption="_ABA.inp";
//	   ABAQnames->Label8->Caption="_ABA_node.inp";
//	   ABAQnames->Label9->Caption="_ABA_element.inp";
	   ABAQnames->Label8->Caption="_node.inp";
	   ABAQnames->Label9->Caption="_element.inp";
	   ABAQnames->Label10->Caption="_VED.inp";
	   ABAQnames->Label11->Caption="_ufield.f";
	   ABAQnames->Button1->Caption="OK";
//	   ABAQnames->Button2->Caption="Inoperative";
	   ABAQnames->Button2->Caption="Cancel";
	   ABAQnames->Label2->Enabled=false;ABAQnames->Label3->Enabled=false;ABAQnames->Label4->Enabled=false;
	   ABAQnames->Label5->Enabled=false;ABAQnames->Label6->Enabled=false;ABAQnames->Label8->Enabled=false;
	   ABAQnames->Label9->Enabled=false;ABAQnames->Label10->Enabled=false;ABAQnames->Label11->Enabled=false;
	   ABAQnames->Edit2->Visible=false;ABAQnames->Edit3->Visible=false;ABAQnames->Edit4->Visible=false;
	   ABAQnames->Edit5->Visible=false;ABAQnames->Edit6->Visible=false;
////	   ABAQnames->CheckEdit1="****";
//	   ABAQnames->CheckEdit1=gWsiAlias.c_str();
	   ABAQnames->CheckEdit1=gWsiAlias.t_str();
	   ABAQnames->ShowModal();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must create weld passes->Weld",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"72Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::export_ABA_NODE(char gVFTnameStem[]) // Write ABAQUS-format ASCII nodal geometry file *.inp (or *.in), delimited by ","
{long i=0;
//// char extensChar[]="_ABA_node.inp";
 char extensChar[]="_node.inp";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// char extensChar[]="_node.txt";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;
 viewfile.setf(ios::scientific);
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
	  viewfile.precision(6);
//	  for(i=0;i<base.npoin;i++)if(base.node_map[i]>0)viewfile<<i+1<<","<<base.c1[NDF*i]<<","<<base.c1[NDF*i+1]<<","<<base.c1[NDF*i+2]<<"\n";
	  for(i=0;i<base.npoin;i++)viewfile<<base.node_map[i]+1<<","<<base.c1[NDF*i]<<","<<base.c1[NDF*i+1]<<","<<base.c1[NDF*i+2]<<"\n";
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 viewfile.close();
}
//---------------------------------------------------------------------------
/*
  protected void export_ELEMENT() {
	  try {PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(abaElementFile)));
		  StringBuffer sb = new StringBuffer();
		  for (int i=0; i<frame.fem.ele8s.size();i++){
					 int jd;
					 int [] corner=new int[8];
					 Element8 ele8=null;
					 ele8= (Element8) frame.fem.ele8s.get(i);
					 jd=ele8.getID();
					 corner=ele8.getCorners();
		  sb.append(jd+","+corner[0]+","+corner[1]+","+corner[2]+","+corner[3]+","+corner[4]+","+corner[5]+","+corner[6]+","+corner[7]+"\n");
		  }
		  pw.print(sb.toString());
		  pw.close();
	  }
	  catch(Exception e) {
	  }
}
*/
/*
void TForm1::export_ABA_ELEMENT8() // Write ABAQUS-format ASCII element (8n only, with mapping) connectivity file *.inp (or *.in), delimited by ","
{long i=0;
 char extensChar[]="_ABA_element.inp";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
 try {for(i=0;i<base.nelt;i++)viewfile<<base.el_map[i]+1<<","
				<<base.nop1[MXNPEL*i+0]+1<<","<<base.nop1[MXNPEL*i+1]+1<<","<<base.nop1[MXNPEL*i+2]+1<<","<<base.nop1[MXNPEL*i+3]+1<<","
				<<base.nop1[MXNPEL*i+4]+1<<","<<base.nop1[MXNPEL*i+5]+1<<","<<base.nop1[MXNPEL*i+6]+1<<","<<base.nop1[MXNPEL*i+7]+1<<"\n";
	 }
__finally {Screen->Cursor=Save_Cursor;}
 viewfile.close();
}
*/
/*
void TForm1::export_ABA_ELEMENT8(char gVFTnameStem[]) // Write ABAQUS-format ASCII element (8n only, with mapping) connectivity file *.inp (or *.in), delimited by ","
{long i=0,eltype=0,bscode=0,node=0,t7=10000000,t5=100000,t3=1000;
//// char extensChar[]="_ABA_element.inp";
 char extensChar[]="_element.inp";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// char extensChar[]="_element.txt";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//// try {
//	  for(i=0;i<base.nelt;i++)viewfile<<base.el_map[i]+1<<","
//				<<base.node_map[base.nop1[MXNPEL*i+0]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","
//				<<base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";


				 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
										  if(eltype==8){if(node==8) //EFP 6/12/2014
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
														else
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
													   }
										  else if(eltype==7){if(node==6)
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<"\n";
															 else
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
															}
										  else if(eltype==5){if(node==4)
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<"\n";
															 else
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<"\n";
															}
										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"export_CTSP_ELEMENT8() unsupported element type",L"Terminate",MB_OK);exit(0);}
										 }




//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 viewfile.close();
}
*/
/*
void TForm1::export_ABA_ELEMENT8(char gVFTnameStem[]) // Write ABAQUS-format ASCII element (8n only, with mapping) connectivity file *.inp (or *.in), delimited by ","
{long i=0,eltype=0,bscode=0,node=0,t7=10000000,t5=100000,t3=1000;
//// char extensChar[]="_ABA_element.inp";
//// Version which writes allHex_element.inp as well as ........inp  EFP 8/01/2014
//// Please note that viewfile is theoretically WRONG below, because C3D4/6/8 should not be bundled together.
 char extensChar[]="_element.inp";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// char extensChar[]="_element.txt";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed),hexfile("allhex_element.inp");delete [] fnNeed;
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//// try {
//	  for(i=0;i<base.nelt;i++)viewfile<<base.el_map[i]+1<<","
//				<<base.node_map[base.nop1[MXNPEL*i+0]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","
//				<<base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";


				 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
										  if(eltype==8){if(node==8){ //EFP 6/12/2014
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
																   }
														else {
// Abaqus convention for C3D20: bottom corners, top corners, bottom midsides, top midsides, midheights
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
															 }
													   }
										  else if(eltype==7){if(node==6){
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<"\n";
// Abaqus convention: wedge (n0,n1,n2,n3,n4,n5) becomes hex (n0,n1,n2,n2,n3,n4,n5,n5)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<"\n";
																		}
															 else {
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
// Abaqus convention(?): wedge (n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14) becomes hex (n0,n1,n2,n2,n3,n4,n5,n5,n6,n7,n2,n8,n9,n10,n5,n11,n12,n13,n14,n14)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
																  }
															}
										  else if(eltype==5){if(node==4){
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<"\n";
// Abaqus convention: tetra (n0,n1,n2,n3) becomes hex (n0,n1,n2,n2,n3,n3,n3,n3)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<"\n";
																		}
															 else {
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<"\n";
// Abaqus convention(?): tetra (n0,n1,n2,n3,n4,n5,n6,n7,n8,n9) becomes hex (n0,n1,n2,n2,n3,n3,n3,n3,n4,n5,n2,n6,n3,n3,n3,n3,n7,n8,n9,n9)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<"\n";
																  }
															}
										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"export_CTSP_ELEMENT8() unsupported element type",L"Terminate",MB_OK);exit(0);}
										 }
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 viewfile.close();hexfile.close();
}
*/
void TForm1::export_ABA_ELEMENT8(char gVFTnameStem[]) // Write ABAQUS-format ASCII element (8n only, with mapping) connectivity file *.inp (or *.in), delimited by ","
{long i=0,j=0,eltype=0,bscode=0,node=0,t7=10000000,t5=100000,t3=1000,eltyperec=0,noderec=0,nsum=0;
//// char extensChar[]="_ABA_element.inp";
//// Version which writes allHex_element.inp as well as ........inp  EFP 8/01/2014
//// Please note that viewfile is theoretically WRONG below, because C3D4/6/8 should not be bundled together.
 char extensChar[]="_element.inp";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// char extensChar[]="_element.txt";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//// try {
 for(j=0;j<6;j++)
   {if     (j==0){eltyperec=8;noderec= 8;}
	else if(j==1){eltyperec=8;noderec=20;}
	else if(j==2){eltyperec=7;noderec= 6;}
	else if(j==3){eltyperec=7;noderec=15;}
	else if(j==4){eltyperec=5;noderec= 4;}
	else         {eltyperec=5;noderec=10;}
	nsum=0;
	for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
							 if(eltype==eltyperec && node==noderec)nsum++;
							}
	if(nsum)
	  {
	if     (j==0){eltyperec=8;noderec= 8;viewfile<<"*ELEMENT,TYPE=C3D8R\n";} //CAUTION: Check that *ELEM begins in col.1
	else if(j==1){eltyperec=8;noderec=20;viewfile<<"*ELEMENT,TYPE=C3D20\n";}
	else if(j==2){eltyperec=7;noderec= 6;viewfile<<"*ELEMENT,TYPE=C3D6\n";}
	else if(j==3){eltyperec=7;noderec=15;viewfile<<"*ELEMENT,TYPE=C2D15\n";}
	else if(j==4){eltyperec=5;noderec= 4;viewfile<<"*ELEMENT,TYPE=C2D4\n";}
	else         {eltyperec=5;noderec=10;viewfile<<"*ELEMENT,TYPE=C2D10\n";}
				 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
//										  if(eltype==8){if(node==8){ //EFP 6/12/2014
										  if(eltype==8 && eltyperec==8){ //EFP 6/12/2014
														if(node==8 && noderec==8){ //EFP 6/12/2014
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
																				}
														else if(node==20 && noderec==20){
// Abaqus convention for C3D20: bottom corners, top corners, bottom midsides, top midsides, midheights
//viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
// Replace single output line with known Abaqus/CAE 6.13 2-line format
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
viewfile<<"      "<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
																					   }
																	   }
//										  else if(eltype==7){if(node==6){
										  else if(eltype==7 && eltyperec==7){
															 if(node==6 && noderec==6){
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<"\n";
																					  }
															 else if(node==15 && noderec==15){
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
																							 }
																			}
//										  else if(eltype==5){if(node==4){
										  else if(eltype==5 && eltyperec==5){
															 if(node==4 && noderec==4){
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<"\n";
																					  }
															 else if(node==10 && noderec==10){
viewfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<"\n";
																							 }
																			}
////										  else {
////honk<<j<<" "<<eltyperec<<" "<<noderec<<" Atype/er/nr/el/nl "<<eltype<<" "<<node<<"\n";
////												extern PACKAGE void __fastcall Beep(void);
////												Application->MessageBox(L"export_CTSP_ELEMENT8() unsupported element type",L"TerminateA",MB_OK);
////												exit(0);
////                                               }
										 }
	  }
   }
viewfile.close();ofstream hexfile("allhex_element.inp");
// hexfile("allhex_element.inp") allows for the fact that Joshua's current temp2odb_solid_save.py requires 8-n hex throughout, without *ELEMENT,...
				 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
										  if(eltype==8){if(node==8){ //EFP 6/12/2014
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
																   }
														else {
// Abaqus convention for C3D20: bottom corners, top corners, bottom midsides, top midsides, midheights
// Replace single output line with known Abaqus/CAE 6.13 2-line format
//hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<
//								 base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
hexfile<<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
hexfile<<"      "<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
															 }
													   }
										  else if(eltype==7){if(node==6){
// Abaqus convention: wedge (n0,n1,n2,n3,n4,n5) becomes hex (n0,n1,n2,n2,n3,n4,n5,n5)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<"\n";
																		}
															 else {
// Abaqus convention(?): wedge (n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14) becomes hex (n0,n1,n2,n2,n3,n4,n5,n5,n6,n7,n2,n8,n9,n10,n5,n11,n12,n13,n14,n14)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
																  }
															}
										  else if(eltype==5){if(node==4){
// Abaqus convention: tetra (n0,n1,n2,n3) becomes hex (n0,n1,n2,n2,n3,n3,n3,n3)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<"\n";
																		}
															 else {
// Abaqus convention(?): tetra (n0,n1,n2,n3,n4,n5,n6,n7,n8,n9) becomes hex (n0,n1,n2,n2,n3,n3,n3,n3,n4,n5,n2,n6,n3,n3,n3,n3,n7,n8,n9,n9)
hexfile <<base.el_map[i]+1<<","<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
								 base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<"\n";
																  }
															}
////										  else {
////honk<<j<<" "<<eltyperec<<" "<<noderec<<" Btype/er/nr/el/nl"<<eltype<<" "<<node<<"\n";
////												extern PACKAGE void __fastcall Beep(void);
////												Application->MessageBox(L"export_CTSP_ELEMENT8() unsupported element type",L"TerminateB",MB_OK);
////												exit(0);
////											   }
										 }
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 hexfile.close();
}

//---------------------------------------------------------------------------
void TForm1::export_VED(char gVFTnameStem[],float *timesave2) // VED= virtual element detection  (based on WSIExportABA.java export_VED)
// Note that the last number in the output file will still have a trailing comma.
// Export with element mapping
// Centroidal distance/speed coded & Correction for non-conforming faces EFP 5/24/2011
// Version with CTSP-compliant "element-based "centroid & weld length  EFP 3/16/2012
// (EFP recommends an "element-area-based" centroid)
{int n1=0,n2=0,n3=0,n4=0,n5=0,n6=0,n7=0,n8=0;
 long i=0,j=0,k=0,ja=0,ist=0,tranche=0,ie=0,iside=0,cen_stt=0,ieq=0,isideq=0,iseq=0,k1=0,k2=0,ngaus=2;
//////////////////
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7},
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7},
	 opp_arr8[6]={2,3,0,1,5,4};//EFP 3/16/2012
//////////////////
 float xfavg=0.,yfavg=0.,zfavg=0.,xpatch=0.,ypatch=0.,zpatch=0.,dist2patch=1.e20,dist2=0.,
	   xup=0.,yup=0.,zup=0.,xlo=0.,ylo=0.,zlo=0.,time=0.,ttime=0.,wpTime=0.,dist=0.
///////////  trash
//,ttimeA=0.,ttimeE=0.,distA=0.,distE=0.,xpatchA=0.,ypatchA=0.,zpatchA=0.,xupA=0.,yupA=0.,zupA=0.,area=0.,xc=0.,yc=0.,zc=0.
///////////
	   ;
/////////// trash
 float DJD=0.,HN[9],SN[MXNPELS],SN1[MXNPELS],SG[NDF*MXNPELS],DJR[9],DJDLIM=3.E-10,POSGP8[2],WEIGP8[2];
///////////
 char extensChar[]="_VED.dat";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// char extensChar[]="_VEDdat.txt";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;

  viewfile.setf(ios::scientific);

 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
	  time=0.;
//	  for(i=0;i<wp.nWeldPass;i++)
	  for(iseq=0;iseq<wp.nWeldPass;iseq++) //Correction EFP 8/15/2011
		{for(i=0;i<wp.nWeldPass;i++)if(iseq+1==wp.seqNum[i])break;
//		{ist=0;for(j=base.nelt*i;j<base.nelt*(i+1);j++){if(wp.eles[j]> -1)ist++;else break;}
		 ist=0;for(j=wp.memWGa*i;j<wp.memWGa*(i+1);j++){if(wp.eles[j]> -1)ist++;else break;}
		 tranche=ist/wp.n_curr_sttEl[i];
//		 ttime=wpTime=0.;
		 wpTime=0.;ttime=time;
/////////////////// trash
//ttimeA=ttimeE=time;
honk<<"ElCenTime ArCenTime CenStTime for SEQ "<<iseq+1<<" and WP "<<i+1<<"\n";
POSGP8[0]= -1./sqrt(3.);POSGP8[1]=1./sqrt(3.);WEIGP8[0]=WEIGP8[1]=  1.00000;
///////////////////
//		 ie=wp.sttEles[wp.memWGa*i+0]/10;iside=wp.sttEles[wp.memWGa*i+0]-10*ie;
//		 if(iside==0 || iside==2){n1=0;n2=3;}
//		 else if(iside==1 || iside==3){n1=1;n2=0;}
//		 else {n1=4;n2=0;}

/////////////
/////////////
/////////////
xpatch=ypatch=zpatch=0.;
for(j=0;j<wp.n_curr_sttEl[i];j++)
  {xfavg=yfavg=zfavg=0.;ieq=wp.sttEles[wp.memWGa*i+j]/10;isideq=wp.sttEles[wp.memWGa*i+j]-10*ieq;
   for(k=0;k<4;k++){xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+0];
					yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+1];
					zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+2];
				   }
   xpatch=xpatch+xfavg/4.;ypatch=ypatch+yfavg/4.;zpatch=zpatch+zfavg/4.;
  }
xpatch=xpatch/float(wp.n_curr_sttEl[i]);ypatch=ypatch/float(wp.n_curr_sttEl[i]);zpatch=zpatch/float(wp.n_curr_sttEl[i]);
for(j=0;j<wp.n_curr_sttEl[i];j++)
  {xfavg=yfavg=zfavg=0.;ieq=wp.sttEles[wp.memWGa*i+j]/10;isideq=wp.sttEles[wp.memWGa*i+j]-10*ieq;
   for(k=0;k<4;k++){xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+0];
					yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+1];
					zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+2];
				   }
   dist2=(xpatch-xfavg/4.)*(xpatch-xfavg/4.)+(ypatch-yfavg/4.)*(ypatch-yfavg/4.)+(zpatch-zfavg/4.)*(zpatch-zfavg/4.);
   if(dist2patch>dist2){cen_stt=j;dist2patch=dist2;} //Not used anymore
  }
////////////// trash
//xpatchA=ypatchA=zpatchA=area=0.;
//for(j=0;j<wp.n_curr_sttEl[i];j++)
//  {xfavg=yfavg=zfavg=0.;ieq=wp.sttEles[wp.memWGa*i+j]/10;isideq=wp.sttEles[wp.memWGa*i+j]-10*ieq;
//   for(k2=0;k2<ngaus;k2++){
//	 for(k1=0;k1<ngaus;k1++){
//					if(isideq==0)     {xc=POSGP8[k1];yc= -1.;zc=POSGP8[k2];}
//					else if(isideq==1){xc=  1.;yc=POSGP8[k1];zc=POSGP8[k2];}
//					else if(isideq==2){xc=POSGP8[k1];yc=  1.;zc=POSGP8[k2];}
//					else if(isideq==3){xc= -1.;yc=POSGP8[k1];zc=POSGP8[k2];}
//					else if(isideq==4){xc=POSGP8[k1];yc=POSGP8[k2];zc= -1.;}
//					else              {xc=POSGP8[k1];yc=POSGP8[k2];zc=  1.;}
//					STFISO8(1,xc,yc,zc,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*ieq,base.c1);
//					STFISO8(3,xc,yc,zc,&DJD,HN,SN1,SG,DJR,base.nop1+MXNPEL*ieq,base.c1);
//					area=area+DJD*WEIGP8[k1]*WEIGP8[k2];
//					for(k=0;k<8;k++){
//xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+k]+0]*SN[k]*DJD*WEIGP8[k1]*WEIGP8[k2];
//yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+k]+1]*SN[k]*DJD*WEIGP8[k1]*WEIGP8[k2];
//zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+k]+2]*SN[k]*DJD*WEIGP8[k1]*WEIGP8[k2];
////honk<<j<<" "<<k2<<" "<<k1<<" "<<k<<" "<<SN[k]<<" rapido "<<xfavg<<" "<<yfavg<<" "<<zfavg<<"\n";
//									}
//							}
//						  }
//   xpatchA=xpatchA+xfavg;ypatchA=ypatchA+yfavg;zpatchA=zpatchA+zfavg;
//  }
//xpatchA=xpatchA/area;ypatchA=ypatchA/area;zpatchA=zpatchA/area;
//honk<<xpatch<<" "<<ypatch<<" "<<zpatch<<" aaaxxx\n";
//honk<<xpatchA<<" "<<ypatchA<<" "<<zpatchA<<" "<<area<<" XAYAZA area\n";
//if(1==1)exit(0);
//////////////
		 for(j=0;j<tranche;j++)
		   {viewfile<<ttime<<", "<<wp.n_curr_sttEl[i]<<"\n";
////////////// trash
//honk<<ttime*wp.speed[i]<<"   "<<ttimeA*wp.speed[i]<<"   "<<ttimeE*wp.speed[i]<<"\n";
honk<<ttime<<"   "<<wp.n_curr_sttEl[i]<<" Tranche "<<j+1<<"\n";
//////////////
			for(k=0;k<wp.n_curr_sttEl[i];k++)viewfile<<base.el_map[wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+k]/10]+1<<", ";
			viewfile<<"\n";
/////////////////// trash
//			ie=wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+cen_stt]/10;
//			iside=wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+cen_stt]-10*ie;
//		 if     (iside==0 || iside==2){n1=0;n2=1;n3=5;n4=4;n5=2;n6=3;n7=7;n8=6;}
//		 else if(iside==1 || iside==3){n1=1;n2=2;n3=6;n4=5;n5=3;n6=0;n7=4;n8=7;}
//		 else                         {n1=0;n2=1;n3=2;n4=3;n5=4;n6=5;n7=6;n8=7;}
//		 xlo=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n1]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n2]+0]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n3]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n4]+0]);
//		 ylo=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n1]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n2]+1]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n3]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n4]+1]);
//		 zlo=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n1]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n2]+2]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n3]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n4]+2]);
//		 xup=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n5]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n6]+0]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n7]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n8]+0]);
//		 yup=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n5]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n6]+1]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n7]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n8]+1]);
//		 zup=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n5]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n6]+2]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n7]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n8]+2]);
//		 distE=sqrt((xup-xlo)*(xup-xlo)+(yup-ylo)*(yup-ylo)+(zup-zlo)*(zup-zlo));
///////////////////
			xup=yup=zup=0.;
			for(ja=0;ja<wp.n_curr_sttEl[i];ja++)
			  {xfavg=yfavg=zfavg=0.;
			   ieq=wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+ja]/10;
			   isideq=opp_arr8[wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+ja]-10*ieq];
			   for(k=0;k<4;k++){xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+0];
								yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+1];
								zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+2];
							   }
			   xup=xup+xfavg/4.;yup=yup+yfavg/4.;zup=zup+zfavg/4.;
			  }
			xup=xup/float(wp.n_curr_sttEl[i]);yup=yup/float(wp.n_curr_sttEl[i]);zup=zup/float(wp.n_curr_sttEl[i]);

			dist=sqrt((xup-xpatch)*(xup-xpatch)+(yup-ypatch)*(yup-ypatch)+(zup-zpatch)*(zup-zpatch));
honk<<xup<<" "<<yup<<" "<<zup<<" UPpointDOWN "<<xpatch<<" "<<ypatch<<" "<<zpatch<<"\n";
			xpatch=xup;ypatch=yup;zpatch=zup;
/////////////// trash
//xupA=yupA=zupA=area=0.;
//for(ja=0;ja<wp.n_curr_sttEl[i];ja++)
//  {xfavg=yfavg=zfavg=0.;ieq=wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+ja]/10;isideq=opp_arr8[wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+ja]-10*ieq];
//   for(k2=0;k2<ngaus;k2++){
//	 for(k1=0;k1<ngaus;k1++){
//					if(isideq==0)     {xc=POSGP8[k1];yc= -1.;zc=POSGP8[k2];}
//					else if(isideq==1){xc=  1.;yc=POSGP8[k1];zc=POSGP8[k2];}
//					else if(isideq==2){xc=POSGP8[k1];yc=  1.;zc=POSGP8[k2];}
//					else if(isideq==3){xc= -1.;yc=POSGP8[k1];zc=POSGP8[k2];}
//					else if(isideq==4){xc=POSGP8[k1];yc=POSGP8[k2];zc= -1.;}
//					else              {xc=POSGP8[k1];yc=POSGP8[k2];zc=  1.;}
//					STFISO8(1,xc,yc,zc,&DJD,HN,SN,SG,DJR,base.nop1+MXNPEL*ieq,base.c1);
//					STFISO8(3,xc,yc,zc,&DJD,HN,SN1,SG,DJR,base.nop1+MXNPEL*ieq,base.c1);
//					area=area+DJD*WEIGP8[k1]*WEIGP8[k2];
//					for(k=0;k<8;k++){xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+k]+0]*SN[k]*DJD*WEIGP8[k1]*WEIGP8[k2];
//									 yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+k]+1]*SN[k]*DJD*WEIGP8[k1]*WEIGP8[k2];
//									 zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+k]+2]*SN[k]*DJD*WEIGP8[k1]*WEIGP8[k2];
//				                    }
//							}
//						  }
//   xupA=xupA+xfavg;yupA=yupA+yfavg;zupA=zupA+zfavg;
//  }
//xupA=xupA/area;yupA=yupA/area;zupA=zupA/area;
//distA=sqrt((xupA-xpatchA)*(xupA-xpatchA)+(yupA-ypatchA)*(yupA-ypatchA)+(zupA-zpatchA)*(zupA-zpatchA));
////honk<<xpatchA<<" "<<ypatchA<<" "<<zpatchA<<" "<<area<<" XAYAZA areaoo "<<distA<<"\n";
//xpatchA=xupA;ypatchA=yupA;zpatchA=zupA;
//ttimeA=ttimeA+distA/wp.speed[i];
//ttimeE=ttimeE+distE/wp.speed[i];
///////////////
			ttime=ttime+dist/wp.speed[i];
			wpTime=wpTime+dist/wp.speed[i];
honk<<ttime<<" "<<wpTime<<" Updated local/global time using dist & speed "<<dist<<" "<<wp.speed[i]<<"\n";
		   }
//		 wp.wpTimes[i]=wpTime+wp.timeInterval[i];
		 wp.wpTimes[i]=wpTime; // Correction EFP 8-25-2010
		 time=time+wpTime+wp.timeInterval[i];
		}
	  *timesave2=time;
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 viewfile.close();
}

//---------------------------------------------------------------------------
void TForm1::export_ABA(char gVFTnameStem[]) // This corresponds to NG's export_ABA_NEW() i.e. second version
// Caution: This does not contain any LUMPED/other content. FIX THIS...
// Export with element mapping
// Centroidal distance/speed coded & Correction for non-conforming faces EFP 5/24/2011
// Version with CTSP-compatible "element-based" centroid & weld length  EFP 3/16/2012
{int nic=0,nrc=0,n1=0,n2=0,n3=0,n4=0,n5=0,n6=0,n7=0,n8=0,icount=0,iactive=0;
 long i=0,j=0,k=0,ja=0,ie=0,iside=0,cen_stt=0,ieq=0,isideq=0,iseq=0,
larr[11],*dumarr=NULL;
//////////////////
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7},
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7},
	 opp_arr8[6]={2,3,0,1,5,4};//EFP 3/16/2012
//////////////////
 float xfavg=0.,yfavg=0.,zfavg=0.,xpatch=0.,ypatch=0.,zpatch=0.,dist2patch=1.e20,dist2=0.,
	   xup=0.,yup=0.,zup=0.,xlo=0.,ylo=0.,zlo=0.,
	   dist=0.,E=0.,mu=0.,hourstiff1=0.,darr[11];
 char cht[200],extensChar[]="_ABA.inp",extensChar1[]="_origABA.inp";
 char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);
 StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;
//Write mirror _origABA.inp for use with Joshua Webb's temp2odb, because _ABA.inp will be adulterated/unusable. EFP 5/05/2013
 char *fnNeed1=new char[strlen(gVFTnameStem)+strlen(extensChar1)+1];
 StringCchCopy(fnNeed1,strlen(gVFTnameStem)+strlen(extensChar1)+1,gVFTnameStem);
 StringCchCat(fnNeed1,strlen(gVFTnameStem)+strlen(extensChar1)+1,extensChar1);
 ofstream mirrfile(fnNeed1);delete [] fnNeed1;

//aaaaaaaaaaaaaa
//aaaaaaaaaaaaaaaa
//aaaaaaaaaaaaaaaaaa
ofstream tmpfile2("scratchAba2.tmp");
ofstream tmpfile4("scratchAba4.tmp");
if(viewfile && mirrfile && tmpfile2 && tmpfile4)
  {tmpfile4.setf(ios::scientific);
//bbbbbbbbbbbbbbbbbb
//bbbbbbbbbbbbbbbb
//bbbbbbbbbbbbbb

 viewfile.setf(ios::scientific);mirrfile.setf(ios::scientific);

 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
	  viewfile<<"*******************************************************\n";
	  viewfile<<"********** Job Header Information & FE Model Definition **********\n";
	  viewfile<<"*******************************************************\n";
	  viewfile<<"*HEADING\n";
	  viewfile<<" ABAQUS Input Deck - Created by VFT for application "<<gVFTnameStem<<" \n";
	  viewfile<<"*PREPRINT, MODEL=NO, ECHO=NO, HISTORY=NO\n";
	  viewfile<<"*NODE, SYSTEM=R, NSET=NDALL, INPUT="<<gVFTnameStem<<"_node.inp\n";
	  viewfile<<"*ELEMENT,TYPE=C3D8R,ELSET=ALLEL, INPUT="<<gVFTnameStem<<"_element.inp\n";
//	  viewfile<<"*ELEMENT,ELSET=ALLEL, INPUT="<<gVFTnameStem<<"_element.inp\n";
	  viewfile<<"************************************************\n";
	  viewfile<<"********** Weld Pass Group Definition **********\n";
	  viewfile<<"************************************************\n";
	  mirrfile<<"*******************************************************\n";
	  mirrfile<<"********** Job Header Information & FE Model Definition **********\n";
	  mirrfile<<"*******************************************************\n";
	  mirrfile<<"*HEADING\n";
	  mirrfile<<" ABAQUS Input Deck - Created by VFT for application "<<gVFTnameStem<<" \n";
	  mirrfile<<"*PREPRINT, MODEL=NO, ECHO=NO, HISTORY=NO\n";
	  mirrfile<<"*NODE, SYSTEM=R, NSET=NDALL, INPUT="<<gVFTnameStem<<"_node.inp\n";
	  mirrfile<<"*ELEMENT,TYPE=C3D8R,ELSET=ALLEL, INPUT="<<gVFTnameStem<<"_element.inp\n";
//	  mirrfile<<"*ELEMENT,ELSET=ALLEL, INPUT="<<gVFTnameStem<<"_element.inp\n";
	  mirrfile<<"************************************************\n";
	  mirrfile<<"********** Weld Pass Group Definition **********\n";
	  mirrfile<<"************************************************\n";
// Not sure what ELSET=AllWD means. In Tee_ABA.inp it is the weld group (elements in increasing order) of the second weld pass, even though there is a first weld pass too?
//// Policy here: Output weld groups associated with actual weld passes (elements in increasing order, commingled)
//	  viewfile<<"*ELSET, ELSET=AllWD\n";mirrfile<<"*ELSET, ELSET=AllWD\n";
	  viewfile<<"*ELSET, ELSET=AllWP\n";mirrfile<<"*ELSET, ELSET=AllWP\n";tmpfile2<<"*ELSET, ELSET=AllWP\n";
	  dumarr=new long[base.nelt];
	  for(i=0;i<base.nelt;i++)dumarr[i]=0;
	  for(i=0;i<wp.nWeldPass;i++){for(j=wp.memWGa*i;j<wp.memWGa*(i+1);j++){if(wp.eles[j]> -1)dumarr[wp.eles[j]/10]=1;else break;}}

	  j=0;for(i=0;i<base.nelt;i++)if(dumarr[i]>0){if(j>0 && j%10==0){viewfile<<"\n";mirrfile<<"\n";tmpfile2<<"\n";}
												  viewfile<<base.el_map[i]+1<<", ";mirrfile<<base.el_map[i]+1<<", ";tmpfile2<<base.el_map[i]+1<<", ";j++;
												 }
	  viewfile<<"\n";mirrfile<<"\n";tmpfile2<<"\n";
	  for(iseq=0;iseq<wp.nWeldPass;iseq++)
		{for(i=0;i<wp.nWeldPass;i++)if(iseq+1==wp.seqNum[i])break;//EFP 8/29/2011
		 viewfile<<"*ELSET, ELSET="<<wp.name[i].t_str()<<"\n";mirrfile<<"*ELSET, ELSET="<<wp.name[i].t_str()<<"\n";tmpfile2<<"*ELSET, ELSET="<<wp.name[i].t_str()<<"\n";k=0;
		 for(j=wp.memWGa*i;j<wp.memWGa*(i+1);j++){if(wp.eles[j]> -1){if(k>0 && k%10==0){viewfile<<"\n";mirrfile<<"\n";tmpfile2<<"\n";}
																	 viewfile<<base.el_map[wp.eles[j]/10]+1<<", ";
																	 mirrfile<<base.el_map[wp.eles[j]/10]+1<<", ";tmpfile2<<base.el_map[wp.eles[j]/10]+1<<", ";k++;
																	}
												  else break;
												 }
		 viewfile<<"\n";mirrfile<<"\n";tmpfile2<<"\n";
		}
	  tmpfile2.close();
	  delete [] dumarr;
	  viewfile<<"**************************************************\n";
	  viewfile<<"********** Material Property Definition **********\n";
	  viewfile<<"**************************************************\n";
	  mirrfile<<"**************************************************\n";
	  mirrfile<<"********** Material Property Definition **********\n";
	  mirrfile<<"**************************************************\n";
	  tmpfile4<<"**************************************************\n";
	  tmpfile4<<"********** Material Property Definition **********\n";
	  tmpfile4<<"**************************************************\n";
//          int len1=frame.matList.get(0).toString().length();if (len1 > 5)len1=5;
//          sb.append("*SOLID SECTION, ELSET=ALLEL, MATERIAL=" + frame.matList.get(0).toString().substring(0,len1) + "\n");
//          sb.append("*HOURGLASS STIFFNESS\n");
//          sb.append(" 423.93\n");
//          sb.append("*SOLID SECTION, ELSET=ALLWD, MATERIAL=" + frame.matList.get(0).toString().substring(0,len1) + "\n");
//          sb.append("*HOURGLASS STIFFNESS\n");
//          sb.append(" 423.93\n");

	  viewfile<<"*SOLID SECTION, ELSET=ALLEL, MATERIAL="<<wms.name[0].t_str()<<"\n";
	  viewfile<<"*HOURGLASS STIFFNESS\n";
	  viewfile<<" 423.93\n";
	  viewfile<<"*SOLID SECTION, ELSET=ALLWP, MATERIAL="<<wms.name[0].t_str()<<"\n";
	  viewfile<<"*HOURGLASS STIFFNESS\n";
	  viewfile<<" 423.93\n";
	  mirrfile<<"*SOLID SECTION, ELSET=ALLEL, MATERIAL="<<wms.name[0].t_str()<<"\n";
	  mirrfile<<"*HOURGLASS STIFFNESS\n";
	  mirrfile<<" 423.93\n";
	  mirrfile<<"*SOLID SECTION, ELSET=ALLWP, MATERIAL="<<wms.name[0].t_str()<<"\n";
	  mirrfile<<"*HOURGLASS STIFFNESS\n";
	  mirrfile<<" 423.93\n";
	  tmpfile4<<"*SOLID SECTION, ELSET=ALLEL, MATERIAL="<<wms.name[0].t_str()<<"\n";
	  tmpfile4<<"*HOURGLASS STIFFNESS\n";
	  tmpfile4<<" 423.93\n";
	  tmpfile4<<"*SOLID SECTION, ELSET=ALLWP, MATERIAL="<<wms.name[0].t_str()<<"\n";
	  tmpfile4<<"*HOURGLASS STIFFNESS\n";
	  tmpfile4<<" 423.93\n";
//          for(int i=0; i<wpNames.size(); i++) {
//              wp = (WeldPass)frame.wpTable.get((String)wpNames.get(i));
//              if(!wp.matName.equals(frame.matList.get(0))) {
//                  sb.append("*SOLID SECTION, ELSET=WP" + wp.seqNum + ", MATERIAL=" + wp.matName.substring(0,len1) + "\n");
//                  sb.append("*HOURGLASS STIFFNESS\n");
//                  sb.append(" 423.93\n");
//              }
//           }

	  for(iseq=0;iseq<wp.nWeldPass;iseq++)
		{for(i=0;i<wp.nWeldPass;i++)if(iseq+1==wp.seqNum[i])break;//EFP 8/29/2011
		 viewfile<<"*SOLID SECTION, ELSET="<<wp.name[i].t_str()<<", MATERIAL="<<wp.matName[i].t_str()<<"\n";
		 viewfile<<"*HOURGLASS STIFFNESS\n";viewfile<<" 423.93\n";
		 mirrfile<<"*SOLID SECTION, ELSET="<<wp.name[i].t_str()<<", MATERIAL="<<wp.matName[i].t_str()<<"\n";
		 mirrfile<<"*HOURGLASS STIFFNESS\n";mirrfile<<" 423.93\n";
		 tmpfile4<<"*SOLID SECTION, ELSET="<<wp.name[i].t_str()<<", MATERIAL="<<wp.matName[i].t_str()<<"\n";
		 tmpfile4<<"*HOURGLASS STIFFNESS\n";mirrfile<<" 423.93\n";
		}


//          for(int i=0; i<frame.matList.size(); i++) {
//	  for(i=0;i<1;i++){
	  for(i=0;i<wms.nMatPropSet;i++){


//////////////////// Coding for hourglass1/2/3/ (Typical ABAQUS mat prop datafile)
//9
//220448.0, 0.3, 1.380E-05,  23.0
//180705.0, 0.3, 1.380E-05, 200.0
//149435.0, 0.3, 1.380E-05, 300.0
//127105.0, 0.3, 1.380E-05, 400.0
//89825.8, 0.3, 1.500E-05, 500.0
//80310.4, 0.3, 1.500E-05, 600.0
//77100.4, 0.3, 1.550E-05, 700.0
//73148.7, 0.3, 1.550E-05, 800.0
//1400.0, 0.3, 1.600E-05, 1500.0
//honk<<wms.matFileName[i].c_str()<<" wms.matFileName[i]\n";
//honk<<wms.matFileName[i].t_str()<<" wms.matFileName[i]\n";
 ifstream ntape(wms.matFileName[i].t_str(),ios::nocreate|ios::binary,0);
 if(ntape){ntape.getline(cht,200-1);ntape.getline(cht,200-1);parse_cdm(cht,4,&nic,&nrc,larr,darr);
		   E=darr[0];mu=darr[1];hourstiff1=0.005*E/(2.*(1.+mu));ntape.close();
		  }
 else {hourstiff1=423.93;
	   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Material property file unavailable",L"Warning",MB_OK);
	  }
///////////////////////////////////////////////

//              sb.append("*MATERIAL, NAME=" + frame.matList.get(i).toString().substring(0,len1) + "\n");
////
//// Use the following with umat35
////
//              sb.append("*USER MATERIAL, CONSTANTS=8\n");
//              sb.append("*DEPVAR\n");
//              sb.append(" 56\n");

//////	  viewfile<<"*MATERIAL, NAME=nnnsm\n";
////	  viewfile<<"*MATERIAL, NAME="<<wms.matFileName[i].c_str()<<"\n";
//	  viewfile<<"*MATERIAL, NAME="<<wms.name[i].c_str()<<"\n";
//	  viewfile<<"*USER MATERIAL, CONSTANTS=8\n";
//	  viewfile<<"*DEPVAR\n";
//	  viewfile<<" 56\n";

////
//// Alternatively, use the following with umat35
////
////              sb.append("*MATERIAL, NAME=" + frame.matList.get(i).toString().substring(0,len1) + "\n");
////              sb.append("*USER MATERIAL, CONSTANTS="+wms.nprops+"\n");
////              sb.append(" " + (i+1) + ","+wms.Ti+","+wms.Ta+","+wms.Tm+","+wms.annjd+","+wms.ved+","+ wms.mcr+","+wms.hetjd+"\n");
////              if(wms.hetjd==-1)sb.append(wms.Steps+"\n");
////              sb.append("*DEPVAR\n");
////              sb.append(" 56\n");

//	  viewfile<<"*MATERIAL, NAME=nnnsm\n";
//	  viewfile<<"*USER MATERIAL, CONSTANTS=7\n";
//	  viewfile<<"1, 750.0, 1500.0, 1500.0, -1.0, -1.0, 0\n";
//	  viewfile<<"*DEPVAR\n";
//	  viewfile<<" 24\n";
//	  viewfile<<"*MATERIAL, NAME="<<wms.name[i].c_str()<<"\n";
	  viewfile<<"*MATERIAL, NAME="<<wms.name[i].t_str()<<"\n";
	  mirrfile<<"*MATERIAL, NAME="<<wms.name[i].t_str()<<"\n";
	  tmpfile4<<"*MATERIAL, NAME="<<wms.name[i].t_str()<<"\n";
//	  viewfile<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]<<"\n";
//Assume extra wms.Steps[i] line below added ONE to wms.nprops[i]  EFP 3/14/2012
// i.e. Do not parse wms.Steps[i] as in the following
	  if(wms.hetjd[i]== -1){
//							viewfile<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]+ParseSteps(wms.Steps[i])<<"\n";
//							mirrfile<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]+ParseSteps(wms.Steps[i])<<"\n";
//xxxxxxxxxxxx
//xxxxxxxxxxxxxx
//xxxxxxxxxxxxxxxx
icount=iactive=0;
for(j=0;j< wms.Steps[i].Length();j++){if(wms.Steps[i]==' ')iactive=0;  //THIS IS ALL WRONG SINCE IT DOES NOT STEP ALONG wms.Steps[i]
									  else if(iactive==0){icount++;iactive=1;}
									 }
							viewfile<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]+icount<<"\n";
							mirrfile<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]+icount<<"\n";
							tmpfile4<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]+icount<<"\n";
//yyyyyyyyyyyyyyyy
//yyyyyyyyyyyyyy
//yyyyyyyyyyyy
						   }
	  else {viewfile<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]<<"\n";
			mirrfile<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]<<"\n";
			tmpfile4<<"*USER MATERIAL, CONSTANTS="<<wms.nprops[i]<<"\n";
		   }
	  viewfile<<" "<<i+1<<","<<wms.Ti[i]<<","<<wms.Ta[i]<<","<<wms.Tm[i]<<","<<wms.annjd[i]<<","<<wms.ved[i]<<","<<wms.mcr[i]<<","<<wms.hetjd[i]<<"\n";
	  mirrfile<<" "<<i+1<<","<<wms.Ti[i]<<","<<wms.Ta[i]<<","<<wms.Tm[i]<<","<<wms.annjd[i]<<","<<wms.ved[i]<<","<<wms.mcr[i]<<","<<wms.hetjd[i]<<"\n";
	  tmpfile4<<" "<<i+1<<","<<wms.Ti[i]<<","<<wms.Ta[i]<<","<<wms.Tm[i]<<","<<wms.annjd[i]<<","<<wms.ved[i]<<","<<wms.mcr[i]<<","<<wms.hetjd[i]<<"\n";
	  if(wms.hetjd[i]== -1){viewfile<<wms.Steps[i].t_str()<<"\n"; // NOTE: Compute & write hourglass here....
							mirrfile<<wms.Steps[i].t_str()<<"\n";
							tmpfile4<<wms.Steps[i].t_str()<<"\n";
						   }
	  viewfile<<"*DEPVAR\n";viewfile<<" 56\n";mirrfile<<"*DEPVAR\n";mirrfile<<" 56\n";tmpfile4<<"*DEPVAR\n";tmpfile4<<" 56\n";
					  }
//          sb.append("***************************************************\n");
//          sb.append("********** Boundary Condition Definition **********\n");
//          sb.append("***************************************************\n");
//          sb.append("*INCLUDE, INPUT=" + wsiAlias + "_bc.inp\n");
//          sb.append("***************************************************\n");
//          sb.append("********** Initial Condition Definition **********\n");
//          sb.append("***************************************************\n");
////
//// for intial conditions temperature the value from the first weld pass preheat is used
////
//              wp = (WeldPass)frame.wpTable.get((String)wpNames.get(0));
//          float troomi=wp.tcuth;
//          sb.append("*INITIAL CONDITIONS, TYPE=FIELD, VARIABLE=1\n");
//          sb.append(" NDALL,"+troomi+"\n");
//          sb.append("*INITIAL CONDITIONS, TYPE=TEMP\n");
//          sb.append(" NDALL,"+troomi+"\n");
//          sb.append("*RESTART, WRITE, FREQ=1, OVERLAY\n");
//          sb.append("***********************************************\n");
//          sb.append("********** Step Procedure Definition **********\n");
//          sb.append("***********************************************\n");
	  viewfile<<"***************************************************\n";
	  viewfile<<"********** Boundary Condition Definition **********\n";
	  viewfile<<"***************************************************\n";
	  viewfile<<"*INCLUDE, INPUT="<<gVFTnameStem<<"_bc.inp\n";
	  viewfile<<"***************************************************\n";
	  viewfile<<"********** Initial Condition Definition **********\n";
	  viewfile<<"***************************************************\n";
	  mirrfile<<"***************************************************\n";
	  mirrfile<<"********** Boundary Condition Definition **********\n";
	  mirrfile<<"***************************************************\n";
	  mirrfile<<"*INCLUDE, INPUT="<<gVFTnameStem<<"_bc.inp\n";
	  mirrfile<<"***************************************************\n";
	  mirrfile<<"********** Initial Condition Definition **********\n";
	  mirrfile<<"***************************************************\n";
	  tmpfile4<<"***************************************************\n";
	  tmpfile4<<"********** Boundary Condition Definition **********\n";
	  tmpfile4<<"***************************************************\n";
	  tmpfile4<<"*INCLUDE, INPUT="<<gVFTnameStem<<"_bc.inp\n";
	  tmpfile4<<"***************************************************\n";
	  tmpfile4<<"********** Initial Condition Definition **********\n";
	  tmpfile4<<"***************************************************\n";
//
// for intial conditions temperature the value from the first weld pass preheat is used
//
//              wp = (WeldPass)frame.wpTable.get((String)wpNames.get(0));
	  float troomi=wp.tcuth[0];
	  viewfile<<"*INITIAL CONDITIONS, TYPE=FIELD, VARIABLE=1\n";
	  viewfile<<" NDALL,"<<troomi<<"\n";
	  viewfile<<"*INITIAL CONDITIONS, TYPE=TEMP\n";
	  viewfile<<" NDALL,"<<troomi<<"\n";
	  viewfile<<"*RESTART, WRITE, FREQ=1, OVERLAY\n";
	  viewfile<<"***********************************************\n";
	  viewfile<<"********** Step Procedure Definition **********\n";
	  viewfile<<"***********************************************\n";
	  mirrfile<<"*INITIAL CONDITIONS, TYPE=FIELD, VARIABLE=1\n";
	  mirrfile<<" NDALL,"<<troomi<<"\n";
	  mirrfile<<"*INITIAL CONDITIONS, TYPE=TEMP\n";
	  mirrfile<<" NDALL,"<<troomi<<"\n";
	  mirrfile<<"*RESTART, WRITE, FREQ=1, OVERLAY\n";
	  mirrfile<<"***********************************************\n";
	  mirrfile<<"********** Step Procedure Definition **********\n";
	  mirrfile<<"***********************************************\n";
	  tmpfile4<<"*INITIAL CONDITIONS, TYPE=FIELD, VARIABLE=1\n";
	  tmpfile4<<" NDALL,"<<troomi<<"\n";
	  tmpfile4<<"*INITIAL CONDITIONS, TYPE=TEMP\n";
	  tmpfile4<<" NDALL,"<<troomi<<"\n";
	  tmpfile4<<"*RESTART, WRITE, FREQ=1, OVERLAY\n";
	  tmpfile4<<"***********************************************\n";
	  tmpfile4<<"********** Step Procedure Definition **********\n";
	  tmpfile4<<"***********************************************\n";
// The following is based on export_ABA_NEW() only
	  int sid = 0;
	  double totalTime=0.;
	  for(iseq=0;iseq<wp.nWeldPass;iseq++)
								 {for(i=0;i<wp.nWeldPass;i++)if(iseq+1==wp.seqNum[i])break;
								  if(wp.hp[i]==1){  // Lumped Mass
//LLLLLLLLLLLLLLLLLLLLLLL
//LLLLLLLLLLLLLLLLLLLLLLL Ignore lumped pass presently (i.e. the following is Moving Arc)
//LLLLLLLLLLLLLLLLLLLLLLL
												  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Moving Arc supported, not Lumped Mass",L"Exit",MB_OK);exit(0);
												 }
								  else           {  // Moving Arc
		 sid ++;
		 viewfile<<"********** Step "<<sid<<" : Heating of Weld Pass "<<i+1<<" - "<<wp.name[i].t_str()<<" **********\n";
		 mirrfile<<"********** Step "<<sid<<" : Heating of Weld Pass "<<i+1<<" - "<<wp.name[i].t_str()<<" **********\n";
		 tmpfile4<<"********** Step "<<sid<<" : Heating of Weld Pass "<<i+1<<" - "<<wp.name[i].t_str()<<" **********\n";
//////  Use following with umat34
//		 viewfile<<"*STEP, INC=1000\n";
////  Use following with umat35
////		 viewfile<<"*STEP, INC=1000, NLGEOM=YES\n";
		 if(wp.mcr[i]==6){viewfile<<"*STEP, INC=1000, NLGEOM=YES\n";// This uses wp.mcr[] assigned from wms.mcr[]
						  mirrfile<<"*STEP, INC=1000, NLGEOM=YES\n";
						  tmpfile4<<"*STEP, INC=1000, NLGEOM=YES\n";
						 }
		 else {viewfile<<"*STEP, INC=1000\n";mirrfile<<"*STEP, INC=1000\n";tmpfile4<<"*STEP, INC=1000\n";
			  }
		 viewfile<<"*STATIC\n";mirrfile<<"*STATIC\n";tmpfile4<<"*STATIC\n";
/////////////
/////////////
/////////////
xpatch=ypatch=zpatch=0.;
for(j=0;j<wp.n_curr_sttEl[i];j++)
  {xfavg=yfavg=zfavg=0.;ieq=wp.sttEles[wp.memWGa*i+j]/10;isideq=wp.sttEles[wp.memWGa*i+j]-10*ieq;
   for(k=0;k<4;k++){xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+0];
					yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+1];
					zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+2];
				   }
   xpatch=xpatch+xfavg/4.;ypatch=ypatch+yfavg/4.;zpatch=zpatch+zfavg/4.;
  }
xpatch=xpatch/float(wp.n_curr_sttEl[i]);ypatch=ypatch/float(wp.n_curr_sttEl[i]);zpatch=zpatch/float(wp.n_curr_sttEl[i]);
for(j=0;j<wp.n_curr_sttEl[i];j++)
  {xfavg=yfavg=zfavg=0.;ieq=wp.sttEles[wp.memWGa*i+j]/10;isideq=wp.sttEles[wp.memWGa*i+j]-10*ieq;
   for(k=0;k<4;k++){xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+0];
					yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+1];
					zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+2];
				   }
   dist2=(xpatch-xfavg/4.)*(xpatch-xfavg/4.)+(ypatch-yfavg/4.)*(ypatch-yfavg/4.)+(zpatch-zfavg/4.)*(zpatch-zfavg/4.);
   if(dist2patch>dist2){cen_stt=j;dist2patch=dist2;}// Not used anymore
  }
//		 ie=wp.sttEles[wp.memWGa*i+cen_stt]/10;iside=wp.sttEles[wp.memWGa*i+cen_stt]-10*ie;
//		 if     (iside==0 || iside==2){n1=0;n2=1;n3=5;n4=4;n5=2;n6=3;n7=7;n8=6;}
//		 else if(iside==1 || iside==3){n1=1;n2=2;n3=6;n4=5;n5=3;n6=0;n7=4;n8=7;}
//		 else                         {n1=0;n2=1;n3=2;n4=3;n5=4;n6=5;n7=6;n8=7;}
//		 xlo=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n1]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n2]+0]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n3]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n4]+0]);
//		 ylo=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n1]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n2]+1]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n3]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n4]+1]);
//		 zlo=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n1]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n2]+2]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n3]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n4]+2]);
//		 xup=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n5]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n6]+0]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n7]+0]+base.c1[NDF*base.nop1[MXNPEL*ie+n8]+0]);
//		 yup=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n5]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n6]+1]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n7]+1]+base.c1[NDF*base.nop1[MXNPEL*ie+n8]+1]);
//		 zup=0.25*(base.c1[NDF*base.nop1[MXNPEL*ie+n5]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n6]+2]+
//				   base.c1[NDF*base.nop1[MXNPEL*ie+n7]+2]+base.c1[NDF*base.nop1[MXNPEL*ie+n8]+2]);
//		 dist=sqrt((xup-xlo)*(xup-xlo)+(yup-ylo)*(yup-ylo)+(zup-zlo)*(zup-zlo));
			xup=yup=zup=0.;
			for(ja=0;ja<wp.n_curr_sttEl[i];ja++)
			  {xfavg=yfavg=zfavg=0.;
//			   ieq=wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+ja]/10;isideq=opp_arr8[wp.eles[wp.memWGa*i+wp.n_curr_sttEl[i]*j+ja]-10*ieq];
			   ieq=wp.sttEles[wp.memWGa*i+ja]/10;isideq=opp_arr8[wp.sttEles[wp.memWGa*i+ja]-10*ieq];
			   for(k=0;k<4;k++){xfavg=xfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+0];
								yfavg=yfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+1];
								zfavg=zfavg+base.c1[NDF*base.nop1[MXNPEL*ieq+gdata8[4*isideq+k]]+2];
							   }
			   xup=xup+xfavg/4.;yup=yup+yfavg/4.;zup=zup+zfavg/4.;
			  }
			xup=xup/float(wp.n_curr_sttEl[i]);yup=yup/float(wp.n_curr_sttEl[i]);zup=zup/float(wp.n_curr_sttEl[i]);

			dist=sqrt((xup-xpatch)*(xup-xpatch)+(yup-ypatch)*(yup-ypatch)+(zup-zpatch)*(zup-zpatch));
//			xpatch=xup;ypatch=yup;zpatch=zup;
// Note: In the above the only step is the first (wp.sttEles) in each weld pass (not every slice as in export_VED) EFP 3/16/2012

////              sb.append(" 0.1, " + wpTimes.get(i) + ", 1.0E-7, " + wpTimes.get(i) + "\n");
//		 viewfile<<" 0.1, "<<wp.wpTimes[i]<<", 1.0E-7, "<<wp.wpTimes[i]<<"\n";
		 viewfile<<" 0.1, "<<wp.wpTimes[i]<<", 1.0E-7, "<<dist/wp.speed[i]<<"\n";
		 mirrfile<<" 0.1, "<<wp.wpTimes[i]<<", 1.0E-7, "<<dist/wp.speed[i]<<"\n";
		 tmpfile4<<" 0.1, "<<wp.wpTimes[i]<<", 1.0E-7, "<<dist/wp.speed[i]<<"\n";

//		 viewfile<<"*CONTROLS, PARAMETERS=LINE SEARCH\n";
//		 viewfile<<" 4\n";
//		 viewfile<<"*CONTROLS, PARAMETERS=FIELD, FIELD=DISPLACEMENT\n";
//		 viewfile<<" 0.02, 1.0\n";
//		 viewfile<<"*FIELD, USER\n";
//		 viewfile<<" NDALL, 1.0\n";
////              if(i == 0) {                               // WHAT TO DO ABOUT THIS?
////                  sb.append("*MODEL CHANGE, REMOVE");
////                  for(int j=1; j<wpNames.size(); j++) {
////                      if((j-1)%10 == 0) sb.append("\n ");
////                      sb.append("WP" + (j+1) + ", ");
////                  }
////                  sb.append("\n");
////              }
////              else {
////                  sb.append("*MODEL CHANGE, ADD\n");
////                  sb.append(" WP" + (i+1) + "\n");
////              }
//		 viewfile<<"*NODE PRINT, FREQUENCY=0\n";
////		 viewfile<<"*EL PRINT, FREQUENCY=0\n"; //Correction EFP 4/19/2010
//		 viewfile<<"*EL PRINT, FREQUENCY=10\n";
////              sb.append("*FILE FORMAT, ASCII\n");
////              sb.append("*NODE FILE, FREQUENCY=0\n");
////              sb.append("*EL FILE, FREQUENCY=0\n");

//		 if(i==0)
		 if(iseq==0)
				 {viewfile<<"*CONTROLS, PARAMETERS=LINE SEARCH\n";
				  viewfile<<" 4\n";
				  viewfile<<"*CONTROLS, PARAMETERS=FIELD, FIELD=DISPLACEMENT\n";
				  viewfile<<" 0.02, 1.0\n";
				  viewfile<<"*FIELD, USER\n";
				  viewfile<<" NDALL, 1.0\n";
				  viewfile<<"*NODE PRINT, FREQUENCY=0\n";
				  viewfile<<"*OUTPUT, FIELD, FREQUENCY=10\n";
				  viewfile<<"*NODE OUTPUT,NSET=NDALL\n";
				  viewfile<<"U,NT\n";
				  viewfile<<"*ELEMENT OUTPUT,ELSET=ALLEL\n";
				  viewfile<<"S,SDV\n";
//			      viewfile<<"*EL PRINT, FREQUENCY=0\n"; //Correction EFP 4/19/2010
				  viewfile<<"*EL PRINT, FREQUENCY=10\n";
				  mirrfile<<"*CONTROLS, PARAMETERS=LINE SEARCH\n";
				  mirrfile<<" 4\n";
				  mirrfile<<"*CONTROLS, PARAMETERS=FIELD, FIELD=DISPLACEMENT\n";
				  mirrfile<<" 0.02, 1.0\n";
				  mirrfile<<"*FIELD, USER\n";
				  mirrfile<<" NDALL, 1.0\n";
				  mirrfile<<"*NODE PRINT, FREQUENCY=0\n";
				  mirrfile<<"*OUTPUT, FIELD, FREQUENCY=10\n";
				  mirrfile<<"*NODE OUTPUT,NSET=NDALL\n";
				  mirrfile<<"U,NT\n";
				  mirrfile<<"*ELEMENT OUTPUT,ELSET=ALLEL\n";
				  mirrfile<<"S,SDV\n";
				  mirrfile<<"*EL PRINT, FREQUENCY=10\n";
				  tmpfile4<<"*CONTROLS, PARAMETERS=LINE SEARCH\n";
				  tmpfile4<<" 4\n";
				  tmpfile4<<"*CONTROLS, PARAMETERS=FIELD, FIELD=DISPLACEMENT\n";
				  tmpfile4<<" 0.02, 1.0\n";
				  tmpfile4<<"*FIELD, USER\n";
				  tmpfile4<<" NDALL, 1.0\n";
				  tmpfile4<<"*NODE PRINT, FREQUENCY=0\n";
				  tmpfile4<<"*OUTPUT, FIELD, FREQUENCY=10\n";
				  tmpfile4<<"*NODE OUTPUT,NSET=NDALL\n";
				  tmpfile4<<"U,NT\n";
				  tmpfile4<<"*ELEMENT OUTPUT,ELSET=ALLEL\n";
				  tmpfile4<<"S,SDV\n";
				  tmpfile4<<"*EL PRINT, FREQUENCY=10\n";
				 }
		 viewfile<<"*END STEP\n";mirrfile<<"*END STEP\n";tmpfile4<<"*END STEP\n";
//              totalTime += Double.parseDouble((String)wpTimes.get(i));
		 totalTime += double(wp.wpTimes[i]);

		 if(wp.timeInterval[i]>0.)
		   {sid ++;
			viewfile<<"********** Step "<<sid<<" : Cooling of Weld Pass "<<i+1<<" - "<<wp.name[i].t_str()<<" **********\n";
			mirrfile<<"********** Step "<<sid<<" : Cooling of Weld Pass "<<i+1<<" - "<<wp.name[i].t_str()<<" **********\n";
			tmpfile4<<"********** Step "<<sid<<" : Cooling of Weld Pass "<<i+1<<" - "<<wp.name[i].t_str()<<" **********\n";
//////  Use following with umat34
//			viewfile<<"*STEP, INC=1000\n";
////
////  Use following with umat35
////			viewfile<<"*STEP, INC=1000, NLGEOM=YES\n";

			if(wp.mcr[i]==6){viewfile<<"*STEP, INC=1000, NLGEOM=YES\n";// This uses wp.mcr[] assigned from wms.mcr[]
							 mirrfile<<"*STEP, INC=1000, NLGEOM=YES\n";
							 tmpfile4<<"*STEP, INC=1000, NLGEOM=YES\n";
							}
			else {viewfile<<"*STEP, INC=1000\n";mirrfile<<"*STEP, INC=1000\n";tmpfile4<<"*STEP, INC=1000\n";
				 }
			viewfile<<"*STATIC\n";mirrfile<<"*STATIC\n";tmpfile4<<"*STATIC\n";
//Per Bud's request, remove the following NG's 0.9 x last step (which was used to avoid exceeding primordial Abaqus' bounds) EFP 5/05/2013
//			if(iseq==wp.nWeldPass-1)viewfile<<" 0.1, "<<0.9*wp.timeInterval[i]<<", 1.0E-7, "<<0.9*wp.timeInterval[i]<<"\n";
//			else                 viewfile<<" 0.1, "<<wp.timeInterval[i]<<", 1.0E-7, "<<wp.timeInterval[i]<<"\n";
			viewfile<<" 0.1, "<<wp.timeInterval[i]<<", 1.0E-7, "<<wp.timeInterval[i]<<"\n";
			mirrfile<<" 0.1, "<<wp.timeInterval[i]<<", 1.0E-7, "<<wp.timeInterval[i]<<"\n";
			tmpfile4<<" 0.1, "<<wp.timeInterval[i]<<", 1.0E-7, "<<wp.timeInterval[i]<<"\n";
//			if(i==0) // From export_ABA_NEW()
//			  {viewfile<<"*CONTROLS, PARAMETERS=LINE SEARCH\n";
//			   viewfile<<" 4\n";
//			   viewfile<<"*CONTROLS, PARAMETERS=FIELD, FIELD=DISPLACEMENT\n";
//			   viewfile<<" 0.02, 1.0\n";
//			   viewfile<<"*FIELD, USER\n";
//			   viewfile<<" NDALL, 1.0\n";
//			   viewfile<<"*NODE PRINT, FREQUENCY=0\n";
//////            viewfile<<"*EL PRINT, FREQUENCY=0\n";
////////                  sb.append("*FILE FORMAT, ASCII\n");
////////                  sb.append("*NODE FILE, FREQUENCY=0\n");
////////                  sb.append("*EL FILE, FREQUENCY=0\n");
//
////			   viewfile<<"*OUTPUT, FIELD, FREQUENCY=9999\n"; //Correction EFP 4/19/2010
//			   viewfile<<"*OUTPUT, FIELD, FREQUENCY=10\n";
//			   viewfile<<"*NODE OUTPUT,NSET=NDALL\n";
//			   viewfile<<"U,NT\n";
//			   viewfile<<"*ELEMENT OUTPUT,ELSET=ALLEL\n";
//			   viewfile<<"S,SDV\n";
////			   viewfile<<"*EL PRINT, FREQUENCY=0\n"; //Correction EFP 4/19/2010
//			   viewfile<<"*EL PRINT, FREQUENCY=10\n";
//			  }
			viewfile<<"*END STEP\n";mirrfile<<"*END STEP\n";tmpfile4<<"*END STEP\n";
			totalTime += wp.timeInterval[i];
		   }
												 }
								 }
//          sid ++;
//          sb.append("********** Step " + sid + " : Final Cooling Step (10 secs) " + "**********\n");
////
////  Use following with umat34
//              sb.append("*STEP, INC=1000\n");
////
////  Use following with umat35
////              sb.append("*STEP, INC=1000, NLGEOM=YES\n");
//          sb.append("*STATIC\n");
//          sb.append(" 1.0, 10.0, 1.0E-7, 10.0\n");
//          sb.append("*CONTROLS, PARAMETERS=LINE SEARCH\n");
//          sb.append(" 4\n");
//          sb.append("*CONTROLS, PARAMETERS=FIELD, FIELD=DISPLACEMENT\n");
//          sb.append(" 0.02, 1.0\n");
//          sb.append("*TEMPERATURE\n");
//          sb.append(" NDALL," + wp.troom + "\n");
//          sb.append("*NODE PRINT, FREQUENCY=0\n");
//          sb.append("*EL PRINT, FREQUENCY=0\n");
////          sb.append("*FILE FORMAT, ASCII\n");
////          sb.append("*NODE FILE, FREQUENCY=0\n");
////          sb.append("*EL FILE, FREQUENCY=0\n");
//          sb.append("*END STEP\n");
//          sb.append("***********************************************************\n");
//          totalTime += 10.0d;

//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 viewfile.close();mirrfile.close();
//aaaaaaaaaaaaaa
//aaaaaaaaaaaaaaaa
//aaaaaaaaaaaaaaaaaa
   tmpfile4.close();
   system("copy omnibusAba.inp+scratchAba2.tmp+scratchAba3.tmp+scratchAba4.tmp");
   system("del scratchAba2.tmp");system("del scratchAba3.tmp");system("del scratchAba4.tmp");
  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unable to open output files",L"Terminate export_ABA()",MB_OK);exit(0);}
//bbbbbbbbbbbbbbbbbb
//bbbbbbbbbbbbbbbb
//bbbbbbbbbbbbbb
}

//---------------------------------------------------------------------------
//void TForm1::export_UFIELD() // Write ABAQUS3.5-format UFIELD FORTRAN file. EFP 3/2/2010
void TForm1::export_UFIELD(char gVFTnameStem[],char ABAdir[],float ttimesave2) // Write ABAQUS3.5-format UFIELD FORTRAN file. EFP 3/2/2010
{int k=0,steptotal=0;
 long i=0,j=0,toteles=0,totnodes=0
 //,totsttEles=0
 ;
// float test2=0.,ttimesave2=15163.195-10.; // Where does ttimesave2 come from globally???
 float test2=0.;
 char extensChar[]="_ufield.f";
// char extensChar[]="_ufield.txt";
 char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;
// ofstream viewfile("TESTufield35temp.txt");
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
//	  totnodes=0;for(k=0;k<base.npoin;k++)if(base.node_map[k]>0)totnodes++;
	  totnodes=base.npoin;  // EFP 4/03/2011

	  steptotal=0;
	  for(k=0;k<wp.nWeldPass;k++)
		{if(wp.hp[k]==0)
		   {toteles=0;
//		   totsttEles=0;
//			for(j=base.nelt*k;j<base.nelt*(k+1);j++){if(wp.eles[j]>=0)toteles++;
			for(j=wp.memWGa*k;j<wp.memWGa*(k+1);j++){if(wp.eles[j]>=0)toteles++;
													 else break;
													}
//			for(j=base.nelt*k;j<base.nelt*(k+1);j++){if(wp.sttEles[j]>=0)totsttEles++;
//													 else break;
//													}
//			steptotal=steptotal+wp.stepInterval[k]+toteles/totsttEles;
			steptotal=steptotal+wp.stepInterval[k]+toteles/wp.n_curr_sttEl[k];
		   }
		 else steptotal=steptotal+wp.stepInterval[k]+(wp.nsegs[k]-1)*10 +6;
		}
	  steptotal++;
	  steptotal++;
	  ttimesave2=ttimesave2+10.;
	  test2=ttimesave2; //Cats ass coding here.....
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMStart
viewfile<<"      subroutine uexternaldb(lop,lrestart,time,dtime,kstep,kinc)\n";
viewfile<<"      implicit real*8 (a-h,o-z)\n";
viewfile<<"c\n";
viewfile<<"c\n";
viewfile<<"      dimension time(2)\n";
viewfile<<"c\n";
viewfile<<"      character*80 pssname,matname\n";
viewfile<<"      common /kfname/matname(10),pssname,kmatfile\n";
viewfile<<"      if(kmatfile.ne.-1) then\n";
for(i=0;i<wms.nMatPropSet;i++)
  {viewfile<<"      matname("<<i+1<<")='"<<ABAdir<<"\n";
//   viewfile<<"     $"<<ExtractFileName(wms.matFileName[i].c_str()).c_str()<<"'\n";
//   viewfile<<"     $"<<ExtractFileName(wms.matFileName[i].c_str()).t_str()<<"'\n";
   viewfile<<"     $"<<ExtractFileName(wms.matFileName[i]).t_str()<<"'\n";
  }

////viewfile<<"	  @@@MATFILENAMES1@@@\n";
////viewfile<<"	 @@@MATCONT1@@@\n";
////viewfile<<"	  @@@MATFILENAMES2@@@\n";
////viewfile<<"	 @@@MATCONT2@@@\n";
////viewfile<<"	  @@@MATFILENAMES3@@@\n";
////viewfile<<"	 @@@MATCONT3@@@\n";
////viewfile<<"	  @@@MATFILENAMES4@@@\n";
////viewfile<<"	 @@@MATCONT4@@@\n";
////viewfile<<"	  @@@MATFILENAMES5@@@\n";
////viewfile<<"	 @@@MATCONT5@@@\n";
////viewfile<<"	  @@@MATFILENAMES6@@@\n";
////viewfile<<"	 @@@MATCONT6@@@\n";
////viewfile<<"	  @@@MATFILENAMES7@@@\n";
////viewfile<<"	 @@@MATCONT7@@@\n";
////viewfile<<"	  @@@MATFILENAMES8@@@\n";
////viewfile<<"	 @@@MATCONT8@@@\n";
////viewfile<<"	  @@@MATFILENAMES9@@@\n";
////viewfile<<"	 @@@MATCONT9@@@\n";
////viewfile<<"	  @@@MATFILENAMES10@@@\n";
////viewfile<<"	 @@@MATCONT10@@@\n";
////viewfile<<"	  @@@VEDFILENAME@@@\n";
////viewfile<<"	 @@@VEDCONT@@@\n";

//viewfile<<"      matname(1)='/home/bbrust/baseline/1e650new.dat'\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"\n";
//viewfile<<"      pssname='testingVDT_VED.dat'\n";

//viewfile<<"      pssname='"<<gVFTnameStem<<"_VED.dat'\n";
////viewfile<<"      pssname='"<<ABAdir<<"\"<<gVFTnameStem<<"_VED.dat'\n";
viewfile<<"      pssname='"<<ABAdir<<"\n";
viewfile<<"     $"<<gVFTnameStem<<"_VED.dat'\n";

//viewfile<<"\n";
viewfile<<"      kmatfile=-1\n";
viewfile<<"      endif\n";
viewfile<<"      return\n";
viewfile<<"      end\n";
viewfile<<"c\n";
viewfile<<"      subroutine ufield(field,kfield,msecpt,kstep,kinc,time,node,\n";
viewfile<<"     $          coords,temp,dtemp,nfield)\n";
viewfile<<"c\n";
viewfile<<"      implicit real*8 (a-h,o-z)\n";
viewfile<<"      parameter (nprecd=2)\n";
viewfile<<"c-------------------------------------------------------------\n";
viewfile<<"c	NNUM-total nodes\n";
viewfile<<"c	NTMAX-Maximum time step\n";
viewfile<<"c	tcutoff-cut off temperature\n";
viewfile<<"c-------------useful to restart a analysis---------------------\n";
viewfile<<"c	ksstep-start to read in temperature at step 'ksstep'\n";
viewfile<<"c	ksinc-start to reas in temperature at increment 'ksinc'\n";
viewfile<<"c---------------------------------------------------------------\n";
viewfile<<"c\n";
viewfile<<"      dimension field(msecpt,nfield),time(2),coords(3),temp(msecpt),\n";
viewfile<<"     $dtemp(msecpt)\n";
viewfile<<"      character*80 tempfile,nodefile\n";
////viewfile<<"      parameter (NNUM=@@@NNUM@@@,\n";
//viewfile<<"      parameter (NNUM="<<base.npoin<<",\n";
viewfile<<"      parameter (NNUM="<<totnodes<<",\n"; //Correction EFP 10/14/2010
//viewfile<<"     $NTMAX=@@@NTMAX@@@,\n";
viewfile<<"     $NTMAX="<<steptotal<<",\n";
//viewfile<<"     $NSPT=@@@NSPT@@@,\n";
viewfile<<"     $NSPT="<<1<<",\n";
//viewfile<<"     $TCUTOFF=@@@TCUTOFF@@@,\n";
viewfile<<"     $TCUTOFF="<<wp.tmelt[0]<<",\n";
//viewfile<<"     $TIMEMAX=@@@TIMEMAX@@@,\n";
viewfile<<"     $TIMEMAX="<<test2<<",\n";
//viewfile<<"     $PREHEATTEMP=@@@PREHEATTEMP@@@,\n";
viewfile<<"     $PREHEATTEMP="<<wp.tcuth[0]<<",\n";
//viewfile<<"     $ROOMTEMP=@@@ROOMTEMP@@@,\n";
viewfile<<"     $ROOMTEMP="<<wp.troom[0]<<",\n";
viewfile<<"     $ksstep=1,ksinc=1)\n";
viewfile<<"      common /ktempfield/tt(2),jd(NNUM),tempjd,nt\n";
viewfile<<"      common /z1/ ztemp(NSPT)\n";
viewfile<<"      common /tk1/ tempdatak1(NNUM,NSPT)\n";
viewfile<<"      common /tk/  tempdatak(NNUM,NSPT)\n";
viewfile<<"      common /tk2/timecurrent\n";
viewfile<<"      common /tk3/ires\n";
viewfile<<"c\n";
//viewfile<<"	  @@@CTSP_TEMPERATURE.OUT@@@\n";
//viewfile<<"	 @@@CTSPCONT@@@\n";
//viewfile<<"	  @@@NODE_FILE@@@\n";
//viewfile<<"	 @@@NODECONT@@@\n";

//////viewfile<<"      tempfile='/home/bbrust/baseline/baseline_CTSP_temp.out'\n";
//viewfile<<"      tempfile='"<<gVFTnameStem<<"_CTSP_temp.out'\n";
////viewfile<<"      tempfile='"<<ABAdir<<"\"<<gVFTnameStem<<"_CTSP_temp.out'\n";
viewfile<<"      tempfile='"<<ABAdir<<"\n";
viewfile<<"     $"<<gVFTnameStem<<"_CTSP_temp.out'\n";
viewfile<<"\n";
//////viewfile<<"      nodefile='/home/bbrust/baseline/baseline_node.inp'\n";
//viewfile<<"      nodefile='"<<gVFTnameStem<<"_node.inp'\n";
////viewfile<<"      nodefile='"<<ABAdir<<"\"<<gVFTnameStem<<"_node.inp'\n";
viewfile<<"      nodefile='"<<ABAdir<<"\n";
viewfile<<"     $"<<gVFTnameStem<<"_node.inp'\n";
viewfile<<"\n";
viewfile<<"c\n";
viewfile<<"      if (ires .ne. -1) then\n";
viewfile<<"      open(17,file=nodefile)\n";
viewfile<<"      do 12 i=1,NNUM\n";
viewfile<<"        read(17,*) ndp,zx,zy,zz\n";
viewfile<<"12      jd(i)=ndp\n";
viewfile<<"      close(17)\n";
viewfile<<"      ires=-1\n";
viewfile<<"      end if\n";
viewfile<<"      IF(time(2).GT.TIMEMAX) then\n";
viewfile<<"      do 999 i=1,msecpt\n";
viewfile<<"        field(i,1)=temp(i)\n";
viewfile<<"999     continue\n";
viewfile<<"      return\n";
viewfile<<"      end if\n";
viewfile<<"c\n";
viewfile<<"      if(kstep.eq.ksstep.and.kinc.eq.ksinc .and. tempjd .ne. -1) then\n";
viewfile<<"      do 10 i=1,NNUM\n";
viewfile<<"        do 10 j=1,NSPT\n";
viewfile<<"          tempdatak(i,j)=PREHEATTEMP\n";
viewfile<<"          tempdatak1(i,j)=PREHEATTEMP\n";
viewfile<<"10        continue\n";
viewfile<<"      tt(1)=0.0\n";
viewfile<<"      tt(2)=0.0\n";
viewfile<<"      end if\n";
viewfile<<"c\n";
viewfile<<"c     check if timecurrent = time(2)\n";
viewfile<<"c\n";
viewfile<<"      if(timecurrent .eq. time(2)) then\n";
viewfile<<"      else\n";
viewfile<<"        timecurrent=time(2)\n";
viewfile<<"      open(16,file=tempfile)\n";
viewfile<<"      tempjd=-1\n";
viewfile<<"C\n";
viewfile<<"C     CHECK IF TIME(2) IS BETWEEN TT(1) AND TT(2)\n";
viewfile<<"C\n";
viewfile<<"887     continue\n";
viewfile<<"      if(time(2) .ge. tt(1) .and. time(2) .le. tt(2)) then\n";
viewfile<<"      else\n";
viewfile<<"        tt(1)=tt(2)\n";
viewfile<<"      do 55 i=1,NNUM\n";
viewfile<<"        do 55 j=1,NSPT\n";
viewfile<<"          tempdatak1(i,j)=tempdatak(i,j)\n";
viewfile<<"          tempdatak(i,j)=PREHEATTEMP\n";
viewfile<<"55        continue\n";
viewfile<<"886   continue\n";
viewfile<<"      read(16,*,end=40) tt(2),numk\n";
viewfile<<"      if(tt(2).eq.0.0.and.numk.eq.0) goto 886\n";
viewfile<<"      if(numk .eq. 0)go to 800\n";
viewfile<<"      do 31 m=1,numk\n";
viewfile<<"        read(16,*,end=40) ndp,(ztemp(j),j=1,NSPT)\n";
viewfile<<"c\n";
viewfile<<"c     find i\n";
viewfile<<"c\n";
viewfile<<"      do 333 i=1,NNUM\n";
viewfile<<"        ndp2=jd(i)\n";
viewfile<<"        if (ndp2 .ne. ndp) then\n";
viewfile<<"        else\n";
viewfile<<"          ii=i\n";
viewfile<<"          go to 334\n";
viewfile<<"        end if\n";
viewfile<<"333     continue\n";
viewfile<<"334   continue\n";
viewfile<<"      i=ii\n";
viewfile<<"      do 26 j=1,NSPT\n";
viewfile<<"        tempdatak(i,j)=ztemp(j)\n";
viewfile<<"26      continue\n";
viewfile<<"31    continue\n";
viewfile<<"      go to 801\n";
viewfile<<"800   continue\n";
viewfile<<"      do 32 i=1,NNUM\n";
viewfile<<"        do 27 j=1,NSPT\n";
viewfile<<"          tempdatak(i,j)=PREHEATTEMP\n";
viewfile<<"27        continue\n";
viewfile<<"32      continue\n";
viewfile<<"801   continue\n";
viewfile<<"      goto 887\n";
viewfile<<"      end if\n";
viewfile<<"40    continue\n";
viewfile<<"      close(16)\n";
viewfile<<"      end if\n";
viewfile<<"c\n";
viewfile<<"c     find i\n";
viewfile<<"c\n";
viewfile<<"      do 335 i=1,NNUM\n";
viewfile<<"        ndp2=jd(i)\n";
viewfile<<"        if (ndp2 .ne. node) then\n";
viewfile<<"        else\n";
viewfile<<"          ii=i\n";
viewfile<<"        go to 336\n";
viewfile<<"        end if\n";
viewfile<<"335     continue\n";
viewfile<<"336   continue\n";
viewfile<<"      if(ndp2.eq.node) go to 350\n";
viewfile<<"      do 349 iii=1,msecpt\n";
viewfile<<"349     temp(iii)=PREHEATTEMP\n";
viewfile<<"      return\n";
viewfile<<"350   i=ii\n";
viewfile<<"      fac=(time(2)-tt(1))/(tt(2)-tt(1))\n";
viewfile<<"      do 70 j=1,msecpt\n";
viewfile<<"       field(j,1)=tempdatak1(i,j)*(1-fac)+tempdatak(i,j)*fac\n";
viewfile<<"       if(field(j,1).ge.tcutoff) field(j,1)=tcutoff\n";
viewfile<<"       temp(j)=field(j,1)\n";
viewfile<<"70     continue\n";
viewfile<<"c\n";
viewfile<<"      return\n";
viewfile<<"      end\n";
viewfile<<"cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n";
//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMEnd
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 viewfile.close();
}
//---------------------------------------------------------------------------
/*
   protected void export_UFIELD() {
	  try {
		  PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(frame.userDir + "/template/ufield35temp.txt")));
		  StringBuffer sb = new StringBuffer();
		  wpNames = new Vector();
		  //wpTimes = new Vector();
		  for(Enumeration enum = frame.wpTable.keys(); enum.hasMoreElements();)
				wpNames.add((String)enum.nextElement());
		  ordWP(wpNames);
		  WeldPass wp = (WeldPass)frame.wpTable.get((String)wpNames.get(0));
		  steptotal = 0;
		  for(int k=0; k<wpNames.size(); k++) {
			  wp = (WeldPass)frame.wpTable.get((String)wpNames.get(k));
			  if (wp.hp==0){
			  steptotal += wp.stepInterval + wp.eles.size()/wp.sttEles.size();
			  }
			  if (wp.hp==1){
			  steptotal += wp.stepInterval + (wp.nsegs-1)*10 + 6;
			  }
			  }
			  steptotal++;
			  steptotal++;
			  ttimesave2=ttimesave2+10.0f;
		  File file = new File(frame.userDir + "/template/ufield35_template.txt");
		  FileInputStream fis = new FileInputStream(file);
		  long fileSize = file.length();
		  byte[] fileBytes = new byte[(int)fileSize];
		  fis.read(fileBytes);
		  fis.close();
		  String fileContent = new String(fileBytes);
		  fileContent = substituted(fileContent, "NNUM", frame.fem.nodes.size() + "");
		  fileContent = substituted(fileContent, "NTMAX", steptotal + "");
		  fileContent = substituted(fileContent, "NSPT", "1" + "");
		  fileContent = substituted(fileContent, "TCUTOFF", wp.tmelt + "");
		  fileContent = substituted(fileContent, "ROOMTEMP", wp.troom + "");
		  fileContent = substituted(fileContent, "PREHEATTEMP", wp.tcuth + "");
		  test=""+ttimesave2;
		  int testlength=test.length();
		  for (int kkk=0; kkk<testlength;kkk++){
		  if (test.charAt(kkk)=='.'){
		  int jjj=testlength-kkk-1;
		  if (jjj > 3){
		  jjj=3;
		  }
		  test2=test.substring(0,kkk+jjj+1);
		  }
		  }
		  fileContent = substituted(fileContent, "TIMEMAX",  test2 + "");
		  String ctspt=null;
		  ctspt="tempfile='"+ abaDir +  wsiAlias + "_CTSP_temp.out'";
		  int m = ctspt.length();
		  if (m+6 < 73){
		  fileContent = substituted(fileContent, "CTSPCONT", "");
		  fileContent = substituted(fileContent, "CTSP_TEMPERATURE.OUT", ctspt);
		  }
		  if (m+6 > 72){
		  String ctsptc=null;
		  ctsptc="$"+ ctspt.substring(66,m);
		  fileContent = substituted(fileContent, "CTSPCONT", ctsptc);
		  fileContent = substituted(fileContent, "CTSP_TEMPERATURE.OUT", ctspt.substring(0,66));
		  }
		  String nodef=null;
		  nodef="nodefile='"+ abaDir + wsiAlias + "_node.inp'";
		  int n = nodef.length();
		  if (n+6 < 73){
		  fileContent = substituted(fileContent, "NODECONT", "");
		  fileContent = substituted(fileContent, "NODE_FILE", nodef);
		  }
		  if (n+6 > 72){
		  String nodefc=null;
		  nodefc="$"+ nodef.substring(66,n);
		  fileContent = substituted(fileContent, "NODECONT", nodefc);
		  fileContent = substituted(fileContent, "NODE_FILE", nodef.substring(0,66));
		  }
		  WeldMatSet wms;
		  String matf=null;
		  String matfc=null;
		  int o=0;
		  for(int i=0; i<frame.matList.size(); i++) {
		  StringBuffer matnames = new StringBuffer();
			  wms = (WeldMatSet)frame.matTable.get((String)frame.matList.get(i));
			  int k = wms.matFileName.lastIndexOf("\\");
			  matnames.append("matname(" + (i+1) + ")='" + abaDir + wms.matFileName.substring(k+1) + "'");
		  matf=matnames.toString();
		  o = matf.length();
		  if (o+6 < 73){
		  fileContent = substituted(fileContent, "MATCONT"+(i+1), "");
		  fileContent = substituted(fileContent, "MATFILENAMES"+(i+1), matf);
		  }
		  if (o+6 > 72){
		  matfc="$"+ matf.substring(66,o);
		  fileContent = substituted(fileContent, "MATCONT"+(i+1), matfc);
		  fileContent = substituted(fileContent, "MATFILENAMES"+(i+1), matf.substring(0,66));
		  }
		  }
		  for(int i=frame.matList.size(); i<10; i++) {
		  fileContent = substituted(fileContent, "MATCONT"+(i+1), "");
		  fileContent = substituted(fileContent, "MATFILENAMES"+(i+1), "");
		  }
		  int k = vedFile.toString().lastIndexOf("\\");
		  String ved=null;
		  ved = "pssname='" + abaDir + vedFile.toString().substring(k+1) + "'";
		  int l = ved.length();
		  if (l+6 < 73){
		  fileContent = substituted(fileContent, "VEDCONT", "");
		  fileContent = substituted(fileContent, "VEDFILENAME", ved);
		  }
		  if (l+6 > 72){
		  String vedc=null;
		  vedc="$"+ ved.substring(66,l);
		  fileContent = substituted(fileContent, "VEDCONT", vedc);
		  fileContent = substituted(fileContent, "VEDFILENAME", ved.substring(0,66));
		  }
		  sb.append(fileContent);
		  pw.print(sb.toString());
		  pw.close();
	  RandomAccessFile f=new RandomAccessFile(frame.userDir + "/template/ufield35temp.txt", "r");
	  String s = null;
	  if (ufieldFile.exists())
	  {
	  ufieldFile.delete();
	  }
	  RandomAccessFile pw1=new RandomAccessFile(ufieldFile, "rw");
	  s=f.readLine();

	 while(s != null)
	 {
	  if(s.length()!=5 && s.length() !=6 )
	  {
	  pw1.writeBytes(s+"\n");
	  }
	  s=f.readLine();
	  if (s.length()==78)
	  {
	  f.close();
	  pw1.close();
	  s=null;
	  }
	 }
	  }
	  catch(Exception e)
	  {
	  System.out.println(e);}
	}
*/
//---------------------------------------------------------------------------
void TForm1::export_ABA_BC(char gVFTnameStem[]) // Write ABAQUS-format ASCII nodal BC
{int ifpre[NDF];long i=0,ir=0,ic=0,icount=0;
 char extensChar[]="_bc.inp";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
 icount=0;for(i=0;i<base.npoin;i++)if(base.nofix[2*i+1])icount++;
 if(icount){
 StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
 ofstream viewfile(fnNeed);delete [] fnNeed;
 viewfile<<"*BOUNDARY,OP=NEW\n";
// viewfile.setf(ios::scientific);
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//// try {
//	  viewfile.precision(6);
//	  for(i=0;i<base.npoin;i++)viewfile<<base.node_map[i]+1<<","<<base.c1[NDF*i]<<","<<base.c1[NDF*i+1]<<","<<base.c1[NDF*i+2]<<"\n";

 for(ir=0;ir<base.npoin;ir++){
if(base.nofix[2*ir+1]==1 || base.nofix[2*ir+1]==4 || base.nofix[2*ir+1]==5 || base.nofix[2*ir+1]==7)ifpre[0]=1;else ifpre[0]=0;
if(base.nofix[2*ir+1]==2 || base.nofix[2*ir+1]==4 || base.nofix[2*ir+1]==6 || base.nofix[2*ir+1]==7)ifpre[1]=1;else ifpre[1]=0;
if(base.nofix[2*ir+1]==3 || base.nofix[2*ir+1]==5 || base.nofix[2*ir+1]==6 || base.nofix[2*ir+1]==7)ifpre[2]=1;else ifpre[2]=0;
for(ic=0;ic<NDF;ic++){if(ifpre[ic])

//viewfile<<base.node_map[ir]+1<<","<<ic+1<<"\n";
if(base.node_map[ir]+1<100000)viewfile<<setw(5)<<base.node_map[ir]+1<<","<<setw(4)<<ic+1<<"\n";
else if(base.node_map[ir]+1<1000000)viewfile<<setw(6)<<base.node_map[ir]+1<<","<<setw(4)<<ic+1<<"\n";
else if(base.node_map[ir]+1<10000000)viewfile<<setw(7)<<base.node_map[ir]+1<<","<<setw(4)<<ic+1<<"\n";
else viewfile<<setw(8)<<base.node_map[ir]+1<<","<<setw(4)<<ic+1<<"\n";
					 }
							 }
////	 }
////__finally {
Screen->Cursor=Save_Cursor;
////}
 viewfile.close();
		   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No BCs found",L"Notice",MB_OK);}
}




//---------------------------------------------------------------------------
void TForm1::export_CTSP_INPUTp(char gVFTnameStem[]) //Version with mirror file  EFP 3/26/2011
{long i=0,k=0,icount=0,steptotal=0,sttEles_size=0,eles_size=0,iseq=0,mstep=0,medge=0,mseg=0,maxelp=0,
	  ipp=0,in=0,ie1=0,iside1=0,is1=0,j=0,lastStepIntv=0; //This line junk EFP 6/16/2012
 float timeWeld=0.,lasttimerec=0.,overlap=3600.;int solidshellsw=0; //0=solid, 1=shell  EFP 8/19/2012
// char extensChar[]="_CTSP_input.in";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
// ofstream viewfile(fnNeed);delete [] fnNeed;
 ofstream mirrorfile("input.in");
// viewfile.setf(ios::scientific);
 mirrorfile.setf(ios::scientific);

 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
	  medge=mseg=icount=maxelp=0; //Corrected EFP 5/12/2010
		 icount++; //Bud's correction  EFP 12/13/2012
	  for(k=0;k<wp.nWeldPass;k++)
		{
//		 icount++;
		 for(i=0;i<wp.memWGa;i++)if(wp.eles[wp.memWGa*k+i]<0)break;
		 icount=icount+i/wp.n_curr_sttEl[k] +wp.stepInterval[k]; //Corrected EFP 5/12/2010
		 if(maxelp<i)maxelp=i; //EFP 3/08/2012
		}
	  if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #time step data",MB_OK);exit(0);}
	  mstep=icount;
//	  viewfile<<"1, "<<icount<<"\n";
	  mirrorfile<<"1, "<<icount<<"\n";
//	  viewfile<<wms.cond[0]<<", "<<wms.heat[0]<<", "<<wms.den[0]<<", "<<wp.eff[0]<<", "<<wp.nWeldPass<<", 0.0\n";//Extra 0 at end (i.e. new format) BB 4/16/2010
	  mirrorfile<<wms.cond[0]<<", "<<wms.heat[0]<<", "<<wms.den[0]<<", "<<wp.eff[0]<<", "<<wp.nWeldPass<<", 0.0\n";//Extra 0 at end (i.e. new format) BB 4/16/2010

//// No Preheat Temperature Version
//// Next Line otherwise delete
////          sb.append(wp.troom + ", " + wp.tmelt  + ", " + wp.tcutl + ", " + wp.source + ", 1, " + wp.maxiHeatStep + ", " + wp.miniHeatStep + "\n");
//// tcuth is used for Preheat Temperature
//// Activate the next line for writing Preheat Temperature
////          sb.append(wp.tcuth + ", "+ wp.troom + ", " + wp.tmelt  + ", " + wp.tcutl + ", " + wp.source + ", 1, " + wp.maxiHeatStep + ", " + wp.miniHeatStep + "\n");

//	  viewfile<<wp.tcuth[0]<<", "<<wp.troom[0]<<", "<<wp.tmelt[0]<<", "<<wp.tcutl[0]<<", "<<wp.source[0]<<", 1, "<<wp.maxiHeatStep[0]<<", "<<wp.miniHeatStep[0]<<"\n";
	  mirrorfile<<wp.tcuth[0]<<", "<<wp.troom[0]<<", "<<wp.tmelt[0]<<", "<<wp.tcutl[0]<<", "<<wp.source[0]<<", 1, "<<wp.maxiHeatStep[0]<<", "<<wp.miniHeatStep[0]<<"\n";
	  steptotal=0;timeWeld=0.;
// boolFlags[]: showFlag=1st digit,circFlag=2nd,edgeFlag=3rd,merge=4th,girthFlag=5th

	  for(iseq=0;iseq<wp.nWeldPass;iseq++)
		{for(k=0;k<wp.nWeldPass;k++)if(iseq+1==wp.seqNum[k])break;
//		 viewfile<<"***** Weld Pass "<<wp.name[k].t_str()<<" *****\n";
		 mirrorfile<<"***** Weld Pass "<<wp.name[k].t_str()<<" *****\n";
		 int circFlag=(wp.boolFlags[k]-100*(wp.boolFlags[k]/100))/10;
		 int edgeFlag=(wp.boolFlags[k]-1000*(wp.boolFlags[k]/1000))/100;
		 int merge=(wp.boolFlags[k]-10000*(wp.boolFlags[k]/10000))/1000;
		 int girthFlag=(wp.boolFlags[k]-100000*(wp.boolFlags[k]/100000))/10000;
		 icount=0;for(i=0;i<4*wp.nWeldPass;i++)if(wp.edgeNodes[i]> -1)icount++;else break;
		 int numEdge = edgeFlag ? icount : 0;
///////////////////////// start EFP 10/12/2011
		 if(numEdge)medge++; //EFP 10/12/2011
///////////////////////// end
		 int cirWeld = circFlag ? wp.shape[k] : 0;
		 int girthWeld=0;
		 if(wp.shape[k]==3){girthWeld=1;cirWeld=0;}
		 if(wp.shape[k]==4){girthWeld=2;cirWeld=0;}
		 int lumpWeld=wp.nsegs[k]; //Lump Pass (1) or Moving Arc (0) Heating Procedure
		 if(wp.hp[k]==0)lumpWeld=0;
//         if(k==0)wp.merge[k]=false;
		 wp.boolFlags[k]=wp.boolFlags[k]-merge*1000; //Zero merge component
		 if(k==0)merge=0;
		 if(merge>0)wp.boolFlags[k]=wp.boolFlags[k]+merge*1000;
		 int mcond=0;if(merge)mcond=1;
//		 viewfile<<"1, "<<wp.type[k] + 1<<", "<<wp.thk1[k]<<", "<<wp.thk2[k]<<", "<<numEdge<<", "<<cirWeld<<", "<<lumpWeld<<", "<<mcond<<", "<<girthWeld<<"\n";
		 mirrorfile<<"1, "<<wp.type[k] + 1<<", "<<wp.thk1[k]<<", "<<wp.thk2[k]<<", "<<numEdge<<", "<<cirWeld<<", "<<lumpWeld<<", "<<mcond<<", "<<girthWeld<<"\n";
//		 viewfile  <<base.node_map[wp.snorm1[4*k+1]]+1<<", "<<base.node_map[wp.snorm1[4*k+2]]+1<<", "<<base.node_map[wp.snorm1[4*k+3]]+1<<", "; // Note that these are the 2/3/4 nodes, not 1
		 mirrorfile<<base.node_map[wp.snorm1[4*k+1]]+1<<", "<<base.node_map[wp.snorm1[4*k+2]]+1<<", "<<base.node_map[wp.snorm1[4*k+3]]+1<<", "; // Note that these are the 2/3/4 nodes, not 1
//		 viewfile  <<base.node_map[wp.snorm2[4*k+1]]+1<<", "<<base.node_map[wp.snorm2[4*k+2]]+1<<", "<<base.node_map[wp.snorm2[4*k+3]]+1<<"\n";
		 mirrorfile<<base.node_map[wp.snorm2[4*k+1]]+1<<", "<<base.node_map[wp.snorm2[4*k+2]]+1<<", "<<base.node_map[wp.snorm2[4*k+3]]+1<<"\n";
//		 viewfile<<wp.timeInterval[k]<<", "<<wp.stepInterval[k]<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<"\n";
		 mirrorfile<<wp.timeInterval[k]<<", "<<wp.stepInterval[k]<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<"\n";
		 icount=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.sttEles[i]> -1)icount++;else break;}
		 if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #weld start elements",MB_OK);exit(0);}
		 sttEles_size=icount;
//		 viewfile<<icount<<"\n";
		 mirrorfile<<icount<<"\n";
//		 for(i=0;i<icount;i++)viewfile  <<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+0]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+1]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+2]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+3]]+1<<"\n";
		 for(i=0;i<icount;i++)mirrorfile<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+0]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+1]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+2]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+3]]+1<<"\n";
		 icount=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.eles[i]> -1)icount++;else break;}
		 if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #weld group elements",MB_OK);exit(0);}
		 eles_size=icount;
/////////////////////////// EFP 10/12/2011
		 if(mseg<icount/wp.n_curr_sttEl[k])mseg=icount/wp.n_curr_sttEl[k];
///////////////////////////
//		 viewfile<<icount;
		 mirrorfile<<icount;
		 for(i=0;i<icount;i++){if(i%10 == 0){//viewfile<<"\n";
											 mirrorfile<<"\n";}
//							   viewfile<<base.el_map[wp.eles[wp.memWGa*k+i]/10] +1; //Corrected EFP 9/10/2010
							   mirrorfile<<base.el_map[wp.eles[wp.memWGa*k+i]/10] +1; //Corrected EFP 9/10/2010
							   if(i%10 != 9 && i != icount-1){//viewfile<<", ";
															  mirrorfile<<", ";}
							  }
//		 viewfile<<"\n";
		 mirrorfile<<"\n";
		 if(wp.hp[k]==0)steptotal += wp.stepInterval[k]+eles_size/sttEles_size;
		 else if(wp.hp[k]==1)steptotal += wp.stepInterval[k]+(wp.nsegs[k]-1)*5+ (wp.nsegs[k])*20 ;

//cccccccccccccccc start [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
		 timeWeld=timeWeld+wp.timeInterval[k]+wp.lend[k]/wp.speed[k];
//cccccccccccccccc end
//		 for(i=0;i<numEdge;i++)viewfile  <<base.node_map[wp.edgeNodes[4*k+i]]+1<<"\n"; //Edge Effect (Correction EFP 4/09/2011
		 for(i=0;i<numEdge;i++)mirrorfile<<base.node_map[wp.edgeNodes[4*k+i]]+1<<"\n"; //Edge Effect (Correction EFP 4/09/2011
//Circular Weld
		 if(circFlag){for(i=0;i<3;i++){
//									   viewfile  <<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
									   mirrorfile<<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
									   if(i<2){//viewfile<<", ";
											   mirrorfile<<", ";}
									  }
//					  viewfile<<"\n";
					  mirrorfile<<"\n";
					 }
//Girth Weld
		 if(girthFlag){for(i=0;i<3;i++){
//										viewfile  <<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
										mirrorfile<<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
										if(i<2){//viewfile<<", ";
												mirrorfile<<", ";}
									   }
//					   viewfile<<"\n";
					   mirrorfile<<"\n";
					  }
		 lasttimerec=wp.timeInterval[k]; //EFP 8/192012
		 lastStepIntv=wp.stepInterval[k]; //EFP 8/192012
		}
//	  viewfile<<"-1\n";
	  mirrorfile<<"-1\n";
////        istep1,steptotal  - this version writes NTMAX (ufield.f) for istep2
////        istep1 is always 1
////
//              steptotal++;
//          pw.print("1, " + steptotal + "\n");
////
////        istep1,istep2  - this version writes a large value for istep2
////
////          pw.print("1,5000\n");
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
 //viewfile.close();
 mirrorfile.close();

 //char extensChar1[]="_CTSP_param.in";char *fnNeed1=new char[strlen(gVFTnameStem)+strlen(extensChar1)+1];
 //StringCchCopy(fnNeed1,strlen(gVFTnameStem)+strlen(extensChar1)+1,gVFTnameStem);StringCchCat(fnNeed1,strlen(gVFTnameStem)+strlen(extensChar1)+1,extensChar1);
 //ofstream view1file(fnNeed1);delete [] fnNeed1;
 ofstream mirror1file("param.in");

 k=0;for(i=0;i<wp.nWeldPass;i++)if(k<wp.n_curr_sttEl[i])k=wp.n_curr_sttEl[i]; //Moved up here per new EK format  EFP 6/26/2012
// view1file<<mstep<<"\n";
 mirror1file<<mstep<<"\n"; //mstep= #timesteps
 if(mseg<2)mseg=2; //EK directive  12/22/2011
// view1file<<mseg<<"\n";
 mirror1file<<mseg<<"\n"; //mseg= Max #segments along weldpass (same for moving arc & lumped mass)
// view1file<<4<<"\n";
 mirror1file<<4<<"\n"; //maxps= #passes (min 4 EK directive 12/22/2011, BB thinks that this is a weird unused CTSP parameter)
// view1file<<max(long(11),k)<<"\n";
 mirror1file<<max(long(11),k)<<"\n"; //maxsc= #heat sources = 11 (i.e. Policy: new EK format)
// view1file<<wp.nWeldPass<<"\n";
 mirror1file<<wp.nWeldPass<<"\n"; //maxwd= #weldpasses
// view1file<<maxelp+1<<"\n";
 mirror1file<<maxelp+1<<"\n"; //Correction 3/08/2012 //maxelp= Max #elements in a weldpass (+1 EK directive 12/22/2011)
// view1file<<k<<"\n";
 mirror1file<<k<<"\n"; //maxelcs= Max #elements a weldpass cross-section
 if(medge<1)medge=1; //Policy: default to min 1  EFP 10/12/2011
// view1file<<medge<<"\n";
 mirror1file<<medge<<"\n"; //medge= #edges with edge effects
 icount=0;for(i=0;i<base.npoin;i++)if(icount<base.node_map[i])icount=base.node_map[i];
// view1file<<icount+1<<"\n";
 mirror1file<<icount+1<<"\n"; //Highest occurring node number EFP 1/06/2012
//cccccccccccccccc start Time taken for this weld set incl. cooling [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
// view1file<<timeWeld<<"\n";
 mirror1file.precision(8);
 mirror1file<<timeWeld<<"\n";
 mirror1file.precision(6);
// view1file<<1<<"\n";
 mirror1file<<1<<"\n"; //No merging needed but include for consistency  EFP 5/20/2012
// view1file<<wp.tcutl[0]<<"\n";
 mirror1file.precision(8);
 mirror1file<<wp.tcutl[0]<<"\n"; //Correction: Low-cut temperature for 1st WP  EFP 5/22/2012
 mirror1file.precision(6);
////cccccccccccccccc end
////cccccccccccccccc start 8 extra data cards EFP 8/19/2012
// view1file<<solidshellsw<<"\n";
 mirror1file<<solidshellsw<<"\n"; //solidshellsw  EFP 5/20/2012
// view1file<<overlap<<"\n";
 mirror1file.precision(8);
 mirror1file<<overlap<<"\n"; //Core-to-core overlap time (sec)  EFP 5/20/2012
// view1file<<wp.tcuth[0]<<"\n";
 mirror1file<<wp.tcuth[0]<<"\n"; //Pre-heat temperature for 1st WP  EFP 5/22/2012
 mirror1file.precision(6);
// view1file<<base.el_map[base.nelt-1]+1<<"\n";
 mirror1file<<base.el_map[base.nelt-1]+1<<"\n"; //Global max element#  EFP 9/16/2012
// view1file<<0<<"\n";
 mirror1file<<0<<"\n"; //(should be 'delt' for multicore)  EFP 5/20/2012
// view1file<<lasttimerec<<"\n";
 mirror1file.precision(8);
 mirror1file<<lasttimerec<<"\n";  //IP ccooling time on last WP per core EFP9/23/2012
 mirror1file.precision(6);
// view1file<<lastStepIntv<<"\n";
 mirror1file<<lastStepIntv<<"\n"; //IP cooling steps on last WP per core  EFP 9/23/2012
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
////10 more
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file.close();
 mirror1file.close();
}
//---------------------------------------------------------------------------
void TForm1::export_CTSP_INPUTp1(char gVFTnameStem[],float overlap) //Version with mirror file  EFP 3/26/2011
// Version for use with mcm only, which writes a preemptive time.out  EFP 6/26/2012
{long i=0,k=0,icount=0,steptotal=0,sttEles_size=0,eles_size=0,iseq=0,mstep=0,medge=0,mseg=0,maxelp=0,
	  ipp=0,in=0,ie1=0,iside1=0,is1=0,j=0,max1=0,lastStepIntv=0; //This line junk EFP 6/16/2012
 float timeWeld=0.,lasttimerec=0.,sum=0.,a0=0.,aval=0.;int solidshellsw=0; //0=solid, 1=shell  EFP 8/19/2012
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7},
	  opp_arr8[6]={2,3,0,1,5,4};
 float dist=0.,xc=0.,yc=0.,zc=0.;
 double heritageTime=0.,T0=0.,CM=0.,delt=0.,deltc=0.,sumdeltc=0.,echo=0.;
// char extensChar[]="_CTSP_input.in";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
// ofstream viewfile(fnNeed);delete [] fnNeed;
 ofstream mirrorfile("input.in");
 ofstream outfile2("time.out");
 ofstream outfile3("scratch0.txt");
// viewfile.setf(ios::scientific);
 mirrorfile.setf(ios::scientific);

 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
	  medge=mseg=icount=maxelp=0; //Corrected EFP 5/12/2010
		 icount++; //Bud's correction  EFP 12/13/2012
	  for(k=0;k<wp.nWeldPass;k++)
		{
//		 icount++;
		 for(i=0;i<wp.memWGa;i++)if(wp.eles[wp.memWGa*k+i]<0)break;
		 icount=icount+i/wp.n_curr_sttEl[k] +wp.stepInterval[k]; //Corrected EFP 5/12/2010
		 if(maxelp<i)maxelp=i; //EFP 3/08/2012
		}
	  if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #time step data",MB_OK);exit(0);}
	  mstep=icount;
//	  viewfile<<"1, "<<icount<<"\n";
	  mirrorfile<<"1, "<<icount<<"\n";
//	  viewfile<<wms.cond[0]<<", "<<wms.heat[0]<<", "<<wms.den[0]<<", "<<wp.eff[0]<<", "<<wp.nWeldPass<<", 0.0\n";//Extra 0 at end (i.e. new format) BB 4/16/2010
	  mirrorfile<<wms.cond[0]<<", "<<wms.heat[0]<<", "<<wms.den[0]<<", "<<wp.eff[0]<<", "<<wp.nWeldPass<<", 0.0\n";//Extra 0 at end (i.e. new format) BB 4/16/2010

// No Preheat Temperature Version
// Next Line otherwise delete
//          sb.append(wp.troom + ", " + wp.tmelt  + ", " + wp.tcutl + ", " + wp.source + ", 1, " + wp.maxiHeatStep + ", " + wp.miniHeatStep + "\n");
// tcuth is used for Preheat Temperature
// Activate the next line for writing Preheat Temperature
//          sb.append(wp.tcuth + ", "+ wp.troom + ", " + wp.tmelt  + ", " + wp.tcutl + ", " + wp.source + ", 1, " + wp.maxiHeatStep + ", " + wp.miniHeatStep + "\n");

//	  viewfile<<wp.tcuth[0]<<", "<<wp.troom[0]<<", "<<wp.tmelt[0]<<", "<<wp.tcutl[0]<<", "<<wp.source[0]<<", 1, "<<wp.maxiHeatStep[0]<<", "<<wp.miniHeatStep[0]<<"\n";
	  mirrorfile<<wp.tcuth[0]<<", "<<wp.troom[0]<<", "<<wp.tmelt[0]<<", "<<wp.tcutl[0]<<", "<<wp.source[0]<<", 1, "<<wp.maxiHeatStep[0]<<", "<<wp.miniHeatStep[0]<<"\n";
	  steptotal=0;timeWeld=0.;
// boolFlags[]: showFlag=1st digit,circFlag=2nd,edgeFlag=3rd,merge=4th,girthFlag=5th

/////////////// start Junk EFP 6/16/2012
max1=1;heritageTime=0.;
outfile2<<setw(12)<<max1<<setw(15)<<scientific<<heritageTime<<"\n";max1++;
outfile3<<0.<<" "<<1<<"\n";
/////////////// end

	  for(iseq=0;iseq<wp.nWeldPass;iseq++)
		{for(k=0;k<wp.nWeldPass;k++)if(iseq+1==wp.seqNum[k])break;
//		 viewfile<<"***** Weld Pass "<<wp.name[k].t_str()<<" *****\n";
		 mirrorfile<<"***** Weld Pass "<<wp.name[k].t_str()<<" *****\n";
////		 int showFlag=wp.boolFlags[k]-10*(wp.boolFlags[k]/10);
		 int circFlag=(wp.boolFlags[k]-100*(wp.boolFlags[k]/100))/10;
		 int edgeFlag=(wp.boolFlags[k]-1000*(wp.boolFlags[k]/1000))/100;
		 int merge=(wp.boolFlags[k]-10000*(wp.boolFlags[k]/10000))/1000;
		 int girthFlag=(wp.boolFlags[k]-100000*(wp.boolFlags[k]/100000))/10000;
		 icount=0;for(i=0;i<4*wp.nWeldPass;i++)if(wp.edgeNodes[i]> -1)icount++;else break;
		 int numEdge = edgeFlag ? icount : 0;
///////////////////////// start EFP 10/12/2011
		 if(numEdge)medge++; //EFP 10/12/2011
///////////////////////// end
		 int cirWeld = circFlag ? wp.shape[k] : 0;
		 int girthWeld=0;
		 if(wp.shape[k]==3){girthWeld=1;cirWeld=0;}
		 if(wp.shape[k]==4){girthWeld=2;cirWeld=0;}
		 int lumpWeld=wp.nsegs[k]; //Lump Pass (1) or Moving Arc (0) Heating Procedure
		 if(wp.hp[k]==0)lumpWeld=0;
//         if(k==0)wp.merge[k]=false;
		 wp.boolFlags[k]=wp.boolFlags[k]-merge*1000; //Zero merge component
		 if(k==0)merge=0;
		 if(merge>0)wp.boolFlags[k]=wp.boolFlags[k]+merge*1000;
		 int mcond=0;if(merge)mcond=1;
//		 viewfile<<"1, "<<wp.type[k] + 1<<", "<<wp.thk1[k]<<", "<<wp.thk2[k]<<", "<<numEdge<<", "<<cirWeld<<", "<<lumpWeld<<", "<<mcond<<", "<<girthWeld<<"\n";
		 mirrorfile<<"1, "<<wp.type[k] + 1<<", "<<wp.thk1[k]<<", "<<wp.thk2[k]<<", "<<numEdge<<", "<<cirWeld<<", "<<lumpWeld<<", "<<mcond<<", "<<girthWeld<<"\n";
//		 viewfile  <<base.node_map[wp.snorm1[4*k+1]]+1<<", "<<base.node_map[wp.snorm1[4*k+2]]+1<<", "<<base.node_map[wp.snorm1[4*k+3]]+1<<", "; // Note that these are the 2/3/4 nodes, not 1
		 mirrorfile<<base.node_map[wp.snorm1[4*k+1]]+1<<", "<<base.node_map[wp.snorm1[4*k+2]]+1<<", "<<base.node_map[wp.snorm1[4*k+3]]+1<<", "; // Note that these are the 2/3/4 nodes, not 1
//		 viewfile  <<base.node_map[wp.snorm2[4*k+1]]+1<<", "<<base.node_map[wp.snorm2[4*k+2]]+1<<", "<<base.node_map[wp.snorm2[4*k+3]]+1<<"\n";
		 mirrorfile<<base.node_map[wp.snorm2[4*k+1]]+1<<", "<<base.node_map[wp.snorm2[4*k+2]]+1<<", "<<base.node_map[wp.snorm2[4*k+3]]+1<<"\n";
//		 viewfile<<wp.timeInterval[k]<<", "<<wp.stepInterval[k]<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<"\n";
		 mirrorfile<<wp.timeInterval[k]<<", "<<wp.stepInterval[k]<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<"\n";
		 icount=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.sttEles[i]> -1)icount++;else break;}
		 if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #weld start elements",MB_OK);exit(0);}
		 sttEles_size=icount;
//		 viewfile<<icount<<"\n";
		 mirrorfile<<icount<<"\n";
//		 for(i=0;i<icount;i++)viewfile  <<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+0]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+1]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+2]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+3]]+1<<"\n";
		 for(i=0;i<icount;i++)mirrorfile<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+0]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+1]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+2]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+3]]+1<<"\n";
		 icount=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.eles[i]> -1)icount++;else break;}
		 if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #weld group elements",MB_OK);exit(0);}
		 eles_size=icount;
/////////////////////////// EFP 10/12/2011
		 if(mseg<icount/wp.n_curr_sttEl[k])mseg=icount/wp.n_curr_sttEl[k];
///////////////////////////
//		 viewfile<<icount;
		 mirrorfile<<icount;
		 for(i=0;i<icount;i++){if(i%10 == 0){//viewfile<<"\n";
											 mirrorfile<<"\n";}
//							   viewfile<<base.el_map[wp.eles[wp.memWGa*k+i]/10] +1; //Corrected EFP 9/10/2010
							   mirrorfile<<base.el_map[wp.eles[wp.memWGa*k+i]/10] +1; //Corrected EFP 9/10/2010
							   if(i%10 != 9 && i != icount-1){//viewfile<<", ";
															  mirrorfile<<", ";}
							  }
//		 viewfile<<"\n";
		 mirrorfile<<"\n";
		 if(wp.hp[k]==0)steptotal += wp.stepInterval[k]+eles_size/sttEles_size;
		 else if(wp.hp[k]==1)steptotal += wp.stepInterval[k]+(wp.nsegs[k]-1)*5+ (wp.nsegs[k])*20 ;

//cccccccccccccccc start [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
		 timeWeld=timeWeld+wp.timeInterval[k]+wp.lend[k]/wp.speed[k];
//cccccccccccccccc end

//		 for(i=0;i<numEdge;i++)viewfile  <<base.node_map[wp.edgeNodes[4*k+i]]+1<<"\n"; //Edge Effect (Correction EFP 4/09/2011
		 for(i=0;i<numEdge;i++)mirrorfile<<base.node_map[wp.edgeNodes[4*k+i]]+1<<"\n"; //Edge Effect (Correction EFP 4/09/2011
//Circular Weld
		 if(circFlag){for(i=0;i<3;i++){
//									   viewfile  <<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
									   mirrorfile<<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
									   if(i<2){//viewfile<<", ";
											   mirrorfile<<", ";}
									  }
//					  viewfile<<"\n";
					  mirrorfile<<"\n";
					 }
//Girth Weld
		 if(girthFlag){for(i=0;i<3;i++){
//										viewfile  <<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
										mirrorfile<<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
										if(i<2){//viewfile<<", ";
												mirrorfile<<", ";}
									   }
//					   viewfile<<"\n";
					   mirrorfile<<"\n";
					  }

////////////////// start Junk EFP 6/16/2012
						  for(ipp=0;ipp<eles_size/wp.n_curr_sttEl[k];ipp++){dist=0.;
					   for(in=0;in<wp.n_curr_sttEl[k];in++){
ie1=wp.eles[wp.memWGa*k+wp.n_curr_sttEl[k]*ipp+in]/10;iside1=wp.eles[wp.memWGa*k+wp.n_curr_sttEl[k]*ipp+in]-10*ie1;
xc=yc=zc=0.;
for(is1=0;is1<4;is1++){xc=xc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+0]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+0];
					   yc=yc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+1]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+1];
					   zc=zc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+2]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+2];
					  }
xc=xc/4.;yc=yc/4.;zc=zc/4.;dist=dist+sqrt(xc*xc+yc*yc+zc*zc);//EFP dislikes this non-area-weighted centroid
														   }
delt=dist/(float(wp.n_curr_sttEl[k])*wp.speed[k]);
heritageTime=heritageTime+delt;
//viewfile1<<heritageTime<<"\n";
outfile2<<setw(12)<<max1<<setw(15)<<scientific<<heritageTime<<"\n";max1++;
//if(ipp<eles_size/wp.n_curr_sttEl[k] -1)outfile3<<delt<<" "<<3<<"\n";else outfile3<<delt<<" "<<2<<"\n";
if(ipp<eles_size/wp.n_curr_sttEl[k] -1)outfile3<<heritageTime<<" "<<3<<"\n";else outfile3<<heritageTime<<" "<<2<<"\n";
																		   }
////////////
if(wp.stepInterval[k]==1){heritageTime=heritageTime+wp.timeInterval[k];
//viewfile1<<heritageTime<<"\n";
outfile2<<setw(12)<<max1<<setw(15)<<scientific<<heritageTime<<"\n";max1++;
//if(iseq<wp.nWeldPass-1)outfile3<<wp.timeInterval[k]<<" "<<1<<"\n";else outfile3<<wp.timeInterval[k]<<" "<<3<<"\n";
if(iseq<wp.nWeldPass-1)outfile3<<heritageTime<<" "<<1<<"\n";else outfile3<<heritageTime<<" "<<3<<"\n";
						 }
else {
	  echo=heritageTime;
////	  ExpoStep(delt,double(wp.timeInterval[k]),wp.stepInterval[k],&T0,&CM);
////	  for(j=0;j<wp.stepInterval[k];j++){
////heritageTime=echo+T0*(exp(CM*float(j+1))-1.);
////outfile2<<setw(12)<<max1<<setw(15)<<scientific<<heritageTime<<"\n";max1++;
////									   }
//
//	  aval=1.;sum=aval; //EFP 11/24/2012
//	  for(j=0;j<wp.stepInterval[k]-1;j++){aval=aval*1.2;sum=sum+aval;}
//	  a0=wp.timeInterval[k]/sum;
//	  for(j=0;j<wp.stepInterval[k]-1;j++){
//heritageTime=heritageTime+a0;a0=a0*1.2;
//outfile2<<setw(12)<<max1<<setw(15)<<scientific<<heritageTime<<"\n";max1++;
//										 }
	  sumdeltc=0.;
	  for(j=0;j<wp.stepInterval[k]-1;j++){ //EFP 1/18/2013
deltc=wp.timeInterval[k]*
  log((wp.stepInterval[k]-float(j)+float(j)*0.0353)/(wp.stepInterval[k]-float(j)-1+float(j+1)*0.0353))/
  log(1./0.0353);
sumdeltc=sumdeltc+deltc;
heritageTime=heritageTime+wp.timeInterval[k]*
  log((wp.stepInterval[k]-float(j)+float(j)*0.0353)/(wp.stepInterval[k]-float(j)-1+float(j+1)*0.0353))/
  log(1./0.0353);
outfile2<<setw(12)<<max1<<setw(15)<<scientific<<heritageTime<<"\n";max1++;
//outfile3<<deltc<<" "<<3<<"\n";
outfile3<<heritageTime<<" "<<3<<"\n";
										 }

heritageTime=echo+wp.timeInterval[k];
outfile2<<setw(12)<<max1<<setw(15)<<scientific<<heritageTime<<"\n";max1++;
//if(iseq<wp.nWeldPass-1)outfile3<<wp.timeInterval[k]-sumdeltc<<" "<<1<<"\n";else outfile3<<wp.timeInterval[k]-sumdeltc<<" "<<3<<"\n";
if(iseq<wp.nWeldPass-1)outfile3<<heritageTime<<" "<<1<<"\n";else outfile3<<heritageTime<<" "<<3<<"\n";
	 }
////////////////// end
		 lasttimerec=wp.timeInterval[k]; //EFP 8/192012
		 lastStepIntv=wp.stepInterval[k]; //EFP 8/192012
		}
//	  viewfile<<"-1\n";
	  mirrorfile<<"-1\n";
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
// viewfile.close();
 mirrorfile.close();outfile2.close();outfile3.close();
/////////////////////////////////////////////////////////////
 sleep(5); //Allow real time 5 seconds for file to close... Needs <dos.h>
 ifstream infile3("scratch0.txt");
 ofstream outfile3a("preWARP.txt");
 int hcflag1=0,hcrec=3,hc_stor[500];float timesum=0.,time1=0.,time_stor[500];
 infile3>>time1>>hcflag1;
honk<<hcflag1<<" "<<time1<<" first\n";
//if(1==1)exit(0);
 hc_stor[0]=hcflag1;time_stor[0]=time1; //Presume time_stor[0]=0.
 for(i=0;i<wp.nWeldPass;i++){for(j=0;j<100;j++){infile3>>time1>>hcflag1;
honk<<hcflag1<<" "<<time1<<" secnd\n";
//if(j>13)exit(0);
													hc_stor[j+1]=hcflag1;time_stor[j+1]=time1;
													if(hcflag1 != hcrec){timesum=time1;
//honk<<"BREAKING0\n";
																		 break;}
//if(j==11){honk<<"BREAKING1\n";timesum=time1;break;}
												   }
							 outfile3a<<time_stor[0]<<" "<<hc_stor[0]<<" "<<timesum-time_stor[0]<<"\n";
//							 for(k=1;k<j;k++)outfile3a<<time_stor[k]<<" "<<hc_stor[k]<<" "<<timesum-time_stor[k]<<"\n";
							 for(k=1;k<j+1;k++)outfile3a<<time_stor[k]<<" "<<hc_stor[k]<<" "<<timesum-time_stor[k]<<"\n";
							 hc_stor[0]=hcflag1;time_stor[0]=time1;timesum=timesum+wp.timeInterval[i];
							 for(j=0;j<wp.stepInterval[i];j++){infile3>>time1>>hcflag1;
honk<<hcflag1<<" "<<time1<<" third\n";
															   hc_stor[j+1]=hcflag1;time_stor[j+1]=time1;
															  }
//if(1==1)exit(0);
							 outfile3a<<time_stor[0]<<" "<<hc_stor[0]<<" "<<timesum-time_stor[0]<<"\n";
//							 for(k=1;k<j;k++)outfile3a<<time_stor[k]<<" "<<hc_stor[k]<<" "<<timesum-time_stor[k]<<"\n";
							 for(k=1;k<wp.stepInterval[i];k++)outfile3a<<time_stor[k]<<" "<<hc_stor[k]<<" "<<timesum-time_stor[k]<<"\n";
							 if(i==wp.nWeldPass-1)outfile3a<<time_stor[wp.stepInterval[i]]<<" "<<hc_stor[wp.stepInterval[i]]<<" "<<0.<<"\n";
							 hc_stor[0]=hcflag1;time_stor[0]=time1;
							}
 outfile3a.close();infile3.close();DeleteFile("scratch0.txt");
 ofstream outfile4("uexternal_data_file.inp");
 outfile4<<"!  Three non-comment lines with file names required\n";
 outfile4<<"!   1 - name of material.dat file for VFT\n";
 outfile4<<"!   2 - name of VED.dat file\n";
 outfile4<<"!   3 - root of file names for thermal profiles\n";
 outfile4<<"!       There must be file names with extensions\n";
 outfile4<<"!       *.txt & *.bin\n";
 outfile4<<"!       Omit extensions here.\n";
 outfile4<<"!\n";
 outfile4<<"!  File names may have ~/ to denote user home directory.\n";
 outfile4<<"!  WARP3D will resolve to full path name.\n";
 outfile4<<"!\n";
 outfile4<<"./material.dat\n";
 outfile4<<"./VED.dat\n";
 outfile4<<"./warp_temp_2_files\n";
 outfile4<<"!\n";
 outfile4<<"!  Stop when analysis for this thermal profile completed.\n";
 outfile4<<"!  If this number of profiles is not defined, WARP3D will\n";
 outfile4<<"!  write output files, a restart file, and execute normal termination.\n";
 outfile4<<"!\n";
// outfile4<<"  10\n";
 outfile4<<"  10000\n";
 outfile4<<"!\n";
 outfile4<<"!  Values to control output:\n";
 outfile4<<"!  - number of thermal profiles between saving restart file\n";
 outfile4<<"!  - number of thermal profiles between generation of output file\n";
 outfile4<<"!  - file of WARP3D output commands to be executed\n";
 outfile4<<"!\n";
// outfile4<<"  500, 500\n";
 outfile4<<"  10000, 10\n";
 outfile4<<"output_commands.inp\n";
 outfile4<<"!\n";
 outfile4<<"!  Values to control solution when:\n";
 outfile4<<"!  o - a torch or torches comes on\n";
 outfile4<<"!  o - cooling starts\n";
 outfile4<<"!  o - analysis startup and on restarts\n";
 outfile4<<"!\n";
 outfile4<<"! - (N1) number of sequential thermal profiles over which\n";
 outfile4<<"!        to use a larger number of WARP3D load steps\n";
 outfile4<<"! - (N2) number of increased load steps to use (>=1) for\n";
 outfile4<<"!        solution over these profiles\n";
 outfile4<<"!\n";
// outfile4<<"  2, 5\n";
 outfile4<<"  1, 2\n";
 outfile4<<"!  Value to control solution when:\n";
 outfile4<<"!  o - heating is occurring and has continued beyond N1 above\n";
 outfile4<<"!  o - cooling is occurring and has continued beyond N1 above\n";
 outfile4<<"! - (N1) number of sequential thermal profiles over which\n";
 outfile4<<"!\n";
 outfile4<<"!  N3 =1 is the most common value.\n";
 outfile4<<"!\n";
// outfile4<<"  1\n";
 outfile4<<"  2\n";
 outfile4.close();
 ofstream outfile5("output_commands.inp");
// outfile5<<"!  Put WARP3D output commands here. These will be executed after\n";
// outfile5<<"!  solution for a profile completes at the profile frequency \n";
// outfile5<<"!  specified in\n";
// outfile5<<"!  uexternal_data_file.inp\n";
// outfile5<<"!\n";
// outfile5<<"   output displacements nodes 10000-10300\n";
// outfile5<<"   output displacements elements 6000-6050 by 2\n";
// outfile5<<"   output totals only reactions nodes all\n";
// outfile5<<"   output wide eformat noheader strains 91240-91250,\n";
// outfile5<<"       156320-157000 by 3\n";
// outfile5<<"   output wide stresses 156320-157000 by 3\n";
// outfile5<<"   output patran binary displacements stresses strains\n";
// outfile5<<"   output patran binary element stresses strains\n";
 outfile5<<"!  DEFAULT FOR WSO, IF YOU NEED STRESS/STRAIN, COMMENT Line 3,\n";
 outfile5<<"!  UNCOMMENT OTHER LINES AS APPROPRIATE\n";
 outfile5<<"!\n";
 outfile5<<"!    Use patran files for old-version pat2exii until Python\n";
 outfile5<<"!    version becomes faster. Then switch to output flat ..\n";
 outfile5<<"!    commands.\n";
 outfile5<<"!\n";
 outfile5<<"  output patran formatted displacements\n";
 outfile5<<"  output patran formatted stresses\n";
 outfile5<<"  output patran formatted temperatures\n";
 outfile5<<"!\n";
 outfile5<<"!  output patran binary element strains stresses\n";
 outfile5<<"!  output totals only reactions nodes all\n";
 outfile5<<"!\n";
 outfile5<<"!  output flat text nodal stresses\n";
 outfile5<<"!  output flat text nodal temperatures\n";
 outfile5.close();
/////////////////////////////////////////////////////////////

// char extensChar1[]="_CTSP_param.in";char *fnNeed1=new char[strlen(gVFTnameStem)+strlen(extensChar1)+1];
// StringCchCopy(fnNeed1,strlen(gVFTnameStem)+strlen(extensChar1)+1,gVFTnameStem);StringCchCat(fnNeed1,strlen(gVFTnameStem)+strlen(extensChar1)+1,extensChar1);
// ofstream view1file(fnNeed1);delete [] fnNeed1;
 ofstream mirror1file("param.in");

 k=0;for(i=0;i<wp.nWeldPass;i++)if(k<wp.n_curr_sttEl[i])k=wp.n_curr_sttEl[i]; //Moved up here per EK format  EFP 6/26/2012
// view1file<<mstep<<"\n";
 mirror1file<<mstep<<"\n"; //mstep= #timesteps
 if(mseg<2)mseg=2; //EK directive  12/22/2011
// view1file<<mseg<<"\n";
 mirror1file<<mseg<<"\n"; //mseg= Max #segments along weldpass (same for moving arc & lumped mass)
// view1file<<4<<"\n";
 mirror1file<<4<<"\n"; //maxps= #passes (min 4 EK directive 12/22/2011, BB thinks that this is a weird unused CTSP parameter)
// view1file<<max(long(11),k)<<"\n";
 mirror1file<<max(long(11),k)<<"\n"; //maxsc= #heat sources = 11 (i.e. Policy: new EK format)
// view1file<<wp.nWeldPass<<"\n";
 mirror1file<<wp.nWeldPass<<"\n"; //maxwd= #weldpasses
// view1file<<maxelp+1<<"\n";
 mirror1file<<maxelp+1<<"\n"; //Correction 3/08/2012 //maxelp= Max #elements in a weldpass (+1 EK directive 12/22/2011)
// view1file<<k<<"\n";
 mirror1file<<k<<"\n"; //maxelcs= Max #elements a weldpass cross-section
 if(medge<1)medge=1; //Policy: default to min 1  EFP 10/12/2011
// view1file<<medge<<"\n";
 mirror1file<<medge<<"\n"; //medge= #edges with edge effects
 icount=0;for(i=0;i<base.npoin;i++)if(icount<base.node_map[i])icount=base.node_map[i];
// view1file<<icount+1<<"\n";
 mirror1file<<icount+1<<"\n"; //Highest occurring node number EFP 1/06/2012
////cccccccccccccccc start Time taken for this weld set incl. cooling [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
// view1file<<timeWeld<<"\n";
 mirror1file.precision(8);
 mirror1file<<timeWeld<<"\n";
 mirror1file.precision(6);
// view1file<<1<<"\n";
 mirror1file<<1<<"\n"; //No merging needed but include for consistency  EFP 5/20/2012
// view1file<<wp.tcutl[0]<<"\n";
 mirror1file.precision(8);
 mirror1file<<wp.tcutl[0]<<"\n"; //Correction: Low-cut temperature for 1st WP  EFP 5/22/2012
 mirror1file.precision(6);
////cccccccccccccccc end
////cccccccccccccccc start 8 extra data cards EFP 8/19/2012
// view1file<<solidshellsw<<"\n";
 mirror1file<<solidshellsw<<"\n"; //solidshellsw  EFP 5/20/2012
// view1file<<overlap<<"\n";
 mirror1file.precision(8);
 mirror1file<<overlap<<"\n"; //Core-to-core overlap time (sec) EFP 5/20/2012
// view1file<<wp.tcuth[0]<<"\n";
 mirror1file<<wp.tcuth[0]<<"\n"; //Pre-heat temperature for 1st WP  EFP 5/22/2012
 mirror1file.precision(6);
// view1file<<base.el_map[base.nelt-1]+1<<"\n";
 mirror1file<<base.el_map[base.nelt-1]+1<<"\n"; //Global max element#  EFP 9/16/2012
// view1file<<0<<"\n";
 mirror1file<<0<<"\n"; //(should be delt for multicore)extra  EFP 5/20/2012
// view1file<<lasttimerec<<"\n";
 mirror1file.precision(8);
 mirror1file<<lasttimerec<<"\n"; //IP cooling time on last WP per core (sec) EFP 9/23/2012
 mirror1file.precision(6);
// view1file<<lastStepIntv<<"\n";
 mirror1file<<lastStepIntv<<"\n"; //IP cooling steps on last WP per core EFP 5/20/2012
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
////10 more
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file<<0<<"\n";
 mirror1file<<0<<"\n";
// view1file.close();
 mirror1file.close();
}

//---------------------------------------------------------------------------
// void export_CTSP_INPUT_mcm(int,int,int,char []);
// export_CTSP_INPUT_mcm(itranche,1,wp.nWeldPass,gWsiAlias.t_str());
void TForm1::export_CTSP_INPUTp_mcm(long mcmlo,long mcmup,int isw,float lasttimerec,char gVFTnameStem[]) //Version with mirror file  EFP 3/26/2011
//mcm= multi-core manual;mcmlo= lower limit (min 1);mcmup=upper limit (max wp.nWeldPass)  EFP 10/28/2011
// isw=0 ->Extra cooling OFF; 1->Extra cooling ON (e.g. last WP per core, except last core)
{long i=0,k=0,icount=0,//steptotal=0,
	  sttEles_size=0,eles_size=0,iseq=0,mstep=0,medge=0,mseg=0,mWPcs=0,maxelp=0,laststep=0,
	  ipp=0,in=0,ie1=0,iside1=0,is1=0,j=0,laplim=0,LIMOVER=5; //This line junk EFP 6/16/2012
//	  ipp=0,in=0,ie1=0,iside1=0,is1=0,j=0,laplim=0,LIMOVER=500; //This line junk EFP 6/16/2012
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7},
	 opp_arr8[6]={2,3,0,1,5,4},solidshellsw=0; //0=solid, 1=shell  EFP 8/19/2012
 float timeWeld=0.,lasttime=0.,dist=0.,xc=0.,yc=0.,zc=0.,astart=0.,lasttimecom=0.,biasintv=1.5;
 double delt=0.;

 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
 ofstream mirrorfile("input.in");mirrorfile.setf(ios::scientific);

// TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
	  medge=mseg=icount=maxelp=0; //Corrected EFP 5/12/2010
	  icount++; //Bud's correction  EFP 12/13/2012
	  for(iseq=mcmlo-1;iseq<mcmup;iseq++)// Correction  EFP 10/30/2011
		{for(k=0;k<wp.nWeldPass;k++)if(iseq+1==wp.seqNum[k])break;
		 for(i=0;i<wp.memWGa;i++)if(wp.eles[wp.memWGa*k+i]<0)break;
		 icount=icount+i/wp.n_curr_sttEl[k] +wp.stepInterval[k]; //Corrected EFP 5/12/2010
		 if(maxelp<i)maxelp=i; //EFP 3/30/2012
		 laststep=wp.stepInterval[k];lasttime=wp.timeInterval[k];
////		 astart=exp(log(lasttime)-float(laststep-1)*log(1.2));  //EFP 1/25/2013
////		 LIMOVER=1+long(log(lasttimerec/astart)/log(1.2));
////		 lasttimecom=exp(log(astart)+float(LIMOVER-1)*log(1.2));
//		 astart=exp(log(lasttime)-float(laststep-1)*log(biasintv));  //EFP 1/25/2013
//		 LIMOVER=1+long(log(lasttimerec/astart)/log(biasintv));
//		 lasttimecom=exp(log(astart)+float(LIMOVER-1)*log(biasintv));
		 astart=lasttime*((biasintv-1.)/(pow(biasintv,float(laststep))-1.));  //EFP 1/29/2013
		 LIMOVER=long(0.001+log(1.+(biasintv-1.)*(lasttimerec/astart))/log(biasintv));
		 lasttimecom=astart*((pow(biasintv,float(LIMOVER))-1.)/(biasintv-1.));
		}
/////////////////////////
honk<<k<<" "<<laststep<<" "<<lasttime<<" kkkkkk "<<biasintv<<"\n";
honk<<astart<<" "<<LIMOVER<<" "<<lasttimecom<<" astart,LIMOVER,lasttimecom\n";
/////////////////////////
	  if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #time step data",MB_OK);exit(0);}
//////////////////
//cccccccccccccccc start Extra cooling steps for multi-core  EFP 5/20/2012
	  laplim=icount-laststep;if(isw)icount=icount+max(LIMOVER,laststep)-laststep;
//////////////////
	  mstep=icount;
// Note on multi-core option:      EFP 9/03/2012
// Core mstep is not the actual number of times in core time.out.
// Core mstep= SummationOverWPcore(1+ i/wp.n_curr_sttEl[k] +wp.stepInterval[k])
// Actual #times in core time.out= (mstep-#WPcore) +1
// Accordingly, parameter core laplim (below)= mstep-#WPcore +1 -lastStepIntv
////////////////////////////////////////////
	  mirrorfile<<"1, "<<icount<<"\n";
	  mirrorfile<<wms.cond[0]<<", "<<wms.heat[0]<<", "<<wms.den[0]<<", "<<wp.eff[0]<<", "<<mcmup-mcmlo+1<<", 0.0\n";//Extra 0 at end (i.e. new format) BB 4/16/2010
// No Preheat Temperature Version
// Next Line otherwise delete
//          sb.append(wp.troom + ", " + wp.tmelt  + ", " + wp.tcutl + ", " + wp.source + ", 1, " + wp.maxiHeatStep + ", " + wp.miniHeatStep + "\n");
// tcuth is used for Preheat Temperature
// Activate the next line for writing Preheat Temperature
//          sb.append(wp.tcuth + ", "+ wp.troom + ", " + wp.tmelt  + ", " + wp.tcutl + ", " + wp.source + ", 1, " + wp.maxiHeatStep + ", " + wp.miniHeatStep + "\n");
	  mirrorfile<<wp.tcuth[0]<<", "<<wp.troom[0]<<", "<<wp.tmelt[0]<<", "<<wp.tcutl[0]<<", "<<wp.source[0]<<", 1, "<<wp.maxiHeatStep[0]<<", "<<wp.miniHeatStep[0]<<"\n";
//	  steptotal=0;
	  mWPcs=0;timeWeld=0.;
// boolFlags[]: showFlag=1st digit,circFlag=2nd,edgeFlag=3rd,merge=4th,girthFlag=5th
	  for(iseq=mcmlo-1;iseq<mcmup;iseq++)
		{for(k=0;k<wp.nWeldPass;k++)if(iseq+1==wp.seqNum[k])break;
		 mirrorfile<<"***** Weld Pass "<<wp.name[k].t_str()<<" *****\n";
		 if(mWPcs<wp.n_curr_sttEl[k])mWPcs=wp.n_curr_sttEl[k];
		 int circFlag=(wp.boolFlags[k]-100*(wp.boolFlags[k]/100))/10;
		 int edgeFlag=(wp.boolFlags[k]-1000*(wp.boolFlags[k]/1000))/100;
		 int merge=(wp.boolFlags[k]-10000*(wp.boolFlags[k]/10000))/1000;
		 int girthFlag=(wp.boolFlags[k]-100000*(wp.boolFlags[k]/100000))/10000;
		 icount=0;
		 for(i=4*(mcmlo-1);i<4*mcmup;i++)if(wp.edgeNodes[i]> -1)icount++;else break;
		 int numEdge = edgeFlag ? icount : 0;
///////////////////////// start EFP 10/12/2011
		 if(numEdge)medge++; //EFP 10/12/2011
///////////////////////// end
		 int cirWeld = circFlag ? wp.shape[k] : 0;
		 int girthWeld=0;
		 if(wp.shape[k]==3){girthWeld=1;cirWeld=0;}
		 if(wp.shape[k]==4){girthWeld=2;cirWeld=0;}
		 int lumpWeld=wp.nsegs[k]; //Lump Pass (1) or Moving Arc (0) Heating Procedure
		 if(wp.hp[k]==0)lumpWeld=0;
		 wp.boolFlags[k]=wp.boolFlags[k]-merge*1000; //Zero merge component
		 if(k==0)merge=0;
		 if(merge>0)wp.boolFlags[k]=wp.boolFlags[k]+merge*1000;
		 int mcond=0;if(merge)mcond=1;
		 mirrorfile<<"1, "<<wp.type[k] + 1<<", "<<wp.thk1[k]<<", "<<wp.thk2[k]<<", "<<numEdge<<", "<<cirWeld<<", "<<lumpWeld<<", "<<mcond<<", "<<girthWeld<<"\n";
		 mirrorfile<<base.node_map[wp.snorm1[4*k+1]]+1<<", "<<base.node_map[wp.snorm1[4*k+2]]+1<<", "<<base.node_map[wp.snorm1[4*k+3]]+1<<", "; // Note that these are the 2/3/4 nodes, not 1
		 mirrorfile<<base.node_map[wp.snorm2[4*k+1]]+1<<", "<<base.node_map[wp.snorm2[4*k+2]]+1<<", "<<base.node_map[wp.snorm2[4*k+3]]+1<<"\n";
		 if(iseq==mcmup-1 && isw){ //EFP 6/07/2012
//		 mirrorfile<<lasttimerec<<", "<<max(LIMOVER,laststep)<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<"\n";
//honk<<lasttimerec<<", "<<max(LIMOVER,laststep)<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<" mcmCTSP overlapON "<<iseq<<" "<<mcmlo-1<<" "<<mcmup<<" "<<k<<"\n";
		 mirrorfile<<lasttimecom<<", "<<max(LIMOVER,laststep)<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<"\n";
honk<<lasttimecom<<", "<<max(LIMOVER,laststep)<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<" mcmCTSP overlapON "<<iseq<<" "<<mcmlo-1<<" "<<mcmup<<" "<<k<<"\n";
								 }
		 else {
		 mirrorfile<<wp.timeInterval[k]<<", "<<wp.stepInterval[k]<<", "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<"\n";
honk<<wp.timeInterval[k]<<", "<<wp.stepInterval[k]<<" "<<wp.speed[k]<<", "<<wp.curr[k] * wp.volt[k]<<" mcmCTSP overlapOFF "<<iseq<<" "<<mcmlo-1<<" "<<mcmup<<" "<<k<<"\n";
			  }
		 icount=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.sttEles[i]> -1)icount++;else break;}
		 if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #weld start elements",MB_OK);exit(0);}
		 sttEles_size=icount;
		 mirrorfile<<icount<<"\n";
		 for(i=0;i<icount;i++)mirrorfile<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+0]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+1]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+2]]+1<<", "<<base.node_map[wp.sttEleNodes[4*wp.memWGa*k+4*i+3]]+1<<"\n";
		 icount=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.eles[i]> -1)icount++;else break;}
		 if(!icount){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #weld group elements",MB_OK);exit(0);}
		 eles_size=icount;
/////////////////////////// EFP 10/12/2011
		 if(mseg<icount/wp.n_curr_sttEl[k])mseg=icount/wp.n_curr_sttEl[k];
///////////////////////////
		 mirrorfile<<icount;
		 for(i=0;i<icount;i++){if(i%10 == 0)mirrorfile<<"\n";
							   mirrorfile<<base.el_map[wp.eles[wp.memWGa*k+i]/10] +1; //Corrected EFP 9/10/2010
							   if(i%10 != 9 && i != icount-1)mirrorfile<<", ";
							  }
		 mirrorfile<<"\n";

//		 if(iseq==mcmup-1 && isw){          //EFP 6/07/2012
//		 if(wp.hp[k]==0)steptotal += laststep+eles_size/sttEles_size;
//		 else if(wp.hp[k]==1)steptotal += laststep+(wp.nsegs[k]-1)*5+ (wp.nsegs[k])*20 ;
//								 }
//		 else {
//		 if(wp.hp[k]==0)steptotal += wp.stepInterval[k]+eles_size/sttEles_size;
//		 else if(wp.hp[k]==1)steptotal += wp.stepInterval[k]+(wp.nsegs[k]-1)*5+ (wp.nsegs[k])*20 ;
//			  }

//cccccccccccccccc start [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
		 timeWeld=timeWeld+wp.timeInterval[k]+wp.lend[k]/wp.speed[k];
//cccccccccccccccc end
		 for(i=0;i<numEdge;i++)mirrorfile<<base.node_map[wp.edgeNodes[4*k+i]]+1<<"\n"; //Edge Effect (Correction EFP 4/09/2011
//Circular Weld
		 if(circFlag){for(i=0;i<3;i++){mirrorfile<<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
									   if(i<2)mirrorfile<<", ";
									  }
					  mirrorfile<<"\n";
					 }
//Girth Weld
		 if(girthFlag){for(i=0;i<3;i++){mirrorfile<<base.node_map[wp.circEles[3*k+i]]+1; // Corrected EFP 9/10/2010
										if(i<2)mirrorfile<<", ";
									   }
					   mirrorfile<<"\n";
					  }
///////////// start NEW CODING EFP 6/19/2012  reactivated 9/23/2012 EFP
						  ipp=eles_size/wp.n_curr_sttEl[k]-1;dist=0.; //Last slice only
					   for(in=0;in<wp.n_curr_sttEl[k];in++){
ie1=wp.eles[wp.memWGa*k+wp.n_curr_sttEl[k]*ipp+in]/10;iside1=wp.eles[wp.memWGa*k+wp.n_curr_sttEl[k]*ipp+in]-10*ie1;
xc=yc=zc=0.;
for(is1=0;is1<4;is1++){xc=xc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+0]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+0];
					   yc=yc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+1]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+1];
					   zc=zc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+2]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+2];
					  }
xc=xc/4.;yc=yc/4.;zc=zc/4.;dist=dist+sqrt(xc*xc+yc*yc+zc*zc);//EFP dislikes this non-area-weighted centroid
														   }
delt=dist/(float(wp.n_curr_sttEl[k])*wp.speed[k]); //We require the last delt of last WP only
		}
	  mirrorfile<<"-1\n";
 mirrorfile.close();
 ofstream mirror1file("param.in");

 mirror1file<<mstep<<"\n"; //mstep= #timesteps (but not #times in time.out)
 if(mseg<2)mseg=2; //EK directive  12/22/2011 THIS WAS MISSING
 mirror1file<<mseg<<"\n"; //mseg= Max #segments along weldpass (same for moving arc & lumped mass)
 mirror1file<<4<<"\n"; // THIS WAS ONLY 1. maxps= #passes (min 4 EK directive 12/22/2011, BB thinks that this is a weird unused CTSP parameter)
 mirror1file<<max(long(11),mWPcs)<<"\n"; //maxsc= #heat sources = 11 (i.e. Policy: new EK format 6/26/2012)
 mirror1file<<mcmup-mcmlo+1<<"\n"; //maxwd= #weldpasses  EFP 10/30/2011
 mirror1file<<maxelp+1<<"\n"; //Correction 3/30/2012 //maxelp= Max #elements in a weldpass (+1 EK directive 12/22/2011)
 mirror1file<<mWPcs<<"\n"; //maxelcs= Max #elements a weldpass cross-section
 if(medge<1)medge=1; //Policy: default to min 1  EFP 10/12/2011
 mirror1file<<medge<<"\n"; //medge= #edges with edge effects
 icount=0;for(i=0;i<base.npoin;i++)if(icount<base.node_map[i])icount=base.node_map[i];
 mirror1file<<icount+1<<"\n"; //Highest occurring node number EFP 1/06/2012
//cccccccccccccccc start Time taken for this weld-set incl. user-specified cooling, not overlap [EFP does not approve of this non-element-area-based algorithm] EFP 5/18/2012
 mirror1file.precision(8);
 mirror1file<<timeWeld<<"\n";
 mirror1file.precision(6);
 mirror1file<<laplim<<"\n"; //"laplim" needed for overlap & merging  EFP 9/03/2012 Correction Bud 12/13/2012
 mirror1file.precision(8);
 mirror1file<<wp.tcutl[0]<<"\n"; //Correction: Low-cut temperature for 1st WP  EFP 5/22/2012
 mirror1file.precision(6);
////cccccccccccccccc end
////cccccccccccccccc start 8 extra data cards EFP 8/19/2012
 mirror1file<<solidshellsw<<"\n"; //solidshellsw  EFP 5/20/2012
// mirror1file<<lasttimerec<<"\n"; //Core-to-core overlap  EFP 5/20/2012
 mirror1file.precision(8);
 mirror1file<<lasttimecom<<"\n"; //Core-to-core overlap  EFP 1/25/2013
 mirror1file<<wp.tcuth[0]<<"\n"; //Pre-heat temperature for 1st WP  EFP 5/22/2012
 mirror1file.precision(6);
 mirror1file<<base.el_map[base.nelt-1]+1<<"\n"; //Global max element#  EFP 9/16/2012
 mirror1file.precision(8);
 mirror1file<<delt<<"\n"; //Data for standalone mergeCTSPcore  EFP 9/23/2012
 mirror1file<<lasttime<<"\n"; //user-spec IP cooling time on last WP per core (sec) EFP 9/23/2012
 mirror1file.precision(6);
 mirror1file<<laststep<<"\n"; //user-spec IP cooling steps on last WP per core  EFP 9/23/2012
 mirror1file<<0<<"\n";
////10 more
 mirror1file<<0<<"\n";mirror1file<<0<<"\n";mirror1file<<0<<"\n";mirror1file<<0<<"\n";mirror1file<<0<<"\n";
 mirror1file<<0<<"\n";mirror1file<<0<<"\n";mirror1file<<0<<"\n";mirror1file<<0<<"\n";mirror1file<<0<<"\n";
 mirror1file.close();
//	 }
Screen->Cursor=Save_Cursor;
}

//---------------------------------------------------------------------------
int TForm1::merge_CTSPmcm(int solidshellsw,int loCore,int upCore) //Internally-generated time.out info  EFP 1/07/2013
//CAUTION: Unfinished shell/overlap coding  EFP 6/13/2012
//Merge temp.out & time.out files from CTSPmulticore subdirectories  EFP 11/07/2011
//Version with "extra cooling steps on last WP per core" improvement  EFP 5/22/2012
//solidshellsw=0 (solid, with one column of temperature);1 (shell, with five columns of temperatures)
//CTSP convention (outemp.f): Write temperature if >tcuth

//Typical temp.out format (5-temperature shell)
//  0.0000000E+00           0
//   92.51211              10
//  349         50.35         50.49         50.58         50.62         50.61
//  350        100.14        100.73        101.14        101.36        101.39
// 4218        131.42        131.42        131.42        131.42        131.42
// 4573        138.31        138.31        138.31        138.31        138.31
//10785        150.05        150.05        150.05        150.05        150.05
//19599        144.25        144.86        145.24        145.40        145.32
//19629        193.14        180.07        171.68        163.65        153.01
//19640        137.48        138.10        138.47        138.58        138.44
//19667         79.42         85.05         88.85         89.93         87.93
//21072       1270.17       1270.17       1270.17       1270.17       1270.17
//   185.0281              16
//...

//Typical time.out
//           1  0.0000000E+00
//           2   92.51211
//           3   185.0281
//           4   254.1281
//           5   256.9281
//           6   259.7199
//           7   277.5402
//...
{int ic=0,nic=0,nrc=0,upCount=0;
 long in=0,id=0,is=0,ip=0,nnd=0,nnl=0,nnla=0,mstepi=0,mstori=0,mdummy=0,istor=0,nmerg=0,imerg=0,hinode=0,ntimeSer=0,
	  laplim=0,ir=0,lapinit=0,lapinitold=0,bottomloc=0,nsum=0,im=0,imm=0,imstart=0,hinodemax=0,nconcise=0,
	  activen=0,activez=0,irep=0,nreps=0,avamem=0,ndeltrep=0,lotst=0,uptst=0,WPcore=0,laststep=0,larr[5], *nmode_map=NULL, *rmev_map=NULL;
 float timedif=0.,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,tWeldi=0.,km=0.,tcutl=0.,tlapinit=0.,tlapinitold=0.,
	  darr[5],timeSer=0.,fdummy=0.,curdiff=0.,lasttime=0.,aval=0.,sum=0.,a0=0., *readstor=NULL, *mergstor=NULL, *auxlstor=NULL, *timeSeries=NULL, *paramdat=NULL;
 char extensChar1a[]="CTSPsubd00",extensChar1b[]="CTSPsubd0",extensChar1c[]="CTSPsubd",
	  outChar1[]="\\temp.out",outChar2[]="\\time.out",outChar3[]="\\param.in",//Policy: do not use Model_CTSP_param.in
	  outChar4[]="\\tempRevise.out",
	  descript[76], *fnNeed=NULL, *pmNeed=NULL, *otNeed=NULL;
//mmmmmmmmmmmmm
if(1==1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate",L"Needs update",MB_OK);exit(0);}
//mmmmmmmmmmmmm
/*
////////////////////// start timeSeries  EFP 6/21/2012
//ifstream viewfile3("time.out",ios::nocreate);
//if(viewfile3){ntimeSer=0;
//			  while(!viewfile3.eof()) //EFP 7/02/2012
//				{viewfile3.getline(descript,76);
//				 if(strlen(descript))ntimeSer++;
//				}
//			  viewfile3.close();
//			  ifstream viewfile3("time.out",ios::nocreate);
//			  timeSeries=new float[ntimeSer];
//			  for(ic=0;ic<ntimeSer;ic++)viewfile3>>in>>timeSeries[ic];
//			  viewfile3.close();
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
///////////////////////////////////////
 hinodemax=upCount=ntimeSer=0;timedif=0.;
 for(ic=loCore;ic<upCore;ic++){
if(ic<10-1){fnNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
			StringCchCopy(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1a);
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
			pmNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
			StringCchCopy(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1a);
			StringCchCat(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
			StringCchCat(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
		   }
else if(ic<100-1){fnNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
				  StringCchCopy(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1b);
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
				  pmNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
				  StringCchCopy(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1b);
				  StringCchCat(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
				  StringCchCat(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
				 }
else {fnNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
	  StringCchCopy(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1c);
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
	  pmNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
	  StringCchCopy(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1c);
	  StringCchCat(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
	  StringCchCat(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
	 }
ifstream viewfile1(fnNeed,ios::nocreate);delete [] fnNeed;
////////////
ifstream viewfile2(pmNeed,ios::nocreate);delete [] pmNeed;
if(viewfile1){viewfile1.close();upCount++;   //Reorganized by EFP 8/14/2012
			  if(viewfile2){viewfile2>>mstepi; //Read 11-parameter param.in
							viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>WPcore;viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>mdummy;
							viewfile2>>hinode;viewfile2>>tWeldi;viewfile2>>laplim;viewfile2>>tcutl;
							viewfile2>>solidshellsw; //Overrides argument value EFP 8/19/2012

 viewfile2>>mdummy;viewfile2>>fdummy;viewfile2>>mdummy;viewfile2>>fdummy; //Data for standalone mergeCTSPcore  EFP 9/23/2012
 viewfile2>>lasttime; //user-spec IP cooling time on last WP per core (sec) EFP 9/23/2012
 viewfile2>>laststep; //user-spec IP cooling steps on last WP per core  EFP 9/23/2012

							viewfile2.close();
							hinodemax=max(hinode,hinodemax);
/////////
viewfile1>>tstep>>nnl;
if(ic=loCore){timeSeries=new float[hinode];
			  timeSeries[ntimeSer]=tstep+timedif;ntimeSer++;
			 }
for(ir=1;ir<laplim;ir++){viewfile1>>tstep>>nnl;   //SWITCH to strlen HERE
						 timeSeries[ntimeSer]=tstep+timedif;ntimeSer++;
						 if(nnl)for(in=0;in<nnl;in++)viewfile1>>id>>t11;
						}
if(laststep>1){aval=1.;sum=aval; //EFP 11/24/2012
			   for(in=0;in<laststep-1;in++){aval=aval*1.2;sum=sum+aval;}
			   a0=lasttime/sum;
			   for(in=0;in<laststep-1;in++){tstep=tstep+a0;a0=a0*1.2; //TBD: UPDATE mergeCTSP coding here  EFP 1/18/2013
//heritageTime=heritageTime+wp.timeInterval[k]*log((wp.stepInterval[k]-float(j)+float(j)*0.0353)/((wp.stepInterval[k]-float(j)-1+float(j+1)*0.0353))/log(1./0.0353);
											timeSeries[ntimeSer]=tstep+timedif;ntimeSer++;
										   }
			  }
timeSeries[ntimeSer]=tWeldi+timedif;ntimeSer++;
timedif=timedif+tWeldi;
/////////
						   }
			  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate",L"Missing CTSPsubd...\param.in",MB_OK);exit(0);}
			 }
else break;
////////////
							  }

////////////////// EFP 8/15/2012
if(upCount<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate",L"No CTSPsubd... found. Wrong directory chosen? ",MB_OK);exit(0);}
else if(upCount<2){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate",L"Only 1 CTSPsubd... found so no merge?",MB_OK);exit(0);}
//////////////////
/////////////////
ofstream viewfile3("timex.out");
for(ic=0;ic<ntimeSer;ic++)viewfile3<<setw(12)<<ic+1<<setw(15)<<scientific<<timeSeries[ic]<<"\n";
viewfile3.close();
/////////////////
paramdat=new float[2*upCount];
honk<<upCount<<" UPcount "<<hinodemax<<"\n";
/////////////////
 nmode_map=new long[hinodemax];for(is=0;is<hinodemax;is++)nmode_map[is]=0;
/////////////////
 upCore=upCount;lapinit=0;timedif=tlapinit=0.;
 for(ic=loCore;ic<upCore-1;ic++){
if(ic<10-1){fnNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
			StringCchCopy(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1a);
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
			pmNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
			StringCchCopy(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1a);
			StringCchCat(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
			StringCchCat(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
			otNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1];
			StringCchCopy(otNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,extensChar1a);
			StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,IntToStr(ic+1).c_str());
			StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,outChar4);
		   }
else if(ic<100-1){fnNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
				  StringCchCopy(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1b);
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
				  pmNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
				  StringCchCopy(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1b);
				  StringCchCat(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
				  StringCchCat(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
				  otNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1];
				  StringCchCopy(otNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,extensChar1b);
				  StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,IntToStr(ic+1).c_str());
				  StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,outChar4);
				 }
else {fnNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
	  StringCchCopy(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1c);
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
	  pmNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
	  StringCchCopy(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1c);
	  StringCchCat(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
	  StringCchCat(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
	  otNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1];
	  StringCchCopy(otNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,extensChar1c);
	  StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,IntToStr(ic+1).c_str());
	  StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,outChar4);
	 }
						   ifstream viewfile1(fnNeed,ios::nocreate);delete [] fnNeed;
						   ifstream viewfile2(pmNeed,ios::nocreate);delete [] pmNeed;
						   if(viewfile1 && viewfile2)
							 {viewfile2>>mstepi; //Read 11-parameter param.in
							  viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>WPcore;viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>mdummy;
							  viewfile2>>hinode;viewfile2>>tWeldi;viewfile2>>laplim;viewfile2>>tcutl;
//							  viewfile2>>solidshellsw; //Overrides argument value EFP 8/19/2012
							  viewfile2.close();
paramdat[2*ic]=tWeldi;paramdat[2*ic+1]=tcutl; //EFP 7/02/2012
////mstori=mstepi-laplim-1;
//mstori=mstepi-WPcore+1-laplim+1;
mstori=mstepi-laplim+1; //Bud's correction  EFP 12/13/2012
honk<<mstori<<" Memo "<<mstepi<<" "<<laplim<<" "<<hinodemax<<"\n";
//							  if(solidshellsw)auxlstor=new float[5*hinode];else auxlstor=new float[hinode];
//honk<<"\n";honk<<"\n";honk<<ic<<" #core just read param.in "<<hinode<<" "<<loCore<<" "<<upCore<<"\n";
//							  ofstream outfile3(otNeed);delete [] otNeed;
//							  if(solidshellsw){readstor=new float[(5*hinode+1)*mstori];for(is=0;is<(5*hinode+1)*mstori;is++)readstor[is]=0.;}
//							  else {readstor=new float[(hinode+1)*mstori];for(is=0;is<(hinode+1)*mstori;is++)readstor[is]=0.;}

honk<<"\n";honk<<"\n";honk<<ic<<" #core just read param.in "<<hinode<<" "<<loCore<<" "<<upCore<<"\n";
							  if(solidshellsw){auxlstor=new float[5*hinode];
											   readstor=new float[(5*hinode+1)*mstori];for(is=0;is<(5*hinode+1)*mstori;is++)readstor[is]=0.;
											  }
							  else {auxlstor=new float[hinode];
									readstor=new float[(hinode+1)*mstori];for(is=0;is<(hinode+1)*mstori;is++)readstor[is]=0.;
								   }
							  ofstream outfile3(otNeed);delete [] otNeed;

// Task: Badri Athreya says that merge_CTSPmcm() is too slow under Opinion#1 below.
//       (i.e. inputing the "id/t11" bulk of temp.out files using viewfile1.getline/parse protocol)
//       Accordingly, EFP switched to Opinion#2, using faster viewfile1>>id>>t11;
//       However, it is cats ass coding & we must test on Linux.
//
// Opinion#1 (slow so superceded):
// viewfile1>>tstep>>nnd; //FATAL: use getline() in order to remove linefeed character
// However, parse_cdm() is unsatisfactory because an integral "tstep" value might corrupt it.
// FIX IT by introducing parse_cdms().  EFP 11/08/2011
// showpoint & setprecision() added below EFP 12/15/2011

// Opinion#2 (currently implemented & faster):
// Use viewfile1.getline for "nnd tstep" header on each temp.out file (but only output first header)
// Use viewfile1.getline for the "nnl tstep" cards in each temp.out file.
// For some wacko "while(!viewfile1.eof())" reason, a zero nnl will be read.
// Test for nnl=zero before reading/outputing id/t11/etc data.
// This "cats ass" coding has been tested on MS Windows but not yet on Linux. EFP 3/29/2012
//
// TBD: Test & confirm appropriate solid-solid/shell-shell input formats EFP 3/29/2012

//							  viewfile1.getline(descript,76);parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
//							  outfile3<<setw(15)<<scientific<<tstep<<setw(12)<<nnd<<"\n";

							  activen=0;
							  for(ir=0;ir<laplim;ir++)
								{viewfile1>>tstep>>nnl;   //SWITCH to strlen HERE
//								 viewfile1.getline(descript,76);parse_cdm(descript,2,&nic,&nrc,larr,darr);nnl=larr[0];tstep=darr[0];
//honk<<ir+1<<" "<<tstep<<" "<<nnl<<" lappers\n";
								 outfile3<<setw(15)<<scientific<<tstep<<setw(12)<<nnl<<"\n";
/////////////////
honk<<ic+1<<" "<<ir+1<<" ReviseRegular "<<tstep<<" "<<nnl<<"\n";
/////////////////
								 if(nnl) //This is cats ass coding but it works. EFP 3/29/2012
//readstor 	 PROBLEM HERE IF nnl=0  EFP 6/24/2012
									{if(ir==laplim-1)readstor[0]=tstep;
									 if(solidshellsw){for(in=0;in<nnl;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
																			outfile3<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<setw(14)<<t12<<setw(14)<<t13<<setw(14)<<t14<<setw(14)<<t15<<"\n";
																			nmode_map[id-1]=1;
																			if(ir==laplim-1){activen=1;readstor[(id-1)*5+1]=t11;readstor[(id-1)*5+2]=t12;readstor[(id-1)*5+3]=t13;readstor[(id-1)*5+4]=t14;readstor[(id-1)*5+5]=t15;}
																		   } //setw(5->7) above & below for more space EFP 12/15/2011
													 }
									 else {for(in=0;in<nnl;in++){viewfile1>>id>>t11;outfile3<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
																 nmode_map[id-1]=1;
																 if(ir==laplim-1){activen=1;readstor[id]=t11;}
																}
										  }
									}
								}
////////
if(!activen){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate",L"VFT_merge has a problem with inactive nodes",MB_OK);exit(0);}
////////
							  activez=0; //New policy: Include first occurring time point with no active nodes and assign zero temperature throughout (i.e. NOT tcutl) EFP 7/02/2012
////							  for(ir=laplim+1;ir<mstepi-1;ir++) //Why....
//							  for(ir=laplim;ir<mstepi-WPcore+1;ir++) //Why....
							  for(ir=laplim;ir<mstepi;ir++) //Why.... Bud's correction  EFP 12/13/2012
								{viewfile1>>tstep>>nnl;
//honk<<ir+1<<" "<<tstep<<" "<<nnl<<" stoppers\n";
								 if(nnl) //This is cats ass coding but it works. EFP 3/29/2012
									{activen++;
									 if(solidshellsw){readstor[(5*hinode+1)*(ir-laplim+1)+0]=tstep;
													  for(in=0;in<nnl;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
																			nmode_map[id-1]=1;
																			readstor[(5*hinode+1)*(ir-laplim+1)+(id-1)*5+1]=t11;readstor[(5*hinode+1)*(ir-laplim+1)+(id-1)*5+2]=t12;readstor[(5*hinode+1)*(ir-laplim+1)+(id-1)*5+3]=t13;
																			readstor[(5*hinode+1)*(ir-laplim+1)+(id-1)*5+4]=t14;readstor[(5*hinode+1)*(ir-laplim+1)+(id-1)*5+5]=t15;
																		   } //setw(5->7) above & below for more space EFP 12/15/2011
													 }
									 else {readstor[(hinode+1)*(ir-laplim+1)+0]=tstep;
										   for(in=0;in<nnl;in++){viewfile1>>id>>t11;
																 nmode_map[id-1]=1;
																 readstor[(hinode+1)*(ir-laplim+1)+id]=t11;
																}
										  }
									}
								 else if(!activez){activen++;activez++; //All readstor[] assumed zeroed  EFP 7/02/2012
												   if(solidshellsw)readstor[(5*hinode+1)*(ir-laplim+1)+0]=tstep;
												   else readstor[(hinode+1)*(ir-laplim+1)+0]=tstep;
												  }
								}
							  lapinitold=lapinit;tlapinitold=tlapinit;
//							  for(is=lapinit;is<ntimeSer;is++){if(fabs(timeSeries[is]-tWeldi-tlapinit)<0.001){lapinit=is+1;tlapinit=timeSeries[is];break;}}
							  curdiff=1.e+25;
							  for(is=lapinit;is<ntimeSer;is++)  //Version to accommodate imprecision EFP12/21/2012
								{if(fabs(timeSeries[is]-tWeldi-tlapinit)<curdiff)
								   {lapinit=is+1;tlapinit=timeSeries[is];
									curdiff=fabs(timeSeries[is]-tWeldi-tlapinit);
								   }
								 else break;
								}
//honk<<ic<<" LAPPLAND "<<lapinit<<" "<<tlapinit<<" "<<timedif<<"\n";
if(solidshellsw){
///////////////////////
							  for(ir=lapinit;ir<ntimeSer;ir++) //Why does this "lapinit" differ vs "lapinitold+laplim+1" below?
								{bottomloc=0;
								 if(timeSeries[ir]-timedif<=readstor[(5*hinode+1)*(activen-1)+0])
								   {for(im=bottomloc;im<activen;im++)
									 {if(timeSeries[ir]-timedif>readstor[(5*hinode+1)*im+0])bottomloc=im;
									  else break;
									 }
km=((readstor[(5*hinode+1)*(bottomloc+1)+0]-timeSeries[ir]+timedif))/(readstor[(5*hinode+1)*(bottomloc+1)+0]-readstor[(5*hinode+1)*bottomloc+0]);nsum=0;
for(in=0;in<5*hinode;in++)auxlstor[in]=km*readstor[(5*hinode+1)*bottomloc+in+1]+(1.-km)*readstor[(5*hinode+1)*(bottomloc+1)+in+1];
for(in=0;in<hinode;in++)if(auxlstor[5*in+0]>tcutl || auxlstor[5*in+1]>tcutl || auxlstor[5*in+2]>tcutl || auxlstor[5*in+3]>tcutl || auxlstor[5*in+4]>tcutl)nsum++;
outfile3<<setw(11)<<resetiosflags(ios::scientific)<<dec<<showpoint<<setprecision(7)<<timeSeries[ir]-tlapinitold<<setw(16)<<nsum<<"\n";
if(nsum){for(in=0;in<hinode;in++)if(auxlstor[5*in+0]>tcutl || auxlstor[5*in+1]>tcutl || auxlstor[5*in+2]>tcutl || auxlstor[5*in+3]>tcutl || auxlstor[5*in+4]>tcutl)
		   outfile3<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<auxlstor[5*in+0]<<setw(14)<<auxlstor[5*in+1]<<setw(14)<<auxlstor[5*in+2]<<setw(14)<<auxlstor[5*in+3]<<setw(14)<<auxlstor[5*in+4]<<"\n";
		}
								   }
								 else break;
								}
///////////////////////
				}
else {
							  for(ir=lapinitold+laplim+1;ir<ntimeSer;ir++)
								{bottomloc=0;
honk<<ir<<" "<<activen<<" "<<timeSeries[ir]-timedif<<" "<<timedif<<" capa "<<readstor[(hinode+1)*(activen-1)+0]<<"\n";
								 if(timeSeries[ir]-timedif<=readstor[(hinode+1)*(activen-1)+0])
								   {for(im=bottomloc;im<activen;im++)
									 {if(timeSeries[ir]-timedif>readstor[(hinode+1)*im+0])bottomloc=im;
									  else break;
									 }
//honk<<readstor[(hinode+1)*(bottomloc+1)+0]<<" "<<timeSeries[ir]-timedif<<" roos "<<readstor[(hinode+1)*(bottomloc+1)+0]<<" "<<readstor[(hinode+1)*bottomloc+0]<<"\n";
									km=((readstor[(hinode+1)*(bottomloc+1)+0]-timeSeries[ir]+timedif))/(readstor[(hinode+1)*(bottomloc+1)+0]-readstor[(hinode+1)*bottomloc+0]);nsum=0;
									for(in=0;in<hinode;in++)
									  {auxlstor[in]=km*readstor[(hinode+1)*bottomloc+in+1]+(1.-km)*readstor[(hinode+1)*(bottomloc+1)+in+1];
									   if(auxlstor[in]>tcutl)nsum++;
									  }
outfile3<<setw(11)<<resetiosflags(ios::scientific)<<dec<<showpoint<<setprecision(7)<<timeSeries[ir]-tlapinitold<<setw(16)<<nsum<<"\n";
/////////////////
honk<<ic+1<<" "<<ir+1<<" ReviseInterp "<<timeSeries[ir]-tlapinitold<<" "<<nsum<<"\n";
/////////////////
if(nsum){for(in=0;in<hinode;in++)if(auxlstor[in]>tcutl)outfile3<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<auxlstor[in]<<"\n";
		}
//honk<<ir<<" "<<bottomloc<<" "<<nsum<<" "<<km<<" SuperF\n";
//										 }
								   }
								 else break;
								}
	 }
							  viewfile1.close();outfile3.close();
							  delete [] auxlstor;delete [] readstor;
							  timedif=timedif+tWeldi;
							 }
						   else break;
						  }



//////////////////////
//////////////////////
//////////////////////
//////////////////////
 ic=upCore-1;
if(ic<10-1){fnNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
			StringCchCopy(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1a);
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
			pmNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
			StringCchCopy(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1a);
			StringCchCat(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
			StringCchCat(pmNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
		   }
else if(ic<100-1){fnNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
				  StringCchCopy(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1b);
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
				  pmNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
				  StringCchCopy(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1b);
				  StringCchCat(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
				  StringCchCat(pmNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
				 }
else {fnNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
	  StringCchCopy(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1c);
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
	  pmNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1];
	  StringCchCopy(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,extensChar1c);
	  StringCchCat(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,IntToStr(ic+1).c_str());
	  StringCchCat(pmNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar3)+1,outChar3);
	 }
 ifstream viewfile1(fnNeed,ios::nocreate);delete [] fnNeed;
 ifstream viewfile2(pmNeed,ios::nocreate);delete [] pmNeed;
 viewfile2>>mstepi;viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>WPcore;viewfile2>>mdummy;viewfile2>>mdummy;viewfile2>>mdummy;
 viewfile2>>hinode;viewfile2>>tWeldi;viewfile2>>laplim;viewfile2>>tcutl;
// viewfile2>>solidshellsw; //Overrides argument value EFP 8/19/2012
 viewfile2.close();
 paramdat[2*ic]=tWeldi;paramdat[2*ic+1]=tcutl; //EFP 7/02/2012
//// for(ir=0;ir<mstepi-1;ir++){viewfile1>>tstep>>nnl;   //SWITCH to strlen HERE
// for(ir=0;ir<mstepi-WPcore+1;ir++)
 for(ir=0;ir<mstepi;ir++) //Bud's correction  EFP 12/13/2012
						   {viewfile1>>tstep>>nnl;   //SWITCH to strlen HERE
							if(nnl){
if(solidshellsw)for(in=0;in<nnl;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;nmode_map[id-1]=1;} //setw(5->7) above & below for more space EFP 12/15/2011
else            for(in=0;in<nnl;in++){viewfile1>>id>>t11;nmode_map[id-1]=1;}
								   }
						   }
 viewfile1.close();
 nconcise=0;for(is=0;is<hinodemax;is++)if(nmode_map[is]){nconcise++;nmode_map[is]=nconcise;}
 honk<<nconcise<<" "<<hinodemax<<" nconcise+hinodemax\n";

/////////////////////////
 rmev_map=new long[nconcise];nsum=0;for(is=0;is<hinodemax;is++)if(nmode_map[is]){rmev_map[nsum]=is;nsum++;}
/////////////////////////

//////////////////////
//////////////////////
//////////////////////
//////////////////////

//%%%%%%%%%%%%%%%%%%%
//              SP numbers=ms.dwAvailPhys/4 =MXIMEM;DP numbers=ms.dwAvailPhys/(4*MPREC) =MXIMEM/MPREC;
//              Memory coding to replace MRAM as follows:
//                  MEMORYSTATUS ms;ms.dwLength=sizeof(MEMORYSTATUS);
//                  GlobalMemoryStatus(&ms);
//                  honk<<ms.dwTotalPhys<<" TPhys "<<ms.dwAvailPhys<<"\n";
//                  honk<<ms.dwTotalPageFile<<" TFile "<<ms.dwAvailPageFile<<"\n";
//                  honk<<ms.dwTotalVirtual<<" TVirt "<<ms.dwAvailVirtual<<"\n";
//                  MXIMEM=ms.dwAvailPhys/4;
//                  RAM_AVAIL=(MXIMEM-.............)/MPREC;
//       0
//GlobalMemoryStatus(&ms);
//if(4*(ms.dwAvailPhys/20)>unsigned((ntranche+5)*nFacets+3*ntranche+2)) // 80% of available long word memory
//%%%%%%%%%%%%%%%%%%%
MEMORYSTATUS ms;ms.dwLength=sizeof(MEMORYSTATUS);GlobalMemoryStatus(&ms);
honk<<"\n";
honk<<ms.dwTotalPhys<<" TPhys "<<ms.dwAvailPhys<<"\n";
honk<<ms.dwTotalPageFile<<" TFile "<<ms.dwAvailPageFile<<"\n";
honk<<ms.dwTotalVirtual<<" TVirt "<<ms.dwAvailVirtual<<"\n";
honk<<"\n";
//TBD: Test  mergstor=new float[(ntimeSer-1)*5*nconcise] memory & split if necessary using GlobalXXX memory info


 ofstream outfile1("temp.out");
 //ofstream outfile2("time.out");
// timedif=0.;
 //max1=1;
// if(solidshellsw){mergstor=new float[(ntimeSer-1)*5*hinodemax];for(is=0;is< (ntimeSer-1)*5*hinodemax;is++)mergstor[is]=0.;
//				  auxlstor=new float[5*hinodemax];
//				 }
// else {mergstor=new float[(ntimeSer-1)*hinodemax];for(is=0;is< (ntimeSer-1)*hinodemax;is++)mergstor[is]=0.;
//	   auxlstor=new float[hinodemax];
//	  }
 if(solidshellsw){auxlstor=new float[5*nconcise];
				  avamem=ms.dwAvailPhys/4 -1048576;nreps=long(1.+float((ntimeSer-1)*5*nconcise)/float(avamem));
				  if(nreps>1)ndeltrep=long(1.+float(ntimeSer-1)/float(nreps));else ndeltrep=ntimeSer-1;
				  mergstor=new float[ndeltrep*5*nconcise];
				 }
 else {auxlstor=new float[nconcise];
	   avamem=ms.dwAvailPhys/4 -1048576;nreps=long(1.+float((ntimeSer-1)*nconcise)/float(avamem));
//nreps=2;
	   if(nreps>1)ndeltrep=long(1.+float(ntimeSer-1)/float(nreps));else ndeltrep=ntimeSer-1;
honk<<avamem<<" "<<nreps<<" repoman "<<ndeltrep<<" "<<ntimeSer-1<<"\n";
	   mergstor=new float[ndeltrep*nconcise];  // This should be ntimeSer-1 --> ntimeSer
	  }
///////////////////
////////////////////
/////////////////////
lotst=0;
for(irep=0;irep<nreps;irep++){timedif=0.;
							  if(solidshellsw)for(is=0;is<ndeltrep*5*nconcise;is++)mergstor[is]=0.;
							  else 			  for(is=0;is<ndeltrep*nconcise;is++)mergstor[is]=0.;
							  uptst=lotst+ndeltrep;
							  if(uptst>ntimeSer-1)uptst=ntimeSer-1;
honk<<irep<<" Neander "<<lotst<<" "<<uptst<<"\n";
 for(ic=loCore;ic<upCore;ic++){if(ic<upCore-1){
if(ic<10-1){fnNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1];
			StringCchCopy(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,extensChar1a);
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,IntToStr(ic+1).c_str());
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,outChar4);
		   }
else if(ic<100-1){fnNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1];
				  StringCchCopy(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,extensChar1b);
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,IntToStr(ic+1).c_str());
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,outChar4);
				 }
else {fnNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1];
	  StringCchCopy(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,extensChar1c);
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,IntToStr(ic+1).c_str());
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar4)+1,outChar4);
	 }
											  }
							   else {
if(ic<10-1){fnNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
			StringCchCopy(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1a);
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
			StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
		   }
else if(ic<100-1){fnNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
				  StringCchCopy(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1b);
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
				  StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
				 }
else {fnNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1];
	  StringCchCopy(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,extensChar1c);
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,IntToStr(ic+1).c_str());
	  StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+strlen(outChar1)+1,outChar1);
	 }
									}
honk<<fnNeed<<" opening REVISED\n";
							   ifstream viewfile1(fnNeed,ios::nocreate);delete [] fnNeed;
							   if(viewfile1)
								 {tWeldi=paramdat[2*ic];tcutl=paramdat[2*ic+1]; //EFP 7/02/2012
								  viewfile1.getline(descript,76);parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
								  if(irep==0 && ic==loCore)
									{if(nnd){
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate",L"First time card of first WP must not have temperature cards.",MB_OK);exit(0);
											}
									 else outfile1<<setw(15)<<scientific<<tstep+timedif<<setw(12)<<nnd<<"\n";
									}
								  imstart=0;
// Programming note: The following coding replaces do{}while(!...eof()) with
// while(!...eof()){} but eof() still fails to detect the end of file.
// In accordance with suggestions on www.msdn.com, EFP switched to the string length test
// viewfile1.getline(descript,76);if(strlen(descript)){}     EFP 6/25/2012
////								  do {
								  while(!viewfile1.eof())
									 {viewfile1.getline(descript,76);
									  if(strlen(descript))
										{parse_cdm(descript,2,&nic,&nrc,larr,darr);nnl=larr[0];tstep=darr[0];
//if(ic==4-1)honk<<tstep<<" "<<nnl<<" "<<imstart<<" "<<ntimeSer-1<<" Graeca\n";
										 if(nnl) //This is cats ass coding but it works. EFP 3/29/2012 readstor 	 PROBLEM HERE IF nnl=0  EFP 6/24/2012
										   {
////
//if(ic==4-1){for(im=imstart;im<ntimeSer;im++)honk<<im<<" "<<timeSeries[im]<<" "<<fabs(timeSeries[im]-tstep-timedif)<<" "<<tstep<<" "<<timedif<<" MOO\n";
//		   }
////

//											for(im=imstart;im<ntimeSer;im++)if(fabs(timeSeries[im]-tstep-timedif)<0.001)break;
											curdiff=1.e+25;
											im=imstart;
											for(imm=imstart;imm<ntimeSer;imm++)  //Version to accommodate imprecision EFP12/21/2012
											  {if(fabs(timeSeries[imm]-tstep-timedif)<curdiff){curdiff=fabs(timeSeries[imm]-tstep-timedif);
																							   im=imm;
																							  }
											   else break;
											  }
//honk<<ic<<" "<<tstep<<" "<<nnl<<" "<<im<<" Isandlewana "<<timeSeries[im]<<" "<<timedif<<"\n";
											if(solidshellsw){for(is=0;is<5*nconcise;is++)auxlstor[is]=0.;
															 for(in=0;in<nnl;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
																				   auxlstor[(nmode_map[id-1]-1)*5+0]=t11;auxlstor[(nmode_map[id-1]-1)*5+1]=t12;auxlstor[(nmode_map[id-1]-1)*5+2]=t13;auxlstor[(nmode_map[id-1]-1)*5+3]=t14;auxlstor[(nmode_map[id-1]-1)*5+4]=t15;
																				  } //setw(5->7) above & below for more space EFP 12/15/2011
//for(is=0;is<5*nconcise;is++)mergstor[(im-1)*5*nconcise+is]=mergstor[(im-1)*5*nconcise+is]+auxlstor[is];
if(im-1>=lotst && im-1<uptst)for(is=0;is<5*nconcise;is++)mergstor[(im-1-lotst)*5*nconcise+is]=mergstor[(im-1-lotst)*5*nconcise+is]+auxlstor[is];
															}
											else {for(is=0;is<nconcise;is++)auxlstor[is]=0.;
												  for(in=0;in<nnl;in++){viewfile1>>id>>t11;auxlstor[nmode_map[id-1]-1]=t11;}
//for(is=0;is<nconcise;is++)mergstor[(im-1)*nconcise+is]=mergstor[(im-1)*nconcise+is]+auxlstor[is];

if(ic==4-1)honk<<irep<<" "<<ic<<" "<<im<<" "<<lotst<<" "<<uptst<<"\n";

if(im-1>=lotst && im-1<uptst)for(is=0;is<nconcise;is++){

//if(is==1417-1)honk<<irep<<" "<<ic<<" "<<im<<" "<<lotst<<" "<<uptst<<" "<<is<<" "<<mergstor[(im-1-lotst)*nconcise+is]<<" "<<auxlstor[is]<<"\n";
														mergstor[(im-1-lotst)*nconcise+is]=mergstor[(im-1-lotst)*nconcise+is]+auxlstor[is];
													   }
												 }
											imstart=im;
										   }
										}
									 }
								  viewfile1.close();timedif=timedif+tWeldi;
								 }
							   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Failure",L"Missing tempRevise.txt",MB_OK);}
							  }

/////////////////////////
// delete [] auxlstor;
// rmev_map=new long[nconcise];nsum=0;for(is=0;is<hinodemax;is++)if(nmode_map[is]){rmev_map[nsum]=is;nsum++;}
// delete [] nmode_map;
/////////////////////////

if(solidshellsw){
////
// for(is=1;is<ntimeSer;is++){
 for(is=lotst+1;is<uptst+1;is++){
							nsum=0;
							for(in=0;in<nconcise;in++)if(mergstor[(is-1-lotst)*5*nconcise+5*in+0]>tcutl ||
														 mergstor[(is-1-lotst)*5*nconcise+5*in+1]>tcutl ||
														 mergstor[(is-1-lotst)*5*nconcise+5*in+2]>tcutl ||
														 mergstor[(is-1-lotst)*5*nconcise+5*in+3]>tcutl ||
														 mergstor[(is-1-lotst)*5*nconcise+5*in+4]>tcutl)nsum++;
outfile1<<setw(15)<<scientific<<timeSeries[is]<<setw(12)<<nsum<<"\n";
if(nsum){
for(in=0;in<nconcise;in++)if(mergstor[(is-1-lotst)*5*nconcise+5*in+0]>tcutl ||
							 mergstor[(is-1-lotst)*5*nconcise+5*in+1]>tcutl ||
							 mergstor[(is-1-lotst)*5*nconcise+5*in+2]>tcutl ||
							 mergstor[(is-1-lotst)*5*nconcise+5*in+3]>tcutl ||
							 mergstor[(is-1-lotst)*5*nconcise+5*in+4]>tcutl)
outfile1<<setw(7)<<rmev_map[in]+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<mergstor[(is-1-lotst)*5*nconcise+5*in+0]<<setw(14)
																			<<mergstor[(is-1-lotst)*5*nconcise+5*in+1]<<setw(14)
																			<<mergstor[(is-1-lotst)*5*nconcise+5*in+2]<<setw(14)
																			<<mergstor[(is-1-lotst)*5*nconcise+5*in+3]<<setw(14)
																			<<mergstor[(is-1-lotst)*5*nconcise+5*in+4]<<setw(14)<<"\n";
		}
						   }
////
				}
else {
////
// for(is=1;is<ntimeSer;is++)
 for(is=lotst+1;is<uptst+1;is++)
						   {nsum=0;for(in=0;in<nconcise;in++)if(mergstor[(is-1-lotst)*nconcise+in]>tcutl)nsum++;
							outfile1<<setw(15)<<scientific<<timeSeries[is]<<setw(12)<<nsum<<"\n";
							if(nsum){for(in=0;in<nconcise;in++)if(mergstor[(is-1-lotst)*nconcise+in]>tcutl)outfile1<<setw(7)<<rmev_map[in]+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<mergstor[(is-1-lotst)*nconcise+in]<<"\n";
									}
						   }
////
	 }


							  lotst=uptst;
							 }
/////////////////////
////////////////////
///////////////////
 outfile1.close();
 delete [] auxlstor;delete [] mergstor;delete [] rmev_map;delete [] paramdat;delete [] nmode_map;
////////////////////////////////
//	 }
// __finally {
Screen->Cursor=Save_Cursor;
//}
////////////////////// start EFP 6/21/2012
			  delete [] timeSeries; //CORRECTION: missing delete added  EFP 8/14/2012
//			 }
//else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Failure",L"Missing time.out time series",MB_OK);}
////////////////////// end
 return upCount;
*/
}
//---------------------------------------------------------------------------
// Fortran code from TimeStep.f  EFP 6/16/2012
//       subroutine TimeStep(mstep,np1,nt,maxtime,
//     $  maxwd,iw,timelast,stepmax,stepmin,emin)
//.............
//		st=ss/spe(iw,i)
//	if (nn.ne.1) then
//         DELT=STEP(nn)-STEP(nn-1)
//	else
//	   delt=5.0
//	endif
//         IF (ncool(iw,i).GT.1) THEN
//         CALL ExpoStep(DELT,tcool(iw,i),ncool(iw,i),T0,CM)
//         TMM=st
//         do 130 j=1,ncool(iw,i)
//          SM=T0*(EXP(CM*J)-1)
//         nn=nn+1
//           st=tmm+sm
//         step(nn+maxtime)=st+timelast
//130     continue
//	endif
//	if (ncool(iw,i).eq.1) THEN
//        nn=nn+1
//        step(nn+maxtime)=step(maxtime+nn-1)+tcool(iw,i)
//	endif
//		st=st*spe(iw,i)
//...........
//---------------------------------------------------------------------------
// Fortran code from ExpoStep.f  EFP 6/16/2012
//C     CALCUALTE THE TWO PARAMETERS(C AND T0) IN ORDER TO GENERATE THE COOLING
//C     TIME STEPS WITH A EXPONIENCIAL INCREASE.
//C     T(X)=T0*(EXP(C*X)-1)
//       SUBROUTINE ExpoStep(DELT,TOTAL,MAXN,T0,CM)
//       EMIN=0.0005
//       EMAX=50./MAXN
//       C1=EMIN
//       C2=EMAX-EMIN
//       CM=0.5*(C1+C2)
//       DO 10 I=1,10000
//         CALL CALCT3Point(C1,C2,CM,T1,T2,TM,T0,DELT,MAXN)
//         IF (ABS(TM-TOTAL).LE.EMIN) GOTO 20
//         CALL GetCenter(C1,C2,CM,T1,T2,TM,TOTAL)
//10     CONTINUE
//20     CONTINUE
//       RETURN
//	   END
void TForm1::ExpoStep(double DELT,double TOTAL,long MAXN,double *T0,double *CM)
{long i=0;double EMIN=0.0005,EMAX=50./double(MAXN),C1=0.,C2=0.,CMM=0.,T1=0.,T2=0.,TM=0.,T00=0.;
 C1=EMIN;C2=EMAX-EMIN;CMM=0.5*(C1+C2);T00= *T0;
 for(i=0;i<10000;i++){CALCT3Point(C1,C2,CMM,&T1,&T2,&TM,&T00,DELT,MAXN);
					  if(fabs(TM-TOTAL)<=EMIN)break;else GetCenter(&C1,&C2,&CMM,T1,T2,TM,TOTAL);
					 }
 *T0=T00; *CM=CMM;
}
//---------------------------------------------------------------------------
// Fortran code from Calct3Point.f  EFP 6/16/2012
//		 SUBROUTINE CALCT3Point(C1,C2,CM,T1,T2,TM,T0,DELT,MAXN)
//         CALL CALCTL(T1,T0,C1,MAXN,DELT)
//         CALL CALCTL(T2,T0,C2,MAXN,DELT)
//         CALL CALCTL(TM,T0,CM,MAXN,DELT)
//         RETURN
//		 END
void TForm1::CALCT3Point(double C1,double C2,double CM,double *T1,double *T2,double *TM,double *T0,double DELT,long MAXN)
{double TT0= *T0,TT1= *T1,TT2= *T2,TTM= *TM;
 calctl(&TT1,&TT0,C1,MAXN,DELT);calctl(&TT2,&TT0,C2,MAXN,DELT);calctl(&TTM,&TT0,CM,MAXN,DELT);
 *T0=TT0; *T1=TT1; *T2=TT2; *TM=TTM;
}
//---------------------------------------------------------------------------
// Fortran code from GetCenter.f  EFP 6/16/2012
//	  SUBROUTINE GetCenter(C1,C2,CM,T1,T2,TM,TOTAL)
//      IF (TOTAL.GT.T1.AND.TOTAL.LT.TM) THEN
//        C2=CM
//      ELSEIF (TOTAL.GT.TM.AND.TOTAL.LT.T2) THEN
//        C1=CM
//      ELSE
//        STOP 'ERROR IN SUBROUTINE GETCENTER. PLEASE DECREASE THE TOTAL
//     %   NUMBER OF COOLING STEPS, OR INCREASE THE TOTAL COOLING TIME.'
//      ENDIF
//      CM=0.5*(C1+C2)
//      RETURN
//	  END
void TForm1::GetCenter(double *C1,double *C2,double *CM,double T1,double T2,double TM,double TOTAL)
{if(TOTAL>T1 && TOTAL<TM)*C2= *CM;
 else if(TOTAL>TM && TOTAL<T2)*C1= *CM;
 else {honk<<"TERMINATE: ERROR IN SUBROUTINE GETCENTER. PLEASE DECREASE THE TOTAL \nNUMBER OF COOLING STEPS, OR INCREASE THE TOTAL COOLING TIME.\n";
	   exit(0);
	  }
 *CM=0.5*( *C1+ *C2);
}
//---------------------------------------------------------------------------
// Fortran code from Calctl.f  EFP 6/16/2012
//C     T(X)=T0*(EXP(C*X)-1)
//C     T0 AND C ARE TO BE DECIDED.
//C     CALCULATE T0
//C     DELT=T0*(EXP(C)-1): T(X)=DELT, X=1 (FIRST STEP)
//C     CALCULATE THE LAST TIME STEP
//       SUBROUTINE CALCTL(TL,T0,C,MAXN,DELT)
//       T0=DELT/(EXP(C)-1)
//       TL=T0*(EXP(C*MAXN)-1)
//       RETURN
//	   END
void TForm1::calctl(double *TL,double *T0,double C,long MAXN,double DELT){*T0=DELT/(exp(C)-1); *TL= *T0*(exp(C*float(MAXN))-1);}
//---------------------------------------------------------------------------
void TForm1::export_CTSP_NODE(char gVFTnameStem[]) // Identical to ABAQUS-format ASCII nodal geometry file *.inp (or *.in), delimited by ","
{long i=0; //Version with mirror file  EFP 3/26/2011
// char extensChar[]="_CTSP_node.in";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
// ofstream viewfile(fnNeed);delete [] fnNeed;
 ofstream mirrorfile("node.in");
// viewfile.setf(ios::scientific);
 mirrorfile.setf(ios::scientific);

 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
 //try {
 //viewfile.precision(6);
	  mirrorfile.precision(6);
//	  for(i=0;i<base.npoin;i++)  viewfile<<base.node_map[i]+1<<","<<base.c1[NDF*i]<<","<<base.c1[NDF*i+1]<<","<<base.c1[NDF*i+2]<<"\n";
	  for(i=0;i<base.npoin;i++)mirrorfile<<base.node_map[i]+1<<","<<base.c1[NDF*i]<<","<<base.c1[NDF*i+1]<<","<<base.c1[NDF*i+2]<<"\n";
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
// viewfile.close();
 mirrorfile.close();
}
//---------------------------------------------------------------------------
void TForm1::export_CTSP_ELEMENT8(char gVFTnameStem[]) // Identical to ABAQUS format ASCII element (8n only, with element mapping) connectivity file *.inp (or *.in), delimited by ","
{long i=0,eltype=0,bscode=0,node=0,t7=10000000,t5=100000,t3=1000;
// char extensChar[]="_CTSP_element.in";char *fnNeed=new char[strlen(gVFTnameStem)+strlen(extensChar)+1];
// StringCchCopy(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,gVFTnameStem);StringCchCat(fnNeed,strlen(gVFTnameStem)+strlen(extensChar)+1,extensChar);
// ofstream viewfile(fnNeed);delete [] fnNeed;
 ofstream mirrorfile("element.in"); //Version with mirror file  EFP 3/26/2011
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//// try {
////      for(i=0;i<base.nelt;i++)viewfile<<base.el_map[i]+1<<","
////				<<base.node_map[base.nop1[MXNPEL*i+0]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","
////				<<base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
//	  for(i=0;i<base.nelt;i++)mirrorfile<<base.el_map[i]+1<<","
//				<<base.node_map[base.nop1[MXNPEL*i+0]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","
//				<<base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";


				 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
										  if(eltype==8){if(node==8) //EFP 6/12/2014
mirrorfile<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
														else
mirrorfile<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+16]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
													   }
										  else if(eltype==7){if(node==6)
mirrorfile<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<"\n";
															 else
mirrorfile<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+12]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
															}
										  else if(eltype==5){if(node==4)
mirrorfile<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<"\n";
															 else
mirrorfile<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<","<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<","<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<"\n";
															}
										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"export_CTSP_ELEMENT8() unsupported element type",L"Terminate",MB_OK);exit(0);}
										 }


//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
// viewfile.close();
 mirrorfile.close();
}
//---------------------------------------------------------------------------
void TForm1::exportCTSP_public()
////{wchar_t curMess0[]=L"_CTSP_input.in\n",curMess1[]=L"_CTSP_node.in\n",curMess2[]=L"_CTSP_element.in",string0[90];
//{wchar_t curMess0[]=L"_input.in\n",curMess1[]=L"_node.in\n",curMess2[]=L"_element.in",string0[90];
//////		  Application->MessageBox(PtrToStringChars(gWsiAlias),L"Warning",MB_OK); // Visual C++ function
// gWsiAlias=ABAQnames->CheckEdit1;
// StringCchCopyW(string0,90,gWsiAlias.w_str());StringCchCatW(string0,90,curMess0);
// StringCchCatW(string0,90,gWsiAlias.w_str());StringCchCatW(string0,90,curMess1);
// StringCchCatW(string0,90,gWsiAlias.w_str());StringCchCatW(string0,90,curMess2);
//honk<<"\n"<<" Writing three CTSP(TM) datafiles...\n";
// extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Writing 3 CTSP files",MB_OK);
// export_CTSP_INPUT(gWsiAlias.c_str());export_CTSP_NODE(gWsiAlias.c_str());export_CTSP_ELEMENT8(gWsiAlias.c_str());
{gWsiAlias=ABAQnames->CheckEdit1;
	   ABAQnames->CheckIsel=3;
	   ABAQnames->Edit3->Enabled=true;
	   ABAQnames->Edit5->Enabled=true;
	   ABAQnames->Edit3->Visible=true;ABAQnames->Edit5->Visible=true;
	   ABAQnames->Label1->Enabled=false;ABAQnames->Label3->Enabled=true;ABAQnames->Label5->Enabled=true;
	   ABAQnames->Label9->Enabled=true;ABAQnames->Label11->Enabled=true;
	   ABAQnames->Label3->Visible=true;
	   ABAQnames->Label5->Visible=true;
	   ABAQnames->Label9->Visible=true;
	   ABAQnames->Label11->Visible=true;
	   ABAQnames->CheckEdit1=gWsiAlias;ABAQnames->CheckEdit3=gWsiAlias;ABAQnames->CheckEdit5=gWsiAlias;
	   ABAQnames->Edit1->Enabled=false;ABAQnames->Button1->Caption="Write files";

//	   ABAQnames->ShowModal();
}
//---------------------------------------------------------------------------
void TForm1::exportCTSP3_public()
{gWsiAlias=CTSPnames->CheckEdit1;
	   CTSPnames->CheckIsel=1;
	   CTSPnames->Edit2->Enabled=true;CTSPnames->Edit3->Enabled=true;CTSPnames->Edit5->Enabled=true;CTSPnames->Edit6->Enabled=true;
	   CTSPnames->Edit2->Visible=true;CTSPnames->Edit3->Visible=true;CTSPnames->Edit5->Visible=true;CTSPnames->Edit6->Visible=true;
	   CTSPnames->Label1->Enabled=false;
	   CTSPnames->Label2->Enabled=true;
	   CTSPnames->Label3->Enabled=true;
	   CTSPnames->Label8->Enabled=true;
	   CTSPnames->Label4->Enabled=false;
//	   CTSPnames->Label5->Enabled=false;
	   CTSPnames->Label6->Enabled=true;
	   CTSPnames->Label7->Enabled=true;
	   CTSPnames->Label9->Enabled=true;
	   CTSPnames->Label10->Enabled=true;
	   CTSPnames->Label2->Visible=true;
	   CTSPnames->Label3->Visible=true;
	   CTSPnames->Label5->Visible=true;
	   CTSPnames->Label6->Visible=true;
	   CTSPnames->Label7->Visible=true;
	   CTSPnames->Label8->Visible=true;
	   CTSPnames->Label9->Visible=true;
	   CTSPnames->Label10->Visible=true;
	   CTSPnames->CheckEdit1=gWsiAlias;CTSPnames->CheckEdit2=gWsiAlias;CTSPnames->CheckEdit3=gWsiAlias;CTSPnames->CheckEdit5=gWsiAlias;
	   CTSPnames->Edit1->Enabled=false;
////	   CTSPnames->Edit4->Enabled=false;
//	   CTSPnames->Button1->Caption="Write files";

	   if(CTSPnames->CheckEdit4==1)CTSPnames->Button1->Caption="Write files";
	   else {CTSPnames->Label5->Caption="/CTSPsubdN/..._CTSP_input.in";
			 CTSPnames->Label6->Caption="/CTSPsubdN/..._CTSP_node.in";
			 CTSPnames->Label7->Caption="/CTSPsubdN/..._CTSP_element.in";
			 CTSPnames->Label9->Caption="/CTSPsubdN/..._CTSP_param.in";
			 CTSPnames->Button1->Caption="Write multi_core directories";
			}
//	   ABAQnames->ShowModal();
}
//---------------------------------------------------------------------------
void TForm1::exportCTSP1_public()
////{wchar_t curMess0[]=L"_CTSP_input.in\n",curMess1[]=L"_CTSP_node.in\n",curMess2[]=L"_CTSP_element.in",string0[90];
{wchar_t curMess0[]=L"_CTSP_input.in\n",curMess1[]=L"_CTSP_node.in\n",curMess2[]=L"_CTSP_element.in\n",curMess3[]=L"_CTSP_param.in",string0[160];
//{wchar_t curMess0[]=L"_CTSP_input.txt\n",curMess1[]=L"_CTSP_node.txt\n",curMess2[]=L"_CTSP_element.txt",string0[90];
////		  Application->MessageBox(PtrToStringChars(gWsiAlias),L"Warning",MB_OK); // Visual C++ function
 gWsiAlias=ABAQnames->CheckEdit1;
 StringCchCopyW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess0);
 StringCchCatW(string0,160,gWsiAlias.w_str()); StringCchCatW(string0,160,curMess1);
 StringCchCatW(string0,160,gWsiAlias.w_str()); StringCchCatW(string0,160,curMess2);
 StringCchCatW(string0,160,gWsiAlias.w_str()); StringCchCatW(string0,160,curMess3);
honk<<"\n"<<" Writing four CTSP(TM) datafiles...\n";
 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Writing 4 CTSP files exportCTSP1_public()",MB_OK);
// export_CTSP_INPUT(gWsiAlias.c_str());
// export_CTSP_NODE(gWsiAlias.c_str());
// export_CTSP_ELEMENT8(gWsiAlias.c_str());
 export_CTSP_INPUTp(gWsiAlias.t_str());
 export_CTSP_NODE(gWsiAlias.t_str());
 export_CTSP_ELEMENT8(gWsiAlias.t_str());
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}

//---------------------------------------------------------------------------
void TForm1::exportCTSP2_public() //Version with load balancing  EFP 11/24/2012
// FRANTIC NOTICE: ic, mcmlo.... must be int (not long, or HUGE PROBLEMS) so set maxCore=128
// For some reason, Delete *.* does not work so EFP has to delete files individually
//  (but this does not include the CTSPxxx.exe executable, which will hopefully be elsewhere.)
////{wchar_t curMess0[]=L"_CTSP_input.in\n",curMess1[]=L"_CTSP_node.in\n",curMess2[]=L"_CTSP_element.in",string0[90];
//{int ic=0,mcmlo=0,mcmup=0,mcminc=0,maxCore=128,mcm=CTSPnames->CheckEdit4;
{int ic=0,mcmlo=0,mcmup=0,mcminc=0,maxCore=999,mcm=CTSPnames->CheckEdit4; //EFP 4/29/2013
 long i=0,ip=0,iseq=0,icount=0,itotal=0,stepsum=0, *loadBal=NULL;
//char *temps;
 char extensChar1a[]="CTSPsubd00",extensChar1b[]="CTSPsubd0",extensChar1c[]="CTSPsubd",
	  extensChar2[]="_CTSP_input.in",extensChar3[]="_CTSP_element.in",extensChar4[]="_CTSP_node.in",extensChar5[]="_CTSP_param.in",
	  *fnNeed=NULL
//	  ,*fnNeed1=NULL,*fnNeed2=NULL,*fnNeed3=NULL,*fnNeed4=NULL,*fnNeed5=NULL
;
 char buf[3+1];
 wchar_t curMess0[]=L"_CTSP_input.in\n",curMess1[]=L"_CTSP_node.in\n",curMess2[]=L"_CTSP_element.in\n",curMess3[]=L"_CTSP_param.in",string0[160];
//{wchar_t curMess0[]=L"_CTSP_input.txt\n",curMess1[]=L"_CTSP_node.txt\n",curMess2[]=L"_CTSP_element.txt",string0[90];
////		  Application->MessageBox(PtrToStringChars(gWsiAlias),L"Warning",MB_OK); // Visual C++ function
 gWsiAlias=CTSPnames->CheckEdit1;
 StringCchCopyW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess0);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess1);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess2);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess3);
 if(mcm==1){
honk<<"\n"<<" Writing CTSP(TM) files...\n";
			extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Writing CTSP files exportCTSP2_public()",MB_OK);



			for(ic=0;ic<maxCore;ic++){ //Empty & remove any preexisting subdirectories  EFP 11/06/2011
// Allow for input.in, element.in, node.in, param.in, temp.out, time.out, etc but not *.exe
									  if(!DelSubd0(ic,gWsiAlias))break;
									 }



//			export_CTSP_INPUTp(gWsiAlias.t_str());export_CTSP_NODE(gWsiAlias.t_str());export_CTSP_ELEMENT8(gWsiAlias.t_str());
		   }
 else {itotal=0;loadBal=new long[wp.nWeldPass];
	   for(ip=0;ip<wp.nWeldPass;ip++)
		{icount=1;itotal++;for(i=0;i<wp.memWGa;i++)if(wp.eles[wp.memWGa*ip+i]<0)break;
		 icount=icount+i/wp.n_curr_sttEl[ip] +wp.stepInterval[ip];
		 itotal=itotal+i/wp.n_curr_sttEl[ip] +wp.stepInterval[ip];loadBal[ip]=icount;
		}
//	   mcminc=wp.nWeldPass/mcm;
	   mcminc=1+ itotal/mcm;mcmlo=1;
	   for(ip=0;ip<wp.nWeldPass;ip++)wp.lstart[ip]=double(CTSPnames->CheckEdit6);

honk<<"\n"<<wp.lstart[0]<<" "<<mcm<<" "<<wp.nWeldPass<<" "<<mcminc<<" Writing multi-core CTSP(TM) directories...\n";
	   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Writing multi-core CTSP directories",MB_OK);
	   for(ic=0;ic<mcm;ic++){stepsum=0;
//							 for(ip=0;ip<wp.nWeldPass;ip++){stepsum=stepsum+loadBal[ip];
//															if(stepsum>=mcminc*(ic+1))break;
//														   }
//							 if(stepsum-mcminc*(ic+1)>mcminc*(ic+1)+loadBal[ip]-stepsum)ip=ip-1;
//							 if(ip>wp.nWeldPass-mcm+ic)ip=wp.nWeldPass-mcm+ic;
//							 if(ip<ic)ip=ic;  //Correction: EFP 11/25/2012
//							 if(ic==mcm-1)mcmup=wp.nWeldPass;
////							 else mcmup=mcmlo+mcminc-1;
//							 else mcmup=ip+1;

							 for(iseq=0;iseq<wp.nWeldPass;iseq++)//This should be done by sequence Correction  EFP 9/12/2013
							   {for(ip=0;ip<wp.nWeldPass;ip++)if(iseq+1==wp.seqNum[ip])break;
								stepsum=stepsum+loadBal[ip];
								if(stepsum>=mcminc*(ic+1))break;
							   }
							 if(stepsum-mcminc*(ic+1)>mcminc*(ic+1)+loadBal[ip]-stepsum)iseq=iseq-1;
							 if(iseq>wp.nWeldPass-mcm+ic)iseq=wp.nWeldPass-mcm+ic;
							 if(iseq<ic)iseq=ic;  //Correction: EFP 11/25/2012
							 if(ic==mcm-1)mcmup=wp.nWeldPass;
							 else mcmup=iseq+1;

honk<<ic+1<<" "<<mcmlo<<" "<<mcmup<<" LoadBalanceScheme "<<wp.nWeldPass<<"\n";
//							 if(ic<10-1){fnNeed=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+1];
							 if(ic<10-1){
										 gcvt(double(ic+1),1,buf);
honk<<buf<<"\n";//if(1==1)exit(0);
										 fnNeed=new char[strlen(extensChar1a)+strlen(buf)+1];
//										 StringCchCopy(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+1,extensChar1a);
										 StringCchCopy(fnNeed,strlen(extensChar1a)+strlen(buf)+1,extensChar1a);
//										 StringCchCat(fnNeed,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+1,IntToStr(ic+1).c_str());
										 StringCchCat(fnNeed,strlen(extensChar1a)+strlen(buf)+1,buf);
										}
							 else if(ic<100-1){gcvt(double(ic+1),2,buf);
//											   fnNeed=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+1];
//											   StringCchCopy(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+1,extensChar1b);
//											   StringCchCat(fnNeed,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+1,IntToStr(ic+1).c_str());
											   fnNeed=new char[strlen(extensChar1b)+strlen(buf)+1];
											   StringCchCopy(fnNeed,strlen(extensChar1b)+strlen(buf)+1,extensChar1b);
											   StringCchCat(fnNeed,strlen(extensChar1b)+strlen(buf)+1,buf);
											  }
							 else {gcvt(double(ic+1),3,buf);
//								   fnNeed=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+1];
//								   StringCchCopy(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+1,extensChar1c);
//								   StringCchCat(fnNeed,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+1,IntToStr(ic+1).c_str());
								   fnNeed=new char[strlen(extensChar1c)+strlen(buf)+1];
								   StringCchCopy(fnNeed,strlen(extensChar1c)+strlen(buf)+1,extensChar1c);
								   StringCchCat(fnNeed,strlen(extensChar1c)+strlen(buf)+1,buf);
								  }
							 if(!DirectoryExists(fnNeed))CreateDirectoryA(fnNeed,NULL);
							 SetCurrentDirectory(fnNeed);delete [] fnNeed;
							 if(ic==mcm-1)export_CTSP_INPUTp_mcm(mcmlo,mcmup,0,float(wp.lstart[0]),gWsiAlias.t_str());//Extra cooling OFF
							 else         export_CTSP_INPUTp_mcm(mcmlo,mcmup,1,float(wp.lstart[0]),gWsiAlias.t_str());//Extra cooling ON
							 export_CTSP_NODE(gWsiAlias.t_str());
							 export_CTSP_ELEMENT8(gWsiAlias.t_str());
							 mcmlo=mcmup+1;SetCurrentDirectory("..");
							}
////////////////
	   delete [] loadBal;
////////////////



	   for(ic=mcm;ic<maxCore;ic++){ //Empty & remove any preexisting excess subdirectories  EFP 11/01/2011
// Allow for input.in, element.in, node.in, param.in, temp.out, time.out, etc but not *.exe
								   if(!DelSubd0(ic,gWsiAlias))break;
								  }



	  }
//////Policy: write input.in (all WP), element.in, node.in to model directory regardless of multi-core  EFP 11/06/2011
//// export_CTSP_INPUTp(gWsiAlias.t_str());
 export_CTSP_INPUTp1(gWsiAlias.t_str(),float(wp.lstart[0])); //Version which writes preemptive time.out  EFP 6/26/2012
 export_CTSP_NODE(gWsiAlias.t_str());export_CTSP_ELEMENT8(gWsiAlias.t_str());
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
int TForm1::DelSubd0(int ic,String gWsiAlias)
//WARNING: This code does not delete any possible executable, or the directory in such case  EFP 6/27/2012
{int flag=0;
 char buf[3+1];
 char extensChar1a[]="CTSPsubd00",extensChar1b[]="CTSPsubd0",extensChar1c[]="CTSPsubd",
	  extensChar2[]="_CTSP_input.in",extensChar3[]="_CTSP_element.in",extensChar4[]="_CTSP_node.in",extensChar5[]="_CTSP_param.in",
	  *fnNeed=NULL,*fnNeed1=NULL,*fnNeed2=NULL,*fnNeed3=NULL,*fnNeed4=NULL,*fnNeed5=NULL;
 if(ic<10-1){
			 gcvt(double(ic+1),1,buf);
//			 fnNeed1=new char[strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+1];
//			 StringCchCopy(fnNeed1,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+1,extensChar1a);
//			 StringCchCat(fnNeed1,strlen(extensChar1a)+strlen(IntToStr(ic+1).c_str())+1,IntToStr(ic+1).c_str());
			 fnNeed1=new char[strlen(extensChar1a)+strlen(buf)+1];
			 StringCchCopy(fnNeed1,strlen(extensChar1a)+strlen(buf)+1,extensChar1a);
			 StringCchCat(fnNeed1,strlen(extensChar1a)+strlen(buf)+1,buf);
			}
 else if(ic<100-1){gcvt(double(ic+1),2,buf);
//				   fnNeed1=new char[strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+1];
//				   StringCchCopy(fnNeed1,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+1,extensChar1b);
//				   StringCchCat(fnNeed1,strlen(extensChar1b)+strlen(IntToStr(ic+1).c_str())+1,IntToStr(ic+1).c_str());
				   fnNeed1=new char[strlen(extensChar1b)+strlen(buf)+1];
				   StringCchCopy(fnNeed1,strlen(extensChar1b)+strlen(buf)+1,extensChar1b);
				   StringCchCat(fnNeed1,strlen(extensChar1b)+strlen(buf)+1,buf);
				  }
 else {gcvt(double(ic+1),3,buf);
//	   fnNeed1=new char[strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+1];
//	   StringCchCopy(fnNeed1,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+1,extensChar1c);
//	   StringCchCat(fnNeed1,strlen(extensChar1c)+strlen(IntToStr(ic+1).c_str())+1,IntToStr(ic+1).c_str());
	   fnNeed1=new char[strlen(extensChar1c)+strlen(buf)+1];
	   StringCchCopy(fnNeed1,strlen(extensChar1c)+strlen(buf)+1,extensChar1c);
	   StringCchCat(fnNeed1,strlen(extensChar1c)+strlen(buf)+1,buf);
	  }
 if(DirectoryExists(fnNeed1)){SetCurrentDirectory(fnNeed1);
 fnNeed2=new char[strlen(gWsiAlias.t_str())+strlen(extensChar2)+1];
 StringCchCopy(fnNeed2,strlen(gWsiAlias.t_str())+strlen(extensChar2)+1,gWsiAlias.t_str());
 StringCchCat(fnNeed2,strlen(gWsiAlias.t_str())+strlen(extensChar2)+1,extensChar2);
 DeleteFile(fnNeed2);DeleteFile("input.in");delete [] fnNeed2;

 fnNeed3=new char[strlen(gWsiAlias.t_str())+strlen(extensChar3)+1];
 StringCchCopy(fnNeed3,strlen(gWsiAlias.t_str())+strlen(extensChar3)+1,gWsiAlias.t_str());
 StringCchCat(fnNeed3,strlen(gWsiAlias.t_str())+strlen(extensChar3)+1,extensChar3);
 DeleteFile(fnNeed3);DeleteFile("element.in");delete [] fnNeed3;

 fnNeed4=new char[strlen(gWsiAlias.t_str())+strlen(extensChar4)+1];
 StringCchCopy(fnNeed4,strlen(gWsiAlias.t_str())+strlen(extensChar4)+1,gWsiAlias.t_str());
 StringCchCat(fnNeed4,strlen(gWsiAlias.t_str())+strlen(extensChar4)+1,extensChar4);
 DeleteFile(fnNeed4);DeleteFile("node.in");delete [] fnNeed4;

 fnNeed5=new char[strlen(gWsiAlias.t_str())+strlen(extensChar5)+1];
 StringCchCopy(fnNeed5,strlen(gWsiAlias.t_str())+strlen(extensChar5)+1,gWsiAlias.t_str());
 StringCchCat(fnNeed5,strlen(gWsiAlias.t_str())+strlen(extensChar5)+1,extensChar5);
 DeleteFile(fnNeed5);DeleteFile("param.in");delete [] fnNeed5;

 DeleteFile("temp.out");DeleteFile("time.out");DeleteFile("*.exe"); //Which might or might not exist
 DeleteFile("tempRevise.out"); //EFP 6/27/2012
 SetCurrentDirectory("..");RemoveDirectory(fnNeed1);flag=1;
							 }
 else flag=0;
 delete [] fnNeed1;return flag;
}

//---------------------------------------------------------------------------
void TForm1::exportABAQUS_public()
{gWsiAlias=ABAQnames->CheckEdit1;
	   ABAQnames->CheckIsel=1;ABAQnames->Edit2->Visible=true;ABAQnames->Edit3->Visible=true;
	   ABAQnames->Edit4->Visible=true;ABAQnames->Edit5->Visible=true;ABAQnames->Edit6->Visible=true;
	   ABAQnames->Label1->Enabled=false;
	   ABAQnames->Label2->Enabled=true;ABAQnames->Label3->Enabled=true;ABAQnames->Label4->Enabled=true;
	   ABAQnames->Label5->Enabled=true;ABAQnames->Label6->Enabled=true;ABAQnames->Label8->Enabled=true;
	   ABAQnames->Label9->Enabled=true;ABAQnames->Label10->Enabled=true;ABAQnames->Label11->Enabled=true;
	   ABAQnames->CheckEdit1=gWsiAlias;ABAQnames->CheckEdit2=gWsiAlias;ABAQnames->CheckEdit3=gWsiAlias;
	   ABAQnames->CheckEdit4=gWsiAlias;ABAQnames->CheckEdit5=gWsiAlias;ABAQnames->CheckEdit6="****";
	   ABAQnames->Edit1->Enabled=false;ABAQnames->Button1->Caption="Write files";

//	   ABAQnames->ShowModal();
}
//---------------------------------------------------------------------------
void TForm1::exportABAQUS1_public()
{float timesave2=0.;
//// wchar_t curMess0[]=L"_ABA.inp\n",    //curMess0[]=L"_ABA_input.inp\n",
////		 curMess1[]=L"_VED.dat\n",curMess2[]=L"_ABA_node.inp\n",
////		 curMess3[]=L"_ABA_element.inp\n",curMess4[]=L"_ufield.f",string0[120];
 wchar_t curMess0[]=L"_ABA.inp\n",    //curMess0[]=L"_ABA_input.inp\n",
		 curMess1[]=L"_VED.dat\n",curMess2[]=L"_node.inp\n",
//		 curMess3[]=L"_element.inp\n",curMess4[]=L"_ufield.f",string0[120]; //Correction EFP 5/12/2010
		 curMess3[]=L"_element.inp\n",curMess4[]=L"_ufield.f",string0[160]; //Correction EFP 11/12/2012
// wchar_t curMess0[]=L"_ABA.txt\n",    //curMess0[]=L"_ABA_input.inp\n",
//		 curMess1[]=L"_VEDdat.txt\n",curMess2[]=L"_node.txt\n",
//		 curMess3[]=L"_element.txt\n",curMess4[]=L"_ufield.txt",string0[120]; //Correction EFP 5/12/2010

// StringCchCopyW(string0,120,gWsiAlias.w_str());StringCchCatW(string0,120,curMess0);
// StringCchCatW(string0,120,gWsiAlias.w_str());StringCchCatW(string0,120,curMess1);
// StringCchCatW(string0,120,gWsiAlias.w_str());StringCchCatW(string0,120,curMess2);
// StringCchCatW(string0,120,gWsiAlias.w_str());StringCchCatW(string0,120,curMess3);
// StringCchCatW(string0,120,gWsiAlias.w_str());StringCchCatW(string0,120,curMess4);
 StringCchCopyW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess0);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess1);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess2);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess3);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess4);

//			   export_ABA_NODE(ABAQnames->CheckEdit2.c_str()); // Write ABAQUS-format ASCII nodal geometry file *.inp (or *.in), delimited by ","
//			   export_ABA_ELEMENT8(ABAQnames->CheckEdit3.c_str()); // Write ABAQUS-format ASCII element (8n only, with mapping) connectivity file *.inp (or *.in), delimited by ","
			   export_ABA_NODE(ABAQnames->CheckEdit2.t_str()); // Write ABAQUS-format ASCII nodal geometry file *.inp (or *.in), delimited by ","
			   export_ABA_ELEMENT8(ABAQnames->CheckEdit3.t_str()); // Write ABAQUS-format ASCII element (8n only, with mapping) connectivity file *.inp (or *.in), delimited by ","
// Dire warning: Must call export_VED() before export_ABA() or export_UFIELD() because it computes .......
//			   export_VED(ABAQnames->CheckEdit4.c_str(),&timesave2); // VED= virtual element detection
//			   export_ABA(ABAQnames->CheckEdit1.c_str());
//			   export_UFIELD(ABAQnames->CheckEdit5.c_str(),ABAQnames->CheckEdit6.c_str(),timesave2); // EFP 03/02/2010
			   export_VED(ABAQnames->CheckEdit4.t_str(),&timesave2); // VED= virtual element detection
			   export_ABA(ABAQnames->CheckEdit1.t_str());
			   export_UFIELD(ABAQnames->CheckEdit5.t_str(),ABAQnames->CheckEdit6.t_str(),timesave2); // EFP 03/02/2010
//vvvvvvvvvvvvvvvvvvvvvvvvvvvv
export_ABA_BC(ABAQnames->CheckEdit1.t_str());  //EFP 4/10/2013
//vvvvvvvvvvvvvvvvvvvvvvvvvvvv
// ToCTSP2->Enabled=true;
honk<<"\n"<<" Writing five SIMULIA/ABAQUS(TM) datafiles...\n";
			   extern PACKAGE void __fastcall Beep(void);
//			   Application->MessageBox(L"*_ABA_input.inp\n*_VED.dat\n*_ABA_node.inp\n*_ABA_element.inp\n*_ufield.f",L"Writing 5 S/ABAQUS files",MB_OK);
			   Application->MessageBox(string0,L"Writing 5 S/ABAQUS files",MB_OK);
//			   delete ABAQnames;  // Why? Why? Why? EFP 4/19/2010
			   ABAQnames=NULL;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
void __fastcall TForm1::MaskElem0Execute(TObject *Sender)
//Same as BitBtn10Click()
{if(base.nop1){iplotType=2;FD_LButtonstatus=16;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
			  }  // Include elements within poly
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"73Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::persistVFT()
// Plots on tBitmap canvas
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 long inw=0,ie=0,ct_curr_sttEl=0,ict=0,iside=0,ir=0,ip=0,
// ipp=0,is=0,
icount=0,
	  eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 float xave=0.,yave=0.,zave=0.
 //,xnor=0.,ynor=0.,znor=0.
 ;
 TPoint ptDraw[MAXPOINTS];
// honk<<ClientWidth<<" "<<ClientHeight<<" "<<wp.nWeldPass<<" persistVFT\n";
////////////////
//tBitmap->Canvas->Brush->Color=clYellow;
//tBitmap->Canvas->Pen->Width=4;
//tBitmap->Canvas->Pen->Color==clRed;
//ptDraw[0].x=0;ptDraw[0].y=0;
//ptDraw[1].x=0;ptDraw[1].y=ClientHeight/3;
//ptDraw[2].x=ClientWidth/3;ptDraw[2].y=ClientHeight/3;
//ptDraw[3].x=ClientWidth/3;ptDraw[3].y=0;
//tBitmap->Canvas->Polygon(ptDraw,4-1);
////////////////


//// for(inw=0;inw<MAX_WELDPASSES;inw++)
 for(inw=0;inw<wp.nWeldPass;inw++)
// for(inw=0;inw<wp.nWeldPass-1;inw++)
   {
//	ct_curr_sttEl=base.nelt;
	ct_curr_sttEl=wp.memWGa; //Correction EFP 3/23/2012
	for(ie=0;ie<wp.memWGa;ie++)if(wp.sttEles[wp.memWGa*inw+ie]<0){ct_curr_sttEl=ie;break;}

//	icount=base.nelt;
	icount=wp.memWGa; //Correction EFP 3/23/2012
//	for(ie=0;ie<base.nelt;ie++)if(wp.eles[base.nelt*inw+ie]<0){icount=ie;break;}
	for(ie=0;ie<wp.memWGa;ie++)if(wp.eles[wp.memWGa*inw+ie]<0){icount=ie;break;}

//honk<<inw+1<<" "<<ct_curr_sttEl<<" "<<icount<<" InfoOut\n";

	if(ct_curr_sttEl)
	 {xave=yave=zave=0.;
	  for(ict=0;ict<ct_curr_sttEl;ict++)
	  {ie=wp.sttEles[wp.memWGa*inw+ict]/10;iside=wp.sttEles[wp.memWGa*inw+ict]-10*(wp.sttEles[wp.memWGa*inw+ict]/10);
	   eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
////	   ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//						else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//						else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//							  else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
// 							 }
ieGID=base.arrELSET[ie];
////////////// but this does not use indat.xxx ?
	   //Canvas->Brush->Color=clWhite;Canvas->Pen->Color=clWhite;
	   ir=ieGID-9*(ieGID/9);

//honk<<ict+1<<" "<<ie+1<<" "<<iside+1<<" "<<node<<" "<<ieGID<<" "<<ir<<" kiwiP\n";ir=6;
//honk<<ict+1<<" "<<ie+1<<" "<<iside+1<<" "<<node<<" "<<ieGID<<" "<<ir<<" kiwiP\n";

	   if     (ir==0)tBitmap->Canvas->Brush->Color=clRed;
	   else if(ir==1)tBitmap->Canvas->Brush->Color=clLtGray; // Coding for color contrast
	   else if(ir==2)tBitmap->Canvas->Brush->Color=clBlue;
	   else if(ir==3)tBitmap->Canvas->Brush->Color=clGreen;
	   else if(ir==4)tBitmap->Canvas->Brush->Color=clLime;
	   else if(ir==5)tBitmap->Canvas->Brush->Color=clNavy;
	   else if(ir==6)tBitmap->Canvas->Brush->Color=clYellow;
	   else if(ir==7)tBitmap->Canvas->Brush->Color=clOlive;
	   else          tBitmap->Canvas->Brush->Color=clMaroon;

tBitmap->Canvas->Brush->Color=wp.WeldColor[inw];

//honk<<inw+1<<" "<<ict+1<<" "<<ir<<" "<<(long)clBlack<<" "<<(long)wp.WeldColor[inw]<<" persistCK\n";

	   if     (ir==0)tBitmap->Canvas->Pen->Color=clMaroon; // Coding for double color contrast
	   else if(ir==1)tBitmap->Canvas->Pen->Color=clRed;
	   else if(ir==2)tBitmap->Canvas->Pen->Color=clLtGray;
	   else if(ir==3)tBitmap->Canvas->Pen->Color=clBlue;
	   else if(ir==4)tBitmap->Canvas->Pen->Color=clGreen;
	   else if(ir==5)tBitmap->Canvas->Pen->Color=clLime;
	   else if(ir==6)tBitmap->Canvas->Pen->Color=clNavy;
	   else if(ir==7)tBitmap->Canvas->Pen->Color=clYellow;
	   else          tBitmap->Canvas->Pen->Color=clOlive;
	   tBitmap->Canvas->Pen->Width=4;
	   for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]]+0.5);
						   ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+1]+0.5);

//honk<<ip+1<<" "<<ptDraw[ip].x<<" "<<ptDraw[ip].y<<" PTDrP\n";

						  }

////////////////
//Canvas->Brush->Color=clYellow;
//ptDraw[0].x=0;ptDraw[0].y=0;
//ptDraw[1].x=0;ptDraw[1].y=ClientHeight/3;
//ptDraw[2].x=ClientWidth/3;ptDraw[2].y=ClientHeight/3;
//ptDraw[3].x=ClientWidth/3;ptDraw[3].y=0;
////////////////

	   tBitmap->Canvas->Polygon(ptDraw,4-1);
	   for(ip=0;ip<8;ip++){xave=xave+indat.c1[NDF*indat.nop1[MXNPEL*ie+ip]+0];
						   yave=yave+indat.c1[NDF*indat.nop1[MXNPEL*ie+ip]+1];
						   zave=zave+indat.c1[NDF*indat.nop1[MXNPEL*ie+ip]+2];
						  }
	  }
	  xave=xave/float(8*ct_curr_sttEl);yave=yave/float(8*ct_curr_sttEl);zave=zave/float(8*ct_curr_sttEl);
/////////////////


/*
//	  wp.stpEle[inw]=10*ie+iside;
	  if(wp.stpEle[inw]>=0){
	  ie=wp.stpEle[inw]/10;iside=wp.stpEle[inw]-10*(wp.stpEle[inw]/10);
	  ir=ieGID-9*(ieGID/9);
	  if     (ir==0)tBitmap->Canvas->Brush->Color=clOlive; // Coding for triple color contrast
	  else if(ir==1)tBitmap->Canvas->Brush->Color=clMaroon;
	  else if(ir==2)tBitmap->Canvas->Brush->Color=clRed;
	  else if(ir==3)tBitmap->Canvas->Brush->Color=clLtGray;
	  else if(ir==4)tBitmap->Canvas->Brush->Color=clBlue;
	  else if(ir==5)tBitmap->Canvas->Brush->Color=clGreen;
	  else if(ir==6)tBitmap->Canvas->Brush->Color=clLime;
	  else if(ir==7)tBitmap->Canvas->Brush->Color=clNavy;
	  else          tBitmap->Canvas->Brush->Color=clYellow;
	  if     (ir==0)tBitmap->Canvas->Pen->Color=clMaroon; // Coding for double color contrast
	  else if(ir==1)tBitmap->Canvas->Pen->Color=clRed;
	  else if(ir==2)tBitmap->Canvas->Pen->Color=clLtGray;
	  else if(ir==3)tBitmap->Canvas->Pen->Color=clBlue;
	  else if(ir==4)tBitmap->Canvas->Pen->Color=clGreen;
	  else if(ir==5)tBitmap->Canvas->Pen->Color=clLime;
	  else if(ir==6)tBitmap->Canvas->Pen->Color=clNavy;
	  else if(ir==7)tBitmap->Canvas->Pen->Color=clYellow;
	  else          tBitmap->Canvas->Pen->Color=clOlive;
	  tBitmap->Canvas->Pen->Width=4;
	  xnor=ynor=znor=0.;
	  for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]]+0.5);
						  ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+1]+0.5);
						  xnor=xnor+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]  ];
						  ynor=ynor+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+1];
						  znor=znor+indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*iside+ip]]+2];
						 }
	  xnor=xnor/4.;ynor=ynor/4.;znor=znor/4.;
	  tBitmap->Canvas->Polygon(ptDraw,4-1);tBitmap->Canvas->Pen->Width=6;
//	  if(wp.arrows[NDF*3*inw+NDF*0+0]*(xnor-xave)+wp.arrows[NDF*3*inw+NDF*0+1]*(ynor-yave)+wp.arrows[NDF*3*inw+NDF*0+2]*(znor-zave)>0.)
//		   {  // Directions as above or
//tBitmap->Canvas->Ellipse(int(xave)-8,ClientHeight-(int(yave)-8),int(xave)+8,ClientHeight-(int(yave)+8));
//tBitmap->Canvas->MoveTo(int(xave),ClientHeight-int(yave));
//if((xnor-xave)*(xnor*xave)+(ynor-yave)*(ynor-yave)>0.001*0.001)tBitmap->Canvas->LineTo(int(xnor),ClientHeight-int(ynor));
//else tBitmap->Canvas->LineTo(int(xave+100*(xnor-xave)),ClientHeight-int(ynor+100*(ynor-yave)));
//		   }
//	  else {  // Reverse direction
//tBitmap->Canvas->Ellipse(int(xnor)-8,ClientHeight-(int(ynor)-8),int(xnor)+8,ClientHeight-(int(ynor)+8));
//tBitmap->Canvas->MoveTo(int(xnor),ClientHeight-int(ynor));
//if((xnor-xave)*(xnor*xave)+(ynor-yave)*(ynor-yave)>0.001*0.001)tBitmap->Canvas->LineTo(int(xave),ClientHeight-int(yave));
//else tBitmap->Canvas->LineTo(int(xnor+100*(xave-xnor)),ClientHeight-int(ynor+100*(yave-ynor)));
//		   }
						   }
*/


/*
	  if(icount/ct_curr_sttEl){
	  ir=inw%9;
honk<<inw<<" QUADCOLOR "<<ir<<"\n";
	  if     (ir==0){tBitmap->Canvas->Brush->Color=clYellow;tBitmap->Canvas->Pen->Color=clYellow;}
	  else if(ir==1){tBitmap->Canvas->Brush->Color=clOlive; tBitmap->Canvas->Pen->Color=clOlive;} // Coding for quad color contrast
	  else if(ir==2){tBitmap->Canvas->Brush->Color=clMaroon;tBitmap->Canvas->Pen->Color=clMaroon;}
	  else if(ir==3){tBitmap->Canvas->Brush->Color=clRed;  tBitmap->Canvas->Pen->Color=clRed;}
	  else if(ir==4){tBitmap->Canvas->Brush->Color=clLtGray;tBitmap->Canvas->Pen->Color=clLtGray;}
	  else if(ir==5){tBitmap->Canvas->Brush->Color=clBlue;  tBitmap->Canvas->Pen->Color=clBlue;}
	  else if(ir==6){tBitmap->Canvas->Brush->Color=clBlue;  tBitmap->Canvas->Pen->Color=clBlue;}
	  else if(ir==7){tBitmap->Canvas->Brush->Color=clLime;  tBitmap->Canvas->Pen->Color=clLime;}
	  else if(ir==8){tBitmap->Canvas->Brush->Color=clNavy;  tBitmap->Canvas->Pen->Color=clNavy;}
/////////////////
	  tBitmap->Canvas->Pen->Width=1;
	  for(ict=0;ict<ct_curr_sttEl;ict++){for(ipp=0;ipp<icount/ct_curr_sttEl;ipp++)
//										 {ie=wp.eles[base.nelt*inw+ct_curr_sttEl*ipp+ict];eltype=indat.matno[ie]/t7;
										 {ie=wp.eles[base.nelt*inw+ct_curr_sttEl*ipp+ict]/10;eltype=indat.matno[ie]/t7;
if(eltype==8)for(is=0;is<6;is++)
			   {tBitmap->Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*is+0]]  ]+0.5),
										ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*is+0]]+1]+0.5));
				for(ip=1;ip<4;ip++)tBitmap->Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*is+ip]]  ]+0.5),
														   ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie+gdata8[4*is+ip]]+1]+0.5));
			   }
else {
	  honk<<ie+1<<" miscreantNonHex "<<eltype<<"\n";
	  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex-element found in this weld pass.",L"Terminate",MB_OK);exit(0);
	 }
										 }
									  }
							  }
*/

//	  if(wp.snorm1[4*inw+0]>=0){
//					tBitmap->Canvas->Brush->Color=clWhite;tBitmap->Canvas->Pen->Color=clWhite;
//					xave=yave=0;  // Assumes 8/20n elements
//					for(ip=0;ip<4;ip++){xave=xave+indat.c1[NDF*wp.snorm1[4*inw+ip]  ];yave=yave+indat.c1[NDF*wp.snorm1[4*inw+ip]+1];}
//					xave=xave/double(4);yave=yave/double(4);
//					tBitmap->Canvas->Ellipse(int(xave)-2,ClientHeight-(int(yave)-2),int(xave)+2,ClientHeight-(int(yave)+2));
//					tBitmap->Canvas->Pen->Color=clYellow;tBitmap->Canvas->Pen->Width=6;
//					tBitmap->Canvas->MoveTo(int(xave),ClientHeight-int(yave));
//					tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*wp.arrows[NDF*3*inw+NDF*1+0]),
//											ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*wp.arrows[NDF*3*inw+NDF*1+1])));
//							   }
//	  if(wp.snorm2[4*inw+0]>=0){
//					tBitmap->Canvas->Brush->Color=clWhite;tBitmap->Canvas->Pen->Color=clWhite;
//					xave=yave=0;  // Assumes 8/20n elements
//					for(ip=0;ip<4;ip++){xave=xave+indat.c1[NDF*wp.snorm2[4*inw+ip]  ];yave=yave+indat.c1[NDF*wp.snorm2[4*inw+ip]+1];}
//					xave=xave/double(4);yave=yave/double(4);
//					tBitmap->Canvas->Ellipse(int(xave)-2,ClientHeight-(int(yave)-2),int(xave)+2,ClientHeight-(int(yave)+2));
//					tBitmap->Canvas->Pen->Color=clYellow;tBitmap->Canvas->Pen->Width=6;
//					tBitmap->Canvas->MoveTo(int(xave),ClientHeight-int(yave));
//					tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(100.*wp.arrows[NDF*3*inw+NDF*2+0]),
//											ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(100.*wp.arrows[NDF*3*inw+NDF*2+1])));
//							   }
	 }
   }
}
//---------------------------------------------------------------------------
void TForm1::persistVFT1(long startWP,long endWP)
// Plots on tBitmap canvas
// startWP & endWP begin with 0
{int vertplot[15]={1,5,6,2,3,7,4,0,3,7,6,2,1,5,4};
 long inw=0,ie=0,ct_curr_sttEl=0,in=0,ipp=0,is1=0,ie1=0,ip1=0,icount=0,eltype1=0,t7=10000000;
 TPoint ptDraw[MAXPOINTS];tBitmap->Canvas->Pen->Width=1;
 for(inw=startWP;inw<endWP+1;inw++)
   {
//	ct_curr_sttEl=base.nelt;
	ct_curr_sttEl=wp.memWGa; //Correction EFP 3/23/2012
	for(ie=0;ie<wp.memWGa;ie++)if(wp.sttEles[wp.memWGa*inw+ie]<0){ct_curr_sttEl=ie;break;}
//	icount=base.nelt;
	icount=wp.memWGa; //Correction EFP 3/23/2012
	for(ie=0;ie<wp.memWGa;ie++)if(wp.eles[wp.memWGa*inw+ie]<0){icount=ie;break;}
	if(icount){tBitmap->Canvas->Brush->Color=wp.WeldColor[inw];tBitmap->Canvas->Pen->Color=wp.WeldColor[inw];
			   for(in=0;in<ct_curr_sttEl;in++)
				 {for(ipp=0;ipp<icount/ct_curr_sttEl;ipp++){
ie1=wp.eles[wp.memWGa*inw+ct_curr_sttEl*ipp+in]/10;eltype1=indat.matno[ie1]/t7;
if(eltype1==8){tBitmap->Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]  ]+0.5),
									   ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]+1]+0.5));
			   for(ip1=0;ip1<15;ip1++)
tBitmap->Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+vertplot[ip1]]  ]+0.5),
						ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+vertplot[ip1]]+1]+0.5));
			  }
//else {honk<<ie1+1<<" miscreantNonHex "<<eltype1<<"\n";
//	  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex-element found in this weld pass.",L"Terminate",MB_OK);exit(0);
//	 }
else {honk<<ie1+1<<" persistVFT1() miscreantNonHex "<<eltype1<<"\n"; //Modification EFP 5/04/2011
//	  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex-element found in this weld pass.",L"Warning",MB_OK);
	 }
														   }
											  }
			  }
   }
}

//---------------------------------------------------------------------------
//void TForm1::persistVFT1a(long nWP,int util_arr[])
void TForm1::persistVFT1a(long nWP,long util_arr[])
// Plots weld pass outline on tBitmap canvas
// startWP & endWP begin with 0
{int vertplot[15]={1,5,6,2,3,7,4,0,3,7,6,2,1,5,4};
 long inw=0,ie=0,ct_curr_sttEl=0,in=0,ipp=0,is1=0,ie1=0,iside1=0,ip1=0,icount=0,eltype1=0,t7=10000000;
 float xave=0.,yave=0.,zave=0.,xc=0.,yc=0.,zc=0.,DJD=0.,HN[9],SN[8],SG[24],DJR[9+1];
 TPoint ptDraw[MAXPOINTS];
// tBitmap->Canvas->Pen->Width=1;
 for(inw=0;inw<nWP;inw++)
  {if(util_arr[inw]/10)
   {
//	ct_curr_sttEl=base.nelt;
	ct_curr_sttEl=wp.memWGa; //Correction EFP 3/23/2012
	for(ie=0;ie<wp.memWGa;ie++)if(wp.sttEles[wp.memWGa*inw+ie]<0){ct_curr_sttEl=ie;break;}
//	icount=base.nelt;
	icount=wp.memWGa; //Correction EFP 3/23/2012
	for(ie=0;ie<wp.memWGa;ie++)if(wp.eles[wp.memWGa*inw+ie]<0){icount=ie;break;}
	if(icount){tBitmap->Canvas->Brush->Color=wp.WeldColor[inw];tBitmap->Canvas->Pen->Color=wp.WeldColor[inw];
			   tBitmap->Canvas->Pen->Width=1;
			   for(in=0;in<ct_curr_sttEl;in++)
				 {for(ipp=0;ipp<icount/ct_curr_sttEl;ipp++){
ie1=wp.eles[wp.memWGa*inw+ct_curr_sttEl*ipp+in]/10;eltype1=indat.matno[ie1]/t7;
if(eltype1==8){tBitmap->Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]  ]+0.5),
									   ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+0]+1]+0.5));
			   for(ip1=0;ip1<15;ip1++)
tBitmap->Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+vertplot[ip1]]  ]+0.5),
						ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+vertplot[ip1]]+1]+0.5));
			  }
	else {honk<<ie1+1<<" persistVFT1a() miscreantNonHex "<<eltype1<<"\n"; //Modification
//	  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex-element found in this weld pass.",L"Warning",MB_OK);
		 }
														   }
				 }
////////////////// Insert weld direction arrow here  EFP 3/22/2012
///////////////////
////////////////////
xave=yave=zave=0.;
for(ip1=0;ip1<wp.n_curr_sttEl[inw];ip1++)
  {for(in=0;in<8;in++){xave=xave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*inw+ip1]/10)+in]+0];
					   yave=yave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*inw+ip1]/10)+in]+1];
					   zave=zave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*inw+ip1]/10)+in]+2];
					  }
  }
xave=xave/double(8*wp.n_curr_sttEl[inw]);yave=yave/double(8*wp.n_curr_sttEl[inw]);zave=zave/double(8*wp.n_curr_sttEl[inw]);
tBitmap->Canvas->Pen->Width=3;tBitmap->Canvas->Brush->Color=clWhite;tBitmap->Canvas->Pen->Color=clWhite;
tBitmap->Canvas->Ellipse(int(xave)-5,ClientHeight-(int(yave)-5),int(xave)+5,ClientHeight-(int(yave)+5));
tBitmap->Canvas->Brush->Color=clBlue;tBitmap->Canvas->Pen->Color=clBlue;
tBitmap->Canvas->MoveTo(int(xave),ClientHeight-int(yave));
ie1=wp.sttEles[wp.memWGa*inw+0]/10;iside1=wp.sttEles[wp.memWGa*inw+0]-10*ie1; // Use first start element face as normal
if(iside1==0){xc=  0.;yc= -1.;zc=  0.;}else if(iside1==2){xc=  0.;yc=  1.;zc=  0.;}else if(iside1==1){xc=  1.;yc=  0.;zc=  0.;}else if(iside1==3){xc= -1.;yc=  0.;zc=  0.;}else if(iside1==4){xc=  0.;yc=  0.;zc= -1.;}else {xc=  0.;yc=  0.;zc=  1.;}
STFISO8(3,xc,yc,zc,&DJD,HN,SN,SG,DJR,indat.nop1+MXNPEL*ie1,indat.c1); //EFP 3/24/2012
//tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//						ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1]))); //GIANTS
//tBitmap->Canvas->MoveTo(int(xave+25.*(-wp.arrows[NDF*3*inw+NDF*0+0]-wp.arrows[NDF*3*inw+NDF*0+1]))+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//						ClientHeight-(int(yave+25.*(-wp.arrows[NDF*3*inw+NDF*0+0]-wp.arrows[NDF*3*inw+NDF*0+1]))+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1])));
//tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//						ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1])));
//tBitmap->Canvas->LineTo(int(xave+25.*(-wp.arrows[NDF*3*inw+NDF*0+0]+wp.arrows[NDF*3*inw+NDF*0+1]))+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//						ClientHeight-(int(yave+25.*(-wp.arrows[NDF*3*inw+NDF*0+1]+wp.arrows[NDF*3*inw+NDF*0+0]))+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1])));
tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1]))); //GIANTS
tBitmap->Canvas->MoveTo(int(xave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
tBitmap->Canvas->LineTo(int(xave+25.*(HN[0]-HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[1]-HN[0]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
////////////////////
///////////////////
//////////////////
			  }
   }
  }
}
//---------------------------------------------------------------------------
//void TForm1::persistVFT2(long nWP,int util_arr[])
void TForm1::persistVFT2(long nWP,long util_arr[])
// Plots weld pass start elements on tBitmap canvas
//{int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
{int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 TPoint ptDraw[MAXPOINTS];
 long inw=0,ir=0,in=0,ie1=0,iside1=0,ip=0,ir1=0,ip1=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 float xave=0.,yave=0.,zave=0.,xc=0.,yc=0.,zc=0.,DJD=0.,HN[9],SN[8],SG[24],DJR[9+1];
 for(inw=0;inw<nWP;inw++)
   {ir=util_arr[inw]/10;
	if(util_arr[inw]-10*ir){tBitmap->Canvas->Brush->Color=wp.WeldColor[inw];
							for(in=0;in<wp.memWGa;in++)
							  {if(wp.sttEles[wp.memWGa*inw+in]>=0)
								 {ie1=wp.sttEles[wp.memWGa*inw+in]/10;
								  iside1=wp.sttEles[wp.memWGa*inw+in]-10*ie1;
//
eltype=indat.matno[ie1]/t7;bscode=(indat.matno[ie1]-eltype*t7)/t5;node=(indat.matno[ie1]-eltype*t7-bscode*t5)/t3;
////ieGID=indat.matno[ie1]-eltype*t7-bscode*t5-node*t3;
////////////// EFP 2/20/2012
//////	   ieGID=base.arrELSET[ base.trackELSET[ie1+1]-1 ];
////	   ieGID=indat.arrELSET[ indat.trackELSET[ie1+1]-1 ];
//////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie1+1]-indat.trackELSET[ie1]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie1+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie1+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie1]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie1+1]-1 ];                      //Prioritize WP
//							 }
ieGID=indat.arrELSET[ie1];
////////////// but this does not use indat.xxx ?
////////////
		  ir1=ieGID-9*(ieGID/9);
		  if     (ir1==0)tBitmap->Canvas->Pen->Color=clMaroon; // Coding for double color contrast
		  else if(ir1==1)tBitmap->Canvas->Pen->Color=clRed;
		  else if(ir1==2)tBitmap->Canvas->Pen->Color=clLtGray;
		  else if(ir1==3)tBitmap->Canvas->Pen->Color=clBlue;
		  else if(ir1==4)tBitmap->Canvas->Pen->Color=clGreen;
		  else if(ir1==5)tBitmap->Canvas->Pen->Color=clLime;
		  else if(ir1==6)tBitmap->Canvas->Pen->Color=clNavy;
		  else if(ir1==7)tBitmap->Canvas->Pen->Color=clYellow;
		  else           tBitmap->Canvas->Pen->Color=clOlive;
		  tBitmap->Canvas->Pen->Width=2;
//
								  for(ip=0;ip<4;ip++){ptDraw[ip].x=int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+ip]]]+0.5);
													  ptDraw[ip].y=ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEL*ie1+gdata8[4*iside1+ip]]+1]+0.5);
													 }
								  tBitmap->Canvas->Polygon(ptDraw,4-1);
								 }
							   else break;
							  }
////////////////// Insert weld direction arrow here  EFP 3/22/2012
///////////////////
////////////////////
xave=yave=zave=0.;
for(ip1=0;ip1<wp.n_curr_sttEl[inw];ip1++)
  {for(in=0;in<8;in++){xave=xave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*inw+ip1]/10)+in]+0];
					   yave=yave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*inw+ip1]/10)+in]+1];
					   zave=zave+indat.c1[NDF*indat.nop1[MXNPEL*(wp.sttEles[wp.memWGa*inw+ip1]/10)+in]+2];
					  }
  }
xave=xave/double(8*wp.n_curr_sttEl[inw]);yave=yave/double(8*wp.n_curr_sttEl[inw]);zave=zave/double(8*wp.n_curr_sttEl[inw]);
tBitmap->Canvas->Pen->Width=3;tBitmap->Canvas->Brush->Color=clWhite;tBitmap->Canvas->Pen->Color=clWhite;
tBitmap->Canvas->Ellipse(int(xave)-5,ClientHeight-(int(yave)-5),int(xave)+5,ClientHeight-(int(yave)+5));
tBitmap->Canvas->Brush->Color=clBlue;tBitmap->Canvas->Pen->Color=clBlue;
tBitmap->Canvas->MoveTo(int(xave),ClientHeight-int(yave));
ie1=wp.sttEles[wp.memWGa*inw+0]/10;iside1=wp.sttEles[wp.memWGa*inw+0]-10*ie1; // Use first start element face as normal
if(iside1==0){xc=  0.;yc= -1.;zc=  0.;}else if(iside1==2){xc=  0.;yc=  1.;zc=  0.;}else if(iside1==1){xc=  1.;yc=  0.;zc=  0.;}else if(iside1==3){xc= -1.;yc=  0.;zc=  0.;}else if(iside1==4){xc=  0.;yc=  0.;zc= -1.;}else {xc=  0.;yc=  0.;zc=  1.;}
STFISO8(3,xc,yc,zc,&DJD,HN,SN,SG,DJR,indat.nop1+MXNPEL*ie1,indat.c1); //EFP 3/24/2012
//tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1]))); //GIANTS
//tBitmap->Canvas->MoveTo(int(xave+25.*(-wp.arrows[NDF*3*inw+NDF*0+0]-wp.arrows[NDF*3*inw+NDF*0+1]))+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//ClientHeight-(int(yave+25.*(-wp.arrows[NDF*3*inw+NDF*0+0]-wp.arrows[NDF*3*inw+NDF*0+1]))+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1])));
//tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1])));
//tBitmap->Canvas->LineTo(int(xave+25.*(-wp.arrows[NDF*3*inw+NDF*0+0]+wp.arrows[NDF*3*inw+NDF*0+1]))+(min(ClientWidth,ClientHeight)/200)*int( 50.*wp.arrows[NDF*3*inw+NDF*0+0]),
//ClientHeight-(int(yave+25.*(-wp.arrows[NDF*3*inw+NDF*0+1]+wp.arrows[NDF*3*inw+NDF*0+0]))+(min(ClientWidth,ClientHeight)/200)*int(50.*wp.arrows[NDF*3*inw+NDF*0+1])));
tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1]))); //GIANTS
tBitmap->Canvas->MoveTo(int(xave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[0]+HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
tBitmap->Canvas->LineTo(int(xave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave)+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
tBitmap->Canvas->LineTo(int(xave+25.*(HN[0]-HN[1]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[0]),ClientHeight-(int(yave+25.*(HN[1]-HN[0]))+(min(ClientWidth,ClientHeight)/200)*int(-50.*HN[1])));
////////////////////
///////////////////
//////////////////
						   }
   }
}

//---------------------------------------------------------------------------
long TForm1::FDcullfacet_arEc(long nelt,long nop1[],long matno[],float c1[],int arELEM[],long arbFacet[],long rbTemp[])
// Version with 20n elements. FDorderfacet() merged below  EFP 1/02/2012
{long nFacets=0,ij=0,ies=0,eltypes=0,bscodes=0,nodes=0,fType=0,t3=1000,t5=100000,t7=10000000;
 float CENT=1./3.,DJD=0.,HN[9],SN[8],SG[24],DJR[9+1],proximi=0.,distant=0.;
 float testcor[4*2]= { -0.9,-0.9,
						0.9,-0.9,
						0.9, 0.9,
					   -0.9, 0.9};
 int is=0,iprox=0,idist=0,npts=0,iside=0;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdata6[20]={0,1,4,3,
				 1,2,5,4,
				 2,0,3,5,
				 0,2,1,0,
				 3,4,5,0};
 int gdata4[12]={0,2,1,
				 1,2,3,
				 2,0,3,
				 3,0,1};
 nFacets=0;
 for(ies=0;ies<nelt;ies++)if(arELEM[ies])
   {eltypes=matno[ies]/t7;bscodes=(matno[ies]-eltypes*t7)/t5;nodes=(matno[ies]-eltypes*t7-bscodes*t5)/t3;
	if(bscodes>0)
	  {if(bscodes >= 32){bscodes=bscodes-32;
if(nodes==8)STFISO8(3,0.,0.,1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else for(ij=0;ij<4;ij++){STFISO20(3,testcor[2*ij],testcor[2*ij+1],1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
						 if(HN[2]>0.)break;
						}
						 if(HN[2]>0.){iside=5;arbFacet[nFacets]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTemp[nFacets]=iprox*100+idist;
//////////////////
									  nFacets++;
									 }
						}
	   if(bscodes >= 16){bscodes=bscodes-16;
if(eltypes==7)STFISO6(3,CENT,CENT, 1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else {if(nodes==8)STFISO8(3,  0.,  0., -1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
	  else for(ij=0;ij<4;ij++){STFISO20(3,testcor[2*ij],testcor[2*ij+1],-1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
							   if(HN[2]>0.)break;
							  }
	 }
						 if(HN[2]>0.){iside=4;arbFacet[nFacets]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTemp[nFacets]=iprox*100+idist;
//////////////////
									  nFacets++;
									 }
						}
	   if(bscodes >=  8){bscodes=bscodes-8;
if(eltypes==5)     STFISO4(3,CENT,CENT,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else if(eltypes==7)STFISO6(3,CENT,CENT, -1.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else {if(nodes==8) STFISO8(3, -1.,  0.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
	  else for(ij=0;ij<4;ij++){STFISO20(3,-1.,testcor[2*ij],testcor[2*ij+1],&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
							   if(HN[2]>0.)break;
							  }
	 }
						 if(HN[2]>0.){iside=3;arbFacet[nFacets]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTemp[nFacets]=iprox*100+idist;
//////////////////
									  nFacets++;
									 }
						}
	   if(bscodes >=  4){bscodes=bscodes-4;
if(eltypes==5)     STFISO4(3,CENT,  0.,CENT,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else if(eltypes==7)STFISO6(3,0.5,0.,0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else               {
// Wrong???   if(nodes==8){STFISO8(3,  1.,  0.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ies,c1);test=HN[2];}
   if(nodes==8)STFISO8(3,0.,1.,0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
   else for(ij=0;ij<4;ij++){STFISO20(3,testcor[2*ij],1.,testcor[2*ij+1],&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
							if(HN[2]>0.)break;
						   }
				   }
						 if(HN[2]>0.){iside=2;arbFacet[nFacets]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTemp[nFacets]=iprox*100+idist;
//////////////////
									  nFacets++;
									 }
						}
	   if(bscodes >=  2){bscodes=bscodes-2;
if(eltypes==5)     STFISO4(3,  0.,CENT,CENT,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else if(eltypes==7)STFISO6(3,0.,0.5,0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else {if(nodes==8) STFISO8(3,  1.,  0.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
	  else for(ij=0;ij<4;ij++){STFISO20(3,1.,testcor[2*ij],testcor[2*ij+1],&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
							   if(HN[2]>0.)break;
							  }
	 }
						 if(HN[2]>0.){iside=1;arbFacet[nFacets]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTemp[nFacets]=iprox*100+idist;
//////////////////
									  nFacets++;
									 }
						}
	   if(bscodes >=  1){
if(eltypes==5)     STFISO4(3,CENT,CENT,CENT,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else if(eltypes==7)STFISO6(3,0.5,0.5,0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
else {if(nodes==8) STFISO8(3,  0., -1.,  0.,&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
	  else for(ij=0;ij<4;ij++){STFISO20(3,testcor[2*ij],-1.,testcor[2*ij+1],&DJD,HN,SN,SG,DJR,nop1+MXNPEI*ies,c1);
							   if(HN[2]>0.)break;
							  }
	 }
						 if(HN[2]>0.){iside=0;arbFacet[nFacets]=ies*t3+fType*10+iside;
//////////////////
proximi= -1.e28;distant= 1.e28;
if(eltypes==5){for(is=0;is<3;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];iprox=gdata4[3*iside+is];}
								   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata4[3*iside+is]]+2];idist=gdata4[3*iside+is];}
								  }
			  }
else if(eltypes==7){if(iside>2)npts=3;else npts=4;
					for(is=0;is<npts;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];iprox=gdata6[4*iside+is];}
										   if(distant>c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata6[4*iside+is]]+2];idist=gdata6[4*iside+is];}
										  }
				   }
else for(is=0;is<4;is++){if(proximi<c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){proximi=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];iprox=gdata8[4*iside+is];}
						 if(distant>c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2]){distant=c1[NDF*nop1[MXNPEI*ies+gdata8[4*iside+is]]+2];idist=gdata8[4*iside+is];}
						}
rbTemp[nFacets]=iprox*100+idist;
//////////////////
									  nFacets++;
									 }
						}
		 }
	 }
 return nFacets;
}
//---------------------------------------------------------------------------
void TForm1::maskelemPolyhea(int flag)
// Subroutine to hide polygon-surrounded-elements from mesh visibility (flag != 0), or to show only them (flag=0)
// This does NOT section the mesh.
{int *polytri=NULL,tricount=0,pc=0;
 long in=0,ie=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000;
 float xavg=0.,yavg=0.;
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor= crHourGlass;
// try {
	  polytri=new int[2*3*polypts*polypts];if(polytri==NULL){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Insufficient dynamic memory for polygon",L"Return",MB_OK);return;}
	  tricount=0;est_polytri(polytri,&tricount);
	  for(ie=0;ie<indat.nelt;ie++)
		{eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
		 xavg=yavg=0.;for(in=0;in<node;in++){xavg=xavg+float(indat.c1[NDF*indat.nop1[MXNPEL*ie+in]  ]);
											 yavg=yavg+float(indat.c1[NDF*indat.nop1[MXNPEL*ie+in]+1]);
											}
		 xavg=xavg/float(node);yavg=yavg/float(node);
		 pc=poly_contain(polytri,tricount,xavg,yavg);

//bligh=base.arELEM[ie];

		 if((flag && !pc) || (!flag && pc))base.arELEM[ie]=0;

// honk<<ie+1<<" "<<bligh<<" "<<base.arELEM[ie]<<" Bef/AftBligh\n";

		}
	  delete [] polytri;
////	  indat.nelt=new_nelt;indat.npoin=new_npoin;indat.nvfix=new_nvfix;indat.nedge=new_nedge;
////      base.nelt=new_nelt;base.npoin=new_npoin;FDbase_indat(1,shapecombo);FDrot_status();
//	  if(iPaintyesno-10*(iPaintyesno/10))FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
//	  else {
if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
else {
//	  FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
	  FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
	  FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
	 }
//		   }
	  iPaintyesno=iPaintyesno-10*(iPaintyesno/10) +10;iCullyesno=0;iCircleplot=1;Invalidate();
//	 }
//__finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::est_polytri(int polytri[],int *tricount)
{int ip=0,ipp=0,ippp=0,ipc=0,signp=0,signm=0,signpd=0,signmd=0,indicsign=0,iter=0,lolim=0,tri_idic[MAX_POLYPOINTS],ntri_idic[MAX_POLYPOINTS],psearch=polypts,pscount=0,ipstart=0;
 float dx1=0.,dy1=0.,dx3=0.,dy3=0.,norm=0.,xave=0.,yave=0.;
 for(ip=0;ip<polypts;ip++)tri_idic[ip]=ip;
 for(iter=0;iter<polypts;iter++)
   {signp=0;signm=0;
	for(ip=0;ip<psearch;ip++)
	  {ipp=ip+1;if(ipp>=psearch)ipp=0;ippp=ipp+1;if(ippp>=psearch)ippp=0;
	   dx1=float(polycord[2*tri_idic[ipp]]-polycord[2*tri_idic[ip]]);dy1=float(polycord[2*tri_idic[ipp]+1]-polycord[2*tri_idic[ip]+1]);
	   norm=sqrt(dx1*dx1+dy1*dy1);dx1=dx1/norm;dy1=dy1/norm;
	   dx3=float(polycord[2*tri_idic[ippp]]-polycord[2*tri_idic[ip]]);dy3=float(polycord[2*tri_idic[ippp]+1]-polycord[2*tri_idic[ip]+1]);
	   norm=sqrt(dx3*dx3+dy3*dy3);dx3=dx3/norm;dy3=dy3/norm;
	   if(dx1*dy3-dx3*dy1 >=0.)signp++;else signm++;
	  }
	if(signp>signm)indicsign=1;else if(signp<signm)indicsign= -1;
	else
	  {xave=yave=0.;
	   for(ip=0;ip<psearch;ip++){xave=xave+float(polycord[2*tri_idic[ip]]);yave=yave+float(polycord[2*tri_idic[ip]+1]);}
	   xave=xave/float(psearch);yave=yave/float(psearch);signpd=signmd=0;
	   for(ip=0;ip<psearch;ip++)
		 {ipp=ip+1;if(ipp>=psearch)ipp=0;
		  dx1=float(polycord[2*tri_idic[ipp]]-polycord[2*tri_idic[ip]]);dy1=float(polycord[2*tri_idic[ipp]+1]-polycord[2*tri_idic[ip]+1]);
		  norm=sqrt(dx1*dx1+dy1*dy1);dx1=dx1/norm;dy1=dy1/norm;
		  dx3=xave-float(polycord[2*tri_idic[ip]]);dy3=yave-float(polycord[2*tri_idic[ip]+1]);
		  norm=sqrt(dx3*dx3+dy3*dy3);dx3=dx3/norm;dy3=dy3/norm;
		  if(dx1*dy3-dx3*dy1>=0.)signpd++;else signmd++;
		 }
	   if(signpd>signmd)indicsign=1;else indicsign= -1;
	  }
//
	for(ip=0;ip<psearch;ip++)
	  {ipp=ip+1;if(ipp>=psearch)ipp=0;ippp=ipp+1;if(ippp>=psearch)ippp=0;
	   dx1=float(polycord[2*tri_idic[ipp]]-polycord[2*tri_idic[ip]]);dy1=float(polycord[2*tri_idic[ipp]+1]-polycord[2*tri_idic[ip]+1]);
	   norm=sqrt(dx1*dx1+dy1*dy1);dx1=dx1/norm;dy1=dy1/norm;
	   dx3=float(polycord[2*tri_idic[ippp]]-polycord[2*tri_idic[ip]]);dy3=float(polycord[2*tri_idic[ippp]+1]-polycord[2*tri_idic[ip]+1]);
	   norm=sqrt(dx3*dx3+dy3*dy3);dx3=dx3/norm;dy3=dy3/norm;
	   if(dx1*dy3-dx3*dy1>=0. && indicsign<0)break;if(dx1*dy3-dx3*dy1<0. && indicsign>0)break;
	  }
	ipstart=ipp;pscount=0;lolim=1000;ip=0;
	for(ipc=0;ipc<psearch;ipc++)
	   {if(ip>=psearch)break;
		ipp=ipstart+1;if(ipp>=psearch)ipp=0;ippp=ipp+1;if(ippp>=psearch)ippp=0;
		dx1=float(polycord[2*tri_idic[ipp]]-polycord[2*tri_idic[ipstart]]);dy1=float(polycord[2*tri_idic[ipp]+1]-polycord[2*tri_idic[ipstart]+1]);
		norm=sqrt(dx1*dx1+dy1*dy1);dx1=dx1/norm;dy1=dy1/norm;
		dx3=float(polycord[2*tri_idic[ippp]]-polycord[2*tri_idic[ipstart]]);dy3=float(polycord[2*tri_idic[ippp]+1]-polycord[2*tri_idic[ipstart]+1]);
		norm=sqrt(dx3*dx3+dy3*dy3);dx3=dx3/norm;dy3=dy3/norm;
		if(dx1*dy3-dx3*dy1 >=0. && indicsign>0 && ippp!=lolim)
		 {polytri[6* *tricount  ]=polycord[2*tri_idic[ipstart]];polytri[6* *tricount+1]=polycord[2*tri_idic[ipstart]+1];
		  polytri[6* *tricount+2]=polycord[2*tri_idic[ipp]];polytri[6* *tricount+3]=polycord[2*tri_idic[ipp]+1];
		  polytri[6* *tricount+4]=polycord[2*tri_idic[ippp]];polytri[6* *tricount+5]=polycord[2*tri_idic[ippp]+1];
		  ntri_idic[pscount]=tri_idic[ippp];pscount++;if(lolim>ipp)lolim=ipp;
		  *tricount= *tricount+1;ip=ip+2;ipstart=ipstart+2;
		  if(ipstart==psearch)ipstart=0;else if(ipstart==psearch+1)ipstart=1;
		 }
		else if(dx1*dy3-dx3*dy1 <0. && indicsign<0 && ippp!=lolim)
		 {polytri[6* *tricount  ]=polycord[2*tri_idic[ipstart]];polytri[6* *tricount+1]=polycord[2*tri_idic[ipstart]+1];
		  polytri[6* *tricount+2]=polycord[2*tri_idic[ipp]];polytri[6* *tricount+3]=polycord[2*tri_idic[ipp]+1];
		  polytri[6* *tricount+4]=polycord[2*tri_idic[ippp]];polytri[6* *tricount+5]=polycord[2*tri_idic[ippp]+1];
		  ntri_idic[pscount]=tri_idic[ippp];pscount++;if(lolim>ipp)lolim=ipp;
		  *tricount= *tricount+1;ip=ip+2;ipstart=ipstart+2;
		  if(ipstart==psearch)ipstart=0;else if(ipstart==psearch+1)ipstart=1;
		 }
		else {ntri_idic[pscount]=tri_idic[ipp];pscount++;ip++;ipstart=ipstart+1;if(ipstart>=psearch)ipstart=0;}
	   }
	if(pscount<3)break;psearch=pscount;for(ipc=0;ipc<psearch;ipc++)tri_idic[ipc]=ntri_idic[ipc];
   }
}
//---------------------------------------------------------------------------
int TForm1::poly_contain(int polytri[],int tricount,float xnor,float ynor)
{int ic=0,ip=0,icp=0,ipolypts=0;float dx1=0.,dy1=0.,dx2=0.,dy2=0.,dx3=0.,dy3=0.,norm=0.,xave=0.,yave=0.;
 for(ip=0;ip<tricount;ip++)
   {xave=yave=0.;for(ic=0;ic<3;ic++){xave=xave+float(polytri[6*ip+2*ic]);yave=yave+float(polytri[6*ip+2*ic+1]);}xave=xave/3.;yave=yave/3.;ipolypts=0;
	for(ic=0;ic<3;ic++)
	  {icp=ic+1;if(icp>=3)icp=0;
	   dx1=float(polytri[6*ip+2*icp]-polytri[6*ip+2*ic]);dy1=float(polytri[6*ip+2*icp+1]-polytri[6*ip+2*ic+1]);
	   norm=sqrt(dx1*dx1+dy1*dy1);if(norm<0.001)norm=0.001;dx1=dx1/norm;dy1=dy1/norm;
	   dx2=xave-float(polytri[6*ip+2*ic]);dy2=yave-float(polytri[6*ip+2*ic+1]);
	   norm=sqrt(dx2*dx2+dy2*dy2);if(norm<0.001)norm=0.001;dx2=dx2/norm;dy2=dy2/norm;
	   dx3=xnor-float(polytri[6*ip+2*ic]);dy3=ynor-float(polytri[6*ip+2*ic+1]);
	   norm=sqrt(dx3*dx3+dy3*dy3);if(norm<0.001)norm=0.001;dx3=dx3/norm;dy3=dy3/norm;
	   if((dx1*dy2-dx2*dy1)*(dx1*dy3-dx3*dy1)>=0.)ipolypts++;
	  }
	if(ipolypts>=3)return ip+1;
   }
 return 0;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BackGroundColorF0Execute(TObject *Sender)
{BackGroundColorF0->Checked=true;BackGroundColorF1->Checked=false;BackGroundColorF2->Checked=false;
 BackGroundColorF3->Checked=false;BackGroundColorF4->Checked=false;BackGroundColorF5->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iBackGroundColor=0;iCullyesno=1;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BackGroundColorF1Execute(TObject *Sender)
{BackGroundColorF0->Checked=false;BackGroundColorF1->Checked=true;BackGroundColorF2->Checked=false;
 BackGroundColorF3->Checked=false;BackGroundColorF4->Checked=false;BackGroundColorF5->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iBackGroundColor=1;iCullyesno=1;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BackGroundColorF2Execute(TObject *Sender)
{BackGroundColorF0->Checked=false;BackGroundColorF1->Checked=false;BackGroundColorF2->Checked=true;
 BackGroundColorF3->Checked=false;BackGroundColorF4->Checked=false;BackGroundColorF5->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iBackGroundColor=2;iCullyesno=1;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BackGroundColorF3Execute(TObject *Sender)
{BackGroundColorF0->Checked=false;BackGroundColorF1->Checked=false;BackGroundColorF2->Checked=false;
 BackGroundColorF3->Checked=true;BackGroundColorF4->Checked=false;BackGroundColorF5->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iBackGroundColor=3;iCullyesno=1;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BackGroundColorF4Execute(TObject *Sender)
{BackGroundColorF0->Checked=false;BackGroundColorF1->Checked=false;BackGroundColorF2->Checked=false;
 BackGroundColorF3->Checked=false;BackGroundColorF4->Checked=true;BackGroundColorF5->Checked=false;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iBackGroundColor=4;iCullyesno=1;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BackGroundColorF5Execute(TObject *Sender)
{// Other colors
 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported in this version",L"Halt",MB_OK);
// BackGroundColorF0->Checked=false;BackGroundColorF1->Checked=false;BackGroundColorF2->Checked=false;
// BackGroundColorF3->Checked=false;BackGroundColorF4->Checked=false;BackGroundColorF5->Checked=true;
// iBackGroundColor=5;iCullyesno=1;Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::XY_rotExecute(TObject *Sender)
{float dum=0.;
 if(base.nop1)Rot_program(0,dum,dum,dum);
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"74Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::YZ_rotExecute(TObject *Sender)
{float dum=0.,val=90.;
 if(base.nop1)Rot_program(1,dum,val,dum);
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"75Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ZX_rotExecute(TObject *Sender)
{float dum=0.,val=90.;
 if(base.nop1)Rot_program(1,val,dum,dum);
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"76Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::XY_rotmExecute(TObject *Sender)
{float dum=0.,val=180.;
 if(base.nop1)Rot_program(1,dum,dum,val);
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"77Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::YZ_rotm1Execute(TObject *Sender)
{float dum=0.,val= -90.;
 if(base.nop1)Rot_program(1,dum,val,dum);
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"78Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ZX_rotmExecute(TObject *Sender)
{float dum=0.,val= -90.;
 if(base.nop1)Rot_program(1,val,dum,dum);
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"79Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::XYrot_public(){float dum=0.;Rot_program(0,dum,dum,dum);}
void TForm1::YZrot_public(){float dum=0.,val=90.;Rot_program(1,dum,val,dum);}
void TForm1::ZXrot_public(){float dum=0.,val=90.;Rot_program(1,val,dum,dum);}
void TForm1::XYrotm_public(){float dum=0.,val=180.;Rot_program(1,dum,dum,val);}
void TForm1::YZrotm_public(){float dum=0.,val= -90.;Rot_program(1,dum,val,dum);}
void TForm1::ZXrotm_public(){float dum=0.,val= -90.;Rot_program(1,val,dum,dum);}

//---------------------------------------------------------------------------
void TForm1::Rot_program(int isw,float ang0,float ang1,float ang2)
{
 long ie=0,eltype=0,bscode=0,node=0,ieGID=0,ipid=0,t7=10000000,t5=100000,t3=1000;
 FDbase_indat(1,shapecombo,iplotflag,nColRes);
 if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
//	else {FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);}
 else {
//								      FDcomp_nGID();
	   FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
	   FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
	  }
/////////////// EFP 3/19/2012
for(ie=0;ie<base.nelt;ie++)
	{eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
////	 ipid=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//	 else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//	 else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//		   else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=base.arrELSET[ie];
////	 indat.matno[ie]=indat.matno[ie]-ipid+ieGID;
//	 indat.arrELSET[ indat.trackELSET[ie+1]-1 ]=ieGID;
	 indat.arrELSET[ie]=ieGID;
	}
/////////////
 iPaintyesno=10+1;iCullyesno=0;
//	rangle[0]=rangle0[0]=0.;rangle[1]=rangle0[1]=0.;rangle[2]=rangle0[2]=180.;
 rangle[0]=rangle0[0]=ang0;rangle[1]=rangle0[1]=ang1;rangle[2]=rangle0[2]=ang2;
 axis_plot_init();  //EFP 9/17/2010
 if(isw){FDrotate(0,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);
		 FDrotate_axisplot(0,rangle); //EFP 9/17/2010
		}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 iplotflag=1;iCircleplot=1;Invalidate();
}

//---------------------------------------------------------------------------
void __fastcall TForm1::PanGo1Execute(TObject *Sender)//Note: Timer functions should be tested for model in "start time function" EFP 3/22/2012
{long ntranche=8,subdivGo=4,i=0,iq=0,ic=0,ie=0,t3=1000,iWP=0,iside=0,iSeq=0,iseg=0,icount3=0,iup=0,icdiv=0, *arbFace1=NULL, *rbTem1=NULL;
 int *edgFace1=NULL,TB1H=0,P1W=0;bool dir=true;
// int gdata8[24]={0,1,5,4,
//				 1,2,6,5,
//				 3,2,6,7,
//				 0,3,7,4,
//				 0,1,2,3,
//				 4,5,6,7};
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
 int gdedges8[12*2]={0,1,//First 9 edges are continuous
					 1,2,
					 2,3,
					 3,0,
					 0,4,
					 4,5,
					 5,6,
					 6,7,
					 7,4,
					 1,5,
					 2,6,
					 3,7};
// TPoint ptDraw[MAXPOINTS];
 MEMORYSTATUS ms;ms.dwLength=sizeof(MEMORYSTATUS);
 if(FD_LButtonstatus==11 && stateVFT==2){
   if(zoomRect.left-zoomRect.right && zoomRect.top-zoomRect.bottom){
	   rangle[0]=180.*float(-zoomRect.top+zoomRect.bottom)/float(ClientHeight- TB1H);rangle0[0]=rangle0[0]+rangle[0];
	   rangle[1]=180.*float(zoomRect.right-zoomRect.left)/float(ClientWidth- P1W);rangle0[1]=rangle0[1]+rangle[1];
//       rangle[2]=0.;rangle0[2]=rangle0[2]+rangle[2];FDrotate(0,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);iCullyesno=0;Invalidate();
	   rangle[2]=0.;rangle0[2]=rangle0[2]+rangle[2];

honk<<rangle[0]<<" "<<rangle[1]<<" "<<rangle[2]<<" PanGoBefANGLE "<<glGdiff<<"\n";
rangle[0]=rangle[0]/glGdiff;
rangle[1]=rangle[1]/glGdiff;
rangle[2]=rangle[2]/glGdiff;
honk<<rangle[0]<<" "<<rangle[1]<<" "<<rangle[2]<<" PanGoAftANGLE\n";

	   FDrotate(0,indat.npoin,indat.c1,rangle,trans_op,prod_op,rot_op,nDefects,CrackCor);
	   FDrotate_axisplot(0,rangle); //EFP 9/17/2010
	   zoomRect.left=zoomRect.right;zoomRect.top=zoomRect.bottom;iCullyesno=0;Invalidate();
																   }
										}
 else if(FD_LButtonstatus==11 && stateVFT==3){
   if(panMouseM){for(i=0;i<indat.npoin;i++){indat.c1[NDF*i  ]=indat.c1[NDF*i  ]+double(Xpan1-Xpan0);
											indat.c1[NDF*i+1]=indat.c1[NDF*i+1]-double(Ypan1-Ypan0);
										   }
				 if(nDefects){for(iq=0;iq<nDefects;iq++)
							   {for(ic=0;ic<3;ic++){CrackCor[9*iq+3*ic+0]=CrackCor[9*iq+3*ic+0]+double(Xpan1-Xpan0);
													CrackCor[9*iq+3*ic+1]=CrackCor[9*iq+3*ic+1]-double(Ypan1-Ypan0);
												   }
							   }
							 }
				 gl_indatMedian[0]=gl_indatMedian[0]+float(Xpan1-Xpan0);
				 gl_indatMedian[1]=gl_indatMedian[1]-float(Ypan1-Ypan0);
				 Xpan0=Xpan1;Ypan0=Ypan1;panMouseM=0;
//				 int ipltF=iplotflag;iplotflag=0;Invalidate();
//				 iplotflag=ipltF;
				 Invalidate();
				}
										 }
 else if(FD_LButtonstatus==13){
//                               tx=0.5*(1.-timerZoom)*double(ClientWidth- P1W);ty=0.5*(1.-timerZoom)*double(ClientHeight- TB1H);
//							   for(i=0;i<indat.npoin;i++){indat.c1[NDF*i  ]=timerZoom*indat.c1[NDF*i  ]+tx;
//														  indat.c1[NDF*i+1]=timerZoom*indat.c1[NDF*i+1]+ty;
// 														  indat.c1[NDF*i+2]=timerZoom*indat.c1[NDF*i+2];
//														 }
//							   if(nDefects)for(iq=0;iq<nDefects;iq++)
//											{for(ic=0;ic<3;ic++){CrackCor[9*iq+3*ic+0]=timerZoom*CrackCor[9*iq+3*ic+0]+tx;
//																 CrackCor[9*iq+3*ic+1]=timerZoom*CrackCor[9*iq+3*ic+1]+ty;
//																 CrackCor[9*iq+3*ic+2]=timerZoom*CrackCor[9*iq+3*ic+2];
//																}
//											}
//							   Invalidate();
zoomRect.left=int(0.05*double(ClientWidth- P1W));
zoomRect.right=int(0.95*double(ClientWidth- P1W));
zoomRect.top=int(0.05*double(ClientHeight- TB1H));
zoomRect.bottom=int(0.95*double(ClientHeight- TB1H));
							   CmZoomIn2(indat.npoin,indat.c1,trans_op,prod_op,trans_zoom,prod_zoom,nDefects,CrackCor);
							  }
 else if(FD_LButtonstatus==19){iSeq=icTimer5-1000*(icTimer5/1000); //Plot by WP cross-sectional slice  EFP 1/01/0212
							   if(iSeq<wp.nWeldPass) //icTimer5=a+1000b, where a=current WP sequence & b=current slice
								 {for(iWP=0;iWP<wp.nWeldPass;iWP++){WeldPassEditSeqn->CheckSeq=iWP;iup=WeldPassEditSeqn->CheckSeq;
																	if(iup==iSeq+1)break;
																   }
								  dir=WeldPassEditSeqn->CheckDir;
								  icount3=0;for(i=0;i<wp.memWGa;i++){if(wp.eles[wp.memWGa*iWP+i]>=0)icount3++;else break;}
								  if(icTimer5/1000<icount3/wp.n_curr_sttEl[iWP]){
Canvas->Pen->Width=2;Canvas->Pen->Color=wp.WeldColor[iWP];
for(icdiv=0;icdiv<wp.n_curr_sttEl[iWP];icdiv++)
  {if(dir)ie=wp.eles[wp.memWGa*iWP+wp.n_curr_sttEl[iWP]*icTimer5/1000 +icdiv]/10;
   else   ie=wp.eles[wp.memWGa*iWP+wp.n_curr_sttEl[iWP]*(icount3/wp.n_curr_sttEl[iWP]-1-icTimer5/1000)+icdiv]/10;
   iq=0;Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+0]]  ]+0.5),
					   ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+0]]+1]+0.5));
   for(iq=0;iq<9;iq++)Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+1]]  ]+0.5),
									 ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+1]]+1]+0.5));
   for(iq=9;iq<12;iq++){Canvas->MoveTo(int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+0]]  ]+0.5),
									   ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+0]]+1]+0.5));
						Canvas->LineTo(int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+1]]  ]+0.5),
									   ClientHeight-int(indat.c1[NDF*indat.nop1[MXNPEI*ie+gdedges8[2*iq+1]]+1]+0.5));
					   }
  }
icTimer5=icTimer5+1000;
																				}
								  else icTimer5=iSeq+1;
								 }
							   else {Timer2->Enabled=false;FD_LButtonstatus=FD_LBrec;stateVFT=stateVFTrec;
									 for(i=0;i<base.nelt;i++)base.arELEM[i]=1;
									 FDrestore();Screen->Cursor=crSizeAll;
									}
							  }
}
//---------------------------------------------------------------------------
void __fastcall TForm1::SaveExecute(TObject *Sender)
{if(base.nop1)
//{
//extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Please use SaveAs",L"Halt",MB_OK);
////VFTrSave(); // EFP 10/04/2011
			   VFT_SaveAs1(0); //Default filename Model.VFTr  EFP 11/23/2012
//			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"80Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::SaveAs2Execute(TObject *Sender)
//// *.VFTr is NOT COMMA-DELIMITED currently
//{if(base.nop1)VFT_SaveAs(gWsiAlias.t_str());
{if(base.nop1)
//VFT_SaveAs(); //Note that this does NOT use gWsiAlias   EFP 1/07/2011
			   VFT_SaveAs1(1); //User-input filename *.VFTr  EFP 11/23/2012
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"81Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::SaveAs3Execute(TObject *Sender)//Create WP-only *.VFTa file
{if(base.nop1)
//VFT_SaveAs(); //Note that this does NOT use gWsiAlias   EFP 1/07/2011
			   VFT_SaveAs1(2); //User-input filename *.VFTr  EFP 11/23/2012
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"A81Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
////void __fastcall TForm1::SaveAsExecute(TObject *Sender)
//void TForm1::VFT_SaveAs(char gVFTnameStem[])
void TForm1::VFT_SaveAs1(int ksw)
//Convention: isw=0 default name Model.VFTr; isw= other user chosen filename  EFP 11/23/2012
// *.VFTr is NOT COMMA-DELIMITED currently
// TBD: Currently using & writing highest node number but only writing active nodes. Switch to memory-saving "true node number" scheme
//      This is a cat's ass scheme. Switch to pre-read/reserve memory/read again
{long i=0,j=0,isw=0,jsw=0,control[10],eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000,accum=0;
 char *fnNeed=NULL;
 if(base.nop1)
//   {if(ksw)
   {if(ksw==1)
	  {SaveDialog1->Filter= "VFTr format (*.VFTr,*.vftr)|*.VFTr;*.vftr";
//    SaveDialog1->Caption= "Caution: Type .VFTr if not present";
	   if(SaveDialog1->Execute())
		 {jsw=1;
///////////////////
honk<<SaveDialog1->FileName.t_str()<<" SaveDialog1->FileName.t_str()\n"; //Note that c_str() & w_str() do not work here
honk<<ExtractFileName(SaveDialog1->FileName).t_str()<<" ExtractFileName(SaveDialog1->FileName).t_str()\n";
honk<<ExtractFileExt(SaveDialog1->FileName).t_str()<<" ExtractFileExt(SaveDialog1->FileName).t_str()\n";
		  fnNeed=new char[strlen(SaveDialog1->FileName.t_str())+1+5];
		  StringCchCopy(fnNeed,strlen(SaveDialog1->FileName.t_str())+1+5,SaveDialog1->FileName.t_str());
		  if(ExtractFileExt(SaveDialog1->FileName)==L"")StringCchCat(fnNeed,strlen(SaveDialog1->FileName.t_str())+1+5,".VFTr");
		 }
	   else {jsw=0;
//	   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open SaveAs dialog",L"Failure",MB_OK);
			}
	  }
	else if(ksw==2){jsw=1;
					fnNeed=new char[11];fnNeed[0]='M';fnNeed[1]='o';fnNeed[2]='d';fnNeed[3]='e';fnNeed[4]='l';fnNeed[5]='.';fnNeed[6]='V';fnNeed[7]='F';fnNeed[8]='T';fnNeed[9]='a';fnNeed[10]='\0';
				   }
	else {jsw=1;
		  fnNeed=new char[11];fnNeed[0]='M';fnNeed[1]='o';fnNeed[2]='d';fnNeed[3]='e';fnNeed[4]='l';fnNeed[5]='.';fnNeed[6]='V';fnNeed[7]='F';fnNeed[8]='T';fnNeed[9]='r';fnNeed[10]='\0';
		 }
	if(jsw)
	  {StringCchCopy(VFTr_name,strlen(fnNeed),fnNeed);
	   ofstream ntape(fnNeed);delete [] fnNeed;
honk<<VFTr_name<<" VFTr_name VFTSAVEASsolid\n";
	   if(ntape){ntape.setf(ios::scientific);


//aaaaaaaaaaaaaaaaaaaaa
if(ksw!=2){
//bbbbbbbbbbbbbbbbbbbbb
				 for(i=0;i<10;i++)control[i]=0;
honk<<base.npoin<<" enter VFTsaveAs "<<base.nelt<<"\n";
////				 control[0]=1; //Flag for old *.VFT
//				 control[0]=2; //Flag for VFT version3.x
				 control[0]=3; //Flag for VFT version3.x for 2013, with wp.lstart==weld length
				 control[1]=base.npoin; //#nodes (Currently, highest node-NOT #active nodes)
				 control[2]=base.nelt; //#elem   (Currently, #active elements, not highest element)
//				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//				 try {
				 ntape<<control[0]<<" "<<control[1]<<" "<<control[2]<<" "<<control[3]<<" "<<control[4]<<" "<<
						control[5]<<" "<<control[6]<<" "<<control[7]<<" "<<control[8]<<" "<<control[9]<<"\n";
//				 for(i=0;i<base.npoin;i++)ntape<<i+1<<" "<<base.c1[NDF*i  ]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n"; //EFP 11/24/2010
//				 for(i=0;i<base.npoin;i++)if(base.node_map[i]>0)ntape<<i+1<<" "<<base.c1[NDF*i  ]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n"; //EFP 11/24/2010
				 for(i=0;i<base.npoin;i++)ntape<<base.node_map[i]+1<<" "<<base.c1[NDF*i  ]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n"; //EFP 11/24/2010
//				 for(i=0;i<base.npoin;i++){if(base.node_map[i]>0)ntape<<i+1<<" "<<base.c1[NDF*i  ]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n";
//										   else ntape<<0<<" "<<base.c1[NDF*i  ]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n";
//										  }
//// Policy: Write out 8 "corners" regardless of element type... Zero for nonexistent corners
//////				 for(i=0;i<base.nelt;i++)ntape<<i+1<<" "<<base.nop1[MXNPEL*i  ]+1<<" "<<base.nop1[MXNPEL*i+1]+1<<" "<<base.nop1[MXNPEL*i+2]+1<<" "<<base.nop1[MXNPEL*i+3]+1<<" "<<
//////														  base.nop1[MXNPEL*i+4]+1<<" "<<base.nop1[MXNPEL*i+5]+1<<" "<<base.nop1[MXNPEL*i+6]+1<<" "<<base.nop1[MXNPEL*i+7]+1<<"\n";
////				 for(i=0;i<base.nelt;i++)ntape<<base.el_map[i]+1<<" "<<base.nop1[MXNPEL*i  ]+1<<" "<<base.nop1[MXNPEL*i+1]+1<<" "<<base.nop1[MXNPEL*i+2]+1<<" "<<base.nop1[MXNPEL*i+3]+1<<" "<<
////																	   base.nop1[MXNPEL*i+4]+1<<" "<<base.nop1[MXNPEL*i+5]+1<<" "<<base.nop1[MXNPEL*i+6]+1<<" "<<base.nop1[MXNPEL*i+7]+1<<"\n";
//				 for(i=0;i<base.nelt;i++)ntape<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<" "<<
//																	   base.node_map[base.nop1[MXNPEL*i+4]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
				 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
										  if(eltype==8){if(node==8) //EFP 6/12/2014
ntape<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+4]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+6]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+7]]+1<<"\n";
														else
ntape<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+12]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+15]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+16]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+17]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+18]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+19]]+1<<"\n";
													   }
										  else if(eltype==7){if(node==6)
ntape<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+4]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+5]]+1<<"\n";
															 else
ntape<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+10]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+11]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+12]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+13]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+14]]+1<<"\n";
															}
										  else if(eltype==5){if(node==4)
ntape<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i  ]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+1]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+2]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+3]]+1<<"\n";
															 else
ntape<<base.el_map[i]+1<<" "<<base.node_map[base.nop1[MXNPEL*i   ]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 1]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 2]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 3]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+ 4]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 5]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 6]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 7]]+1<<" "<<
							  base.node_map[base.nop1[MXNPEL*i+ 8]]+1<<" "<<base.node_map[base.nop1[MXNPEL*i+ 9]]+1<<"\n";
															}
										  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"VFT_SaveAs() unsupported element type",L"Terminate",MB_OK);exit(0);}
										 }
honk<<wp.nWeldGroup<<" SaveAs wp.nWeldGroup\n";


//ntape<<base.nelt<<"\n";
//if(1==1)exit(0);
accum=0;ntape<<accum<<"\n"; //Just in case  EFP 4/03/2011
accum=0;ntape<<accum<<"\n";// Omit JavaVFT group[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupsall[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupA[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupsallname[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupsallindex[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groups[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupscount[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupname[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupsname[]
//wwwwwwwwwwwwwww
//wwwwwwwwwwwwwww
//wwwwwwwwwwwwwww
//wp.nWeldGroup=0;
//extern PACKAGE void __fastcall Beep(void);
//Application->MessageBox(L"wp.nWeldGroup set to 0",L"Frantic note",MB_OK);
//wwwwwwwwwwwwwww
//wwwwwwwwwwwwwww
//wwwwwwwwwwwwwww
				 ntape<<wp.nWeldGroup<<"\n";
//if(1==1)exit(0);

				 if(wp.nWeldGroup){for(j=0;j<wp.nWeldGroup;j++)
								   {
/////////////  Include just in case  EFP 4/03/2011
//////////////
//////////////
accum=0;ntape<<accum<<"\n"; //Just in case  EFP 4/03/2011
accum=0;ntape<<accum<<"\n";// Omit JavaVFT group[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupsall[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupA[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupsallname[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupsallindex[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groups[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupscount[]
accum=0;ntape<<accum<<"\n";// Omit JavaVFT groupname[]
//////////////
/////////////
////////////
									accum=0;
//									for(i=0;i<base.nelt;i++){
//eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[i]-eltype*t7-bscode*t5-node*t3;
//															 if(ieGID==j+1)accum++;
//															}
									for(i=0;i<base.nelt;i++){
////eltype=base.orig_matno[i]/t7;bscode=(base.orig_matno[i]-eltype*t7)/t5;node=(base.orig_matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.orig_matno[i]-eltype*t7-bscode*t5-node*t3;

////	 if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
////	 else ieGID=base.arrELSET[ base.trackELSET[i]+1 ];
//////////////// EFP 2/20/2012
//						if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
//						else if(base.arrELSET[ base.trackELSET[i+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[i+1]-2 ];
//						else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[i]+base.GIDcol ]; //Prioritize WG
//							  else ieGID=base.arrELSET[ base.trackELSET[i+1]-1 ];                      //Prioritize WP
//							 }
ieGID=base.arrELSET[i];
////////////// but this does not use indat.xxx ?

															 if(ieGID==j+1)accum++;
															}
									ntape<<accum<<"\n";
////									ntape<<"WeldGroup "<<j+1<<"\n";
//									ntape<<base.groupsname[j].c_str()<<"\n";// EFP 3/15/2011
									ntape<<base.groupsname[j].t_str()<<"\n";// EFP 3/15/2011 then 3/27/2011
									for(i=0;i<base.nelt;i++){
////eltype=base.orig_matno[i]/t7;bscode=(base.orig_matno[i]-eltype*t7)/t5;node=(base.orig_matno[i]-eltype*t7-bscode*t5)/t3;ieGID=base.orig_matno[i]-eltype*t7-bscode*t5-node*t3;

////	 if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
////	 else ieGID=base.arrELSET[ base.trackELSET[i]+1 ];
//////////////// EFP 2/20/2012
//						if(base.trackELSET[i+1]-base.trackELSET[i]==1)ieGID=0;
//						else if(base.arrELSET[ base.trackELSET[i+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[i+1]-2 ];
//						else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[i]+base.GIDcol ]; //Prioritize WG
//							  else ieGID=base.arrELSET[ base.trackELSET[i+1]-1 ];                      //Prioritize WP
//							 }
ieGID=base.arrELSET[i];
////////////// but this does not use indat.xxx ?

															 if(ieGID==j+1)ntape<<i+1<<"\n";
															}
								   }
								  }

////				 for(i=0;i<base.npoin;i++)ntape<<i+1<<" "<<i+1<<"\n"; // Nodal hashtable
//				 for(i=0;i<base.npoin;i++)ntape<<i+1<<" "<<base.node_map[i]+1<<"\n"; // Nodal hashtable
//				 for(i=0;i<base.nelt;i++)ntape<<i+1<<" "<<base.el_map[i]+1<<"\n"; // Element hashtable
//


//aaaaaaaaaaaaaaaaaaaaa
		  }
//bbbbbbbbbbbbbbbbbbbbb
honk<<wp.nWeldPass<<" pear0\n";
				 ntape<<wp.nWeldPass<<"\n";
//if(1==1)exit(0);
				 if(wp.nWeldPass){for(i=0;i<wp.nWeldPass;i++){
		ntape<<wp.name[i].t_str()<<"\n";
		ntape<<wp.matName[i].t_str()<<"\n";
		ntape<<wp.seqNum[i]<<"\n";
		ntape<<wp.boolFlags[i]<<"\n";
		ntape<<wp.type[i]<<"\n";
		ntape<<wp.shape[i]<<"\n";
		ntape<<wp.stepInterval[i]<<"\n";
		ntape<<wp.hp[i]<<"\n";
		ntape<<wp.nsegs[i]<<"\n";
		ntape<<wp.iselect[i]<<"\n"; //Remember wp.eles[]=10*ie+iside in the following (ditto wp.sttEles[])
//		for(j=0;j<wp.memWGa;j++)ntape<<wp.eles[wp.memWGa*i+j]<<"\n";  // Elements in this weld pass
		accum=0;for(j=0;j<wp.memWGa;j++){if(wp.eles[wp.memWGa*i+j]> -1)accum++;  // Elements in this weld pass
										 else break;
										}
		ntape<<accum<<"\n";
		for(j=0;j<accum;j++)ntape<<wp.eles[wp.memWGa*i+j]<<"\n";  // Elements in this weld pass
////		wp.sttEles=new long[wp.nWeldPass+1*bnelt*4];  // No need for *4 ????
//		for(j=0;j<wp.memWGa;j++)ntape<<wp.sttEles[wp.memWGa*i+j]<<"\n";  // No need for *4 ????
		accum=0;for(j=0;j<wp.memWGa;j++){if(wp.sttEles[wp.memWGa*i+j]> -1)accum++;
										 else break;
										}
		ntape<<accum<<"\n";
		for(j=0;j<accum;j++)ntape<<wp.sttEles[wp.memWGa*i+j]<<"\n";  // No need for *4 ????
//		wp.stpEle=new long[wp.nWeldPass+1*bnelt];  // No need for *bnelt
		ntape<<wp.stpEle[i]<<"\n";  // No need for *bnelt
//		for(j=0;j<wp.memWGa;j++)ntape<<wp.firstEle[wp.memWGa*i+j]<<"\n";
		accum=0;for(j=0;j<wp.memWGa;j++){if(wp.firstEle[wp.memWGa*i+j]> -1)accum++;
										 else break;
										}
		ntape<<accum<<"\n";
		for(j=0;j<accum;j++)ntape<<wp.firstEle[wp.memWGa*i+j]<<"\n";
//		for(j=0;j<wp.memWGa;j++)ntape<<wp.nextEle[wp.memWGa*i+j]<<"\n";
		accum=0;for(j=0;j<wp.memWGa;j++){if(wp.nextEle[wp.memWGa*i+j]> -1)accum++;
										 else break;
										}
		ntape<<accum<<"\n";
		for(j=0;j<accum;j++)ntape<<wp.nextEle[wp.memWGa*i+j]<<"\n";
		for(j=0;j<4;j++)ntape<<wp.snorm1[i*4+j]<<"\n";
		for(j=0;j<4;j++)ntape<<wp.snorm2[i*4+j]<<"\n";
		for(j=0;j<3;j++)ntape<<wp.circEles[i*3+j]<<"\n";

////////////////////
////////////////////
//////////////////// Attempt to accommodate uncertain edgeEles/edgeNodes  EFP 4/09/2011
//		for(j=0;j<wp.memWGa;j++)ntape<<wp.edgeEles[wp.memWGa*i+j]<<"\n";
		accum=0;for(j=0;j<wp.memWGa;j++){if(wp.edgeEles[wp.memWGa*i+j]> -1)accum++;
										 else break;
										}
		ntape<<accum<<"\n";
//		for(j=0;j<accum;j++)ntape<<wp.edgeEles[wp.memWGa*i+j]<<"\n";
//		for(j=0;j<4;j++)ntape<<wp.edgeNodes[i*4+j]<<"\n"; // correct???
		if(accum){
				  for(j=0;j<accum;j++)ntape<<wp.edgeEles[wp.memWGa*i+j]<<"\n";
				  for(j=0;j<4;j++)ntape<<wp.edgeNodes[i*4+j]<<"\n"; // correct???
				 }
////////////////////
////////////////////
////////////////////

//		for(j=0;j<4*wp.memWGa;j++)ntape<<wp.sttEleNodes[i*wp.memWGa*4+j]<<"\n";
		accum=0;for(j=0;j<4*wp.memWGa;j++){if(wp.sttEleNodes[i*wp.memWGa*4+j]> -1)accum++;
										   else break;
										  }
		ntape<<accum<<"\n";
		for(j=0;j<accum;j++)ntape<<wp.sttEleNodes[i*wp.memWGa*4+j]<<"\n";
//		ntape<<wp.curr[i]<<"\n";
//		ntape<<wp.volt[i]<<"\n";
//		ntape<<wp.eff[i]<<"\n";
//		ntape<<wp.speed[i]<<"\n";
//		ntape<<wp.troom[i]<<"\n";
//		ntape<<wp.tmelt[i]<<"\n";
//		ntape<<wp.tcutl[i]<<"\n";
//		ntape<<wp.tcuth[i]<<"\n";
//		ntape<<wp.timeInterval[i]<<"\n";
//		ntape<<wp.maxiHeatStep[i]<<"\n";
//		ntape<<wp.miniHeatStep[i]<<"\n";
//		ntape<<wp.thk1[i]<<"\n";
//		ntape<<wp.thk2[i]<<"\n";
//		ntape<<wp.lstart[i]<<"\n";
//		ntape<<wp.lend[i]<<"\n";

		ntape<<wp.curr[i]<<"\n"<<wp.volt[i]<<"\n"<<wp.eff[i]<<"\n"<<wp.speed[i]<<"\n";
		ntape<<wp.troom[i]<<"\n"<<wp.tmelt[i]<<"\n"<<wp.tcutl[i]<<"\n"<<wp.tcuth[i]<<"\n";
		ntape<<wp.timeInterval[i]<<"\n"<<wp.maxiHeatStep[i]<<"\n"<<wp.miniHeatStep[i]<<"\n";
		ntape<<wp.thk1[i]<<"\n"<<wp.thk2[i]<<"\n";
		ntape<<wp.lstart[i]<<"\n"<<wp.lend[i]<<"\n";

//		for(j=0;j<wp.memWGa;j++)ntape<<wp.hlightel[wp.memWGa*i+j]<<"\n"; //Convention: 1st col= elem side#
		accum=0;for(j=0;j<wp.memWGa;j++){if(wp.hlightel[wp.memWGa*i+j]> -1)accum++; //Convention: 1st col= elem side#
										 else break;
										}
		ntape<<accum<<"\n";
		for(j=0;j<accum;j++)ntape<<wp.hlightel[wp.memWGa*i+j]<<"\n"; //Convention: 1st col= elem side#
		for(j=0;j<3*NDF;j++)ntape<<wp.arrows[3*NDF*i+j]<<"\n"; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		ntape<<wp.n_curr_sttEl[i]<<"\n";
		ntape<<wp.wpTimes[i]<<"\n";
		ntape<<wp.source[i]<<"\n";
		ntape<<wp.mcr[i]<<"\n"; // Not part of original VFT
///////////////////////////
//if(1==1)exit(0);
honk<<(long)wp.WeldColor[i]<<" Weldcolor "<<i<<"\n";
///////////////////////////
		ntape<<(long)wp.WeldColor[i]<<"\n";
		accum=0;ntape<<accum<<"\n";//Just in case  EFP 4/03/2011
															 }
								 }
//aaaaaaaaaaaaaaaaaaaaa
if(ksw!=2){
//bbbbbbbbbbbbbbbbbbbbb
honk<<wps.nWeldParamSet<<" pear1\n";
//if(1==1)exit(0);
				 ntape<<wps.nWeldParamSet<<"\n";
				 if(wps.nWeldParamSet){for(i=0;i<wps.nWeldParamSet;i++){
//		ntape<<wps.name[i].t_str()<<"\n";
//		ntape<<wps.curr[i]<<"\n";
//		ntape<<wps.volt[i]<<"\n";
//		ntape<<wps.eff[i]<<"\n";
//		ntape<<wps.speed[i]<<"\n";

		ntape<<wps.name[i].t_str()<<"\n";ntape<<wps.curr[i]<<"\n"<<wps.volt[i]<<"\n"<<wps.eff[i]<<"\n"<<wps.speed[i]<<"\n";
		accum=0;ntape<<accum<<"\n";  //Just in case of future expansion  EFP 4/03/2011
																	   }
									  }
honk<<wms.nMatPropSet<<" pear2\n";

//if(1==1)exit(0);

				 ntape<<wms.nMatPropSet<<"\n";
				 if(wms.nMatPropSet){for(i=0;i<wms.nMatPropSet;i++){
		ntape<<wms.name[i].t_str()<<"\n";
		ntape<<wms.matFileName[i].t_str()<<"\n";
//		ntape<<wms.Steps[i].t_str()<<"\n"; //Emergency EFP 11/11/2010
		ntape<<"0\n";

//		ntape<<wms.mcr[i]<<"\n";
//		ntape<<wms.annjd[i]<<"\n";
//		ntape<<wms.ved[i]<<"\n";
//		ntape<<wms.hetjd[i]<<"\n";
//		ntape<<wms.nprops[i]<<"\n";
//		ntape<<wms.cond[i]<<"\n";
//		ntape<<wms.heat[i]<<"\n";
//		ntape<<wms.den[i]<<"\n";
//		ntape<<wms.Ti[i]<<"\n";
//		ntape<<wms.Ta[i]<<"\n";
//		ntape<<wms.Tm[i]<<"\n";
//		ntape<<int(wms.switc[i])<<"\n";

		ntape<<wms.mcr[i]<<"\n"<<wms.annjd[i]<<"\n"<<wms.ved[i]<<"\n"<<wms.hetjd[i]<<"\n"<<wms.nprops[i]<<"\n";
		ntape<<wms.cond[i]<<"\n"<<wms.heat[i]<<"\n"<<wms.den[i]<<"\n"<<wms.Ti[i]<<"\n"<<wms.Ta[i]<<"\n"<<wms.Tm[i]<<"\n";
		ntape<<int(wms.switc[i])<<"\n";
		accum=0;ntape<<accum<<"\n";  //Just in case of future expansion  EFP 4/03/2011
																   }
									}
		accum=0;ntape<<accum<<"\n";  //Just in case of future expansion  EFP 4/03/2011
//aaaaaaaaaaaaaaaaaaaaa
		  }
//bbbbbbbbbbbbbbbbbbbbb
//
//if(1==1)exit(0);



////					 }
////				 __finally {
//				 Screen->Cursor=Save_Cursor;
////				 }
				 ntape.close();

/////////// Cursor EFP 1/21/2011
//Screen->Cursor=crSizeAll;
///////////
//if(1==1)exit(0);

				}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open file",L"Failure",MB_OK);}
	  }
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"84Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::RestoreExecute(TObject *Sender)
//Same as BitBtn9Click()
{if(base.nop1){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
			   iplotType=0;FDrestore();
//               FD_LButtonstatus=11; // stateVFT=2 for pivot, 3 for pan
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"86Get geometry file->File/Open.",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::ImportVFTrExecute(TObject *Sender)
//void __fastcall TForm1::CAPgeomOpenExecute(TObject *Sender)
// Import *.VFTr
// TBD: Currently using & reading highest node number. Switch to memory-saving "true node number" scheme
// Policy on 4/09/2011 Nodal geom list & topology list are shifted. Subsequent data is NOT shifted.
// Note current policy: *.VFTr files can have WG & WP. However, whenever an element has both WG & WP, WP takes precedence.
//    A subroutine checks for annihilation of WG.  EFP 1/23/2012
// TBD: increase 199 to allow for 20n hex element connectivity read from 1 line
{
 int nic=0,nrc=0
//, *temp_allGID=NULL
;
// int *tw_allGID=NULL;
 float pval=0.,darr[9];
// long ix=0,i=0,ii=0,ie=0,ir=0,ipid=0,nop0=0,nop1=0,nop2=0,nop3=0,nop4=0,nop5=0,nop6=0,nop7=0,dummy=0,larr[9]
 long ix=0,i=0,ii=0,ie=0,ir=0,ipid=0,nop0=0,nop1=0,nop2=0,nop3=0,nop4=0,nop5=0,nop6=0,nop7=0,dummy=0,larr[20+1]
	  ,control[10],accum=0,j=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000,sumlim=0,
	  nodeuplim=0,nodelolim=0,eluplim=0,wpWG=0,wpWP=0,in=0,ip=0,inp=0,sumELSETel=0, *revnode_map=NULL;
 char descript0[41],descript1[41],descript2[41],cht[10*(MXNPELS+3)],chtm[200],*temp_cht=NULL; // Anticipate 23I10
//String efpAnsi1[20];
//String *efpAnsi=NULL;
//String *SWPTname=NULL;
char *efpChar=NULL;
 wchar_t curMess0[]=L"WeldParam",string1[15],curMess1[16],curMess2[]=L"Reduced from ",curMess3[]=L" to ",string0[32];
// wchar_t string0[40],curMess0[]=L"WeldParam",string1[15];
//wchar_t curMess0[]=L"WeldParam",string1[15];
// _ltow(wps.nWeldParamSet+1,string1,10);
// StringCchCatW(curMess0,39+1,string1); //Length of destination curMess0 is provided.
// wps.name[wps.nWeldParamSet]=curMess0;

//String *tw_groupsname=NULL;

 base.npoin=base.nelt=base.nvfix=base.nedge=base.pload=base.mat=base.nblod=nGIDmax=base.allGrp=base.ELSETelsum=0;
 base.matsteps=base.ncoorf=1;MXNPEL=8;
 if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
 else {
 OpenDialog1->Filter= "VFTr format (*.VFTr,*.vftr)|*.VFTr;*.vftr";
 if(OpenDialog1->Execute())
   {ifstream ntape0(OpenDialog1->FileName.c_str(),ios::nocreate|ios::binary,0);
	if(ntape0)
	  {
////////////////////////////////////////// start EFP 11/13/2011
//char *driveEFP=NULL,*dirEFP=NULL,*extEFP=NULL;
//driveEFP=new char[260];dirEFP=new char[260];extEFP=new char[260];
////fnsplit(OpenDialog1->FileName.c_str(),driveEFP,dirEFP,modelName_g,extEFP);
//_wfnsplit(OpenDialog1->FileName,driveEFP,dirEFP,modelName_g,extEFP);
//honk<< driveEFP<<" driveEFP\n";honk<< dirEFP<<" dirEFP\n";honk<< modelName_g<<" modelName_g\n";honk<< extEFP<<" extEFP\n";
//delete [] driveEFP;delete [] dirEFP;delete [] extEFP;
//
//gWsiAlias=(String)modelName_g; // where char modelName_g[260] in *.h
//honk<<gWsiAlias.t_str()<<" gWsiAliasImportVFTrmmmmmm\n";
//// Perhaps the above should be moved within   if(ntape){  ??? EFP 2/27/2012
////////////////////////////////////////// end




//TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {




//				 ntape>>control[0]>>control[1]>>control[2]>>control[3]>>control[4]>>
//						control[5]>>control[6]>>control[7]>>control[8]>>control[9];
				 ntape0.getline(chtm,199);parse_cdm(chtm,8,&nic,&nrc,larr,darr);
/////////////// EFP 4/04/2011
//	   if(larr[0]==2){sumELSETel=0;
	   if(larr[0]==3){sumELSETel=0;
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
///////////////
//				 base.npoin=control[1]; //#nodes (Currently, highest node-NOT #active nodes)
//				 base.nelt=control[2]; //#elem
				 base.npoin=larr[1]; //#nodes (Currently, highest node-NOT #active nodes)
				 base.nelt=larr[2]; //#elem
honk<<base.npoin<<" Total npoin/nelt "<<base.nelt<<"\n";
honk<<base.npoin<<" "<<base.nelt<<" "<<MXNPEL<<" #nodes,#nelm,MXNPEL VFTgeomOpenExecute\n";
	   if(base.nelt> LONG_INT/t3){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Excessive #elements in *.VFT file",L"Terminate",MB_OK);exit(0);}
	   nodeuplim=0;nodelolim=LONG_INT;
	   for(i=0;i<base.npoin;i++)
		 {ntape0.getline(chtm,199);parse_cdm(chtm,4,&nic,&nrc,larr,darr);ix=larr[0];
		  if(nodeuplim<ix)nodeuplim=ix;
		  if(nodelolim>ix)nodelolim=ix;
		 }
	   eluplim=0;
	   for(i=0;i<base.nelt;i++){ntape0.getline(chtm,199);parse_cdm(chtm,9,&nic,&nrc,larr,darr);ii=larr[0];
								if(eluplim<ii)eluplim=ii;
							   }
//////////////////////  EFP 2/11/2012
///////////////////////
////////////////////////
/////////////////////////
//////////////////////////
///////////////////////////
ntape0.getline(chtm,199); //Just in case  EFP 4/03/2011
ntape0.getline(chtm,199);// Omit JavaVFT group[]
ntape0.getline(chtm,199);// Omit JavaVFT groupsall[]
ntape0.getline(chtm,199);// Omit JavaVFT groupA[]
ntape0.getline(chtm,199);// Omit JavaVFT groupsallname[]
ntape0.getline(chtm,199);// Omit JavaVFT groupsallindex[]
ntape0.getline(chtm,199);// Omit JavaVFT groups[]
ntape0.getline(chtm,199);// Omit JavaVFT groupscount[]
ntape0.getline(chtm,199);// Omit JavaVFT groupname[]
ntape0.getline(chtm,199);// Omit JavaVFT groupsname[]
				 ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wpWG=larr[0];
/////////////////////////////////
//FDdynmem_manage(13,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.ncoorf,dummy,dummy);//EFP 3/15/2011
/////////////////////////////////
				 if(wpWG)         {sumlim=0;
								   for(j=0;j<wpWG;j++)
								   {
ntape0.getline(chtm,199); //Just in case  EFP 4/03/2011
ntape0.getline(chtm,199);// Omit JavaVFT group[]
ntape0.getline(chtm,199);// Omit JavaVFT groupsall[]
ntape0.getline(chtm,199);// Omit JavaVFT groupA[]
ntape0.getline(chtm,199);// Omit JavaVFT groupsallname[]
ntape0.getline(chtm,199);// Omit JavaVFT groupsallindex[]
ntape0.getline(chtm,199);// Omit JavaVFT groups[]
ntape0.getline(chtm,199);// Omit JavaVFT groupscount[]
ntape0.getline(chtm,199);// Omit JavaVFT groupname[]
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
ntape0.getline(chtm,199);
									if(sumlim<accum)sumlim=accum;
									for(ii=0;ii<accum;ii++){ntape0.getline(chtm,199);
															sumELSETel++;
														   }
								   }
								   wp.memWGa=sumlim;
								  }
				 else wp.memWGa=0;
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wpWP=larr[0];
			   if(wpWP)     {   for(i=0;i<wpWP;i++){
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		wp.memWGa=max(wp.memWGa,accum);//Emergency Code to plot WP without WG
		for(j=0;j<accum;j++){ntape0.getline(chtm,199);
//parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.eles[wp.memWGa*i+j]=larr[0];
							 sumELSETel++;
							}
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++)ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++)ntape0.getline(chtm,199);
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++)ntape0.getline(chtm,199);
		for(j=0;j<4;j++)ntape0.getline(chtm,199);
		for(j=0;j<4;j++)ntape0.getline(chtm,199);
		for(j=0;j<3;j++)ntape0.getline(chtm,199);
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		if(accum){ //Attempt to accommodate uncertain edgeEles/edgeNodes  EFP 4/09/2011
				  for(j=0;j<accum;j++)ntape0.getline(chtm,199);
				  for(j=0;j<4;j++)ntape0.getline(chtm,199);
				 }
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++)ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++)ntape0.getline(chtm,199);
		for(j=0;j<3*NDF;j++)ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
ntape0.getline(chtm,199);
														   }
							   }
/*
				 for(i=0;i<wp.nWeldPass;i++){
											 for(j=0;j<wp.memWGa;j++)
											   {if(wp.eles[wp.memWGa*i+j]<0)break;
												else {ie=wp.eles[wp.memWGa*i+j]/10;
eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
base.matno[ie]=base.matno[ie]-ieGID+wp.nWeldGroup+i+1;
													 }
											   }
											 wp.prevGID[i]=ieGID; //Correction EFP 3/27/2011
											}
nGID=wp.nWeldGroup+wp.nWeldPass+1;nGIDmax=nGID;
*/
///////////////////////////
//////////////////////////
/////////////////////////
////////////////////////
///////////////////////
//////////////////////


//HERO
	   GeomFileName=OpenDialog1->FileName;ntape0.close();
/////////// Cursor EFP 1/03/2013
//Screen->Cursor=crSizeAll;
Screen->Cursor=Save_Cursor;
///////////
//	   base.matsteps=matstep;
//honk<<nodeuplim<<" "<<nodelolim<<" "<<base.npoin<<" "<<eluplim<<" "<<base.nelt<<" "<<MXNPEL<<" DDDDDDDD\n";
	   if(nodeuplim != base.npoin)honk<<nodeuplim<<" Nonconsecutive node numbers in file "<<base.npoin<<"\n";
	   if(eluplim != base.nelt)honk<<eluplim<<" Nonconsecutive element numbers in file "<<base.nelt<<"\n";
	   if(base.npoin>0 && base.nelt>0)
//		 {FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.ncoorf,dummy,MXNPEL);
		 {FDdynmem_manage(1,base.npoin,base.nelt,dummy,dummy,dummy,base.npoin,dummy,dummy,dummy,dummy,base.ncoorf,dummy,MXNPEL);
		  FDdynmem_manage(15,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt);
//vvvvvvvvvvvvvvvvvvv //Correction  EFp 4/13/2013
			 for(in=0;in<2*base.npoin;in++)base.nofix[in]=0;
			 for(in=0;in<base.npoin;in++)base.nrfix[in]=0;
			 for(in=0;in<NDF*base.npoin;in++)base.presc[in]=0.;
//vvvvvvvvvvvvvvvvvvv
		  ifstream ntape(OpenDialog1->FileName.c_str(),ios::nocreate|ios::binary,0);
		  if(ntape)
			{
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//			 base.allGrp=wpWG+1;
			 base.allGrp=wpWG+wpWP+1;//Emergency Code to plot WP without WG
honk<<base.allGrp<<" "<<wpWG<<" "<<wpWP<<" Zooey0 "<<wp.memWGa<<"\n";
//if(1==1)exit(0);

	   for(i=0;i<base.nelt;i++)base.arELEM[i]=1; //Correction EFP 12/03/2010
	   for(i=0;i<base.nelt;i++)base.arrELSET[i]=0;
//	   for(i=0;i<base.npoin;i++)base.node_map[i]= -1;
revnode_map=new long[nodeuplim-nodelolim+1];
//			   temp_allGID=new int[(base.allGrp+wpWP)*base.nelt];
//			   for(in=0;in<(base.allGrp+wpWP)*base.nelt;in++)temp_allGID[in]=0;
//			   for(in=0;in<base.nelt;in++)temp_allGID[in]=1;
				 ntape.getline(chtm,199);
	   for(i=0;i<base.npoin;i++) //Remember that this is cat's ass max-memory coding
		 {
//		  ntape>>ix>>descript0>>descript1>>descript2;
//		  if(ix>0){parse_cdv(descript0,&pval);base.c1[NDF*ix-3]= pval;
//				   parse_cdv(descript1,&pval);base.c1[NDF*ix-2]= pval;
//				   parse_cdv(descript2,&pval);base.c1[NDF*ix-1]= pval;
//				   base.node_map[ix-1]=1;
//				  }
//		  else {base.c1[NDF*ix-3]=base.c1[NDF*ix-2]=base.c1[NDF*ix-1]=0.;}

		  ntape.getline(chtm,199);parse_cdm(chtm,4,&nic,&nrc,larr,darr);ix=larr[0]-1;
////		  if(ix>0){base.c1[NDF*ix-3]=darr[0];base.c1[NDF*ix-2]=darr[1];base.c1[NDF*ix-1]=darr[2];}
////		  else {base.c1[NDF*ix-3]=base.c1[NDF*ix-2]=base.c1[NDF*ix-1]=0.;}
//		  base.c1[NDF*ix-3]=darr[0];base.c1[NDF*ix-2]=darr[1];base.c1[NDF*ix-1]=darr[2]; //EFP 11/24/2010
		  base.c1[NDF*i]=darr[0];base.c1[NDF*i+1]=darr[1];base.c1[NDF*i+2]=darr[2]; //EFP 4/03/2011
		  base.node_map[i]=ix;
		  revnode_map[ix-nodelolim+1]=i;
///////////////////////////////////////////////////
//honk<<i+1<<" "<<ix+1<<" headtohead "<<i<<" "<<ix-nodelolim+1<<" "<<base.node_map[i]+1<<" IngressC "<<base.c1[NDF*i]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n";
///////////////////////////////////////////////////
		 }
		 ipid=1; //Treat all elements as base metal initially
				 for(i=0;i<base.nelt;i++){
				 ntape.getline(chtm,199);
////				 parse_cdm(chtm,9,&nic,&nrc,larr,darr);
//				 parse_cdmQ(chtm,21,&nic,&nrc,larr,darr,strlen(chtm)); //Test this to make sure it can read correctly
				 parse_cdmQb(chtm,21,&nic,&nrc,larr,darr,strlen(chtm)-1); //strlen() should not include end-of-line BUT IT DOES SO USE -1??? Why? EFP 6/19/2014

//honk<<i<<" "<<nic<<" "<<strlen(chtm)<<" Quasimodo "<<chtm<<"\n";
//if(nic==9)honk<<larr[0]<<" VFTin8 "<<larr[1]<<" "<<larr[2]<<" "<<larr[3]<<" "<<larr[4]<<" "<<larr[5]<<" "<<larr[6]<<" "<<larr[7]<<" "<<larr[8]<<"\n";
//if(nic==7)honk<<larr[0]<<" VFTin6666666 "<<larr[1]<<" "<<larr[2]<<" "<<larr[3]<<" "<<larr[4]<<" "<<larr[5]<<" "<<larr[6]<<"\n";
////if(1==1)exit(0);

				 ii=larr[0]-1;// TBD: shift this
				 base.el_map[i]=ii;
				 if(nic-1==8){
base.nop1[MXNPEL*i  ]=revnode_map[larr[1]-nodelolim];base.nop1[MXNPEL*i+1]=revnode_map[larr[2]-nodelolim];
base.nop1[MXNPEL*i+2]=revnode_map[larr[3]-nodelolim];base.nop1[MXNPEL*i+3]=revnode_map[larr[4]-nodelolim];
base.nop1[MXNPEL*i+4]=revnode_map[larr[5]-nodelolim];base.nop1[MXNPEL*i+5]=revnode_map[larr[6]-nodelolim];
base.nop1[MXNPEL*i+6]=revnode_map[larr[7]-nodelolim];base.nop1[MXNPEL*i+7]=revnode_map[larr[8]-nodelolim];
//				 base.matno[i]=8*t7+8*1000; // EFP 1/30/2011
//				 base.orig_matno[i]=8*t7+8*1000;

honk<<ii+1<<" VFTc3D888888 "<<i<<"\n";

				 base.matno[i]=base.orig_matno[i]=8*t7+8*1000;
							 }
				 else if(nic-1==6){
base.nop1[MXNPEL*i  ]=revnode_map[larr[1]-nodelolim];base.nop1[MXNPEL*i+1]=revnode_map[larr[2]-nodelolim];
base.nop1[MXNPEL*i+2]=revnode_map[larr[3]-nodelolim];base.nop1[MXNPEL*i+3]=revnode_map[larr[4]-nodelolim];
base.nop1[MXNPEL*i+4]=revnode_map[larr[5]-nodelolim];base.nop1[MXNPEL*i+5]=revnode_map[larr[6]-nodelolim];

honk<<ii+1<<" VFTc3D6 "<<i<<"\n";

				 base.matno[i]=base.orig_matno[i]=7*t7+6*1000;
								  }
				 else if(nic-1==4){
base.nop1[MXNPEL*i  ]=revnode_map[larr[1]-nodelolim];base.nop1[MXNPEL*i+1]=revnode_map[larr[2]-nodelolim];
base.nop1[MXNPEL*i+2]=revnode_map[larr[3]-nodelolim];base.nop1[MXNPEL*i+3]=revnode_map[larr[4]-nodelolim];
				 base.matno[i]=base.orig_matno[i]=5*t7+4*1000;
								  }
				 else if(nic-1==20){
base.nop1[MXNPEL*i   ]=revnode_map[larr[ 1]-nodelolim];base.nop1[MXNPEL*i+ 1]=revnode_map[larr[ 2]-nodelolim];
base.nop1[MXNPEL*i+ 2]=revnode_map[larr[ 3]-nodelolim];base.nop1[MXNPEL*i+ 3]=revnode_map[larr[ 4]-nodelolim];
base.nop1[MXNPEL*i+ 4]=revnode_map[larr[ 5]-nodelolim];base.nop1[MXNPEL*i+ 5]=revnode_map[larr[ 6]-nodelolim];
base.nop1[MXNPEL*i+ 6]=revnode_map[larr[ 7]-nodelolim];base.nop1[MXNPEL*i+ 7]=revnode_map[larr[ 8]-nodelolim];
base.nop1[MXNPEL*i+ 8]=revnode_map[larr[ 9]-nodelolim];base.nop1[MXNPEL*i+ 9]=revnode_map[larr[10]-nodelolim];
base.nop1[MXNPEL*i+10]=revnode_map[larr[11]-nodelolim];base.nop1[MXNPEL*i+11]=revnode_map[larr[12]-nodelolim];
base.nop1[MXNPEL*i+12]=revnode_map[larr[13]-nodelolim];base.nop1[MXNPEL*i+13]=revnode_map[larr[14]-nodelolim];
base.nop1[MXNPEL*i+14]=revnode_map[larr[15]-nodelolim];base.nop1[MXNPEL*i+15]=revnode_map[larr[16]-nodelolim];
base.nop1[MXNPEL*i+16]=revnode_map[larr[17]-nodelolim];base.nop1[MXNPEL*i+17]=revnode_map[larr[18]-nodelolim];
base.nop1[MXNPEL*i+18]=revnode_map[larr[19]-nodelolim];base.nop1[MXNPEL*i+19]=revnode_map[larr[20]-nodelolim];
				 base.matno[i]=base.orig_matno[i]=8*t7+20*1000;
								   }
				 else if(nic-1==15){
base.nop1[MXNPEL*i   ]=revnode_map[larr[ 1]-nodelolim];base.nop1[MXNPEL*i+ 1]=revnode_map[larr[ 2]-nodelolim];
base.nop1[MXNPEL*i+ 2]=revnode_map[larr[ 3]-nodelolim];base.nop1[MXNPEL*i+ 3]=revnode_map[larr[ 4]-nodelolim];
base.nop1[MXNPEL*i+ 4]=revnode_map[larr[ 5]-nodelolim];base.nop1[MXNPEL*i+ 5]=revnode_map[larr[ 6]-nodelolim];
base.nop1[MXNPEL*i+ 6]=revnode_map[larr[ 7]-nodelolim];base.nop1[MXNPEL*i+ 7]=revnode_map[larr[ 8]-nodelolim];
base.nop1[MXNPEL*i+ 8]=revnode_map[larr[ 9]-nodelolim];base.nop1[MXNPEL*i+ 9]=revnode_map[larr[10]-nodelolim];
base.nop1[MXNPEL*i+10]=revnode_map[larr[11]-nodelolim];base.nop1[MXNPEL*i+11]=revnode_map[larr[12]-nodelolim];
base.nop1[MXNPEL*i+12]=revnode_map[larr[13]-nodelolim];base.nop1[MXNPEL*i+13]=revnode_map[larr[14]-nodelolim];
base.nop1[MXNPEL*i+14]=revnode_map[larr[15]-nodelolim];
				 base.matno[i]=base.orig_matno[i]=7*t7+15*1000;
								   }
				 else if(nic-1==10){
base.nop1[MXNPEL*i   ]=revnode_map[larr[ 1]-nodelolim];base.nop1[MXNPEL*i+ 1]=revnode_map[larr[ 2]-nodelolim];
base.nop1[MXNPEL*i+ 2]=revnode_map[larr[ 3]-nodelolim];base.nop1[MXNPEL*i+ 3]=revnode_map[larr[ 4]-nodelolim];
base.nop1[MXNPEL*i+ 4]=revnode_map[larr[ 5]-nodelolim];base.nop1[MXNPEL*i+ 5]=revnode_map[larr[ 6]-nodelolim];
base.nop1[MXNPEL*i+ 6]=revnode_map[larr[ 7]-nodelolim];base.nop1[MXNPEL*i+ 7]=revnode_map[larr[ 8]-nodelolim];
base.nop1[MXNPEL*i+ 8]=revnode_map[larr[ 9]-nodelolim];base.nop1[MXNPEL*i+ 9]=revnode_map[larr[10]-nodelolim];
				 base.matno[i]=base.orig_matno[i]=5*t7+10*1000;
								   }
				 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"ImportVFTr: Unsupported element type",L"Terminate",MB_OK);exit(0);}
///////////


										 }
			 delete [] revnode_map;
ntape.getline(chtm,199); //Just in case  EFP 4/03/2011
ntape.getline(chtm,199);// Omit JavaVFT group[]
ntape.getline(chtm,199);// Omit JavaVFT groupsall[]
ntape.getline(chtm,199);// Omit JavaVFT groupA[]
ntape.getline(chtm,199);// Omit JavaVFT groupsallname[]
ntape.getline(chtm,199);// Omit JavaVFT groupsallindex[]
ntape.getline(chtm,199);// Omit JavaVFT groups[]
ntape.getline(chtm,199);// Omit JavaVFT groupscount[]
ntape.getline(chtm,199);// Omit JavaVFT groupname[]
ntape.getline(chtm,199);// Omit JavaVFT groupsname[]

//	   ntape>>base.npoin>>base.nelt;
honk<<base.npoin<<" Highest npoin/nelt "<<base.nelt<<"\n";
honk<<base.npoin<<" "<<base.nelt<<" "<<MXNPEL<<" #nodes,#nelm,MXNPEL VFTgeomOpenExecute\n";
honk<<"\n";
	   for(i=0;i<9*base.ncoorf;i++)base.cangl[i]=0.;for(i=0;i<base.ncoorf;i++){base.cangl[9*i]=base.cangl[9*i+4]=base.cangl[9*i+8]=1.;}
//				 ntape>>wp.nWeldGroup;

				 ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.nWeldGroup=larr[0];
/////////////////////////////////
FDdynmem_manage(13,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.ncoorf,dummy,dummy);//EFP 3/15/2011
/////////////////////////////////
honk<<wp.nWeldGroup<<" ImportVFTr wp.nWeldGroup\n";
//if(1==1)exit(0);


				 if(wp.nWeldGroup){//sumlim=0;
								   for(j=0;j<wp.nWeldGroup;j++)
								   {

/////////////  Include just in case  EFP 4/03/2011
//////////////
//////////////
ntape.getline(chtm,199); //Just in case  EFP 4/03/2011
ntape.getline(chtm,199);// Omit JavaVFT group[]
ntape.getline(chtm,199);// Omit JavaVFT groupsall[]
ntape.getline(chtm,199);// Omit JavaVFT groupA[]
ntape.getline(chtm,199);// Omit JavaVFT groupsallname[]
ntape.getline(chtm,199);// Omit JavaVFT groupsallindex[]
ntape.getline(chtm,199);// Omit JavaVFT groups[]
ntape.getline(chtm,199);// Omit JavaVFT groupscount[]
ntape.getline(chtm,199);// Omit JavaVFT groupname[]
//////////////
/////////////
////////////


//									ntape>>accum;
				 ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
//									ntape>>descript0;
ntape.getline(chtm,199);
//////////////////////////////
temp_cht=new char[strlen(chtm)-1]; // This presumes the format  ** WeldGroupName\n
for(i=0;i<int(strlen(chtm))-1;i++)temp_cht[i]=chtm[i];
base.groupsname[j]=temp_cht; //EFP 3/15/2011
///////////////////////////////////////////////////
honk<<base.groupsname[j].c_str()<<" base.groupsname[j]\n";
///////////////////////////////////////////////////
delete [] temp_cht;
//*temp_cht=NULL;
//////////////////////////////

//honk<<strlen(chtm)<<" "<<chtm<<" "<<" WGnameCK0\n";


//									if(sumlim<accum)sumlim=accum;
									for(ii=0;ii<accum;ii++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);i=larr[0]; //DO I NEED A GLOBAL-LOCAL TRANSF HERE...?
//									i=i-1;
//temp_allGID[base.nelt*(j+1)+i]=1;//Add coding for basemetal&weldgroup
base.arrELSET[i-1]=j+1;//Add coding for basemetal&weldgroup
														   }
								   }
//								   wp.memWGa=sumlim;
								  }
//				 else wp.memWGa=0;

honk<<wp.nWeldGroup<<" ImportVFTr wp.nWeldGroup/wp.memWGa "<<wp.memWGa<<"\n";

//				 for(i=0;i<base.npoin;i++){
////				                           ntape>>ii>>j;
//ntape.getline(chtm,199);parse_cdm(chtm,2,&nic,&nrc,larr,darr);ii=larr[0];j=larr[1];
////										   base.node_map[ii-1]=j-1; // Correction EFP 11/24/2010
//										   base.node_map[i]=j-1; // Node hashtable
//										  }
//				 for(i=0;i<base.nelt;i++){
////				                          ntape>>ii>>j;
//ntape.getline(chtm,199);parse_cdm(chtm,2,&nic,&nrc,larr,darr);ii=larr[0];j=larr[1];
//										  base.el_map[i]=j-1; // Element hashtable
//										 }
//
//				 ntape>>wp.nWeldPass;
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.nWeldPass=larr[0];
honk<<wp.nWeldPass<<" wp.nWeldPass ImpVFTr\n";
////if(wp.nWeldPass> -1000000)exit(0);
			   if(wp.nWeldPass){

//iPersistVFT=1;
ir=iPersistVFT/10;
iPersistVFT=10*ir+1;

			   FDdynmem_manage(9,dummy,wp.memWGa,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
//HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH Brain
								for(i=0;i<wp.nWeldPass;i++){



////		ntape>>descript0;wp.name[i]=L"WeldPassName";
//		ntape>>descript0;wp.name[i]=descript0;
ntape.getline(chtm,199);
//efpChar=new char[strlen(chtm)];StringCchCopyA(efpChar,strlen(chtm),chtm);
//wp.name[i]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL;

efpChar=new char[12];
char buf[3+1];
if     (i+1< 10)gcvt(double(i+1),1,buf);
else if(i+1<100)gcvt(double(i+1),2,buf);
else            gcvt(double(i+1),3,buf);

StringCchCopyA(efpChar,12,"weldpass");
//StringCchCatA(efpChar,12,IntToStr(__int64(i+1)).c_str());
StringCchCatA(efpChar,12,buf);
wp.name[i]=PAnsiChar(efpChar);
delete efpChar; *efpChar=NULL; //Ignore input WP name


////		ntape>>descript0;wp.matName[i]=L"MatName";
//		ntape>>descript0;wp.matName[i]=descript0;
ntape.getline(chtm,199);
//wp.matName[i]=chtm;
efpChar=new char[strlen(chtm)];
StringCchCopyA(efpChar,strlen(chtm),chtm);
wp.matName[i]=PAnsiChar(efpChar);
delete efpChar; *efpChar=NULL;
////////////////////////////////////////////////////////////////
honk<<wp.name[i].c_str()<<" wp.name[i]\n";
honk<<wp.matName[i].c_str()<<" wp.matName[i]\n";
////////////////////////////////////////////////////////////////



//		ntape>>wp.seqNum[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.seqNum[i]=larr[0];
wp.reset[i]=wp.seqNum[i]*10+0; //Convention: 1col=weld reversal & other cols=original seqNum (reset is NOT in *.VFTr)  EFP 3/24/2012
//		ntape>>wp.boolFlags[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.boolFlags[i]=larr[0];
//		ntape>>wp.type[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.type[i]=larr[0];
//		ntape>>wp.shape[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.shape[i]=larr[0];
//		ntape>>wp.stepInterval[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.stepInterval[i]=larr[0];
//		ntape>>wp.hp[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.hp[i]=larr[0];
//		ntape>>wp.nsegs[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.nsegs[i]=larr[0];
//		ntape>>wp.iselect[i]; //Remember wp.eles[]=10*ie+iside in the following (ditto wp.sttEles[])
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.iselect[i]=larr[0];
////		for(j=0;j<base.nelt;j++)ntape>>wp.eles[i*base.nelt+j];  // Elements in this weld pass (C++ convention)
//		for(j=0;j<wp.memWGa;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.eles[wp.memWGa*i+j]=larr[0];
//								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.eles[wp.memWGa*i+j]=larr[0];
////temp_allGID[base.nelt*(base.allGrp+i+1)+larr[0]/10]=1;//Add coding for basemetal&weldgroup
//temp_allGID[base.nelt*(base.allGrp+i)+larr[0]/10]=1;//Add coding for basemetal&weldgroup
							 base.arrELSET[larr[0]/10]=i+1;//Emergency Code to plot WP without WG
								}

//////		wp.sttEles=new long[wp.nWeldPass+1*bnelt*4];  // No need for *4 ????
////		for(j=0;j<base.nelt;j++)ntape>>wp.sttEles[i*base.nelt+j];  // No need for *4 ????
//		for(j=0;j<wp.memWGa;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.sttEles[wp.memWGa*i+j]=larr[0];
//								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.sttEles[wp.memWGa*i+j]=larr[0];
								}

////		wp.stpEle=new long[wp.nWeldPass+1*bnelt];  // No need for *bnelt
//		ntape>>wp.stpEle[i];  // No need for *bnelt
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.stpEle[i]=larr[0];
////		for(j=0;j<base.nelt;j++)ntape>>wp.firstEle[i*base.nelt+j];
//		for(j=0;j<wp.memWGa;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.firstEle[wp.memWGa*i+j]=larr[0];
//								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.firstEle[wp.memWGa*i+j]=larr[0];
								}
////		for(j=0;j<base.nelt;j++)ntape>>wp.nextEle[i*base.nelt+j];
//		for(j=0;j<wp.memWGa;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.nextEle[wp.memWGa*i+j]=larr[0];
//								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.nextEle[wp.memWGa*i+j]=larr[0];
								}
//		for(j=0;j<4;j++)ntape>>wp.snorm1[i*4+j];
		for(j=0;j<4;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.snorm1[i*4+j]=larr[0];
						}
//		for(j=0;j<4;j++)ntape>>wp.snorm2[i*4+j];
		for(j=0;j<4;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.snorm2[i*4+j]=larr[0];
						}
//		for(j=0;j<3;j++)ntape>>wp.circEles[i*3+j]; //What policy???
		for(j=0;j<3;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.circEles[i*3+j]=larr[0];
						}
////		for(j=0;j<base.nelt;j++)ntape>>wp.edgeEles[i*base.nelt+j];
//		for(j=0;j<wp.memWGa;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.edgeEles[wp.memWGa*i+j]=larr[0];
//								}



ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
//		for(j=0;j<accum;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.edgeEles[wp.memWGa*i+j]=larr[0];
//							}
////		for(j=0;j<4;j++)ntape>>wp.edgeNodes[i*4+j]; // correct???
//		for(j=0;j<4;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.edgeNodes[i*4+j]=larr[0];
//						}
		if(accum){ //Attempt to accommodate uncertain edgeEles/edgeNodes  EFP 4/09/2011
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.edgeEles[wp.memWGa*i+j]=larr[0];
								}
//		for(j=0;j<4;j++)ntape>>wp.edgeNodes[i*4+j]; // correct???
		for(j=0;j<4;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.edgeNodes[i*4+j]=larr[0];
						}
				 }


////		for(j=0;j<4*base.nelt;j++)ntape>>wp.sttEleNodes[i*base.nelt*4+j];
//		for(j=0;j<4*wp.memWGa;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.sttEleNodes[i*wp.memWGa*4+j]=larr[0];
//								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.sttEleNodes[i*wp.memWGa*4+j]=larr[0];
								}
//		ntape>>wp.curr[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.curr[i]=darr[0];
//		ntape>>wp.volt[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.volt[i]=darr[0];
//		ntape>>wp.eff[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.eff[i]=darr[0];
//		ntape>>wp.speed[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.speed[i]=darr[0];
//		ntape>>wp.troom[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.troom[i]=darr[0];
//		ntape>>wp.tmelt[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.tmelt[i]=darr[0];
//		ntape>>wp.tcutl[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.tcutl[i]=darr[0];
//		ntape>>wp.tcuth[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.tcuth[i]=darr[0];
//		ntape>>wp.timeInterval[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.timeInterval[i]=darr[0];
//		ntape>>wp.maxiHeatStep[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.maxiHeatStep[i]=darr[0];
//		ntape>>wp.miniHeatStep[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.miniHeatStep[i]=darr[0];
//		ntape>>wp.thk1[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.thk1[i]=darr[0];
//		ntape>>wp.thk2[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.thk2[i]=darr[0];
//		ntape>>wp.lstart[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.lstart[i]=darr[0];
//		ntape>>wp.lend[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.lend[i]=darr[0];
////		for(j=0;j<base.nelt;j++)ntape>>wp.hlightel[i*base.nelt+j]; //Convention: 1st col= elem side#
//		for(j=0;j<wp.memWGa;j++){
//ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.hlightel[wp.memWGa*i+j]=larr[0];
//								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.hlightel[wp.memWGa*i+j]=larr[0];
								}
//		for(j=0;j<3*NDF;j++)ntape>>wp.arrows[3*NDF*i+j]; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		for(j=0;j<3*NDF;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.arrows[3*NDF*i+j]=darr[0];
							}
//		ntape>>wp.n_curr_sttEl[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.n_curr_sttEl[i]=larr[0];
//		ntape>>wp.wpTimes[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.wpTimes[i]=darr[0];
//		ntape>>wp.source[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.source[i]=larr[0];
if(wp.source[i]==2*(wp.source[i]/2)){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"#heat reflection sources must be odd",L"Error",MB_OK);}//EFP 3/13/2012
//		ntape>>wp.mcr[i]; // Not part of original VFT
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.mcr[i]=larr[0];
//		ntape>>ii;wp.WeldColor[i]=(TColor)ii;
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);
////////////////////////////////////
honk<<i<<" VFTrImpColor "<<larr[0]<<"\n";
////////////////////////////////////
wp.WeldColor[i]=(TColor)larr[0];

ntape.getline(chtm,199);

														   }
							   }
//				 for(i=0;i<wp.nWeldPass;i++){
//											 for(j=0;j<wp.memWGa;j++)
//											   {if(wp.eles[wp.memWGa*i+j]<0)break;
//												else {ie=wp.eles[wp.memWGa*i+j]/10;
////eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;
////ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
//////base.matno[ie]=base.matno[ie]-ieGID+wp.nWeldGroup+i+1;
////base.matno[ie]=base.matno[ie]-ieGID+base.allGrp+i;
//temp_allGID[base.nelt*(base.allGrp+i)+ie]=1;//Add coding for basemetal&weldgroup
//													 }
//											   }
////											 wp.prevGID[i]=ieGID; //Correction EFP 3/27/2011
///////////////
////honk<<i<<" read in wp.prevGID[i] "<<wp.prevGID[i]<<"\n";
///////////////
//											}
//nGID=wp.nWeldGroup+wp.nWeldPass+1;nGIDmax=nGID;
//NNNNNNNNNNNNNNNNNNNN
//				 ntape>>wps.nWeldParamSet;
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wps.nWeldParamSet=larr[0];

honk<<wps.nWeldParamSet<<" wps.nWeldParamSet\n";

				 if(wps.nWeldParamSet){
									   FDdynmem_manage(11,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
									   for(i=0;i<wps.nWeldParamSet;i++){








////		ntape>>descript0;wps.name[i]=L"WeldParamName";
//		ntape>>descript0;wps.name[i]=descript0;
ntape.getline(chtm,199);

//wps.name[i]=chtm;
//wps.name[i]=(String)chtm;
//wps.name[i]=chtm.t_str();
//wps.name[i]=L"ding";

//honk<<chtm<<" chtm\n";
//honk<<wps.name[i].c_str()<<" wps.name[i]\n";

//// _ltow(i+1,string1,10);
//// StringCchCopyW(curMess1,39+1,curMess0); //Length of destination curMess0 is provided.
//// StringCchCatW(curMess1,39+1,string1); //Length of destination curMess0 is provided.
//// wps.name[i]=curMess1;
//efpChar=new char[strlen(chtm)];StringCchCopyA(efpChar,strlen(chtm),chtm);
//wps.name[i]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL;



//////////////////////////////
temp_cht=new char[strlen(chtm)-1]; // This presumes the format  ** WeldGroupName\n
for(j=0;j<int(strlen(chtm))-1;j++)temp_cht[j]=chtm[j];
wps.name[i]=temp_cht; //EFP 3/15/2011
delete [] temp_cht;*temp_cht=NULL;
//////////////////////////////




//		ntape>>wps.curr[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wps.curr[i]=darr[0];

honk<<chtm<<" chtm\n";
honk<<wps.curr[i]<<" wps.curr[i]\n";

//		ntape>>wps.volt[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wps.volt[i]=darr[0];

honk<<chtm<<" chtm\n";
honk<<wps.volt[i]<<" wps.volt[i]\n";

//		ntape>>wps.eff[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wps.eff[i]=darr[0];

honk<<chtm<<" chtm\n";
honk<<wps.eff[i]<<" wps.eff[i]\n";

//		ntape>>wps.speed[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wps.speed[i]=darr[0];

honk<<chtm<<" chtm\n";
honk<<wps.speed[i]<<" wps.speed[i]\n";
ntape.getline(chtm,199);

																	  }
									  }
//				 ntape>>wms.nMatPropSet;
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.nMatPropSet=larr[0];
				 if(wms.nMatPropSet){
									 FDdynmem_manage(10,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
									 for(i=0;i<wms.nMatPropSet;i++){
//		ntape>>descript0;wms.name[i]=L"WeldMaterialSet";
//		ntape>>descript0;wms.matFileName[i]=L"MatPropFileName";
//		ntape>>descript0;wms.Steps[i]=L"Steps";

////		ntape>>descript0;wms.name[i]=descript0;
ntape.getline(chtm,199);
//ntape.getline(efpAnsi1,19);

//honk<<strlen(chtm)<<" wms.name strlen\n";
//honk<<strlen(efpAnsi1)<<" wms.name strlen\n";

//wms.name[i]=chtm;
// StringCchCopyW(wms.name[i],strlen(chtm),(String)chtm);
//StrPCopy();
//StrPLCopy(wms.name[i],chtm,strlen(chtm)-1);

//efpAnsi=new String[strlen(chtm)];
//efpAnsi=chtm;
// StringCchCopyA(efpAnsi,strlen(chtm),chtm);
//wms.name[i]=efpAnsi;

//delete efpAnsi;
//AnsiToUnicode(chtm,&efpAnsi);
//wms.name[i]=string(chtm);
//wms.name[i]=PAnsiChar(chtm);

efpChar=new char[strlen(chtm)];StringCchCopyA(efpChar,strlen(chtm),chtm);
wms.name[i]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL;



//		ntape>>descript0;wms.matFileName[i]=descript0;
ntape.getline(chtm,199);
//wms.matFileName[i]=chtm;
efpChar=new char[strlen(chtm)];StringCchCopyA(efpChar,strlen(chtm),chtm);
wms.matFileName[i]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL;




//		ntape>>descript0;wms.Steps[i]=descript0;
ntape.getline(chtm,199);
//wms.Steps[i]=chtm;
efpChar=new char[strlen(chtm)];StringCchCopyA(efpChar,strlen(chtm),chtm);
wms.Steps[i]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL;



//		ntape>>wms.mcr[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.mcr[i]=larr[0];
//		ntape>>wms.annjd[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.annjd[i]=larr[0];
//		ntape>>wms.ved[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.ved[i]=larr[0];
//		ntape>>wms.hetjd[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.hetjd[i]=larr[0];
//		ntape>>wms.nprops[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.nprops[i]=larr[0];
//		ntape>>wms.cond[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.cond[i]=darr[0];
//		ntape>>wms.heat[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.heat[i]=darr[0];
//		ntape>>wms.den[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.den[i]=darr[0];
//		ntape>>wms.Ti[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.Ti[i]=darr[0];
//		ntape>>wms.Ta[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.Ta[i]=darr[0];
//		ntape>>wms.Tm[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.Tm[i]=darr[0];
//		ntape>>wms.switc[i];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wms.switc[i]=bool(larr[0]);
ntape.getline(chtm,199);
																  }
									}
ntape.getline(chtm,199);
	   ntape.close();
//	   GeomFileName=OpenDialog1->FileName;

//TBD: NodalCoincidence

nGID=wp.nWeldGroup+wp.nWeldPass+1;nGIDmax=nGID;
//honk<<base.allGrp<<" "<<wp.nWeldGroup<<" "<<wp.nWeldPass<<" Deschanel\n";
///////////////////////////////////


///////////////////// EFP 2/12/2012
//////////////////////
///////////////////////
base.ELSETelsum=base.nelt+sumELSETel;

for(i=0;i<wp.nWeldPass;i++){for(j=0;j<wp.memWGa;j++)
							   {if(wp.eles[wp.memWGa*i+j]>=0)
								  {ie=wp.eles[wp.memWGa*i+j]/10;
//								   wp.prevGID[i]=base.arrELSET[ base.trackELSET[ie]+1 ];
								   wp.prevGID[i]=base.arrELSET[ie];
								   break;
								  }
							   }
						   }
//if(1==1)exit(0);
///////////////////////
//////////////////////
/////////////////////

for(ii=0;ii<base.nelt;ii++)base.orig_matno[ii]=base.matno[ii]; //TBD: Revise foregoing coding to allow for this new line  EFP 1/23/2012
/////////////////////////////////////
	   wp.highest=wp.nWeldPass;wps.highest=wps.nWeldParamSet;wms.highest=wms.nMatPropSet;
	   FDbase_indat(3,shapecombo,iplotflag,nColRes);
/////////////////////////////////////

//			   FDdynmem_manage(-16,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   FDdynmem_manage(-17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
////			   FDdynmem_manage(16,dummy,base.nelt,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);//EFP 8/07/2011
//			   FDdynmem_manage(17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt+2*sumELSETel);//EFP 8/07/2011
			   FDdynmem_manage(17,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,base.nelt);//EFP 8/07/2011
			   indat.GIDcol=base.GIDcol;
			   for(in=0;in<base.nelt;in++)indat.arrELSET[in]=base.arrELSET[in];

////	}
////__finally {
//Screen->Cursor=Save_Cursor;
////}





	if(nGID<1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No geometry IDs found",L"Halt",MB_OK);return;}
//    else {if(iPaintyesno/10==0){FDelemfacets2();iPaintyesno=10;iCullyesno=0;}iCircleplot=1;Invalidate();}
	else {if(iPaintyesno/10==0){
//								FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);
								if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
//								else {FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);}
//								iPaintyesno=10;iCullyesno=0;
								else {
//								FDcomp_nGID();
									  FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
									  FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);
									 }
								iPaintyesno=10+1;iCullyesno=0;
//								iPaintyesno=10;iCullyesno=0;
							   }
//			 stateVFT=0;FD_LButtonstatus=11;
			 stateVFT=2;FD_LButtonstatus=11;

honk<<base.npoin<<" exiting ImportVFTr "<<base.nelt<<"\n";
Form1->Caption=GeomFileName;
///////////// Cursor EFP 1/21/2011
//Screen->Cursor=crSizeAll;
/////////////

		  iplotflag=1;iCircleplot=1;Invalidate();
		 }
////////////////
/////////// Cursor EFP 1/03/2013
//Screen->Cursor=crSizeAll;
Screen->Cursor=Save_Cursor;
///////////
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen *.VFTr file",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Nodes/elements missing from *.VFTr datafile",L"Failure",MB_OK);}








					 }
//	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not a *.VFTr format file",L"Failure",MB_OK);}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Not a version3 *.VFTr format file",L"Failure",MB_OK);}
////////////////
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.VFTr file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
 }
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ImportVFTaExecute(TObject *Sender)//EFP routine to add WPs to existing model  3/09/2014
{long i=0,j=0,accum=0,ir=0,dum=0,wpWP=0,larr[9];
 int nic=0,nrc=0;
 char buf[3+1];
 float darr[9];
 char descript0[41],descript1[41],descript2[41],cht[10*(MXNPELS+3)],chtm[200], *efpChar=NULL;
// if(base.nop1){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, close current file->FileClose",L"Halt",MB_OK);}
// else {
 if(base.nop1){
 OpenDialog1->Filter= "VFTa format (*.VFTa,*.vfta)|*.VFTa;*.vfta";
 if(OpenDialog1->Execute())
   {ifstream ntape(OpenDialog1->FileName.c_str(),ios::nocreate|ios::binary,0);
	if(ntape)
	  {
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;

ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wpWP=larr[0];
honk<<wpWP<<" wpWP ImpVFTa\n";
			   if(wpWP)       {
			   ir=iPersistVFT/10;iPersistVFT=10*ir+1;
//			   FDdynmem_manage(9,dummy,wp.memWGa,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy,dummy);
			   FDdynmem_manage(6,dum,wp.memWGa,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,wpWP); //WARNING:wp.memWGa needs recompute
								for(i=0;i<wpWP;i++)    {
ntape.getline(chtm,199);
//efpChar=new char[strlen(chtm)];StringCchCopyA(efpChar,strlen(chtm),chtm);
//wp.name[i]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL;
efpChar=new char[12];
if     (i+1+wp.nWeldPass<  10)gcvt(double(i+1+wp.nWeldPass),1,buf);
else if(i+1+wp.nWeldPass< 100)gcvt(double(i+1+wp.nWeldPass),2,buf);
else if(i+1+wp.nWeldPass<1000)gcvt(double(i+1+wp.nWeldPass),3,buf);
else                          gcvt(double(i+1+wp.nWeldPass),4,buf);

StringCchCopyA(efpChar,12,"weldpass");
//StringCchCatA(efpChar,12,IntToStr(__int64(i+1+wp.nWeldPass)).c_str());
StringCchCatA(efpChar,12,buf);
wp.name[i+wp.nWeldPass]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL; //Ignore input WP name
ntape.getline(chtm,199);
efpChar=new char[strlen(chtm)];StringCchCopyA(efpChar,strlen(chtm),chtm);
wp.matName[i+wp.nWeldPass]=PAnsiChar(efpChar);delete efpChar; *efpChar=NULL;
////////////////////////////////////////////////////////////////
honk<<wp.name[i+wp.nWeldPass].c_str()<<" ADDEDwp.name[i]\n";
honk<<wp.matName[i+wp.nWeldPass].c_str()<<" ADDEDwp.matName[i]\n";
////////////////////////////////////////////////////////////////
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.seqNum[i+wp.nWeldPass]=larr[0]+wp.nWeldPass;
wp.reset[i+wp.nWeldPass]=wp.seqNum[i+wp.nWeldPass]*10+0; //Convention: 1col=weld reversal & other cols=original seqNum (reset is NOT in *.VFTr)  EFP 3/24/2012
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.boolFlags[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.type[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.shape[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.stepInterval[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.hp[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.nsegs[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.iselect[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.eles[wp.memWGa*(i+wp.nWeldPass)+j]=larr[0];
							 base.arrELSET[larr[0]/10]=i+1+wp.nWeldPass;//Emergency Code to plot WP without WG
								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.sttEles[wp.memWGa*(i+wp.nWeldPass)+j]=larr[0];
								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.stpEle[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.firstEle[wp.memWGa*(i+wp.nWeldPass)+j]=larr[0];
								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.nextEle[wp.memWGa*(i+wp.nWeldPass)+j]=larr[0];
								}
		for(j=0;j<4;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.snorm1[(i+wp.nWeldPass)*4+j]=larr[0];
						}
		for(j=0;j<4;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.snorm2[(i+wp.nWeldPass)*4+j]=larr[0];
						}
		for(j=0;j<3;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.circEles[(i+wp.nWeldPass)*3+j]=larr[0];
						}

ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		if(accum){ //Attempt to accommodate uncertain edgeEles/edgeNodes  EFP 4/09/2011
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.edgeEles[wp.memWGa*(i+wp.nWeldPass)+j]=larr[0];
								}
		for(j=0;j<4;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.edgeNodes[(i+wp.nWeldPass)*4+j]=larr[0];
						}
				 }

ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.sttEleNodes[(i+wp.nWeldPass)*wp.memWGa*4+j]=larr[0];
								}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.curr[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.volt[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.eff[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.speed[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.troom[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.tmelt[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.tcutl[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.tcuth[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.timeInterval[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.maxiHeatStep[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.miniHeatStep[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.thk1[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.thk2[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.lstart[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.lend[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);accum=larr[0];
		for(j=0;j<accum;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.hlightel[wp.memWGa*(i+wp.nWeldPass)+j]=larr[0];
								}
		for(j=0;j<3*NDF;j++){
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.arrows[3*NDF*(i+wp.nWeldPass)+j]=darr[0];
							}
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.n_curr_sttEl[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.wpTimes[i+wp.nWeldPass]=darr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.source[i+wp.nWeldPass]=larr[0];
if(wp.source[i+wp.nWeldPass]==2*(wp.source[i+wp.nWeldPass]/2)){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"#heat reflection sources must be odd",L"Error",MB_OK);}//EFP 3/13/2012
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);wp.mcr[i+wp.nWeldPass]=larr[0];
ntape.getline(chtm,199);parse_cdm(chtm,1,&nic,&nrc,larr,darr);
////////////////////////////////////
honk<<i+wp.nWeldPass<<" VFTaImpColor "<<larr[0]<<"\n";
////////////////////////////////////
wp.WeldColor[i+wp.nWeldPass]=(TColor)larr[0];

ntape.getline(chtm,199);
														   }
								wp.nWeldPass=wp.nWeldPass+wpWP;
                                base.allGrp=base.allGrp+wpWP;
							   }


	   ntape.close();
Screen->Cursor=Save_Cursor;
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.VFTa file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
// }
		 }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"87Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
//ii=WGannihilate(wp.nWeldGroup,wp.nWeldPass,base.nelt,base.matno,base.groupsname);
//long WGannihilate(long,long,long,long [],String []);
long TForm1::WGannihilate(long nWeldGroup,long nWeldPass,long nelt,long matno[],String groupsname[])
// Routine to annihilate a WG which totally overlaps with a WP (per 1-GID-per-element memory model)  EFP 1/23/2012
// Note: base metal GID==0
{long WGsurvive=0,ie=0,iWG=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000,sum=0, *status=NULL;
 status=new long[nWeldGroup+nWeldPass];for(iWG=0;iWG<nWeldGroup+nWeldPass;iWG++)status[iWG]=1;
 for(iWG=0;iWG<nWeldGroup;iWG++)
   {sum=0;for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
////								 ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//						else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//						else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//							  else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=base.arrELSET[ie];
////////////// but this does not use indat.xxx ?
								 if(iWG+1==ieGID)sum++;
								}
	if(sum)WGsurvive++;else status[iWG]=0;
   }
 sum=0;for(iWG=0;iWG<nWeldGroup+nWeldPass;iWG++)if(status[iWG]){sum++;status[iWG]=sum;
																if(iWG<nWeldGroup)groupsname[sum-1]=groupsname[iWG];
															   }
// for(iWG=0;iWG<nWeldGroup+nWeldPass;iWG++)honk<<iWG+1<<" "<<status[iWG]<<" New statUS\n";
 for(ie=0;ie<nelt;ie++){eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
////						ieGID=matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)ieGID=0;
//						else if(base.arrELSET[ base.trackELSET[ie+1]-1 ]<0)ieGID=base.arrELSET[ base.trackELSET[ie+1]-2 ];
//						else {if(base.GIDcol==1)ieGID=base.arrELSET[ base.trackELSET[ie]+base.GIDcol ]; //Prioritize WG
//							  else ieGID=base.arrELSET[ base.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
ieGID=base.arrELSET[ie];
////////////// but this does not use indat.xxx ?
////						if(ieGID)matno[ie]=matno[ie]-ieGID+status[ieGID-1];
//						if(ieGID)base.arrELSET[ base.trackELSET[ie+1]-1 ]=status[ieGID-1];
						if(ieGID)base.arrELSET[ie]=status[ieGID-1];
					   }
 delete [] status;return WGsurvive;
}

//---------------------------------------------------------------------------
void __fastcall TForm1::EditWeldPassExecute(TObject *Sender) //Full
{long ip=0;
 if(base.nop1)
   {if(wps.nWeldParamSet)
	  {if(wms.nMatPropSet)
		{if(wp.nWeldPass)
		   {if(!VFTlistbox)
			  {VFTlistbox=new TForm26(6,this); // The value 6 here has no meaning anymore EFP 1/03/2011
			   VFTlistbox->Caption="EditWeldPass (Full)";
			   wp.EDIT_SEL=0;
//			   for(ip=0;ip<wp.nWeldPass;ip++)VFTlistbox->ListBox1->Items->Add(wp.name[ip].c_str());
			   for(ip=0;ip<wp.nWeldPass;ip++)VFTlistbox->ListBox1->Items->Add(wp.name[ip].t_str());
			   VFTlistbox->ListBox1->ItemIndex=wp.nWeldPass-1;
			   VFTlistbox->ShowModal();
			  }
			else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
		   }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes found",L"Halt",MB_OK);}
		}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First create a material property set",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First create a weld parameter set",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void TForm1::EditWeldPassProg(int VFTitemindex)
{long j=0,
//i=0,is=0,isw=0,
ir=0,
//cur=0,prod=1,aflag=0,nwid=0,Sverige[MAX_GID],GIDspac=1+(wp.nWeldPass-1)/16,
val[(MAX_GID+1)/16],
	  ie=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
// wchar_t string0[40],curMess0[]=L"weld",string1[11];  //TEST FOR EXISTING FORM
		  if(CreateLinWeldPass==NULL)
			  {if(iPaintyesno/10)
												 {
 wp.CreateWPassMode=0;
// for(is=0;is<GIDspac;is++){FwriteUNVselGID->CheckOX=is;val[is]=FwriteUNVselGID->CheckOX;if(val[is])isw=is+1;}
// if(isw){
//		 for(i=0;i<MAX_GID;i++)Sverige[i]=0;
//		 for(is=0;is<isw;is++){cur=val[is];prod=1;aflag=0;
//							   if(wp.nWeldPass>1)
//											{for(i=16*is;i<min(long(wp.nWeldPass),16*(is+1));i++){aflag=aflag+prod;prod=2*prod;}
//											 prod=prod/2;
//											}
//							   for(i=min(long(wp.nWeldPass),16*(is+1))-16*is;i>0;i--){aflag=aflag-prod;if(cur>aflag){cur=cur-prod;Sverige[i+16*is-1]=1;}
//																					  prod=prod/2;
//																					 }
//							  }
//		 nwid=0;for(is=0;is<MAX_GID;is++)if(Sverige[is]){Sverige[nwid]=is;nwid++;}
////		 refGID=0;
////		 for(i=0;i<base.npoin;i++)
////		   for(j=0;j<nwid;j++){base.res1[refGID]=base.res1[nColRes*i+Sverige[j]];
////							   refGID++;
////							  }
////		 nColRes=nwid;ResultOut(base.npoin,base.res1,nwid);
//		 for(j=0;j<nwid;j++)honk<<j<<" "<<Sverige[j]<<" Here we go\n";
//
//		 i=Sverige[0]; //Policy: Edit first active weld pass only (This will disappear when EFP changes from CheckListBox to ListBox)
//		 glWPRECORD=i;isw=glEDIT_SEL; //Shameful

//honk<<glWPRECORD<<" "<<VFTitemindex<<" "<<glEDIT_SEL<<" EFP Edit Ck\n";

		 wp.PRECORD=VFTitemindex;
//		 isw=wp.EDIT_SEL; //Shameful but not used?????  EFP 11/06/2011




///////////
wp.temp_name=wp.name[wp.PRECORD];
wp.temp_matName=wp.matName[wp.PRECORD];
wp.temp_seqNum=wp.seqNum[wp.PRECORD];
wp.temp_boolFlags=wp.boolFlags[wp.PRECORD];
wp.temp_type=wp.type[wp.PRECORD];
wp.temp_shape=wp.shape[wp.PRECORD];
wp.temp_stepInterval=wp.stepInterval[wp.PRECORD];
wp.temp_hp=wp.hp[wp.PRECORD];
wp.temp_nsegs=wp.nsegs[wp.PRECORD];
wp.temp_iselect=wp.iselect[wp.PRECORD];
wp.temp_stpEle=wp.stpEle[wp.PRECORD];
wp.temp_curr=wp.curr[wp.PRECORD];
wp.temp_volt=wp.volt[wp.PRECORD];
wp.temp_eff=wp.eff[wp.PRECORD];
wp.temp_speed=wp.speed[wp.PRECORD];
wp.temp_troom=wp.troom[wp.PRECORD];
wp.temp_tmelt=wp.tmelt[wp.PRECORD];
wp.temp_tcutl=wp.tcutl[wp.PRECORD];
wp.temp_tcuth=wp.tcuth[wp.PRECORD];
wp.temp_timeInterval=wp.timeInterval[wp.PRECORD];
wp.temp_maxiHeatStep=wp.maxiHeatStep[wp.PRECORD];
wp.temp_miniHeatStep=wp.miniHeatStep[wp.PRECORD];
wp.temp_thk1=wp.thk1[wp.PRECORD];
wp.temp_thk2=wp.thk2[wp.PRECORD];
wp.temp_lstart=wp.lstart[wp.PRECORD];
wp.temp_lend=wp.lend[wp.PRECORD];
wp.temp_n_curr_sttEl=wp.n_curr_sttEl[wp.PRECORD];
wp.temp_reset=wp.reset[wp.PRECORD];
wp.temp_wpTimes=wp.wpTimes[wp.PRECORD];
wp.temp_source=wp.source[wp.PRECORD];
wp.temp_mcr=wp.mcr[wp.PRECORD];
wp.temp_WeldColor=wp.WeldColor[wp.PRECORD]; // Policy: Reserve one extra nWeldPass and copy "to-be-edited" data there.
wp.temp_prevGID=wp.prevGID[wp.PRECORD];
wp.temp_util_arr=wp.util_arr[wp.PRECORD];
//  CAUTION: Not all variables are backed-up... TBD: Comprehensive coding  EFP 4/03/2011
wp.temp_eles=new long[wp.nWeldPass*wp.memWGa];wp.temp_sttEles=new long[wp.nWeldPass*wp.memWGa];wp.temp_sttEleNodes=new long[wp.nWeldPass*wp.memWGa*4];
for(j=0;j<wp.nWeldPass*wp.memWGa;j++)wp.temp_eles[j]=wp.eles[j];
for(j=0;j<wp.nWeldPass*wp.memWGa;j++)wp.temp_sttEles[j]=wp.sttEles[j];
for(j=0;j<wp.nWeldPass*wp.memWGa*4;j++)wp.temp_sttEleNodes[j]=wp.sttEleNodes[j];
//
// The following 2 lines are no longer necessary
for(j=0;j<wp.memWGa;j++)wp.eles[wp.nWeldPass*wp.memWGa+j]=wp.eles[wp.PRECORD*wp.memWGa+j];
for(j=0;j<wp.memWGa;j++)wp.sttEles[wp.nWeldPass*wp.memWGa+j]=wp.sttEles[wp.PRECORD*wp.memWGa+j];

for(j=0;j<wp.memWGa;j++)wp.firstEle[wp.nWeldPass*wp.memWGa+j]=wp.firstEle[wp.PRECORD*wp.memWGa+j];
for(j=0;j<wp.memWGa;j++)wp.nextEle[wp.nWeldPass*wp.memWGa+j]=wp.nextEle[wp.PRECORD*wp.memWGa+j];
for(j=0;j<4;j++)wp.snorm1[wp.nWeldPass*4+j]=wp.snorm1[wp.PRECORD*4+j];
for(j=0;j<4;j++)wp.snorm2[wp.nWeldPass*4+j]=wp.snorm2[wp.PRECORD*4+j];
for(j=0;j<3;j++)wp.circEles[wp.nWeldPass*3+j]=wp.circEles[wp.PRECORD*3+j]; //Policy???
for(j=0;j<wp.memWGa;j++)wp.edgeEles[wp.nWeldPass*wp.memWGa+j]=wp.edgeEles[wp.PRECORD*wp.memWGa+j];
for(j=0;j<4;j++)wp.edgeNodes[wp.nWeldPass*4+j]=wp.edgeNodes[wp.PRECORD*4+j]; // correct???
// The following line is no longer necessary
for(j=0;j<4*wp.memWGa;j++)wp.sttEleNodes[wp.nWeldPass*wp.memWGa*4+j]=wp.sttEleNodes[wp.PRECORD*wp.memWGa*4+j];

for(j=0;j<wp.memWGa;j++)wp.hlightel[wp.nWeldPass*wp.memWGa+j]=wp.hlightel[wp.PRECORD*wp.memWGa+j];
for(j=0;j<3*NDF;j++)wp.arrows[3*NDF*wp.nWeldPass+j]=wp.arrows[3*NDF*wp.PRECORD+j];





// Policy: Do erase any data at this point (NEW POLICY: DO NOT ERASE  EFP 3/30/2012)
//wp.count_curr_sttEl=0;
//for(j=0;j<wp.memWGa;j++)wp.eles[wp.PRECORD*wp.memWGa+j]= -1;
//for(j=0;j<wp.memWGa;j++)wp.sttEles[wp.PRECORD*wp.memWGa+j]= -1;
//for(j=0;j<wp.memWGa;j++)wp.firstEle[wp.PRECORD*wp.memWGa+j]= -1;
//for(j=0;j<wp.memWGa;j++)wp.nextEle[wp.PRECORD*wp.memWGa+j]= -1;
//for(j=0;j<4;j++)wp.snorm1[wp.PRECORD*4+j]= -1;
//for(j=0;j<4;j++)wp.snorm2[wp.PRECORD*4+j]= -1;
//for(j=0;j<3;j++)wp.circEles[wp.PRECORD*3+j]= -1;
//for(j=0;j<wp.memWGa;j++)wp.edgeEles[wp.PRECORD*wp.memWGa+j]= -1;
//for(j=0;j<4;j++)wp.edgeNodes[wp.PRECORD*4+j]= -1; // correct???
//for(j=0;j<4*wp.memWGa;j++)wp.sttEleNodes[wp.PRECORD*wp.memWGa*4+j]= -1;
//for(j=0;j<wp.memWGa;j++)wp.hlightel[wp.PRECORD*wp.memWGa+j]= -1;
//for(j=0;j<3*NDF;j++)wp.arrows[3*NDF*wp.PRECORD+j]=0.;
//for(ie=0;ie<base.nelt;ie++)
//  {eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
//   ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
//   if(ieGID==wp.nWeldGroup+wp.PRECORD+1){indat.matno[ie]=indat.matno[ie]-ieGID+wp.prevGID[wp.PRECORD];
//										 base.matno[ie]=base.matno[ie]-ieGID+wp.prevGID[wp.PRECORD];
//										}
//  }






/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
//		  if(CreateLinWeldPass==NULL)
//			  {if(iPaintyesno/10)
//												 {
												  VFTon=1;
												  wp.count_curr_sttEl=wp.n_curr_sttEl[wp.PRECORD];//Correction EFP 3/30/2012
/*
												  wp.count_curr_sttEl=0;
												  wp.tcuth[wp.nWeldPass]=25.;
												  wp.seqNum[wp.nWeldPass]=wp.nWeldPass+1;
												  wp.eff[wp.nWeldPass]=0.75;
												  wp.wpTimes[wp.nWeldPass]=457.20;
												  wp.timeInterval[wp.nWeldPass]=600.0;
												  wp.tcuth[wp.nWeldPass]=25.;
										  wp.troom[wp.nWeldPass]=25.;
										  wp.tmelt[wp.nWeldPass]=1500.;
										  wp.tcutl[wp.nWeldPass]=50.;
										  wp.source[wp.nWeldPass]=11;
										  wp.maxiHeatStep[wp.nWeldPass]=1000.;
										  wp.miniHeatStep[wp.nWeldPass]=0.001;
												  wp.type[wp.nWeldPass]=0;
												  wp.thk1[wp.nWeldPass]=12.7;
												  wp.thk2[wp.nWeldPass]=12.7;
wp.timeInterval[0]=1000.;wp.timeInterval[1]=500.;for(i=2;i<MAX_WELDPASSES;i++)wp.timeInterval[i]=1000.;
wp.stepInterval[0]=5;wp.stepInterval[1]=50;for(i=2;i<MAX_WELDPASSES;i++)wp.stepInterval[i]=5;
										  wp.speed[wp.nWeldPass]=5.;
										  wp.curr[wp.nWeldPass]=350.; // Unknown
										  wp.volt[wp.nWeldPass]=25.; // Unknown but curr*volt=8750
										  wp.boolFlags[wp.nWeldPass]=0;
										  wp.hp[wp.nWeldPass]=0;// Moving Arc
										  wp.nsegs[wp.nWeldPass]=1;
										 wp.seqNum[wp.nWeldPass]=wp.nWeldPass+1;
										 if(wp.nWeldPass){
												  wp.tcuth[wp.nWeldPass]=wp.tcuth[wp.nWeldPass-1];
												  wp.wpTimes[wp.nWeldPass]=wp.wpTimes[wp.nWeldPass-1];
												  wp.timeInterval[wp.nWeldPass]=wp.timeInterval[wp.nWeldPass-1];
												  wp.stepInterval[wp.nWeldPass]=wp.stepInterval[wp.nWeldPass-1];
										  wp.troom[wp.nWeldPass]=wp.troom[wp.nWeldPass-1];
										  wp.tmelt[wp.nWeldPass]=wp.tmelt[wp.nWeldPass-1];
										  wp.tcutl[wp.nWeldPass]=wp.tcutl[wp.nWeldPass-1];
										  wp.source[wp.nWeldPass]=wp.source[wp.nWeldPass-1];
										  wp.maxiHeatStep[wp.nWeldPass]=wp.maxiHeatStep[wp.nWeldPass-1];
										  wp.miniHeatStep[wp.nWeldPass]=wp.miniHeatStep[wp.nWeldPass-1];
												  wp.type[wp.nWeldPass]=wp.type[wp.nWeldPass-1];
												  wp.shape[wp.nWeldPass]=wp.shape[wp.nWeldPass-1];
												  wp.thk1[wp.nWeldPass]=wp.thk1[wp.nWeldPass-1];
												  wp.thk2[wp.nWeldPass]=wp.thk2[wp.nWeldPass-1];
										  wp.boolFlags[wp.nWeldPass]=wp.boolFlags[wp.nWeldPass-1];
										  wp.hp[wp.nWeldPass]=wp.hp[wp.nWeldPass-1];// Moving Arc
										  wp.nsegs[wp.nWeldPass]=wp.nsegs[wp.nWeldPass-1];
										  wp.mcr[wp.nWeldPass]=wp.mcr[wp.nWeldPass-1];
														 }
										 else            {
												  wp.tcuth[wp.nWeldPass]=25.;
												  wp.wpTimes[wp.nWeldPass]=457.20;
												  wp.timeInterval[wp.nWeldPass]=450.0;
												  wp.stepInterval[wp.nWeldPass]=5;
										  wp.troom[wp.nWeldPass]=25.;
										  wp.tmelt[wp.nWeldPass]=1500.;
										  wp.tcutl[wp.nWeldPass]=50.;
										  wp.source[wp.nWeldPass]=11;
										  wp.maxiHeatStep[wp.nWeldPass]=1000.;
										  wp.miniHeatStep[wp.nWeldPass]=0.001;
												  wp.type[wp.nWeldPass]=0;
												  wp.shape[wp.nWeldPass]=0;
												  wp.thk1[wp.nWeldPass]=0.;
												  wp.thk2[wp.nWeldPass]=0.;
										  wp.boolFlags[wp.nWeldPass]=0;
										  wp.hp[wp.nWeldPass]=0;// Moving Arc
										  wp.nsegs[wp.nWeldPass]=1;
										  wp.mcr[wp.nWeldPass]=0;
														  }
*/
///////////////////////////////////////////////////////////////////////
												  FD_LButtonstatus=17;
//												  iPersistVFT=1;
												  ir=iPersistVFT/10;
												  iPersistVFT=10*ir+1;

/////////// Cursor EFP 1/21/2011
Screen->Cursor=crDefault;
///////////
////												  CreateLinWeldPass=new TForm15(2,wp.nWeldPass+1,wp.seqNum[wp.nWeldPass],0,0,0,0,
////																				wms.nMatPropSet,wms.name,
////																				wps.nWeldParamSet,wps.name,
////																				this); // (weldpass#,weldseq#,...)

//if(isw){
//												  CreateLinWeldPass=new TForm15(3,wp.PRECORD+1,wp.seqNum[wp.PRECORD],0,0,0,0,
//																				wms.nMatPropSet,wms.name,
//																				wps.nWeldParamSet,wps.name,
//																				this); // (weldpass#,weldseq#,...)
//CreateLinWeldPass->Caption="Edit to get partial length weld pass";
//CreateLinWeldPass->Label3->Caption="All start elements";
//CreateLinWeldPass->Label4->Caption="One stop element";
//	   }
//else {
//												  CreateLinWeldPass=new TForm15(2,wp.PRECORD+1,wp.seqNum[glWPRECORD],0,0,0,0,
//																				wms.nMatPropSet,wms.name,
//																				wps.nWeldParamSet,wps.name,
//																				this); // (weldpass#,weldseq#,...)
//CreateLinWeldPass->Caption="Edit to get full length weld pass";
//CreateLinWeldPass->Label3->Caption="All start elements";
//CreateLinWeldPass->Label4->Caption="Auto-gen full length (click for direction)";
//	 }

												  CreateLinWeldPass=new TForm15(4,wp.PRECORD+1,wp.seqNum[wp.PRECORD],0,0,
																				wp.snorm1[wp.PRECORD*4+0],wp.snorm2[wp.PRECORD*4+0],
																				wms.nMatPropSet,wms.name,
																				wps.nWeldParamSet,wps.name,
																				this); // (weldpass#,weldseq#,...)

CreateLinWeldPass->CheckBox1->Enabled=false;//Disconnect weld direction CheckBox1 EFP 4/03/2011

//CreateLinWeldPass->CheckEdit1=wp.name[wp.PRECORD];
//CreateLinWeldPass->CheckEdit1=wp.name[wp.PRECORD].c_str();
CreateLinWeldPass->CheckEdit1=wp.name[wp.PRECORD].t_str();


CreateLinWeldPass->Caption="Edit weld pass";
CreateLinWeldPass->Label3->Caption="All start elements";
CreateLinWeldPass->Label4->Caption="One stop element";



CreateLinWeldPass->Label7->Caption="Plate1 normal";
CreateLinWeldPass->Label8->Caption="Plate2 normal";
CreateLinWeldPass->Button1->Caption="Enter";
CreateLinWeldPass->Button2->Caption="Restore";
CreateLinWeldPass->Button3->Caption="Cancel";
// _ltow(wp.nWeldPass+1,string1,10);StringCchCatW(curMess0,11,string1);
// CreateLinWeldPass->CheckEdit1=curMess0;

///////////////////// EFP 1/03/2011
CreateLinWeldPass->CheckFunction=4; // Note that 4 will be replaced by user-selected option 4/5/6/7
CreateLinWeldPass->RadioGroup1->Caption="Change weld pass to";
CreateLinWeldPass->RadioGroup1->Enabled=True;
CreateLinWeldPass->RadioGroup1->Visible=True;
CreateLinWeldPass->PageControl1->TabIndex=2;
/////////////////////


//CreateLinWeldPass->CheckEdit9=0.;
//CreateLinWeldPass->CheckEdit10=0.;
//CreateLinWeldPass->CheckEdit11=0.;
//CreateLinWeldPass->CheckEdit12=0.;
// NEW POLICY: DO NOT ERASE EDITED WELD DATA BEFOREHAND  EFP 3/30/2012
CreateLinWeldPass->CheckEdit9=wp.curr[wp.PRECORD]; // Need to test this
CreateLinWeldPass->CheckEdit10=wp.volt[wp.PRECORD];
CreateLinWeldPass->CheckEdit11=wp.eff[wp.PRECORD];
CreateLinWeldPass->CheckEdit12=wp.speed[wp.PRECORD];



/////////////// i has no meaning in the following so change to glWPRECORD  EFP 1/07/2011
//CreateLinWeldPass->CheckEdit13=wp.troom[i];
//CreateLinWeldPass->CheckEdit14=wp.tmelt[i];
//CreateLinWeldPass->CheckEdit15=wp.tcutl[i];
//CreateLinWeldPass->CheckEdit16=wp.tcuth[i];
//CreateLinWeldPass->CheckEdit17=wp.timeInterval[i]; // Interpass cooling time???
//CreateLinWeldPass->CheckEdit19=wp.stepInterval[i]; // Interpass cooling steps???
//CreateLinWeldPass->CheckEdit18=wp.maxiHeatStep[i]; // Max heating time(output)???
//CreateLinWeldPass->CheckEdit20=wp.miniHeatStep[i]; // Min heating time(output)???
//CreateLinWeldPass->CheckEdit21=wp.thk1[i]; // Plate1 thickness???
//CreateLinWeldPass->CheckEdit22=wp.thk2[i]; // Plate2 thickness???
////CreateLinWeldPass->CheckEditXXX=wp.hp[i]; // Moving Arc only (hp=0) at present (and this must be selected by TForm15 RadioButton5&6)
//CreateLinWeldPass->CheckEdit23=wp.nsegs[i]; // Lumped pass heating procedure: Number of lumped segments
//CreateLinWeldPass->CheckEdit24=1; // Near-edge effect: Number of required edges???
////CreateLinWeldPass->ComboBox1->ItemIndex = 0;
////CreateLinWeldPass->ComboBox2->ItemIndex = 0;
//CreateLinWeldPass->CheckType=wp.type[i];
//CreateLinWeldPass->CheckShape=wp.shape[i];
//CreateLinWeldPass->CheckWeldColor=wp.WeldColor[i];

CreateLinWeldPass->CheckEdit13=wp.troom[wp.PRECORD];
CreateLinWeldPass->CheckEdit14=wp.tmelt[wp.PRECORD];
CreateLinWeldPass->CheckEdit15=wp.tcutl[wp.PRECORD];
CreateLinWeldPass->CheckEdit16=wp.tcuth[wp.PRECORD];
CreateLinWeldPass->CheckEdit17=wp.timeInterval[wp.PRECORD]; // Interpass cooling time???
CreateLinWeldPass->CheckEdit19=wp.stepInterval[wp.PRECORD]; // Interpass cooling steps???
CreateLinWeldPass->CheckEdit18=wp.maxiHeatStep[wp.PRECORD]; // Max heating time(output)???
CreateLinWeldPass->CheckEdit20=wp.miniHeatStep[wp.PRECORD]; // Min heating time(output)???
CreateLinWeldPass->CheckEdit21=wp.thk1[wp.PRECORD]; // Plate1 thickness???
CreateLinWeldPass->CheckEdit22=wp.thk2[wp.PRECORD]; // Plate2 thickness???
//CreateLinWeldPass->CheckEditXXX=wp.hp[wp.PRECORD]; // Moving Arc only (hp=0) at present (and this must be selected by TForm15 RadioButton5&6)
CreateLinWeldPass->CheckEdit23=wp.nsegs[wp.PRECORD]; // Lumped pass heating procedure: Number of lumped segments
CreateLinWeldPass->CheckEdit24=1; // Near-edge effect: Number of required edges???
//CreateLinWeldPass->ComboBox1->ItemIndex = 0;
//CreateLinWeldPass->ComboBox2->ItemIndex = 0;
CreateLinWeldPass->CheckType=wp.type[wp.PRECORD];
CreateLinWeldPass->CheckShape=wp.shape[wp.PRECORD];
/////////////
//		  ir=wp.nWeldPass-9*(wp.nWeldPass/9);
//		  if     (ir==0)CreateLinWeldPass->CheckWeldColor=clRed;
//		  else if(ir==1)CreateLinWeldPass->CheckWeldColor=clLtGray; // Coding for color contrast
//		  else if(ir==2)CreateLinWeldPass->CheckWeldColor=clBlue;
//		  else if(ir==3)CreateLinWeldPass->CheckWeldColor=clGreen;
//		  else if(ir==4)CreateLinWeldPass->CheckWeldColor=clLime;
//		  else if(ir==5)CreateLinWeldPass->CheckWeldColor=clNavy;
//		  else if(ir==6)CreateLinWeldPass->CheckWeldColor=clYellow;
//		  else if(ir==7)CreateLinWeldPass->CheckWeldColor=clOlive;
//		  else          CreateLinWeldPass->CheckWeldColor=clMaroon;
CreateLinWeldPass->CheckWeldColor=wp.WeldColor[wp.PRECORD];

CreateLinWeldPass->Edit2->Enabled=false;






/////////////
//CreateLinWeldPass->PageControl1->ActivePage=0;
//												  CreateLinWeldPass->ShowModal();
												  CreateLinWeldPass->Show();
//												  delete CreateLinWeldPass;CreateLinWeldPass=NULL;
												 }
//				  else {
//		//				ltoa(MAX_WELDPASSES,string0,10);
//		//				strcat(string0,currMess);
//		//				extern PACKAGE void __fastcall Beep(void);
//		//				Application->MessageBox(string0,L"Halt",MB_OK);
//
//						extern PACKAGE void __fastcall Beep(void);
//						Application->MessageBox(_ltow(MAX_WELDPASSES,string0,10),L"Halt: MAX_WELDPASSES exceeded",MB_OK);
//					   }
//				 }
			   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Use VIEW/PAINT to paint",L"Halt",MB_OK);}
			  }
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Weld pass creation/edit dialog already exists",L"Notice",MB_OK);}
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
//		}
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must check at least one weld pass to edit.",L"Repeat",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::wpEdit_public(){
int missing=0;long j=0,i=wp.PRECORD; //Shameful
//int ccc=CreateLinWeldPass->CheckISEL;
//long ccL=CreateLinWeldPass->CheckEdit23;
//honk<<ccc<<" ccc\n";
//honk<<ccL<<" ccL\n";
//double ccD=CreateLinWeldPass->CheckEdit9;
///////////////////////////////////////////// EFP 03/04/2010
honk<<i<<" EditLinWeldPass\n";
//if(1==1)exit(0);

if(CreateLinWeldPass->CheckEdit1=="****")
  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to enter weld pass name",L"Repeat",MB_OK);
   missing++;
  }
else wp.name[i]=CreateLinWeldPass->CheckEdit1;
delete [] wp.temp_eles;delete [] wp.temp_sttEles;delete [] wp.temp_sttEleNodes;
wp.seqNum[i]=CreateLinWeldPass->CheckEdit2;
//wp.curr[wp.nWeldPass]=CreateLinWeldPass->CheckEdit9;
//wp.volt[wp.nWeldPass]=CreateLinWeldPass->CheckEdit10;
//wp.eff[wp.nWeldPass]=CreateLinWeldPass->CheckEdit11;
//wp.speed[wp.nWeldPass]=CreateLinWeldPass->CheckEdit12;
wp.troom[i]=CreateLinWeldPass->CheckEdit13;
wp.tmelt[i]=CreateLinWeldPass->CheckEdit14;
wp.tcutl[i]=CreateLinWeldPass->CheckEdit15;
wp.tcuth[i]=CreateLinWeldPass->CheckEdit16;
wp.type[i]=CreateLinWeldPass->CheckType;
wp.shape[i]=CreateLinWeldPass->CheckShape;
wp.timeInterval[i]=CreateLinWeldPass->CheckEdit17; // Interpass cooling time???
wp.stepInterval[i]=CreateLinWeldPass->CheckEdit19; // Interpass cooling steps???
wp.maxiHeatStep[i]=CreateLinWeldPass->CheckEdit18; // Max heating time(output)???
wp.miniHeatStep[i]=CreateLinWeldPass->CheckEdit20; // Min heating time(output)???
if(CreateLinWeldPass->CheckEdit21>0.0001 && CreateLinWeldPass->CheckEdit22>0.0001)
  {wp.thk1[i]=CreateLinWeldPass->CheckEdit21; // Plate1 thickness???
   wp.thk2[i]=CreateLinWeldPass->CheckEdit22; // Plate2 thickness???
  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to enter plate thicknesses",L"Repeat",MB_OK);
	  missing++;
	 }
wp.hp[i]=0;// Moving arc only at present (selected by TForm15 RadioButton5&6)
wp.nsegs[i]=CreateLinWeldPass->CheckEdit23; // Lumped pass heating procedure: Number of lumped segments
//wp.XXX[wp.nWeldPass]=CreateLinWeldPass->CheckEdit24; // Near-edge effect: Number of required edges??? (Which array should this be???)

//if(CreateLinWeldPass->CheckMatName>=0)wp.matName[wp.nWeldPass]=wms.matFileName[CreateLinWeldPass->CheckMatName]; // Need to test this INCORRECT
//else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Material Property Set Name",L"Repeat",MB_OK);
//	  missing++;
//	 }
if(CreateLinWeldPass->CheckMatName>=0){wp.matName[i]=wms.name[CreateLinWeldPass->CheckMatName];
									   wp.mcr[i]=wms.mcr[CreateLinWeldPass->CheckMatName];
									  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Material Property Set Name",L"Repeat",MB_OK);
	  missing++;
	 }
if(CreateLinWeldPass->CheckWeldParName>=0)
  {wp.curr[i]=wps.curr[CreateLinWeldPass->CheckWeldParName]; // Need to test this
   wp.volt[i]=wps.volt[CreateLinWeldPass->CheckWeldParName];
   wp.eff[i]=wps.eff[CreateLinWeldPass->CheckWeldParName];
   wp.speed[i]=wps.speed[CreateLinWeldPass->CheckWeldParName];
  }
else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Weld Parameter Set Name",L"Repeat",MB_OK);
	  missing++;
	 }



//////////////////////  EFP 5/24/2011
if(wp.snorm1[4*i+0]<0 && wp.snorm2[4*i+0]<0)
  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Plate#1 & Plate#2 normals",L"Repeat",MB_OK);
   missing++;
  }
else if(wp.snorm1[4*i+0]<0)
  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Plate#1 normal",L"Repeat",MB_OK);
   missing++;
  }
else if(wp.snorm2[4*i+0]<0)
  {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Forgot to select Plate#2 normal",L"Repeat",MB_OK);
   missing++;
  }
//////////////////////



//honk<<wp.matName[i].c_str()<<" edited WeldPassMatFileName\n";
/////////////////////////////////////////////
							   if(!missing){
//CreateNewFulllinWeldPass1=0;
//CreateNewLinearWeldPass1=0;
WeldPassEditingandSequencing1->Enabled=true;
//ShowWeldSequence1=0;

//honk<<" Crash dive\n";if(1==1)exit(0);

/////////////////////// start EFP 2/02/2011
 for(j=0;j<wp.nWeldPass;j++)if(!wp.n_curr_sttEl[j])DelWeldPass(j,wp.memWGa);
/////////////////////// end

//											wp.nWeldPass=wp.nWeldPass+1;
										   }
honk<<wp.nWeldPass<<" WeldPassEdited\n";

FD_LButtonstatus=11;stateVFT=2;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
							   delete CreateLinWeldPass;CreateLinWeldPass=NULL;// because it was created with Show()?
//iplotflag=1;iCircleplot=1;
//							   iCullyesno=0;

////////////////// start EFP 4/04/2011
								if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
//								else {FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);}
//								iPaintyesno=10;iCullyesno=0;

								else {
//								FDcomp_nGID();
FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
								FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);}
								iPaintyesno=10+1;iCullyesno=0;
////////////////// end
for(j=0;j<nGID;j++)honk<<j<<" "<<nGID<<" "<<arGID[j]<<" arGID\n";
honk<<iplotflag<<" "<<iCircleplot<<" "<<iPaintyesno<<" "<<iplotType<<" "<<iCullyesno<<" graphValCHECK\n";
//for(j=0;j<base.nelt;j++){
//	 if(base.trackELSET[j+1]-base.trackELSET[j]==1)honk<<indat.matno[j]<<" BaseM\n";
//	 else honk<<indat.matno[j]<<" WGggg "<<base.arrELSET[ base.trackELSET[j+1]-2 ]<<" "<<base.arrELSET[ base.trackELSET[j+1]-1 ]<<"\n";
//						}
honk<<wp.nWeldGroup<<" "<<wp.nWeldPass<<" Crash dive\n";
//if(1==1)exit(0);
							   Invalidate();
//honk<<" Arachis\n";
							  }
//---------------------------------------------------------------------------
void TForm1::wpEdit2_public()
{long j=0,ie=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000;
 wp.name[wp.PRECORD]=wp.temp_name;
 wp.matName[wp.PRECORD]=wp.temp_matName;
 wp.seqNum[wp.PRECORD]=wp.temp_seqNum;
 wp.boolFlags[wp.PRECORD]=wp.temp_boolFlags;
 wp.type[wp.PRECORD]=wp.temp_type;
 wp.shape[wp.PRECORD]=wp.temp_shape;
 wp.stepInterval[wp.PRECORD]=wp.temp_stepInterval;
 wp.hp[wp.PRECORD]=wp.temp_hp;
 wp.nsegs[wp.PRECORD]=wp.temp_nsegs;
 wp.iselect[wp.PRECORD]=wp.temp_iselect;
 wp.stpEle[wp.PRECORD]=wp.temp_stpEle;
 wp.curr[wp.PRECORD]=wp.temp_curr;
 wp.volt[wp.PRECORD]=wp.temp_volt;
 wp.eff[wp.PRECORD]=wp.temp_eff;
 wp.speed[wp.PRECORD]=wp.temp_speed;
 wp.troom[wp.PRECORD]=wp.temp_troom;
 wp.tmelt[wp.PRECORD]=wp.temp_tmelt;
 wp.tcutl[wp.PRECORD]=wp.temp_tcutl;
 wp.tcuth[wp.PRECORD]=wp.temp_tcuth;
 wp.timeInterval[wp.PRECORD]=wp.temp_timeInterval;
 wp.maxiHeatStep[wp.PRECORD]=wp.temp_maxiHeatStep;
 wp.miniHeatStep[wp.PRECORD]=wp.temp_miniHeatStep;
 wp.thk1[wp.PRECORD]=wp.temp_thk1;
 wp.thk2[wp.PRECORD]=wp.temp_thk2;
 wp.lstart[wp.PRECORD]=wp.temp_lstart;
 wp.lend[wp.PRECORD]=wp.temp_lend;
 wp.n_curr_sttEl[wp.PRECORD]=wp.temp_n_curr_sttEl;
 wp.reset[wp.PRECORD]=wp.temp_reset;
 wp.wpTimes[wp.PRECORD]=wp.temp_wpTimes;
 wp.source[wp.PRECORD]=wp.temp_source;
 wp.mcr[wp.PRECORD]=wp.temp_mcr;
 wp.WeldColor[wp.PRECORD]=wp.temp_WeldColor; // Policy: Reserve one extra nWeldPass and copy "to-be-edited" data there.
 wp.prevGID[wp.PRECORD]=wp.temp_prevGID;
 wp.util_arr[wp.PRECORD]=wp.temp_util_arr;
// for(j=0;j<base.nelt;j++)wp.eles[wp.PRECORD*base.nelt+j]=wp.eles[wp.nWeldPass*base.nelt+j];
// for(j=0;j<base.nelt;j++)wp.sttEles[wp.PRECORD*base.nelt+j]=wp.sttEles[wp.nWeldPass*base.nelt+j]; for(j=0;j<base.nelt;j++)wp.firstEle[wp.PRECORD*base.nelt+j]=wp.firstEle[wp.nWeldPass*base.nelt+j];
for(j=0;j<wp.nWeldPass*wp.memWGa;j++)wp.eles[j]=wp.temp_eles[j];
for(j=0;j<wp.nWeldPass*wp.memWGa;j++)wp.sttEles[j]=wp.temp_sttEles[j];

 for(j=0;j<wp.memWGa;j++)wp.nextEle[wp.PRECORD*wp.memWGa+j]=wp.nextEle[wp.nWeldPass*wp.memWGa+j];
 for(j=0;j<4;j++)wp.snorm1[wp.PRECORD*4+j]=wp.snorm1[wp.nWeldPass*4+j];
 for(j=0;j<4;j++)wp.snorm2[wp.PRECORD*4+j]=wp.snorm2[wp.nWeldPass*4+j];
 for(j=0;j<3;j++)wp.circEles[wp.PRECORD*3+j]=wp.circEles[wp.nWeldPass*3+j];
 for(j=0;j<wp.memWGa;j++)wp.edgeEles[wp.PRECORD*wp.memWGa+j]=wp.edgeEles[wp.nWeldPass*wp.memWGa+j];
 for(j=0;j<4;j++)wp.edgeNodes[wp.PRECORD*4+j]=wp.edgeNodes[wp.nWeldPass*4+j]; // correct???
// for(j=0;j<4*base.nelt;j++)wp.sttEleNodes[wp.PRECORD*base.nelt*4+j]=wp.sttEleNodes[wp.nWeldPass*base.nelt*4+j];
for(j=0;j<wp.nWeldPass*wp.memWGa*4;j++)wp.sttEleNodes[j]=wp.temp_sttEleNodes[j];

 for(j=0;j<wp.memWGa;j++)wp.hlightel[wp.PRECORD*wp.memWGa+j]=wp.hlightel[wp.nWeldPass*wp.memWGa+j];
 for(j=0;j<3*NDF;j++)wp.arrows[3*NDF*wp.PRECORD+j]=wp.arrows[3*NDF*wp.nWeldPass+j];
//
for(j=0;j<wp.memWGa;j++)
  {if(wp.eles[wp.nWeldPass*wp.memWGa+j]>=0){ie=wp.eles[wp.nWeldPass*wp.memWGa+j]/10;
											eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
////											ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
//	 if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//	 else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//		  }
ieGID=indat.arrELSET[ie];
////											indat.matno[ie]=indat.matno[ie]-ieGID+wp.nWeldGroup+wp.PRECORD+1;
////											base.matno[ie]=base.matno[ie]-ieGID+wp.nWeldGroup+wp.PRECORD+1;
////honk<<j<<" "<<ieGID<<" "<<wp.nWeldGroup+wp.PRECORD+1<<" Restored-editableGID\n";
//											base.arrELSET[ base.trackELSET[ie+1]-1 ]=wp.nWeldGroup+wp.PRECORD+1;
//											indat.arrELSET[ indat.trackELSET[ie+1]-1 ]=wp.nWeldGroup+wp.PRECORD+1;
											base.arrELSET[ie]=wp.nWeldGroup+wp.PRECORD+1;
											indat.arrELSET[ie]=wp.nWeldGroup+wp.PRECORD+1;
										   }
   else break;
  }


 FD_LButtonstatus=11;stateVFT=2;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 delete [] wp.temp_eles;delete [] wp.temp_sttEles;delete [] wp.temp_sttEleNodes;
 delete CreateLinWeldPass;CreateLinWeldPass=NULL;// because it was created with Show()?
//iplotflag=1;iCircleplot=1;
							   iCullyesno=0;Invalidate();// EFP 1/08/2011
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DeleteWeldPassExecute(TObject *Sender)
//{
//extern PACKAGE void __fastcall Beep(void);
//Application->MessageBox(L"Unfinished",L"Halt",MB_OK);return;
{long ip=0;
 if(base.nop1)
  {if(wp.nWeldPass)
	 {if(!VFTlistbox)
		{VFTlistbox=new TForm26(1,this);
		 VFTlistbox->Caption="Delete weldpass";
//		 for(ip=0;ip<wp.nWeldPass;ip++)VFTlistbox->ListBox1->Items->Add(wp.name[ip].c_str());
		 for(ip=0;ip<wp.nWeldPass;ip++)VFTlistbox->ListBox1->Items->Add(wp.name[ip].t_str());
		 VFTlistbox->ListBox1->ItemIndex=wp.nWeldPass-1;
		 VFTlistbox->ShowModal();
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::VFTlistbox_public()
{int VFTitemindex= VFTlistbox->CheckItemIndex,VFTsel= VFTlistbox->CheckISEL;
//honk<<VFTsel<<" "<<VFTitemindex<<" VFTWeldPass\n";
//honk<<VFTlistbox<<" "<<NULL<<" VFTWeldPass1 VFTlistbox_public\n";
 VFTlistbox->Close();
//honk<<VFTlistbox<<" "<<NULL<<" VFTWeldPass2 VFTlistbox_public\n";
// delete [] VFTlistbox; // But is the memory being destroyed???
 VFTlistbox=NULL; // Necessary to set to NULL but why?
// if(VFTsel==1)DelWeldPass(VFTitemindex,base.nelt);
 if(VFTsel==1)DelWeldPass(VFTitemindex,wp.memWGa); //Correction EFP 3/27/2011
 else if(VFTsel==2)DelWeldParam(VFTitemindex);
 else if(VFTsel==3)EditWeldParamProg(VFTitemindex);
 else if(VFTsel==4)EditMatPropProg(VFTitemindex);
 else if(VFTsel==5)DelMatPropProg(VFTitemindex);
 else if(VFTsel==6 || VFTsel==7)EditWeldPassProg(VFTitemindex);
 else if(VFTsel==8)ShowWPoutlineProg(VFTitemindex);
 else if(VFTsel==9)ShowWGselectorProg(VFTitemindex);
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported VFTsel option",L"Failure",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::DelWeldPass(int VFTitemindex,long bnelt)
{
//int i=0,j=0;
// TBD: Adjust memory
 int i=0,*SWTseqNum=NULL,*SWTboolFlags=NULL,*SWTtype=NULL,*SWTshape=NULL,*SWTstepInterval=NULL,
	 *SWThp=NULL,*SWTnsegs=NULL,*SWTiselect=NULL,*SWTmcr=NULL,*SWTsource=NULL,*SWTutil_arr=NULL
//	 ,*SWTedgeFlag,*SWTcircFlag,*SWTmerge
	 ;
// GIDwp: 1st col= current iside, remainder=GID
 long ii=0,in=0,dum=0,eltype1=0,bscode1=0,node1=0,ieGID1=0,t3=1000,t5=100000,t7=10000000,
	  *SWTeles=NULL,*SWTsttEles=NULL,*SWTstpEle=NULL,*SWTfirstEle=NULL,
	  *SWTnextEle=NULL,*SWTsnorm1=NULL,*SWTsnorm2=NULL,
	  *SWTcircEles=NULL,*SWTedgeEles=NULL,*SWTedgeNodes=NULL,*SWTsttEleNodes=NULL,
	  *SWThlightel=NULL,*SWTn_curr_sttEl=NULL,*SWTprevGID=NULL,*SWTreset=NULL;
 float *SWTcurr=NULL,*SWTvolt=NULL,*SWTeff=NULL,*SWTspeed=NULL,*SWTtroom=NULL,*SWTtmelt=NULL,
	   *SWTtcutl=NULL,*SWTtcuth=NULL,*SWTtimeInterval=NULL,
	   *SWTmaxiHeatStep=NULL,*SWTminiHeatStep=NULL,*SWTthk1=NULL,*SWTthk2=NULL,*SWTwpTimes=NULL;
 double *SWTlstart=NULL,*SWTlend=NULL,*SWTarrows=NULL;
 String *SWTname=NULL,*SWTmatName=NULL;
 TColor *SWTWeldColor=NULL;

//honk<<VFTitemindex<<" DelWeldPassBEF "<<bnelt<<" "<<base.nelt<<" "<<wp.nWeldPass<<"\n";
////if(1==1)exit(0);

//for(ii=0;ii<wp.nWeldPass;ii++)
//  {honk<<wp.prevGID[ii]<<" prevGID BEF\n";
//   for(in=0;in<bnelt;in++)honk<<ii+1<<" "<<in+1<<" "<<wp.sttEles[bnelt*ii+in]<<" sttElesBEF\n";
//  }

for(in=0;in<base.nelt;in++)
  {eltype1=indat.matno[in]/t7;bscode1=(indat.matno[in]-eltype1*t7)/t5;node1=(indat.matno[in]-eltype1*t7-bscode1*t5)/t3;
////   ieGID1=indat.matno[in]-eltype1*t7-bscode1*t5-node1*t3;
//	 if(indat.trackELSET[in+1]-indat.trackELSET[in]==1)ieGID1=0;
//	 else if(indat.arrELSET[ indat.trackELSET[in+1]-1 ]<0)ieGID1=indat.arrELSET[ indat.trackELSET[in+1]-2 ];
//	 else {if(indat.GIDcol==1)ieGID1=indat.arrELSET[ indat.trackELSET[in]+indat.GIDcol ]; //Prioritize WG
//		   else ieGID1=indat.arrELSET[ indat.trackELSET[in+1]-1 ];                      //Prioritize WP
//		  }
ieGID1=indat.arrELSET[in];

   if(ieGID1==VFTitemindex+wp.nWeldGroup+1)
	 {
//////	  indat.matno[in]=indat.matno[in]-(VFTitemindex+wp.nWeldGroup+1)+wp.prevGID[VFTitemindex]; //Special purpose coding
//////	  base.matno[in]=base.matno[in]-(VFTitemindex+wp.nWeldGroup+1)+wp.prevGID[VFTitemindex]; //Special purpose coding
////	  indat.matno[in]=indat.matno[in]-ieGID1+base.arrELSET[ base.trackELSET[in]+1 ]; //Special purpose coding
////	  base.matno[in]=base.matno[in]-ieGID1+base.arrELSET[ base.trackELSET[in]+1 ]; //Special purpose coding
//	  base.arrELSET[ base.trackELSET[in]+2 ]= -1;
//	  indat.arrELSET[ indat.trackELSET[in]+2 ]= -1;
	  base.arrELSET[in]= -1;
	  indat.arrELSET[in]= -1;
	 }
////////////////////
   else if(ieGID1>VFTitemindex+wp.nWeldGroup+1){
////                                                indat.matno[in]=indat.matno[in]-1; //VFTsolid only  EFP 3/06/2012
////												base.matno[in]=base.matno[in]-1;
//												base.arrELSET[ base.trackELSET[in]+2 ]=base.arrELSET[ base.trackELSET[in]+2 ]-1;
//												indat.arrELSET[ indat.trackELSET[in]+2 ]=indat.arrELSET[ indat.trackELSET[in]+2 ]-1;
base.arrELSET[in]=base.arrELSET[in]-1;
indat.arrELSET[in]=indat.arrELSET[in]-1;
											   }
////////////////////
  }
////////////////////////// start Correction: Code to adjust seqNum[]  EFP 3/26/2011
 i=wp.seqNum[VFTitemindex];
 for(in=0;in<wp.nWeldPass;in++){if(wp.seqNum[in]>i)wp.seqNum[in]=wp.seqNum[in]-1;
// honk<<in<<" "<<wp.seqNum[in]<<" DEL seqn checkAFT\n";
							   }
////////////////////////// end

//for(in=0;in<wp.nWeldPass;in++)honk<<in<<" "<<(long)wp.WeldColor[in]<<" EarlyCkTk\n";
//////////////////////////////
//////////////////////////////
//////////////////////////////

 if(wp.nWeldPass>1)
	   {SWTname=new String[wp.nWeldPass-1];
		SWTmatName=new String[wp.nWeldPass-1];
		SWTseqNum=new int[wp.nWeldPass-1];
		SWTboolFlags=new int[wp.nWeldPass-1];
		SWTtype=new int[wp.nWeldPass-1];
		SWTshape=new int[wp.nWeldPass-1];
		SWTstepInterval=new int[wp.nWeldPass-1];
		SWThp=new int[wp.nWeldPass-1];
		SWTnsegs=new int[wp.nWeldPass-1];
		SWTiselect=new int[wp.nWeldPass-1];
		SWTeles=new long[(wp.nWeldPass-1)*bnelt];  // Elements in this weld pass
		SWTsttEles=new long[(wp.nWeldPass-1)*bnelt];  // No need for *4 ????
		SWTstpEle=new long[wp.nWeldPass-1];  // No need for *bnelt
		SWTfirstEle=new long[(wp.nWeldPass-1)*bnelt];
		SWTnextEle=new long[(wp.nWeldPass-1)*bnelt];
		SWTsnorm1=new long[(wp.nWeldPass-1)*4];
		SWTsnorm2=new long[(wp.nWeldPass-1)*4];
		SWTcircEles=new long[(wp.nWeldPass-1)*3];
		SWTedgeEles=new long[(wp.nWeldPass-1)*bnelt];
		SWTedgeNodes=new long[(wp.nWeldPass-1)*4]; // correct???
		SWTsttEleNodes=new long[(wp.nWeldPass-1)*bnelt*4];
		SWTcurr=new float[wp.nWeldPass-1];
		SWTvolt=new float[wp.nWeldPass-1];
		SWTeff=new float[wp.nWeldPass-1];
		SWTspeed=new float[wp.nWeldPass-1];
		SWTtroom=new float[wp.nWeldPass-1];
		SWTtmelt=new float[wp.nWeldPass-1];
		SWTtcutl=new float[wp.nWeldPass-1];
		SWTtcuth=new float[wp.nWeldPass-1];
		SWTtimeInterval=new float[wp.nWeldPass-1];
		SWTmaxiHeatStep=new float[wp.nWeldPass-1];
		SWTminiHeatStep=new float[wp.nWeldPass-1];
		SWTthk1=new float[wp.nWeldPass-1];
		SWTthk2=new float[wp.nWeldPass-1];
		SWTlstart=new double[wp.nWeldPass-1];
		SWTlend=new double[wp.nWeldPass-1];
		SWThlightel=new long[(wp.nWeldPass-1)*bnelt]; //Convention: 1st col= elem side#
		SWTarrows=new double[3*NDF*(wp.nWeldPass-1)]; //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		SWTn_curr_sttEl=new long[wp.nWeldPass-1];
		SWTreset=new long[wp.nWeldPass-1];
		SWTwpTimes=new float[wp.nWeldPass-1];
		SWTsource=new int[wp.nWeldPass-1];
		SWTmcr=new int[wp.nWeldPass-1]; // Not part of original VFT
		SWTWeldColor=new TColor[wp.nWeldPass-1];
		SWTprevGID=new long[wp.nWeldPass-1];
		SWTutil_arr=new int[wp.nWeldPass-1];

 if(VFTitemindex)
   {
		for(in=0;in<VFTitemindex;in++) *(SWTname+in)= *(wp.name+in);
		for(in=0;in<VFTitemindex;in++) *(SWTmatName+in)= *(wp.matName+in);
		for(in=0;in<VFTitemindex;in++) *(SWTseqNum+in)= *(wp.seqNum+in);
		for(in=0;in<VFTitemindex;in++) *(SWTboolFlags+in)= *(wp.boolFlags+in);
		for(in=0;in<VFTitemindex;in++) *(SWTtype+in)= *(wp.type+in);
		for(in=0;in<VFTitemindex;in++) *(SWTshape+in)= *(wp.shape+in);
		for(in=0;in<VFTitemindex;in++) *(SWTstepInterval+in)= *(wp.stepInterval+in);
		for(in=0;in<VFTitemindex;in++) *(SWThp+in)= *(wp.hp+in);
		for(in=0;in<VFTitemindex;in++) *(SWTnsegs+in)= *(wp.nsegs+in);
		for(in=0;in<VFTitemindex;in++) *(SWTiselect+in)= *(wp.iselect+in);
		for(in=0;in<VFTitemindex*bnelt;in++) *(SWTeles+in)= *(wp.eles+in);  // Elements in this weld pass
		for(in=0;in<VFTitemindex*bnelt;in++) *(SWTsttEles+in)= *(wp.sttEles+in);  // No need for *4 ????
		for(in=0;in<VFTitemindex;in++) *(SWTstpEle+in)= *(wp.stpEle+in);  // No need for *bnelt
		for(in=0;in<VFTitemindex*bnelt;in++) *(SWTfirstEle+in)= *(wp.firstEle+in);
		for(in=0;in<VFTitemindex*bnelt;in++) *(SWTnextEle+in)= *(wp.nextEle+in);
		for(in=0;in<VFTitemindex*4;in++) *(SWTsnorm1+in)= *(wp.snorm1+in);
		for(in=0;in<VFTitemindex*4;in++) *(SWTsnorm2+in)= *(wp.snorm2+in);
		for(in=0;in<VFTitemindex*3;in++) *(SWTcircEles+in)= *(wp.circEles+in);
		for(in=0;in<VFTitemindex*bnelt;in++) *(SWTedgeEles+in)= *(wp.edgeEles+in);
		for(in=0;in<VFTitemindex*4;in++) *(SWTedgeNodes+in)= *(wp.edgeNodes+in); // correct???
		for(in=0;in<VFTitemindex*bnelt*4;in++) *(SWTsttEleNodes+in)= *(wp.sttEleNodes+in);
		for(in=0;in<VFTitemindex;in++) *(SWTcurr+in)= *(wp.curr+in);
		for(in=0;in<VFTitemindex;in++) *(SWTvolt+in)= *(wp.volt+in);
		for(in=0;in<VFTitemindex;in++) *(SWTeff+in)= *(wp.eff+in);
		for(in=0;in<VFTitemindex;in++) *(SWTspeed+in)= *(wp.speed+in);
		for(in=0;in<VFTitemindex;in++) *(SWTtroom+in)= *(wp.troom+in);
		for(in=0;in<VFTitemindex;in++) *(SWTtmelt+in)= *(wp.tmelt+in);
		for(in=0;in<VFTitemindex;in++) *(SWTtcutl+in)= *(wp.tcutl+in);
		for(in=0;in<VFTitemindex;in++) *(SWTtcuth+in)= *(wp.tcuth+in);
		for(in=0;in<VFTitemindex;in++) *(SWTtimeInterval+in)= *(wp.timeInterval+in);
		for(in=0;in<VFTitemindex;in++) *(SWTmaxiHeatStep+in)= *(wp.maxiHeatStep+in);
		for(in=0;in<VFTitemindex;in++) *(SWTminiHeatStep+in)= *(wp.miniHeatStep+in);
		for(in=0;in<VFTitemindex;in++) *(SWTthk1+in)= *(wp.thk1+in);
		for(in=0;in<VFTitemindex;in++) *(SWTthk2+in)= *(wp.thk2+in);
		for(in=0;in<VFTitemindex;in++) *(SWTlstart+in)= *(wp.lstart+in);
		for(in=0;in<VFTitemindex;in++) *(SWTlend+in)= *(wp.lend+in);
		for(in=0;in<VFTitemindex*bnelt;in++) *(SWThlightel+in)= *(wp.hlightel+in); //Convention: 1st col= elem side#
		for(in=0;in<VFTitemindex*3*NDF;in++) *(SWTarrows+in)= *(wp.arrows+in); //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		for(in=0;in<VFTitemindex;in++) *(SWTn_curr_sttEl+in)= *(wp.n_curr_sttEl+in);
		for(in=0;in<VFTitemindex;in++) *(SWTreset+in)= *(wp.reset+in);
		for(in=0;in<VFTitemindex;in++) *(SWTwpTimes+in)= *(wp.wpTimes+in);
		for(in=0;in<VFTitemindex;in++) *(SWTsource+in)= *(wp.source+in);
		for(in=0;in<VFTitemindex;in++) *(SWTmcr+in)= *(wp.mcr+in); // Not part of original VFT
		for(in=0;in<VFTitemindex;in++) *(SWTWeldColor+in)= *(wp.WeldColor+in);
		for(in=0;in<VFTitemindex;in++) *(SWTprevGID+in)= *(wp.prevGID+in);
		for(in=0;in<VFTitemindex;in++) *(SWTutil_arr+in)= *(wp.util_arr+in);
   }
 if(VFTitemindex+1<wp.nWeldPass)
   {
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTname+in-1)= *(wp.name+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTmatName+in-1)= *(wp.matName+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTseqNum+in-1)= *(wp.seqNum+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTboolFlags+in-1)= *(wp.boolFlags+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTtype+in-1)= *(wp.type+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTshape+in-1)= *(wp.shape+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTstepInterval+in-1)= *(wp.stepInterval+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWThp+in-1)= *(wp.hp+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTnsegs+in-1)= *(wp.nsegs+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTiselect+in-1)= *(wp.iselect+in);
		for(in=(VFTitemindex+1)*bnelt;in<wp.nWeldPass*bnelt;in++) *(SWTeles+in-bnelt)= *(wp.eles+in);  // Elements in this weld pass
		for(in=(VFTitemindex+1)*bnelt;in<wp.nWeldPass*bnelt;in++) *(SWTsttEles+in-bnelt)= *(wp.sttEles+in);  // No need for *4 ????
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTstpEle+in-1)= *(wp.stpEle+in);  // No need for *bnelt
		for(in=(VFTitemindex+1)*bnelt;in<wp.nWeldPass*bnelt;in++) *(SWTfirstEle+in-bnelt)= *(wp.firstEle+in);
		for(in=(VFTitemindex+1)*bnelt;in<wp.nWeldPass*bnelt;in++) *(SWTnextEle+in-bnelt)= *(wp.nextEle+in);
		for(in=(VFTitemindex+1)*4;in<wp.nWeldPass*4;in++) *(SWTsnorm1+in-4)= *(wp.snorm1+in);
		for(in=(VFTitemindex+1)*4;in<wp.nWeldPass*4;in++) *(SWTsnorm2+in-4)= *(wp.snorm2+in);
		for(in=(VFTitemindex+1)*3;in<wp.nWeldPass*3;in++) *(SWTcircEles+in-3)= *(wp.circEles+in);
		for(in=(VFTitemindex+1)*bnelt;in<wp.nWeldPass*bnelt;in++) *(SWTedgeEles+in-bnelt)= *(wp.edgeEles+in);
		for(in=(VFTitemindex+1)*4;in<wp.nWeldPass*4;in++) *(SWTedgeNodes+in-4)= *(wp.edgeNodes+in); // correct???
		for(in=(VFTitemindex+1)*bnelt*4;in<wp.nWeldPass*bnelt*4;in++) *(SWTsttEleNodes+in-bnelt*4)= *(wp.sttEleNodes+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTcurr+in-1)= *(wp.curr+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTvolt+in-1)= *(wp.volt+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTeff+in-1)= *(wp.eff+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTspeed+in-1)= *(wp.speed+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTtroom+in-1)= *(wp.troom+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTtmelt+in-1)= *(wp.tmelt+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTtcutl+in-1)= *(wp.tcutl+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTtcuth+in-1)= *(wp.tcuth+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTtimeInterval+in-1)= *(wp.timeInterval+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTmaxiHeatStep+in-1)= *(wp.maxiHeatStep+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTminiHeatStep+in-1)= *(wp.miniHeatStep+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTthk1+in-1)= *(wp.thk1+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTthk2+in-1)= *(wp.thk2+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTlstart+in-1)= *(wp.lstart+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTlend+in-1)= *(wp.lend+in);
		for(in=(VFTitemindex+1)*bnelt;in<wp.nWeldPass*bnelt;in++) *(SWThlightel+in-bnelt)= *(wp.hlightel+in); //Convention: 1st col= elem side#
		for(in=(VFTitemindex+1)*3*NDF;in<wp.nWeldPass*3*NDF;in++) *(SWTarrows+in-3*NDF)= *(wp.arrows+in); //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTn_curr_sttEl+in-1)= *(wp.n_curr_sttEl+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTreset+in-1)= *(wp.reset+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTwpTimes+in-1)= *(wp.wpTimes+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTsource+in-1)= *(wp.source+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTmcr+in-1)= *(wp.mcr+in); // Not part of original VFT
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTWeldColor+in-1)= *(wp.WeldColor+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTprevGID+in-1)= *(wp.prevGID+in);
		for(in=VFTitemindex+1;in<wp.nWeldPass;in++) *(SWTutil_arr+in-1)= *(wp.util_arr+in);
   }
		FDdynmem_manage(-9,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
		wp.nWeldPass=wp.nWeldPass-1;

honk<<VFTitemindex<<" SWT DelWeldPassAFT "<<bnelt<<" "<<base.nelt<<" "<<wp.nWeldPass<<"\n";
for(ii=0;ii<wp.nWeldPass;ii++)
  {for(in=0;in<bnelt;in++)honk<<ii+1<<" "<<in+1<<" "<< *(SWTsttEles+bnelt*ii+in) <<" SWTsttEles\n";
  }


		FDdynmem_manage( 9,dum,bnelt,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
		for(in=0;in<wp.nWeldPass;in++) *(wp.name+in)= *(SWTname+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.matName+in)= *(SWTmatName+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.seqNum+in)= *(SWTseqNum+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.boolFlags+in)= *(SWTboolFlags+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.type+in)= *(SWTtype+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.shape+in)= *(SWTshape+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.stepInterval+in)= *(SWTstepInterval+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.hp+in)= *(SWThp+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.nsegs+in)= *(SWTnsegs+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.iselect+in)= *(SWTiselect+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.eles+in)= *(SWTeles+in);  // Elements in this weld pass
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.sttEles+in)= *(SWTsttEles+in);  // No need for *4 ????
		for(in=0;in<wp.nWeldPass;in++) *(wp.stpEle+in)= *(SWTstpEle+in);  // No need for *bnelt
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.firstEle+in)= *(SWTfirstEle+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.nextEle+in)= *(SWTnextEle+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(wp.snorm1+in)= *(SWTsnorm1+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(wp.snorm2+in)= *(SWTsnorm2+in);
		for(in=0;in<wp.nWeldPass*3;in++) *(wp.circEles+in)= *(SWTcircEles+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.edgeEles+in)= *(SWTedgeEles+in);
		for(in=0;in<wp.nWeldPass*4;in++) *(wp.edgeNodes+in)= *(SWTedgeNodes+in); // correct???
		for(in=0;in<wp.nWeldPass*bnelt*4;in++) *(wp.sttEleNodes+in)= *(SWTsttEleNodes+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.curr+in)= *(SWTcurr+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.volt+in)= *(SWTvolt+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.eff+in)= *(SWTeff+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.speed+in)= *(SWTspeed+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.troom+in)= *(SWTtroom+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.tmelt+in)= *(SWTtmelt+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.tcutl+in)= *(SWTtcutl+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.tcuth+in)= *(SWTtcuth+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.timeInterval+in)= *(SWTtimeInterval+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.maxiHeatStep+in)= *(SWTmaxiHeatStep+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.miniHeatStep+in)= *(SWTminiHeatStep+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.thk1+in)= *(SWTthk1+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.thk2+in)= *(SWTthk2+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.lstart+in)= *(SWTlstart+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.lend+in)= *(SWTlend+in);
		for(in=0;in<wp.nWeldPass*bnelt;in++) *(wp.hlightel+in)= *(SWThlightel+in); //Convention: 1st col= elem side#
		for(in=0;in<wp.nWeldPass*3*NDF;in++) *(wp.arrows+in)= *(SWTarrows+in); //Convention: 1st arrow=weld direction, 2nd & 3rd=plate normals
		for(in=0;in<wp.nWeldPass;in++) *(wp.n_curr_sttEl+in)= *(SWTn_curr_sttEl+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.reset+in)= *(SWTreset+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.wpTimes+in)= *(SWTwpTimes+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.source+in)= *(SWTsource+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.mcr+in)= *(SWTmcr+in); // Not part of original VFT
		for(in=0;in<wp.nWeldPass;in++) *(wp.WeldColor+in)= *(SWTWeldColor+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.prevGID+in)= *(SWTprevGID+in);
		for(in=0;in<wp.nWeldPass;in++) *(wp.util_arr+in)= *(SWTutil_arr+in);


//for(in=0;in<wp.nWeldPass;in++)honk<<in<<" "<<(long)wp.WeldColor[in]<<" LateCkTk\n";
//////////////////////////////
//////////////////////////////
//////////////////////////////
					delete [] SWTname;SWTname=NULL;
					delete [] SWTmatName;SWTmatName=NULL;
					delete [] SWTseqNum;SWTseqNum=NULL;
					delete [] SWTboolFlags;SWTboolFlags=NULL;
					delete [] SWTtype;SWTtype=NULL;
					delete [] SWTshape;SWTshape=NULL;
					delete [] SWTstepInterval;SWTstepInterval=NULL;
					delete [] SWThp;SWThp=NULL;
					delete [] SWTnsegs;SWTnsegs=NULL;
					delete [] SWTiselect;SWTiselect=NULL;
					delete [] SWTeles;SWTeles=NULL;
					delete [] SWTsttEles;SWTsttEles=NULL;
					delete [] SWTstpEle;SWTstpEle=NULL;
					delete [] SWTfirstEle;SWTfirstEle=NULL;
					delete [] SWTnextEle;SWTnextEle=NULL;
					delete [] SWTsnorm1;SWTsnorm1=NULL;
					delete [] SWTsnorm2;SWTsnorm2=NULL;
					delete [] SWTcircEles;SWTcircEles=NULL;
					delete [] SWTedgeEles;SWTedgeEles=NULL;
					delete [] SWTedgeNodes;SWTedgeNodes=NULL;
					delete [] SWTsttEleNodes;SWTsttEleNodes=NULL;
					delete [] SWTcurr;SWTcurr=NULL;
					delete [] SWTvolt;SWTvolt=NULL;
					delete [] SWTeff;SWTeff=NULL;
					delete [] SWTspeed;SWTspeed=NULL;
					delete [] SWTtroom;SWTtroom=NULL;
					delete [] SWTtmelt;SWTtmelt=NULL;
					delete [] SWTtcutl;SWTtcutl=NULL;
					delete [] SWTtcuth;SWTtcuth=NULL;
					delete [] SWTtimeInterval;SWTtimeInterval=NULL;
					delete [] SWTmaxiHeatStep;SWTmaxiHeatStep=NULL;
					delete [] SWTminiHeatStep;SWTminiHeatStep=NULL;
					delete [] SWTthk1;SWTthk1=NULL;
					delete [] SWTthk2;SWTthk2=NULL;
					delete [] SWTlstart;SWTlstart=NULL;
					delete [] SWTlend;SWTlend=NULL;
					delete [] SWThlightel;SWThlightel=NULL;
					delete [] SWTarrows;SWTarrows=NULL;
					delete [] SWTn_curr_sttEl;SWTn_curr_sttEl=NULL;
					delete [] SWTreset;SWTreset=NULL;
					delete [] SWTwpTimes;SWTwpTimes=NULL;
					delete [] SWTsource;SWTsource=NULL;
					delete [] SWTmcr;SWTmcr=NULL;// Not part of original VFT
					delete [] SWTWeldColor;SWTWeldColor=NULL;
					delete [] SWTprevGID;SWTprevGID=NULL;
					delete [] SWTutil_arr;SWTutil_arr=NULL;
	   }
 else {
		FDdynmem_manage(-9,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
		wp.nWeldPass=wp.nWeldPass-1;
//        extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes in model",L"Warning",MB_OK);
	  }
//for(in=0;in<base.nelt;in++)
//  {eltype1=indat.matno[in]/t7;bscode1=(indat.matno[in]-eltype1*t7)/t5;node1=(indat.matno[in]-eltype1*t7-bscode1*t5)/t3;ieGID1=indat.matno[in]-eltype1*t7-bscode1*t5-node1*t3;
//   if(ieGID1==VFTitemindex+wp.nWeldGroup+1){indat.matno[in]=indat.matno[in]-(VFTitemindex+wp.nWeldGroup+1)+wp.prevGID[VFTitemindex]; //Special purpose coding
//											base.matno[in]=base.matno[in]-(VFTitemindex+wp.nWeldGroup+1)+wp.prevGID[VFTitemindex]; //Special purpose coding
//
//honk<<in<<" "<<VFTitemindex<<" "<<base.matno[in]<<" "<<wp.prevGID[VFTitemindex]<<" DelWPdata\n";
//										   }
//  }
 if(wp.nWeldPass==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"There will be no weld passes in model",L"Warning",MB_OK);}
//iplotflag=1;iCircleplot=1;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////

//honk<<VFTitemindex<<" DelWeldPassAFT "<<bnelt<<" "<<base.nelt<<" "<<wp.nWeldPass<<"\n";
//for(ii=0;ii<wp.nWeldPass;ii++)
//  {honk<<wp.prevGID[ii]<<" prevGID AFT\n";
//   for(in=0;in<bnelt;in++)honk<<ii+1<<" "<<in+1<<" "<<wp.sttEles[bnelt*ii+in]<<" sttElesAFT\n";
//  }

//							   iCullyesno=0;

////////////////// start EFP 4/04/2011
								if(iplotType==2)FDelemfacets_arE3(indat.npoin,indat.nelt,indat.nop1,indat.matno,base.arELEM);
//								else {FDcomp_nGID();FDelemfacets3(indat.npoin,indat.nelt,indat.nop1,indat.matno,arGID);}
//								iPaintyesno=10;iCullyesno=0;

								else {
//								FDcomp_nGID();
FDcomp_nGID(indat.nelt,indat.matno,&nGID,arGID);
								FDelemfacets3a(indat.npoin,indat.nelt,indat.nop1,indat.matno);}
								iPaintyesno=10+1;iCullyesno=0;
////////////////// end
honk<<iplotflag<<" "<<iCircleplot<<" "<<iPaintyesno<<" "<<iplotType<<" "<<iCullyesno<<" DELgraphValCHECK\n";

							   Invalidate();//EFP 1/08/2011
}
//---------------------------------------------------------------------------
void __fastcall TForm1::EditWeldParamExecute(TObject *Sender)
{long ip=0;
 if(base.nop1)
  {if(wps.nWeldParamSet)
	 {if(!CreateWeldingParamSet)// Test here because a "Modal" MessageBox() can not be used after a ShowModal()
		{if(!VFTlistbox)
		   {VFTlistbox=new TForm26(3,this);
			VFTlistbox->Caption="Edit weld param set";
//			for(ip=0;ip<wps.nWeldParamSet;ip++)VFTlistbox->ListBox1->Items->Add(wps.name[ip].c_str());
			for(ip=0;ip<wps.nWeldParamSet;ip++)VFTlistbox->ListBox1->Items->Add(wps.name[ip].t_str());
			VFTlistbox->ListBox1->ItemIndex=wps.nWeldParamSet-1;
			VFTlistbox->ShowModal();
		   }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Close existing Create/Edit box first",L"Halt",MB_OK);}
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld parameter sets found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::EditWeldParamProg(int VFTitemindex)
{
 wp.PRECORD=VFTitemindex;
honk<<wp.PRECORD<<" Enter EditWeldParam()\n";
 CreateWeldingParamSet=new TForm22(1,this); // No test: i.e. This presumes that TForm22 is always created by ShowModal()
 CreateWeldingParamSet->Caption="Edit a Welding Parameter Set";
 CreateWeldingParamSet->Label1->Caption="Welding Parameter Set Name";
 CreateWeldingParamSet->Label2->Caption="Welding Current (Amp):";
 CreateWeldingParamSet->Label3->Caption="Welding Voltage (Volt):";
 CreateWeldingParamSet->Label4->Caption="Arc Efficiency:";
 CreateWeldingParamSet->Label5->Caption="Torch Traveling Speed:";
 CreateWeldingParamSet->Button1->Caption="Enter";
 CreateWeldingParamSet->Button2->Caption="Restore";
 wps.temp_name=wps.name[wp.PRECORD];
 wps.temp_curr=wps.curr[wp.PRECORD];
 wps.temp_volt=wps.volt[wp.PRECORD];
 wps.temp_eff=wps.eff[wp.PRECORD];
 wps.temp_speed=wps.speed[wp.PRECORD];
 CreateWeldingParamSet->CheckEdit1=wps.name[wp.PRECORD].t_str();
 CreateWeldingParamSet->CheckEdit2=wps.curr[wp.PRECORD];
 CreateWeldingParamSet->CheckEdit3=wps.volt[wp.PRECORD];
 CreateWeldingParamSet->CheckEdit4=wps.eff[wp.PRECORD];
 CreateWeldingParamSet->CheckEdit5=wps.speed[wp.PRECORD];
// CreateWeldingParamSet->ShowModal();
 CreateWeldingParamSet->Show();// Note that you can not follow a VFTlistbox->ShowModal() with a CreateWeldingParamSet->ShowModal()
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DeleteWeldParamExecute(TObject *Sender)
{long ip=0;
 if(base.nop1)
  {if(wps.nWeldParamSet)
	 {if(!VFTlistbox)
		{VFTlistbox=new TForm26(2,this);
		 VFTlistbox->Caption="Del weld param set";
//		 for(ip=0;ip<wps.nWeldParamSet;ip++)VFTlistbox->ListBox1->Items->Add(wps.name[ip].c_str());
		 for(ip=0;ip<wps.nWeldParamSet;ip++)VFTlistbox->ListBox1->Items->Add(wps.name[ip].t_str());
		 VFTlistbox->ListBox1->ItemIndex=wps.nWeldParamSet-1;
		 VFTlistbox->ShowModal();
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld parameter sets found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::DelWeldParam(int VFTitemindex)
{long i=0,dum=0;
 float *SWTcurr=NULL,*SWTvolt=NULL,*SWTeff=NULL,*SWTspeed=NULL;
 String *SWTname=NULL;
honk<<VFTitemindex<<" DelWeldParamSet\n";
 if(wps.nWeldParamSet>1)
   {
	SWTname=new String[wps.nWeldParamSet-1];
	SWTcurr=new float[wps.nWeldParamSet-1];
	SWTvolt=new float[wps.nWeldParamSet-1];
	SWTeff=new float[wps.nWeldParamSet-1];
	SWTspeed=new float[wps.nWeldParamSet-1];
	if(VFTitemindex){for(i=0;i<VFTitemindex;i++)SWTname[i]=wps.name[i];
					 for(i=0;i<VFTitemindex;i++)SWTcurr[i]=wps.curr[i];
					 for(i=0;i<VFTitemindex;i++)SWTvolt[i]=wps.volt[i];
					 for(i=0;i<VFTitemindex;i++)SWTeff[i]=wps.eff[i];
					 for(i=0;i<VFTitemindex;i++)SWTspeed[i]=wps.speed[i];
					}
	if(VFTitemindex+1<wps.nWeldParamSet){for(i=VFTitemindex+1;i<wps.nWeldParamSet;i++)SWTname[i-1]=wps.name[i];
										 for(i=VFTitemindex+1;i<wps.nWeldParamSet;i++)SWTcurr[i-1]=wps.curr[i];
										 for(i=VFTitemindex+1;i<wps.nWeldParamSet;i++)SWTvolt[i-1]=wps.volt[i];
										 for(i=VFTitemindex+1;i<wps.nWeldParamSet;i++)SWTeff[i-1]=wps.eff[i];
										 for(i=VFTitemindex+1;i<wps.nWeldParamSet;i++)SWTspeed[i-1]=wps.speed[i];
										}
	FDdynmem_manage(-11,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	wps.nWeldParamSet=wps.nWeldParamSet-1;
	FDdynmem_manage( 11,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	for(i=0;i<wps.nWeldParamSet;i++)wps.name[i]=SWTname[i];
	for(i=0;i<wps.nWeldParamSet;i++)wps.curr[i]=SWTcurr[i];
	for(i=0;i<wps.nWeldParamSet;i++)wps.volt[i]=SWTvolt[i];
	for(i=0;i<wps.nWeldParamSet;i++)wps.eff[i]=SWTeff[i];
	for(i=0;i<wps.nWeldParamSet;i++)wps.speed[i]=SWTspeed[i];
	delete [] SWTname;delete [] SWTcurr;delete [] SWTvolt;delete [] SWTeff;delete [] SWTspeed;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
   }
 else if(wps.nWeldParamSet==1)
   {FDdynmem_manage(-11,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	wps.nWeldParamSet=0;
	extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Weld parameter sets no longer in the model",L"Warning",MB_OK);
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Inadmissible nWeldParamSet in DelWeldParam()",L"Terminate",MB_OK);exit(0);}
}
//---------------------------------------------------------------------------
void TForm1::EditWeldParam_public()
{int isel=CreateWeldingParamSet->CheckISEL;long i=wp.PRECORD;
 if(isel)
   {wps.name[i]=wps.temp_name;wps.curr[i]=wps.temp_curr;wps.volt[i]=wps.temp_volt;wps.eff[i]=wps.temp_eff;wps.speed[i]=wps.temp_speed;
	FD_LButtonstatus=11;stateVFT=2;
	delete CreateWeldingParamSet;
//	CreateWeldingParamSet=NULL;// because it was created with Show()
   }
 else CreateWeldingParamSet->Close();
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 CreateWeldingParamSet=NULL;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::EditMatPropExecute(TObject *Sender)
{long ip=0;
 if(base.nop1)
  {if(wps.nWeldParamSet)
   {if(wms.nMatPropSet)
	 {if(!CreateMatPropSet)// Test here because a "Modal" MessageBox() can not be used after a ShowModal()
		{if(!VFTlistbox)
		   {VFTlistbox=new TForm26(4,this);
			VFTlistbox->Caption="Edit mat prop set";
//			for(ip=0;ip<wms.nMatPropSet;ip++)VFTlistbox->ListBox1->Items->Add(wms.name[ip].c_str());
			for(ip=0;ip<wms.nMatPropSet;ip++)VFTlistbox->ListBox1->Items->Add(wms.name[ip].t_str());
			VFTlistbox->ListBox1->ItemIndex=wms.nMatPropSet-1;
			VFTlistbox->ShowModal();
		   }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Close existing Create/Edit box first",L"Halt",MB_OK);}
	 }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No material property sets found",L"Halt",MB_OK);}
   }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First enter weld parameter set",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::DeleteMatPropExecute(TObject *Sender)
{long ip=0;
 if(base.nop1)
  {if(wms.nMatPropSet)
	 {if(!VFTlistbox)
		{VFTlistbox=new TForm26(5,this);
		 VFTlistbox->Caption="Del mat prop set";
//		 for(ip=0;ip<wms.nMatPropSet;ip++)VFTlistbox->ListBox1->Items->Add(wms.name[ip].c_str());
		 for(ip=0;ip<wms.nMatPropSet;ip++)VFTlistbox->ListBox1->Items->Add(wms.name[ip].t_str());
		 VFTlistbox->ListBox1->ItemIndex=wms.nMatPropSet-1;
		 VFTlistbox->ShowModal();
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No material property sets found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::EditMatPropProg(int VFTitemindex)
{
 wp.PRECORD=VFTitemindex;
honk<<wp.PRECORD<<" Enter EditMatProp()\n";
// TBD: Fix issue with wms.hetjd/nprops/Steps/switc
 CreateMatPropSet=new TForm21(1,this);
 CreateMatPropSet->Caption="Edit a Material Property Set";
 CreateMatPropSet->Label1->Caption="Material Property Set Name";
 CreateMatPropSet->Label2->Caption="Thermal Conductivity:";
 CreateMatPropSet->Label3->Caption="Specific Heat:";
 CreateMatPropSet->Label4->Caption="Density:";
 CreateMatPropSet->Label6->Caption="Steps for Creep Input (comma separated)";
 CreateMatPropSet->CheckBox1->Caption="Switch between Isotropic/Creep";
 CreateMatPropSet->Label7->Caption="Annealing Initiation Temperature";
 CreateMatPropSet->Label8->Caption="Annealing Temperature";
 CreateMatPropSet->Label9->Caption="Material Melting Temperature";
 CreateMatPropSet->Label10->Caption="Mechanical Property File Path/Name:";
 CreateMatPropSet->RadioButton1->Caption="Isotropic (multi-linear)";
 CreateMatPropSet->RadioButton2->Caption="Combined Hardening (multi-linear)";
 CreateMatPropSet->RadioButton3->Caption="Simple Phase Transformation";
 CreateMatPropSet->RadioButton4->Caption="Combined Hardening (linear)";
 CreateMatPropSet->RadioButton5->Caption="Elastic-Plastic-Creep(Isotropic,multi-linear)";
 CreateMatPropSet->RadioButton6->Caption="Complete Phase Transformation";
 CreateMatPropSet->RadioButton9->Caption="No";
 CreateMatPropSet->RadioButton10->Caption="Yes";
 CreateMatPropSet->RadioButton7->Caption="No";
 CreateMatPropSet->RadioButton8->Caption="Yes";
 CreateMatPropSet->Button1->Caption="Choose Mechanical Property File...";
 CreateMatPropSet->Button2->Caption="Enter";
 CreateMatPropSet->Button3->Caption="Restore";
 CreateMatPropSet->GroupBox1->Caption="Physical Properties";
 CreateMatPropSet->RadioGroup1->Caption="Material Constitutive Relation (Double-click Isotropic to get Iso/creep)";
 CreateMatPropSet->Label5->Caption="ABAQUS Material Inputs";
 CreateMatPropSet->GroupBox2->Caption="Annealing";
 CreateMatPropSet->GroupBox3->Caption="VED";
 CreateMatPropSet->GroupBox4->Caption="Mechanical Properties";
// CreateMatPropSet->CheckCheckBox1=false;
// CreateMatPropSet->CheckEdit5a=L"0";

 wms.temp_name=wms.name[wp.PRECORD];
 wms.temp_cond=wms.cond[wp.PRECORD];
 wms.temp_heat=wms.heat[wp.PRECORD];
 wms.temp_den=wms.den[wp.PRECORD];
 wms.temp_Ti=wms.Ti[wp.PRECORD];
 wms.temp_Ti=wms.Ta[wp.PRECORD];
 wms.temp_Ti=wms.Tm[wp.PRECORD];
 wms.temp_matFileName=wms.matFileName[wp.PRECORD];
 wms.temp_mcr=wms.mcr[wp.PRECORD];
 wms.temp_annjd=wms.annjd[wp.PRECORD];
 wms.temp_ved=wms.ved[wp.PRECORD];
///////////////// EFP 9/23/2011
 wms.temp_hetjd=wms.hetjd[wp.PRECORD];
 wms.temp_nprops=wms.nprops[wp.PRECORD];
 wms.temp_Steps=wms.Steps[wp.PRECORD];
 wms.temp_switc=wms.switc[wp.PRECORD];
/////////////////

// CreateMatPropSet->CheckEdit1=wms.name[wp.PRECORD];
// CreateMatPropSet->CheckEdit1=wms.name[wp.PRECORD].c_str();
 CreateMatPropSet->CheckEdit1=wms.name[wp.PRECORD].t_str();
 CreateMatPropSet->CheckEdit2=wms.cond[wp.PRECORD];
 CreateMatPropSet->CheckEdit3=wms.heat[wp.PRECORD];
 CreateMatPropSet->CheckEdit4=wms.den[wp.PRECORD];
 CreateMatPropSet->CheckEdit5=wms.Ti[wp.PRECORD];
 CreateMatPropSet->CheckEdit6=wms.Ta[wp.PRECORD];
 CreateMatPropSet->CheckEdit7=wms.Tm[wp.PRECORD];

// if(wms.nMatPropSet>0)CreateMatPropSet->CheckEdit8=wms.matFileName[wp.PRECORD].c_str();
 if(wms.nMatPropSet>0)CreateMatPropSet->CheckEdit8=wms.matFileName[wp.PRECORD].t_str();
 else CreateMatPropSet->CheckEdit8=L"****";

 if(wms.mcr[wp.PRECORD]==0)CreateMatPropSet->CheckRadioGroup1=0;
// else if(wms.mcr[wp.PRECORD]==1)CreateMatPropSet->CheckRadioGroup1=1;
// else if(wms.mcr[wp.PRECORD]==2)CreateMatPropSet->CheckRadioGroup1=2;
// else if(wms.mcr[wp.PRECORD]==3)CreateMatPropSet->CheckRadioGroup1=3;
// else if(wms.mcr[wp.PRECORD]==5)CreateMatPropSet->CheckRadioGroup1=4;
 else if(wms.mcr[wp.PRECORD]==1)CreateMatPropSet->CheckRadioGroup1=3; //Correction BBrust 3/25/2011
 else if(wms.mcr[wp.PRECORD]==2)CreateMatPropSet->CheckRadioGroup1=1;
 else if(wms.mcr[wp.PRECORD]==3)CreateMatPropSet->CheckRadioGroup1=4;
 else if(wms.mcr[wp.PRECORD]==5)CreateMatPropSet->CheckRadioGroup1=2;
 else CreateMatPropSet->CheckRadioGroup1=5;

// if(wms.annjd[wp.PRECORD]==0)CreateMatPropSet->CheckGroupBox4=false;
// else CreateMatPropSet->CheckGroupBox4=true;
// if(wms.ved[wp.PRECORD]==0)CreateMatPropSet->CheckGroupBox3=false;
// else CreateMatPropSet->CheckGroupBox3=true;

// if(wms.annjd[wp.PRECORD]==0)CreateMatPropSet->CheckGroupBox3=true;//Correction  EFP 9/09/2011
// else CreateMatPropSet->CheckGroupBox3=false;
// if(wms.ved[wp.PRECORD]==0)CreateMatPropSet->CheckGroupBox4=true;
// else CreateMatPropSet->CheckGroupBox4=false;
 if(wms.annjd[wp.PRECORD]==0)CreateMatPropSet->CheckGroupBox3=false;//This seems to be correct  EFP 8/31/2012
 else CreateMatPropSet->CheckGroupBox3=true;
 if(wms.ved[wp.PRECORD]==0)CreateMatPropSet->CheckGroupBox4=false;
 else CreateMatPropSet->CheckGroupBox4=true;

 CreateMatPropSet->CheckCheckBox1=wms.switc[wp.PRECORD];
// CreateMatPropSet->CheckEdit5a=wms.Steps[wp.PRECORD]; //Should be as below???
 CreateMatPropSet->CheckEdit5a=wms.Steps[wp.PRECORD].t_str();

// CreateMatPropSet->Label6->Enabled=true;
// CreateMatPropSet->CheckBox1->Enabled=false;
// CreateMatPropSet->Edit5->Enabled=false;
// CreateMatPropSet->Label6->Visible=false;
// CreateMatPropSet->CheckBox1->Visible=false;
// CreateMatPropSet->Edit5->Visible=false;

	   if(wms.switc[wp.PRECORD]){//EFP 9/23/2011
	   CreateMatPropSet->Label6->Enabled=true;
	   CreateMatPropSet->CheckBox1->Enabled=true;
	   CreateMatPropSet->Edit5->Enabled=true;
	   CreateMatPropSet->Label6->Visible=true;
	   CreateMatPropSet->CheckBox1->Visible=true;
	   CreateMatPropSet->Edit5->Visible=true;
	   CreateMatPropSet->Button4->Enabled=true;
	   CreateMatPropSet->Button4->Visible=true;
 CreateMatPropSet->RadioButton2->Enabled=false;
 CreateMatPropSet->RadioButton3->Enabled=false;
 CreateMatPropSet->RadioButton4->Enabled=false;
 CreateMatPropSet->RadioButton5->Enabled=false;
 CreateMatPropSet->RadioButton6->Enabled=false;
 CreateMatPropSet->RadioButton2->Visible=false;
 CreateMatPropSet->RadioButton3->Visible=false;
 CreateMatPropSet->RadioButton4->Visible=false;
 CreateMatPropSet->RadioButton5->Visible=false;
 CreateMatPropSet->RadioButton6->Visible=false;
									 }
	   else {
	   CreateMatPropSet->Label6->Enabled=true;
	   CreateMatPropSet->CheckBox1->Enabled=true;
	   CreateMatPropSet->Edit5->Enabled=false;
	   CreateMatPropSet->Label6->Visible=false;
	   CreateMatPropSet->CheckBox1->Visible=false;
	   CreateMatPropSet->Edit5->Visible=false;
	   CreateMatPropSet->Button4->Enabled=false;
	   CreateMatPropSet->Button4->Visible=false;
 CreateMatPropSet->RadioButton2->Enabled=true;
 CreateMatPropSet->RadioButton3->Enabled=true;
 CreateMatPropSet->RadioButton4->Enabled=true;
 CreateMatPropSet->RadioButton5->Enabled=true;
 CreateMatPropSet->RadioButton6->Enabled=true;
 CreateMatPropSet->RadioButton2->Visible=true;
 CreateMatPropSet->RadioButton3->Visible=true;
 CreateMatPropSet->RadioButton4->Visible=true;
 CreateMatPropSet->RadioButton5->Visible=true;
 CreateMatPropSet->RadioButton6->Visible=true;
			}

 CreateMatPropSet->Show();
}
//---------------------------------------------------------------------------
void TForm1::DelMatPropProg(int VFTitemindex)
{long i=0,dum=0;
// float *SWTcurr=NULL,*SWTvolt=NULL,*SWTeff=NULL,*SWTspeed=NULL;
// String *SWTname=NULL;

 int isw=0,*SWMTmcr=NULL,*SWMTannjd=NULL,*SWMTved=NULL,*SWMThetjd=NULL,*SWMTnprops=NULL;
 float *SWMTcond=NULL,*SWMTheat=NULL,*SWMTden=NULL,*SWMTTi=NULL,*SWMTTa=NULL,*SWMTTm=NULL;
 String *SWMTname=NULL,*SWMTmatFileName=NULL,*SWMTSteps=NULL;
 bool *SWMTswitc=NULL;
honk<<VFTitemindex<<" DelMatPropSet\n";

 isw=1; // MaterialPropertyName test  EFP 4/15/2011
 if(wp.nWeldPass)
   {for(i=0;i<wp.nWeldPass;i++)
	  {if(wp.matName[i]==wms.name[VFTitemindex]){honk<<i<<" "<<VFTitemindex<<" "<<wms.name[VFTitemindex].t_str()<<" Inadmissible MatPropNames\n";
												 isw=0;break;
												}
	  }
   }
 if(isw){
 if(wms.nMatPropSet>1)
   {
	SWMTmcr=new int[wms.nMatPropSet-1];
	SWMTannjd=new int[wms.nMatPropSet-1];
	SWMTved=new int[wms.nMatPropSet-1];
	SWMThetjd=new int[wms.nMatPropSet-1];
	SWMTnprops=new int[wms.nMatPropSet-1];
	SWMTcond=new float[wms.nMatPropSet-1];
	SWMTheat=new float[wms.nMatPropSet-1];
	SWMTden=new float[wms.nMatPropSet-1];
	SWMTTi=new float[wms.nMatPropSet-1];
	SWMTTa=new float[wms.nMatPropSet-1];
	SWMTTm=new float[wms.nMatPropSet-1];
	SWMTname=new String[wms.nMatPropSet-1];
	SWMTmatFileName=new String[wms.nMatPropSet-1];
	SWMTSteps=new String[wms.nMatPropSet-1];
	SWMTswitc=new bool[wms.nMatPropSet-1];

	if(VFTitemindex){
					 for(i=0;i<VFTitemindex;i++)SWMTmcr[i]=wms.mcr[i];
					 for(i=0;i<VFTitemindex;i++)SWMTannjd[i]=wms.annjd[i];
					 for(i=0;i<VFTitemindex;i++)SWMTved[i]=wms.ved[i];
					 for(i=0;i<VFTitemindex;i++)SWMThetjd[i]=wms.hetjd[i];
					 for(i=0;i<VFTitemindex;i++)SWMTnprops[i]=wms.nprops[i];
					 for(i=0;i<VFTitemindex;i++)SWMTcond[i]=wms.cond[i];
					 for(i=0;i<VFTitemindex;i++)SWMTheat[i]=wms.heat[i];
					 for(i=0;i<VFTitemindex;i++)SWMTden[i]=wms.den[i];
					 for(i=0;i<VFTitemindex;i++)SWMTTi[i]=wms.Ti[i];
					 for(i=0;i<VFTitemindex;i++)SWMTTa[i]=wms.Ta[i];
					 for(i=0;i<VFTitemindex;i++)SWMTTm[i]=wms.Tm[i];
					 for(i=0;i<VFTitemindex;i++)SWMTname[i]=wms.name[i];
					 for(i=0;i<VFTitemindex;i++)SWMTmatFileName[i]=wms.matFileName[i];
					 for(i=0;i<VFTitemindex;i++)SWMTSteps[i]=wms.Steps[i];
					 for(i=0;i<VFTitemindex;i++)SWMTswitc[i]=wms.switc[i];
					}
	if(VFTitemindex+1<wms.nMatPropSet){
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTmcr[i-1]=wms.mcr[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTannjd[i-1]=wms.annjd[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTved[i-1]=wms.ved[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMThetjd[i-1]=wms.hetjd[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTnprops[i-1]=wms.nprops[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTcond[i-1]=wms.cond[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTheat[i-1]=wms.heat[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTden[i-1]=wms.den[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTTi[i-1]=wms.Ti[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTTa[i-1]=wms.Ta[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTTm[i-1]=wms.Tm[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTname[i-1]=wms.name[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTmatFileName[i-1]=wms.matFileName[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTSteps[i-1]=wms.Steps[i];
	for(i=VFTitemindex+1;i<wms.nMatPropSet;i++)SWMTswitc[i-1]=wms.switc[i];
									  }
	FDdynmem_manage(-10,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	wms.nMatPropSet=wms.nMatPropSet-1;
	FDdynmem_manage( 10,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	for(i=0;i<wms.nMatPropSet;i++)wms.mcr[i]=SWMTmcr[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.annjd[i]=SWMTannjd[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.ved[i]=SWMTved[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.hetjd[i]=SWMThetjd[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.nprops[i]=SWMTnprops[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.cond[i]=SWMTcond[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.heat[i]=SWMTheat[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.den[i]=SWMTden[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.Ti[i]=SWMTTi[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.Ta[i]=SWMTTa[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.Tm[i]=SWMTTm[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.name[i]=SWMTname[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.matFileName[i]=SWMTmatFileName[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.Steps[i]=SWMTSteps[i];
	for(i=0;i<wms.nMatPropSet;i++)wms.switc[i]=SWMTswitc[i];

	delete [] SWMTmcr;delete [] SWMTannjd;delete [] SWMTved;delete [] SWMThetjd;delete [] SWMTnprops;
	delete [] SWMTcond;delete [] SWMTheat;delete [] SWMTden;
	delete [] SWMTTi;delete [] SWMTTa;delete [] SWMTTm;
	delete [] SWMTname;delete [] SWMTmatFileName;delete [] SWMTSteps;delete [] SWMTswitc;
   }
 else if(wms.nMatPropSet==1)
   {FDdynmem_manage(-10,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum);
	wms.nMatPropSet=0;
	extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Material property sets no longer in the model",L"Warning",MB_OK);
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Inadmissible nMatPropSet in DelWeldParam()",L"Terminate",MB_OK);exit(0);}
		}
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"A weld pass uses this Material Property Set ",L"Halt: Can not be deleted",MB_OK);}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
void TForm1::EditMatProp_public()
{int isel=CreateMatPropSet->CheckISEL;long i=wp.PRECORD;
 if(isel)
   {wms.mcr[i]=wms.temp_mcr;
	wms.annjd[i]=wms.temp_annjd;
	wms.ved[i]=wms.temp_ved;
	wms.hetjd[i]=wms.temp_hetjd;
	wms.nprops[i]=wms.temp_nprops;
	wms.cond[i]=wms.temp_cond;
	wms.heat[i]=wms.temp_heat;
	wms.den[i]=wms.temp_den;
	wms.Ti[i]=wms.temp_Ti;
	wms.Ta[i]=wms.temp_Ta;
	wms.Tm[i]=wms.temp_Tm;
	wms.name[i]=wms.temp_name;
	wms.matFileName[i]=wms.temp_matFileName;
	wms.Steps[i]=wms.temp_Steps;
	wms.switc[i]=wms.temp_switc;
	FD_LButtonstatus=11;stateVFT=2;
	delete CreateMatPropSet;
//	CreateMatPropSet=NULL;// because it was created with Show()
   }
 else CreateMatPropSet->Close();
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 CreateMatPropSet=NULL;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWG_redExecute(TObject *Sender)
{if(wp.nWeldGroup){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
				   ShowWG_polychrome->Checked=false;ShowWG_red->Checked=true;
				   wp.PAINT_SEL=0;
////					 FDrestore();
//				   Invalidate();
				  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups in this model",L"Notice",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWG_polychromeExecute(TObject *Sender)
{if(wp.nWeldGroup){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
				   ShowWG_polychrome->Checked=true;ShowWG_red->Checked=false;
				   wp.PAINT_SEL=1;
////					 FDrestore();
//				   Invalidate();
				  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups in this model",L"Notice",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWP_lastExecute(TObject *Sender)
{if(base.nop1)
  {if(wp.nWeldPass)
	 {int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;long ir=0,ip=0;
	  iPersistVFT=iPersistVFT+10*(1-j);
	  for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
									 wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
									}
	  wp.util_arr[wp.nWeldPass-1]=wp.util_arr[wp.nWeldPass-1]+10;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
	  ShowWP_hide->Checked=false;ShowWP_last->Checked=true;ShowWP_select->Checked=false;ShowWPout_All->Checked=false;
// FDrestore();
	  Invalidate();
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWPout_AllExecute(TObject *Sender) //Show all WP in outline  EFP 3/22/2012
{if(base.nop1)
  {if(wp.nWeldPass)
	 {int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;
	  long ir=0,is=0,ip=0;
	  iPersistVFT=iPersistVFT+10*(1-j);
// for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
//								wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
//							   }
// is=wp.util_arr[VFTitemindex]+10;
// wp.util_arr[VFTitemindex]=is;
	  for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
									 wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
									 wp.util_arr[ir]=wp.util_arr[ir]+10;

honk<<ir<<" "<<wp.nWeldPass<<" wp.util_arr[ir] "<<wp.util_arr[ir]<<"\n";
									}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////

//if(1==1)exit(0);
	  ShowWP_hide->Checked=false;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=true;
	  Invalidate();
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWP_hideExecute(TObject *Sender)
{if(base.nop1)
  {if(wp.nWeldPass)
	 {int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;iPersistVFT=iPersistVFT-10*j;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
	  ShowWP_hide->Checked=true;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=false;
// FDrestore();
	  Invalidate();
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWP_selectExecute(TObject *Sender)
{long ip=0; //EFP 1/21/2011
 if(base.nop1)
  {if(wp.nWeldPass)
	 {if(!VFTlistbox)
		{VFTlistbox=new TForm26(8,this);
		 VFTlistbox->Caption="Show selected WP outline";
		 wp.EDIT_SEL=0;
//		 for(ip=0;ip<wp.nWeldPass;ip++)VFTlistbox->ListBox1->Items->Add(wp.name[ip].c_str());
		 for(ip=0;ip<wp.nWeldPass;ip++)VFTlistbox->ListBox1->Items->Add(wp.name[ip].t_str());
		 VFTlistbox->ListBox1->ItemIndex=wp.nWeldPass-1;
		 VFTlistbox->ShowModal();
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void TForm1::ShowWPoutlineProg(int VFTitemindex)
{int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;
 long ir=0,is=0,ip=0;
 iPersistVFT=iPersistVFT+10*(1-j);
 for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
								wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
							   }
 is=wp.util_arr[VFTitemindex]+10;
 wp.util_arr[VFTitemindex]=is;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 ShowWP_hide->Checked=false;ShowWP_last->Checked=false;ShowWP_select->Checked=true;ShowWPout_All->Checked=false;
 Invalidate();
}
//---------------------------------------------------------------------------
void TForm1::ShowWGselectorProg(int VFTitemindex)
{long ie=0,eltype=0,bscode=0,node=0,ieGID=0,ipid=0,t7=10000000,t5=100000,t3=1000;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 base.GIDcol=1;FDcomp_nGID(base.nelt,base.matno,&nGID,arGID);
////////////// EFP 2/29/2012
 for(ie=0;ie<base.nelt;ie++)
	{
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)indat.matno[ie]=t3*(indat.matno[ie]/t3);//i.e. ieGID==0
//	 else {eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
////		   ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
//		   ipid=base.arrELSET[ base.trackELSET[ie]+1 ];
////		   if(ipid==VFTitemindex+1)indat.matno[ie]=indat.matno[ie]-ieGID+ipid;
////		   else indat.matno[ie]=t3*(indat.matno[ie]/t3);
//		   if(ipid==VFTitemindex+1)indat.arrELSET[ indat.trackELSET[ie]+1 ]=ipid;
//		   else indat.arrELSET[ indat.trackELSET[ie]+1 ]=0;
//		  }
		   ipid=base.arrELSET[ie];
		   if(ipid==VFTitemindex+1)indat.arrELSET[ie]=ipid;
		   else indat.arrELSET[ie]=0;
	}
////////////////
 Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::WGselAllExecute(TObject *Sender)
{long ie=0,eltype=0,bscode=0,node=0,ieGID=0,t7=10000000,t5=100000,t3=1000;
 if(base.nop1){
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
 base.GIDcol=1;FDcomp_nGID(base.nelt,base.matno,&nGID,arGID);
////////////// EFP 2/29/2012
// for(ie=0;ie<base.nelt;ie++)
//	{if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)indat.matno[ie]=t3*(indat.matno[ie]/t3);//i.e. ieGID==0
//	 else {eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
//		   ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
//		   indat.matno[ie]=indat.matno[ie]-ieGID+base.arrELSET[ base.trackELSET[ie]+1 ];
//		  }
//	}
 for(ie=0;ie<base.nelt;ie++)
	{
//	 if(base.trackELSET[ie+1]-base.trackELSET[ie]==1)indat.arrELSET[ indat.trackELSET[ie]+1 ]=0;//i.e. ieGID==0
//	 else {eltype=indat.matno[ie]/t7;bscode=(indat.matno[ie]-eltype*t7)/t5;node=(indat.matno[ie]-eltype*t7-bscode*t5)/t3;
////		   ieGID=indat.matno[ie]-eltype*t7-bscode*t5-node*t3;
//////////////// EFP 2/20/2012
//						if(indat.trackELSET[ie+1]-indat.trackELSET[ie]==1)ieGID=0;
//						else if(indat.arrELSET[ indat.trackELSET[ie+1]-1 ]<0)ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-2 ];
//						else {if(indat.GIDcol==1)ieGID=indat.arrELSET[ indat.trackELSET[ie]+indat.GIDcol ]; //Prioritize WG
//							  else ieGID=indat.arrELSET[ indat.trackELSET[ie+1]-1 ];                      //Prioritize WP
//							 }
////////////////
////		   indat.matno[ie]=indat.matno[ie]-ieGID+base.arrELSET[ base.trackELSET[ie]+1 ];
//		   indat.arrELSET[ indat.trackELSET[ie]+1 ]=base.arrELSET[ base.trackELSET[ie]+1 ];
//		  }
indat.arrELSET[ie]=base.arrELSET[ie];
	}
////////////////
 Invalidate();
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"88Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWPstartelem_listExecute(TObject *Sender)
{
// long is=0,i=0,ie=0,eltype=0,bscode=0,node=0,ieGID=0,t3=1000,t5=100000,t7=10000000,
//	  prod=1,aflag=0,GIDspac=long(1+(nGIDmax-1)/16),saflag[(MAX_GID+1)/16];
 if(base.nop1)
   {if(iPaintyesno/10)
	  {if(wp.nWeldPass)
					  {if(StartElemListForm){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"StartElList Selector already exists.",L"Warning",MB_OK);}
					   else {
//					         for(is=0;is<GIDspac;is++)saflag[is]=0;
//							 for(is=0;is<GIDspac;is++)
//							   {if(16*is<nGIDmax)
//								  {prod=1;aflag=0;
//								   for(i=16*is;i<min(long(nGIDmax),16*(is+1));i++)
//									  {for(ie=0;ie<base.nelt;ie++)
//										  {eltype=base.matno[ie]/t7;bscode=(base.matno[ie]-eltype*t7)/t5;node=(base.matno[ie]-eltype*t7-bscode*t5)/t3;ieGID=base.matno[ie]-eltype*t7-bscode*t5-node*t3;
//										   if(i==ieGID){aflag=aflag+prod;break;}
//										  }
//									   prod=2*prod;
//									  }
//								   saflag[is]=aflag;
//								  }
//								else break;
//							   }
							 StartElemListForm=new TForm27(0,wp.nWeldPass,wp.name,this);
							 StartElemListForm->Caption="Show WP start elements";
							 StartElemListForm->Button1->Caption="Redraw";
							 StartElemListForm->ShowModal();
							}
					  }
		else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes in model",L"Halt",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must paint first->View/Paint",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"89Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::WG_selectorExecute(TObject *Sender)
{long ip=0; //EFP 1/21/2011
 if(base.nop1)
  {if(wp.nWeldGroup)
	 {if(!VFTlistbox)
		{VFTlistbox=new TForm26(9,this);
		 VFTlistbox->Caption="Show selected Weld Group";
		 wp.EDIT_SEL=0;
		 for(ip=0;ip<wp.nWeldGroup;ip++)VFTlistbox->ListBox1->Items->Add(base.groupsname[ip].t_str());
		 VFTlistbox->ListBox1->ItemIndex=wp.nWeldGroup-1;
		 VFTlistbox->ShowModal();
		}
	  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"List box already exists",L"Halt",MB_OK);}
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld groups found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::SelStrings_public()
{long i=0,j=0,ir=0,sum=0,isel=StartElemListForm->CheckSel;
 for(i=0;i<wp.nWeldPass;i++){StartElemListForm->CheckIndex=i;
							 j=StartElemListForm->CheckIndex;
							 if(j)sum++;
							 ir=wp.util_arr[i]/10;
							 if(isel)wp.util_arr[i]=wp.util_arr[i]+10*(j-ir);//ShowWPoutline
							 else wp.util_arr[i]=10*ir+j;//ShowWPstartElem
// honk<<i<<" SelStrings "<<j<<"\n";
							}
 if(sum){i=iPersistVFT/100;
		 j=(iPersistVFT-100*i)/10;
		 if(isel)iPersistVFT=iPersistVFT+10*(1-j);
		 else iPersistVFT=iPersistVFT+100*(1-i);
		}
 else {j=iPersistVFT/10; //i.e. hide all
	   iPersistVFT=iPersistVFT-10*j;
	  }
 ShowWPstartelem_list->Checked=true;ShowWPstartelem_Hide->Checked=false;//These statements are true as long as StartElemListForm is modal
// delete StartElemListForm;
 StartElemListForm=NULL;
 Invalidate();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ShowWPstartelem_HideExecute(TObject *Sender)
{if(base.nop1)
   {long i=iPersistVFT/100;iPersistVFT=iPersistVFT-100*i;
	ShowWPstartelem_list->Checked=false;ShowWPstartelem_Hide->Checked=true;
	Invalidate();
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::VFT_AutoSave1GoExecute(TObject *Sender)
{
// if(VFT_AutoSaveGo());
// else {Timer4->Enabled=false;
//	   AutoSaveOn->Checked=false;AutoSaveOff->Checked=true;
//	   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not AutoSave",L"Failure",MB_OK);
//	  }
 flag_VFTrSave=1;//EFP 10/02/2011
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AutoSaveOnExecute(TObject *Sender)
{if(base.nop1){
//               if(VFT_AutoSaveGo()){AutoSaveOn->Checked=true;AutoSaveOff->Checked=false;
//									Timer4->Interval=TIMER4_INTV;Timer4->Enabled=true;
//								   }
//			   else {Timer4->Enabled=false;AutoSaveOn->Checked=false;AutoSaveOff->Checked=true;
//					 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not AutoSave",L"Failure",MB_OK);
//					}
/////////////////// Sustensed EFP 4/04/2011
//			   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"AutoSave suspended for further testing",L"Notice",MB_OK);
///////////////////
			   AutoSaveOn->Checked=true;AutoSaveOff->Checked=false;
//			   Timer4->Interval=TIMER4_INTV;
			   Timer4->Interval=IntervalT4;
			   Timer4->Enabled=true;//EFP 10/02/2011
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"90Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AutoSaveOffExecute(TObject *Sender){Timer4->Enabled=false;
															AutoSaveOn->Checked=false;AutoSaveOff->Checked=true;
 flag_VFTrSave=0;//EFP 10/02/2011
														   }
//---------------------------------------------------------------------------
void __fastcall TForm1::Normal_direction1Execute(TObject *Sender)
{if(base.nop1){int i=(wp.avis-100*(wp.avis/100))/10;
			   wp.avis=wp.avis-10*i;
			   Normal_direction1->Checked=true;
			   Complem_direction1->Checked=false;
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"91Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Complem_direction1Execute(TObject *Sender)
{if(base.nop1){int i=(wp.avis-100*(wp.avis/100))/10;
			   wp.avis=wp.avis-10*i+10;
			   Normal_direction1->Checked=false;
			   Complem_direction1->Checked=true;
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"92Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
int TForm1::NodalCoincidenceTest(long npoin,float c1[],long node_map[],float tol)
{int flag=0;long i=0,j=0;float rad=0.,tol2=tol*tol;
honk<<"\n"<<"Nodal coincidence test with tolerance "<<tol<<"\n";
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
 for(i=0;i<npoin-1;i++){
//honk<<i<<" TestCCCC1 "<<c1[NDF*i  ]<<" "<<c1[NDF*i+1]<<" "<<c1[NDF*i+2]<<"\n";
						for(j=i+1;j<npoin;j++)
						  {
//						   rad=(c1[NDF*i  ]-c1[NDF*j  ])*(c1[NDF*i  ]-c1[NDF*j  ])+
//							   (c1[NDF*i+1]-c1[NDF*j+1])*(c1[NDF*i+1]-c1[NDF*j+1])+
//							   (c1[NDF*i+2]-c1[NDF*j+2])*(c1[NDF*i+2]-c1[NDF*j+2]);
//						   if(rad<tol2){flag=1;
//honk<<node_map[i]+1<<" "<<c1[NDF*i]<<" "<<c1[NDF*i+1]<<" "<<c1[NDF*i+2]<<" coincident "
//	<<node_map[j]+1<<" "<<c1[NDF*j]<<" "<<c1[NDF*j+1]<<" "<<c1[NDF*j+2]<<"\n";
//									   }
						   if(c1[NDF*i  ]-c1[NDF*j  ]<tol)
							 {if(c1[NDF*i  ]-c1[NDF*j  ]> -tol)
								{if(c1[NDF*i+1]-c1[NDF*j+1]<tol)
								   {if(c1[NDF*i+1]-c1[NDF*j+1]> -tol)
									  {if(c1[NDF*i+2]-c1[NDF*j+2]<tol)
										 {if(c1[NDF*i+2]-c1[NDF*j+2]> -tol)
											{
						   rad=(c1[NDF*i  ]-c1[NDF*j  ])*(c1[NDF*i  ]-c1[NDF*j  ])+
							   (c1[NDF*i+1]-c1[NDF*j+1])*(c1[NDF*i+1]-c1[NDF*j+1])+
							   (c1[NDF*i+2]-c1[NDF*j+2])*(c1[NDF*i+2]-c1[NDF*j+2]);
						   if(rad<tol2){flag=1;
honk<<node_map[i]+1<<" "<<c1[NDF*i]<<" "<<c1[NDF*i+1]<<" "<<c1[NDF*i+2]<<" NodalCoincidenceTestcoincident "
	<<node_map[j]+1<<" "<<c1[NDF*j]<<" "<<c1[NDF*j+1]<<" "<<c1[NDF*j+2]<<"\n";
									   }
											}
										 }
									  }
								   }
								}
							 }
						  }
					   }
//	 }
// __finally {
Screen->Cursor=Save_Cursor;
//}
 return flag;
}
//---------------------------------------------------------------------------
void TForm1::NodalCoincidenceElimCompact(long *npoin,float c1[],long node_map[],float tol,long nelt,long nop1[],long matno[])
{long in=0,i=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000,j=0,iflag=0,*map=NULL;float rad=0.,tol2=tol*tol;
honk<<"\n"<<"Nodal coincidence elimination with tolerance "<<tol<<"\n";
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
 map=new long[ *npoin];for(i=0;i< *npoin;i++)map[i]=0; //TBD: Test for memory availability
 for(i=0;i<nelt;i++){eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;node=(matno[i]-eltype*t7-bscode*t5)/t3;
					 for(in=0;in<node;in++)map[nop1[MXNPEL*i+in]]=1;
					}
 for(i=0;i< *npoin-1;i++)
   {if(map[i]>0){map[i]=i+1;for(j=i+1;j< *npoin;j++)
							 {if(map[j]>0)
								   {if(c1[NDF*i  ]-c1[NDF*j  ]<tol)
									  {if(c1[NDF*i  ]-c1[NDF*j  ]> -tol)
										 {if(c1[NDF*i+1]-c1[NDF*j+1]<tol)
											{if(c1[NDF*i+1]-c1[NDF*j+1]> -tol)
											   {if(c1[NDF*i+2]-c1[NDF*j+2]<tol)
												  {if(c1[NDF*i+2]-c1[NDF*j+2]> -tol)
													 {rad=(c1[NDF*i  ]-c1[NDF*j  ])*(c1[NDF*i  ]-c1[NDF*j  ])+(c1[NDF*i+1]-c1[NDF*j+1])*(c1[NDF*i+1]-c1[NDF*j+1])+(c1[NDF*i+2]-c1[NDF*j+2])*(c1[NDF*i+2]-c1[NDF*j+2]);
													  if(rad<tol2){
																   map[j]= -(i+1);
																  }
													 }
												  }
											   }
											}
										 }
									  }
								   }
							 }
				}
   }
 in=1;for(i=0;i< *npoin-1;i++){if(map[i]>0){for(j=i+1;j< *npoin;j++){if(map[j]== -map[i])map[j]= -in;}
											map[i]=in;in++;
										   }
							  }
 if(map[*npoin-1]>0)map[*npoin-1]=in;
 in=0;for(i=0;i< *npoin;i++){if(map[i]>0){c1[NDF*in]=c1[NDF*i];c1[NDF*in+1]=c1[NDF*i+1];c1[NDF*in+2]=c1[NDF*i+2];
										  node_map[in]=i;in++;
										 }
							 else if(map[i]<0)map[i]= -map[i];
							}
 *npoin=in;for(i=0;i<nelt;i++){eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;node=(matno[i]-eltype*t7-bscode*t5)/t3;
							   for(in=0;in<node;in++)nop1[MXNPEL*i+in]=map[nop1[MXNPEL*i+in]]-1;
							  }
 delete [] map;
//	 }
// __finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::NodalCoincidenceElimCompact1(long *npoin,float c1[],long node_map[],float tol,long nelt,long nop1[],long matno[])
{long in=0,jn=0,ik=0,i=0,eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000,j=0,iflag=0,*map=NULL;float rad=0.,tol2=tol*tol;
honk<<"\n"<<"Nodal coincidence elimination with tolerance (but never merge nodes on same element) "<<tol<<"\n";
 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
// try {
 map=new long[ *npoin];for(i=0;i< *npoin;i++)map[i]=0; //TBD: Test for memory availability
 for(i=0;i<nelt;i++){eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;node=(matno[i]-eltype*t7-bscode*t5)/t3;
					 for(in=0;in<node;in++)map[nop1[MXNPEL*i+in]]=1;
					}
 for(i=0;i< *npoin-1;i++)
   {if(map[i]>0){map[i]=i+1;for(j=i+1;j< *npoin;j++)
							 {if(map[j]>0)
								   {if(c1[NDF*i  ]-c1[NDF*j  ]<tol)
									  {if(c1[NDF*i  ]-c1[NDF*j  ]> -tol)
										 {if(c1[NDF*i+1]-c1[NDF*j+1]<tol)
											{if(c1[NDF*i+1]-c1[NDF*j+1]> -tol)
											   {if(c1[NDF*i+2]-c1[NDF*j+2]<tol)
												  {if(c1[NDF*i+2]-c1[NDF*j+2]> -tol)
													 {rad=(c1[NDF*i  ]-c1[NDF*j  ])*(c1[NDF*i  ]-c1[NDF*j  ])+(c1[NDF*i+1]-c1[NDF*j+1])*(c1[NDF*i+1]-c1[NDF*j+1])+(c1[NDF*i+2]-c1[NDF*j+2])*(c1[NDF*i+2]-c1[NDF*j+2]);
													  if(rad<tol2){
																   map[j]= -(i+1);
																  }
													 }
												  }
											   }
											}
										 }
									  }
								   }
							 }
				}
   }
/////////////////
 for(i=0;i<nelt;i++)
   {eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;node=(matno[i]-eltype*t7-bscode*t5)/t3;
	for(in=0;in<node;in++)
	  if(map[nop1[MXNPEL*i+in]]<0)
		{ik=map[nop1[MXNPEL*i+in]];
		 for(jn=0;jn<node;jn++)if(in!=jn){if(ik==map[nop1[MXNPEL*i+jn]]){
honk<<"Eltype "<<eltype<<" "<<node<<" Unmerge pair "<<in<<" "<<nop1[MXNPEL*i+in]<<" "<<ik<<" pp "<<jn<<nop1[MXNPEL*i+jn]<<" "<<map[nop1[MXNPEL*i+jn]]<<"\n";
																		 map[nop1[MXNPEL*i+in]]=nop1[MXNPEL*i+in]+1;
																		 map[nop1[MXNPEL*i+jn]]=nop1[MXNPEL*i+jn]+1;
																		}
										  else if(ik== -map[nop1[MXNPEL*i+jn]]){
honk<<"Eltype "<<eltype<<" "<<node<<" Unmerge sngl "<<in<<" "<<nop1[MXNPEL*i+in]<<" "<<ik<<"\n";
																				map[nop1[MXNPEL*i+in]]=nop1[MXNPEL*i+in]+1;
																			   }
										 }
		}
   }
/////////////////
 in=1;for(i=0;i< *npoin-1;i++){if(map[i]>0){for(j=i+1;j< *npoin;j++){if(map[j]== -map[i])map[j]= -in;}
											map[i]=in;in++;
										   }
							  }
 if(map[*npoin-1]>0)map[*npoin-1]=in;
 in=0;for(i=0;i< *npoin;i++){if(map[i]>0){c1[NDF*in]=c1[NDF*i];c1[NDF*in+1]=c1[NDF*i+1];c1[NDF*in+2]=c1[NDF*i+2];
										  node_map[in]=i;in++;
										 }
							 else if(map[i]<0)map[i]= -map[i];
							}
 *npoin=in;for(i=0;i<nelt;i++){eltype=matno[i]/t7;bscode=(matno[i]-eltype*t7)/t5;node=(matno[i]-eltype*t7-bscode*t5)/t3;
							   for(in=0;in<node;in++)nop1[MXNPEL*i+in]=map[nop1[MXNPEL*i+in]]-1;
							  }
 delete [] map;
//	 }
// __finally {
Screen->Cursor=Save_Cursor;
//}
}
//---------------------------------------------------------------------------
void TForm1::Form28_public()
{int isel=F28_Form->CheckISEL,imode=F28_Form->CheckMODE,fORint=F28_Form->CheckForI;
 long i=0,ival=0;float fval=0.;
 if(fORint)fval=F28_Form->CheckFVAL;else ival=F28_Form->CheckIVAL;
 if(!imode){F28_Form->Close();F28_Form=NULL;}
 if(isel==1){for(i=0;i<wps.nWeldParamSet;i++)wps.curr[i]=fval;//WeldParam_curr
			 if(wp.nWeldPass)for(i=0;i<wp.nWeldPass;i++)wp.curr[i]=fval;
			}
 else if(isel==2){for(i=0;i<wps.nWeldParamSet;i++)wps.volt[i]=fval;//WeldParam_volt
				  if(wp.nWeldPass)for(i=0;i<wp.nWeldPass;i++)wp.volt[i]=fval;
				 }
 else if(isel==3){for(i=0;i<wps.nWeldParamSet;i++)wps.eff[i]=fval;//WeldParam_eff
				  if(wp.nWeldPass)for(i=0;i<wp.nWeldPass;i++)wp.eff[i]=fval;
				 }
 else if(isel==4){for(i=0;i<wps.nWeldParamSet;i++)wps.speed[i]=fval;//WeldParam_speed
				  if(wp.nWeldPass)for(i=0;i<wp.nWeldPass;i++)wp.speed[i]=fval;
				 }
//
 else if(isel==5)for(i=0;i<wms.nMatPropSet;i++)wms.cond[i]=fval;//MatProp_ThCond
 else if(isel==6)for(i=0;i<wms.nMatPropSet;i++)wms.heat[i]=fval;//MatProp_SpHeat
 else if(isel==7)for(i=0;i<wms.nMatPropSet;i++)wms.den[i]=fval;//MatProp_Density
//------ TBD: mcr, Steps, nprops, hetjd material choice EFP 9/02/2011 -------
// else if(isel==8)for(i=0;i<wms.nMatPropSet;i++)wms.annjd[i]=ival;//MatProp_annjd(-1 no/0 yes)
 else if(isel==8)for(i=0;i<wms.nMatPropSet;i++)wms.annjd[i]=ival;//MatProp_annjd(-1 yes/0 no)
 else if(isel==9)for(i=0;i<wms.nMatPropSet;i++)wms.Ti[i]=fval;//MatProp_Ti
 else if(isel==10)for(i=0;i<wms.nMatPropSet;i++)wms.Ta[i]=fval;//MatProp_Ta
 else if(isel==11)for(i=0;i<wms.nMatPropSet;i++)wms.Tm[i]=fval;//MatProp_Tm
// else if(isel==12)for(i=0;i<wms.nMatPropSet;i++)wms.ved[i]=ival;//MatProp_VED(-1 no/0 yes)
 else if(isel==12)for(i=0;i<wms.nMatPropSet;i++)wms.ved[i]=ival;//MatProp_VED(-1 yes/0 no)
//------ TBD: joint type, shapes, moving arc EFP 9/02/2011 -------
 else if(isel==13)for(i=0;i<wp.nWeldPass;i++)wp.timeInterval[i]=fval;//WPass_timeInterval
 else if(isel==14)for(i=0;i<wp.nWeldPass;i++)wp.stepInterval[i]=ival;//WPass_stepInterval
 else if(isel==15)for(i=0;i<wp.nWeldPass;i++)wp.maxiHeatStep[i]=fval;//WPass_maxiHeatStep
 else if(isel==16)for(i=0;i<wp.nWeldPass;i++)wp.miniHeatStep[i]=fval;//WPass_miniHeatStep
 else if(isel==17)for(i=0;i<wp.nWeldPass;i++)wp.thk1[i]=fval;//WPass_thk1
 else if(isel==18)for(i=0;i<wp.nWeldPass;i++)wp.thk2[i]=fval;//WPass_thk2
// else if(isel==19)for(i=0;i<wp.nWeldPass;i++)wp.xlay[i]=fval;//WPass_xlay
 else if(isel==20)for(i=0;i<wp.nWeldPass;i++)wp.troom[i]=fval;//WPass_troom
 else if(isel==21)for(i=0;i<wp.nWeldPass;i++)wp.tmelt[i]=fval;//WPass_tmelt
 else if(isel==22)for(i=0;i<wp.nWeldPass;i++)wp.tcutl[i]=fval;//WPass_tcutl
 else if(isel==23)for(i=0;i<wp.nWeldPass;i++)wp.tcuth[i]=fval;//WPass_tcuth
 else if(isel==24){if(NodalCoincidenceTest(base.npoin,base.c1,base.node_map,fval))//NodalCoincidence  EFP 9/07/2011
					 {long tempnpoin=base.npoin;
//					  NodalCoincidenceElimCompact(&tempnpoin,base.c1,base.node_map,fval,base.nelt,base.nop1,base.matno);
					  NodalCoincidenceElimCompact1(&tempnpoin,base.c1,base.node_map,fval,base.nelt,base.nop1,base.matno); //EFP 11/17/2012
					  base.npoin=tempnpoin;
					  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Coincidence found & eliminated. See VFTlogfile.txt",L"Notice",MB_OK);
					 }
				   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No nodal coincidence found",L"Success",MB_OK);}
				  }
 else if(isel==25)IntervalT4=ival;//Timer4 interval
 else if(isel==26)WARP3DepBlock(ival);//WARP3D elastic-plastic blocks  EFP 9/11/2012
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported Form28_public",L"Warning",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::Form28Close_public(){F28_Form->Close();
								  if(F28_Form->CheckMODE)delete F28_Form;
								  F28_Form=NULL;
								 }
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWParam_currExecute(TObject *Sender)
// Usage:
// TForm28(isel,imode,fORint,vl0,vlmin,vlmax,vf0,vfmin,vfmax...)
// imode=0 (modal) & 1 (modeless)
// fORint=0 (long) & 1 (float)
// If long,  vlmin<vl0<vlmax
// If float, vfmin<vf0<vfmax
// Selector isel

//Remember to change CANCEL->CLOSE for Modeless
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wps.nWeldParamSet){F28_Form=new TForm28(1,0,1,vl0,vlmin,vlmax,wps.curr[0],vfmin,vfmax,this);
						  F28_Form->Caption="Change WeldParam current";F28_Form->Button3->Caption="Cancel";
						  F28_Form->ShowModal();
						 }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Parameters",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"95Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWParam_voltExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wps.nWeldParamSet){F28_Form=new TForm28(2,0,1,vl0,vlmin,vlmax,wps.volt[0],vfmin,vfmax,this);
						  F28_Form->Caption="Change WeldParam voltage";F28_Form->Button3->Caption="Cancel";
						  F28_Form->ShowModal();
						 }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Parameters",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"96Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWParam_effExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.;
 if(base.nop1)
   {if(wps.nWeldParamSet){F28_Form=new TForm28(3,0,1,vl0,vlmin,vlmax,wps.eff[0],vfmin,vfmax,this);
						  F28_Form->Caption="Change WeldParam efficiency";F28_Form->Button3->Caption="Cancel";
						  F28_Form->ShowModal();
						 }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Parameters",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"97Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWParam_speedExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wps.nWeldParamSet){F28_Form=new TForm28(4,0,1,vl0,vlmin,vlmax,wps.speed[0],vfmin,vfmax,this);
						  F28_Form->Caption="Change WeldParam speed";F28_Form->Button3->Caption="Cancel";
						  F28_Form->ShowModal();
						 }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Parameters",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"98Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_ThCondExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(5,0,1,vl0,vlmin,vlmax,wms.cond[0],vfmin,vfmax,this);
						F28_Form->Caption="Change MatProp Th.conductivity";F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"99Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_SpHeatExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(6,0,1,vl0,vlmin,vlmax,wms.heat[0],vfmin,vfmax,this);
						F28_Form->Caption="Change MatProp Specific Heat";F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"100Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_DensExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(7,0,1,vl0,vlmin,vlmax,wms.den[0],vfmin,vfmax,this);
						F28_Form->Caption="Change MatProp Density";F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"101Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
//------ TBD: mcr, Steps, nprops, hetjd material choice EFP 9/02/2011 -------
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_AnnealExecute(TObject *Sender)
{long vlmin= -1,vlmax=0;float vf0=0.,vfmin=0.,vfmax=0.;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(8,0,0,wms.annjd[0],vlmin,vlmax,vf0,vfmin,vfmax,this);
//						F28_Form->Caption="MatProp anneal (no -1/yes 0)";
						F28_Form->Caption="MatProp anneal (yes -1/no 0)";
						F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"102Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_TiExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(9,0,1,vl0,vlmin,vlmax,wms.Ti[0],vfmin,vfmax,this);
						F28_Form->Caption="Change MatProp Initiation T";F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"103Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_TaExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(10,0,1,vl0,vlmin,vlmax,wms.Ta[0],vfmin,vfmax,this);
						F28_Form->Caption="Change MatProp Anneal T";F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"104Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_TmExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(11,0,1,vl0,vlmin,vlmax,wms.Tm[0],vfmin,vfmax,this);
						F28_Form->Caption="Change MatProp Melting T";F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"105Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllMatProp_VEDExecute(TObject *Sender)
{long vlmin= -1,vlmax=0;float vf0=0.,vfmin=0.,vfmax=0.;
 if(base.nop1)
   {if(wms.nMatPropSet){F28_Form=new TForm28(12,0,0,wms.ved[0],vlmin,vlmax,vf0,vfmin,vfmax,this);
//						F28_Form->Caption="Change MatProp VED (no -1/yes 0)";
						F28_Form->Caption="Change MatProp VED (yes -1/no 0)";
						F28_Form->Button3->Caption="Cancel";
						F28_Form->ShowModal();
					   }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Material Properties",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"106Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_timeIntervExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(13,0,1,vl0,vlmin,vlmax,wp.timeInterval[0],vfmin,vfmax,this);
					 F28_Form->Caption="InterPass Cooling Time";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"107Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_stepIntervalExecute(TObject *Sender)
{long vlmin=0,vlmax=1000000;float vf0=0.,vfmin=0.,vfmax=0.;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(14,0,0,wp.stepInterval[0],vlmin,vlmax,vf0,vfmin,vfmax,this);
					 F28_Form->Caption="Change InterPass Cooling Steps";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"108Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_maxiHeatStepExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(15,0,1,vl0,vlmin,vlmax,wp.maxiHeatStep[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change Max Heating Time";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"109Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_miniHeatStepExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(16,0,1,vl0,vlmin,vlmax,wp.miniHeatStep[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change Min Heating Time";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"110Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_thk1Execute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(17,0,1,vl0,vlmin,vlmax,wp.thk1[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change Plate#1 thickness";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"111Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_thk2Execute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.000001,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(18,0,1,vl0,vlmin,vlmax,wp.thk2[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change Plate#2 thickness";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"112Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_troomExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin= -273.1,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(20,0,1,vl0,vlmin,vlmax,wp.troom[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change room temperature";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"114Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_tmeltExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin= -273.1,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(21,0,1,vl0,vlmin,vlmax,wp.tmelt[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change melting temperature";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"115Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_tcutlExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin= -273.1,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(22,0,1,vl0,vlmin,vlmax,wp.tcutl[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change low-cut temperature";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"116Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChAllWPass_tcuthExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin= -273.1,vfmax=1.e20;
 if(base.nop1)
   {if(wp.nWeldPass){F28_Form=new TForm28(23,0,1,vl0,vlmin,vlmax,wp.tcuth[0],vfmin,vfmax,this);
					 F28_Form->Caption="Change preheat temperature";F28_Form->Button3->Caption="Cancel";
					 F28_Form->ShowModal();
					}
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Create Weld Pass",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"117Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ChangeTimer4_IntervExecute(TObject *Sender)
{long vlmin=10000,vlmax=LONG_INT;float vf0=0.,vfmin=0.,vfmax=0.;
 if(base.nop1){F28_Form=new TForm28(25,0,0,IntervalT4,vlmin,vlmax,vf0,vfmin,vfmax,this);
			   F28_Form->Caption="Change AutoSave interval";F28_Form->Button3->Caption="Cancel";
			   F28_Form->ShowModal();
			  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"118Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::NodalCoincidenceExecute(TObject *Sender)
{long vl0=0,vlmin=0,vlmax=0;float vfmin=0.,vfmax=1.e20,TOL=1.e-3;
 if(base.nop1)
   {F28_Form=new TForm28(24,0,1,vl0,vlmin,vlmax,TOL,vfmin,vfmax,this);
	F28_Form->Caption="Nodal coincidence test";F28_Form->Button3->Caption="Cancel";
	F28_Form->Label1->Caption="Tolerance";F28_Form->ShowModal();
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"119Get geometry file->File/Open",L"Halt",MB_OK);}
}

//---------------------------------------------------------------------------
void __fastcall TForm1::Action1Execute(TObject *Sender)
{
 if(flag_VFTrSave){//EFP 10/02/2011
///////////////////////////////////////////
TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//try {
////VFTrSave();
	 VFT_SaveAs1(0);
//	}
//__finally {
Screen->Cursor=Save_Cursor;
//}
/////////////////////////////////////////////
honk<<" montmorillonite\n";
				   flag_VFTrSave=0;
				  }
}

//---------------------------------------------------------------------------
//ksw=checkAlphabetic(cht[i]);
//int checkAlphabetic(char);
int TForm1::checkAlphabetic(char cht)
{char alphabet_caps[]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
 char alphabet_smal[]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
 char alphabet_symb[]={'~','!','@','#','$','%','^','&','*','(',')','_','+','{','}','|',':','\"','<','>','\?','`','-','=','[',']','\\',';','\"','/'};
 for(int i=0;i<26;i++)if(cht==alphabet_caps[i])return 1;
 for(int i=0;i<26;i++)if(cht==alphabet_smal[i])return 1;
 for(int i=0;i<30;i++)if(cht==alphabet_symb[i])return 1;
 return 0;
}

//--------------------------------------------------------------------------- solidshellsw=0 (solid) below
void __fastcall TForm1::mergeCTSPmcmNoDelExecute(TObject *Sender){int maxCore=128,solidshellsw=0;mergeCTSPmcmProg(solidshellsw,maxCore,0);}
void __fastcall TForm1::mergeCTSPmcmDelExecute(TObject *Sender){  int maxCore=128,solidshellsw=0;mergeCTSPmcmProg(solidshellsw,maxCore,1);}
//---------------------------------------------------------------------------
void TForm1::mergeCTSPmcmProg(int solidshellsw,int maxCore,int isw)
{int ic=0,in=0; //solidshellsw=0 (solid);1 (shell)      isw=0 (merge);1 (merge & delete)
 wchar_t curMess0[]=L"temp.out & time.out merged from ",curMess1[]=L" CTSP subdirectories",string0[64];
//{wchar_t curMess0[]=L"_CTSP_input.txt\n",curMess1[]=L"_CTSP_node.txt\n",curMess2[]=L"_CTSP_element.txt",string0[90];
////		  Application->MessageBox(PtrToStringChars(gWsiAlias),L"Warning",MB_OK); // Visual C++ function
 if(base.nop1)
   {in=merge_CTSPmcm(solidshellsw,0,maxCore);if(isw)for(ic=0;ic<maxCore;ic++){if(!DelSubd0(ic,modelName_g))break;}
	if(in==0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No CTSP subdirectories/results/param found",L"Halt",MB_OK);}
	else {StringCchCopyW(string0,64,curMess0);StringCchCatW(string0,64,IntToStr(in).w_str());StringCchCatW(string0,64,curMess1);
		  extern PACKAGE void __fastcall Beep(void);
		  if(isw)Application->MessageBox(string0,L"Success & subdirectories deleted",MB_OK);
		  else   Application->MessageBox(string0,L"Success",MB_OK);
		 }
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"First, user must get model file->File/Open or VFTr",L"Halt: Solution directories unknown",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::AboutVFTExecute(TObject *Sender)
{About_VFT=new TForm31(base.comboCWD,this);About_VFT->Left=315;About_VFT->Top=20;
 About_VFT->Caption="VFT weld simulation software";
 About_VFT->Label1->Caption="VFTsolid version 3.2.56g 2014";
 About_VFT->Label2->Caption="VFT + CTSP are proprietary to Caterpillar Corporation.";
 About_VFT->Label3->Caption="Simulia/Abaqus is proprietary to Dassault Systemes.";
 About_VFT->Label4->Caption="WARP3D is public domain software from U.of Illinois (Urbana-Champaign)";
 About_VFT->Label5->Caption="VFT was developed using CodeGear C++ Builder 2009 and is available through";
 About_VFT->Label6->Caption="    Engineering Mechanics Corporation of Columbus (www.emc-sq.com).";
 About_VFT->ShowModal();
}

//---------------------------------------------------------------------------
void __fastcall TForm1::RevEveryWPExecute(TObject *Sender)
{int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;
 long ir=0,ip=0;
 if(base.nop1)
  {if(wp.nWeldPass)
	 {iPersistVFT=iPersistVFT+10*(1-j);
	  for(ir=0;ir<wp.nWeldPass;ir++){RevProg0(ir);
									 ip=wp.util_arr[ir]/10;
									 wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
									 wp.util_arr[ir]=wp.util_arr[ir]+10; //Activate all
									 ip=wp.reset[ir]-10*(wp.reset[ir]/10);
									 wp.reset[ir]=10*(wp.reset[ir]/10)+1-ip;
									}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
//	  ShowWP_hide->Checked=false;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=true;
	  Invalidate();
///////////////
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"No weld passes found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Every2ndWPExecute(TObject *Sender)//Reverse even numbers
{int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;
 long ir=0,ip=0;
 if(base.nop1)
  {if(wp.nWeldPass>1)
	 {iPersistVFT=iPersistVFT+10*(1-j);
	  for(ir=1;ir<wp.nWeldPass;ir=ir+2){RevProg0(ir);
										ip=wp.reset[ir]-10*(wp.reset[ir]/10);
										wp.reset[ir]=10*(wp.reset[ir]/10)+1-ip;
									   }
	  for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
									 wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
									 wp.util_arr[ir]=wp.util_arr[ir]+10; //Activate all
									}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
//	  ShowWP_hide->Checked=false;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=true;
	  Invalidate();
///////////////
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"None or one weld pass found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::EveryOddWPExecute(TObject *Sender)//Odd WPs
{int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;
 long ir=0,ip=0;
 if(base.nop1)
  {if(wp.nWeldPass)
	 {iPersistVFT=iPersistVFT+10*(1-j);
	  for(ir=0;ir<wp.nWeldPass;ir=ir+2){RevProg0(ir);
										ip=wp.reset[ir]-10*(wp.reset[ir]/10);
										wp.reset[ir]=10*(wp.reset[ir]/10)+1-ip;
									   }
	  for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
									 wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
									 wp.util_arr[ir]=wp.util_arr[ir]+10; //Activate all
									}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
//	  ShowWP_hide->Checked=false;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=true;
	  Invalidate();
///////////////
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"None or one weld pass found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ResetWPdirExecute(TObject *Sender)//Reset capability  EFP 3/24/2012
{int i=iPersistVFT/100,j=(iPersistVFT-100*i)/10;
 long ir=0,ip=0;
 if(base.nop1)
  {if(wp.nWeldPass)
	 {iPersistVFT=iPersistVFT+10*(1-j);
	  for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.reset[ir]-10*(wp.reset[ir]/10);
									 if(ip){RevProg0(ir);wp.reset[ir]=10*(wp.reset[ir]/10);}
									}
	  for(ir=0;ir<wp.nWeldPass;ir++){ip=wp.util_arr[ir]/10;
									 wp.util_arr[ir]=wp.util_arr[ir]-10*ip;
									 wp.util_arr[ir]=wp.util_arr[ir]+10; //Activate all
									}
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
//	  ShowWP_hide->Checked=false;ShowWP_last->Checked=false;ShowWP_select->Checked=false;ShowWPout_All->Checked=true;
	  Invalidate();
///////////////
//	  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported in this version",L"Halt",MB_OK);
	 }
   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"None or one weld pass found",L"Halt",MB_OK);}
  }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Import or generate geometry file->File/Misc.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::RevProg0(long iWP)
{int opp_arr8[6]={2,3,0,1,5,4};
 long ie=0,iside=0,ipp=0,ippp=0,ip1=0,in=0,icount=0,is=0,ip=0, *dumarr=NULL;
 float xc=0.,yc=0.,zc=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9];
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7};
//// This might be wrong???
//   if(CRB_sel) //Partial
//	 {ippp=wp.circEles[3*iWP+0];
//	  wp.circEles[3*iWP+0]=wp.circEles[3*iWP+2];
//	  wp.circEles[3*iWP+2]=ippp;
//	 }
//   else // Full
//	 {ippp=wp.circEles[3*iWP+1];
//	  wp.circEles[3*iWP+1]=wp.circEles[3*iWP+2];
//	  wp.circEles[3*iWP+2]=ippp;
//	 }
//// EFP thinks that the coding should be as follows (3/22/2012) TEST THIS!!!
//// CRB_ckShape=CreateLinWeldPass->CheckShape;
//// 0=noncircular,1=fullcircle,2=partialcircle,3=fullgirth,4=partialgirth
   if(wp.shape[iWP]==1 || wp.shape[iWP]==3) //fullcircle or fullgirth
	 {ippp=wp.circEles[3*iWP+1];
	  wp.circEles[3*iWP+1]=wp.circEles[3*iWP+2];
	  wp.circEles[3*iWP+2]=ippp;
	 }
   else
	 {ippp=wp.circEles[3*iWP+0];
	  wp.circEles[3*iWP+0]=wp.circEles[3*iWP+2];
	  wp.circEles[3*iWP+2]=ippp;
	 }
for(in=0;in<wp.memWGa;in++)if(wp.eles[wp.memWGa*iWP+in]<0)break;
icount=in;
//for(in=0;in<icount;in++)honk<<iWP<<" "<<in<<" wpELES bef "<<wp.eles[wp.memWGa*iWP+in]<<"\n";
dumarr=new long[base.nelt];

honk<<iWP+1<<" REVERSING WP\n";

for(in=0;in<icount;in++){dumarr[in]=wp.eles[wp.memWGa*iWP+in];
honk<<in+1<<" "<<dumarr[in]<<" elesBEFORE\n";
                        }
// Rewrite above to allow for mixed faces on sttEles   EFP 12/02/2011
for(ipp=0;ipp<icount/wp.n_curr_sttEl[iWP];ipp++)
  {for(in=0;in<wp.n_curr_sttEl[iWP];in++){ //Correction for missing pair of brackets (also in FormMouseDown) EFP 3/22/2012
ip1=    dumarr[wp.n_curr_sttEl[iWP]*((icount/wp.n_curr_sttEl[iWP])-ipp-1)+in]-
	10*(dumarr[wp.n_curr_sttEl[iWP]*((icount/wp.n_curr_sttEl[iWP])-ipp-1)+in]/10);

//honk<<iWP<<" "<<ipp<<" "<<in<<" "<<ip1<<" InPrrroc "<<wp.eles[wp.memWGa*iWP+wp.n_curr_sttEl[iWP]*ipp+in]
//		 <<" "<<dumarr[wp.n_curr_sttEl[iWP]*((icount/wp.n_curr_sttEl[iWP])-ipp-1)+in]<<"\n";

//wp.eles[wp.memWGa*iWP+wp.n_curr_sttEl[iWP]*ipp+in]=
//10*(dumarr[wp.n_curr_sttEl[iWP]*((icount/wp.n_curr_sttEl[iWP])-ipp-1)+in]/10)-ip1+opp_arr8[ip1];  //Correction  EFP 12/02/2011
wp.eles[wp.memWGa*iWP+wp.n_curr_sttEl[iWP]*ipp+in]=
dumarr[wp.n_curr_sttEl[iWP]*((icount/wp.n_curr_sttEl[iWP])-ipp-1)+in]-ip1+opp_arr8[ip1];  //Correction  EFP 3/22/2012
										 }
  }
 delete [] dumarr;
//// Figure out the following....
//for(in=0;in<wp.count_curr_sttEl;in++)wp.sttEles[wp.memWGa*wp.PRECORD+in]=wp.eles[wp.memWGa*wp.PRECORD+in]/10;//Emergency
// The following corrected  EFP 12/02/2011
 for(in=0;in<wp.n_curr_sttEl[iWP];in++){
//									   ip1=wp.eles[wp.memWGa*iWP+in];
//honk<<iWP<<" "<<in<<" Bef/After sttEles "<<wp.sttEles[wp.memWGa*iWP+in]<<" "<<ip1<<"\n";
										wp.sttEles[wp.memWGa*iWP+in]=wp.eles[wp.memWGa*iWP+in];
									   is=wp.sttEles[wp.memWGa*iWP+in]-10*(wp.sttEles[wp.memWGa*iWP+in]/10);

honk<<in+1<<" "<<wp.sttEles[wp.memWGa*iWP+in]<<" "<<is+1<<" NEW sttEL\n";
									   for(ip=0;ip<4;ip++){  //Added as correction  EFP 4/08/2013
wp.sttEleNodes[wp.memWGa*4*iWP+4*in+ip]=
   base.nop1[MXNPEL*(wp.sttEles[wp.memWGa*iWP+in]/10)+gdata8[4*is+ip]]; //Not necessary here since this is done in export_CTSP()  EFP 3/22/2012

honk<<ip+1<<" "<<wp.sttEleNodes[wp.memWGa*4*iWP+4*in+ip]<<" sttElNodes\n";
														  }
									   }

 ie=wp.sttEles[wp.memWGa*iWP+0]/10;iside=wp.sttEles[wp.memWGa*iWP+0]-10*ie; // Use first start element face as normal
 if(iside==0){xc=0.;yc= -1.;zc=0.;}else if(iside==2){xc=0.;yc=1.;zc=0.;}else if(iside==1){xc=1.;yc=0.;zc=0.;}else if(iside==3){xc= -1.;yc=0.;zc=0.;}else if(iside==4){xc=0.;yc=0.;zc= -1.;}else {xc=0.;yc=0.;zc=1.;}
 STFISO8(3,xc,yc,zc,&DJD,HN,SN,SG,DJR,indat.nop1+MXNPEL*ie,indat.c1);
 wp.arrows[NDF*3*iWP+NDF*0+0]= -HN[0];wp.arrows[NDF*3*iWP+NDF*0+1]= -HN[1];wp.arrows[NDF*3*iWP+NDF*0+2]= -HN[2];
 return;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::TimeshiftCTSP0Execute(TObject *Sender) //EFP 7/05/2012
{float val=0.;tshiftCTSP=new TForm8(2,val,this);tshiftCTSP->Caption="Timeshift CTSP";
 tshiftCTSP->Button2->Caption="Reset";tshiftCTSP->Button3->Caption="Inactive";tshiftCTSP->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::TimeshiftVED0Execute(TObject *Sender) //EFP 11/24/2012
{float val=0.;tshiftCTSP=new TForm8(4,val,this);tshiftCTSP->Caption="Timeshift VED";
 tshiftCTSP->Button2->Caption="Reset";tshiftCTSP->Button3->Caption="Inactive";tshiftCTSP->ShowModal();
}
//---------------------------------------------------------------------------
void __fastcall TForm1::TimeshiftCTSPandVED0Execute(TObject *Sender) //EFP 11/24/2012
{float val=0.;tshiftCTSP=new TForm8(5,val,this);tshiftCTSP->Caption="Timeshift CTSP+VED";
 tshiftCTSP->Button2->Caption="Reset";tshiftCTSP->Button3->Caption="Inactive";tshiftCTSP->ShowModal();
}

////---------------------------------------------------------------------------
void __fastcall TForm1::MergeTimeshiftCTSP0Execute(TObject *Sender){int isw=7;tshiftCTSP2(isw);} //EFP 5/09/2013
void __fastcall TForm1::MergeTimeshiftVED0Execute(TObject *Sender){int isw=8;tshiftCTSP2(isw);}
void __fastcall TForm1::MergeTimeshiftCTSPandVED0Execute(TObject *Sender){int isw=9;tshiftCTSP2(isw);}
//---------------------------------------------------------------------------
void TForm1::tshiftCTSP_public()
//TBD: Write code here to discriminate between solid/shell & set solidshellsw  EFP 7/05/2012
{int solidshellsw=0,nic=0,nrc=0,icheck=0,vcheck=0,isw=tshiftCTSP->checkISW;
 long nnd=0,id=0,in=0,max1=0,vcount=0,larr[5];
 float tshift=tshiftCTSP->Angle0,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,darr[5];
 char descript[76],descript1[8*1024];  //Allow for 1000 elements per VED line
honk<<isw<<" "<<tshift<<" tshiftCTSP_public() but solid models only\n";
/////////
 icheck=0;
 if(isw==2 || isw==5){
// Typical temp.out results format (but may start at non-zero time)
//  0.0000000E+00           0
//   2.540000              41
//     45        167.27
//     52        241.83
//     53        357.34
//     55        309.45
//      .
//      .
/////////
 OpenDialog1->Filter= "CTSP temp result (*.out)|*.out;*.OUT";
 if(OpenDialog1->Execute())
   {ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile1)
	  {vcount=0;viewfile1.getline(descript,76);
	   if(strlen(descript))
		 {vcheck=parse_cdmV(descript,2,&nic,&nrc,larr,darr);
		  if(!vcount && vcheck<0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Failure: possible time.out file?",MB_OK);}
		  else {nnd=larr[0];tstep=darr[0];vcount++;  //Code allows for non-zero nnd on first card
honk<<tstep<<" "<<nnd<<" First card of temp.out\n";
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//				 try {
			 ofstream outfile1("tempShift.out");ofstream outfile2("timeShift.out");max1=1;
			 outfile1<<setw(15)<<scientific<<tstep+tshift<<setw(12)<<nnd<<"\n";
			 outfile2<<setw(12)<<max1<<setw(15)<<scientific<<tstep+tshift<<"\n";max1++;icheck=1;
			 if(nnd){if(solidshellsw){for(in=0;in<nnd;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
															outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<setw(14)<<t12<<setw(14)<<t13<<setw(14)<<t14<<setw(14)<<t15<<setw(14)<<"\n";
														   } //setw(5->7) above & below for more space EFP 12/15/2011
									 }
					 else {for(in=0;in<nnd;in++){viewfile1>>id>>t11;
												 outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
												}
						  }
					}
			 while(!viewfile1.eof())
			   {viewfile1.getline(descript,76);
				if(strlen(descript))
				  {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
				   outfile1<<setw(15)<<scientific<<tstep+tshift<<setw(12)<<nnd<<"\n";
				   outfile2<<setw(12)<<max1<<setw(15)<<scientific<<tstep+tshift<<"\n";max1++;
				   if(nnd){if(solidshellsw){for(in=0;in<nnd;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
																  outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<setw(14)<<t12<<setw(14)<<t13<<setw(14)<<t14<<setw(14)<<t15<<setw(14)<<"\n";
																 } //setw(5->7) above & below for more space EFP 12/15/2011
										   }
						   else {for(in=0;in<nnd;in++){viewfile1>>id>>t11;
													   outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
													  }
								}
						  }
				  }
			   }
			 outfile2.close();outfile1.close();
//					 }
//				 __finally {
			 Screen->Cursor=Save_Cursor;
//			 }
///////////////////////////
			}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);}
	   viewfile1.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.out file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
///////////
					 }
 if(isw==4 || isw==5){
 // Typical ...VED.dat format
//0.000000e+00, 12
//33352, 33351, 33350, 33349, 33360, 33359, 33358, 33357, 33368, 33367, 33366, 33365,
//7.511511e-01, 12
//33348, 33347, 33346, 33345, 33356, 33355, 33354, 33353, 33364, 33363, 33362, 33361,
//1.502439e+00, 12
// .
// .
//2.627592e+04, 12
//32884, 32888, 32932, 32936, 32876, 32880, 32924, 32928, 32868, 32872, 32916, 32920,
//2.987915e+04, 8
//94425, 94433, 94441, 94449, 94427, 94435, 94443, 94451,
//2.988155e+04, 8
//94426, 94434, 94442, 94450, 94428, 94436, 94444, 94452,
 OpenDialog1->Filter= "VED (*.dat)|*.dat;*.DAT";
 if(OpenDialog1->Execute())
   {ifstream viewfile2(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile2)
	  {vcount=0;viewfile2.getline(descript,76);
	   if(strlen(descript))
		 {vcheck=parse_cdmVc(descript,2,&nic,&nrc,larr,darr);
		  if(!vcount && vcheck<0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Failure: possible MatProp.dat file?",MB_OK);}
		  else
			{nnd=larr[0];tstep=darr[0];vcount++;
honk<<tstep<<" "<<nnd<<" First card of VED.dat\n";
		  if(nnd)
			{
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//				 try {
			 ofstream outfile3("VEDshift.dat");icheck=icheck+10;
			 outfile3<<setw(12)<<scientific<<tstep+tshift<<","<<setw(4)<<nnd<<"\n";
			 viewfile2.getline(descript1,8*1024);outfile3<<descript1<<"\n";
			 while(!viewfile2.eof())
			   {viewfile2.getline(descript,76);
				if(strlen(descript))
				  {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
				   outfile3<<setw(12)<<scientific<<tstep+tshift<<","<<setw(4)<<nnd<<"\n";
				   viewfile2.getline(descript1,8*1024);outfile3<<descript1<<"\n";
				  }
			   }
			 outfile3.close();
//					 }
//				 __finally {
			 Screen->Cursor=Save_Cursor;
//			 }
///////////////////////////
			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt *VED.dat file. No elements listed.",L"Failure",MB_OK);}
			}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);}
	   viewfile2.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *VED.dat file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
					 }
///////////
 if(isw==5 && icheck==11)     {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempShift.out & timeShift.out & VEDshift.dat",L"Success",MB_OK);}
 else if(isw==5 && icheck==1) {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempShift.out & timeShift.out",L"Partial success with CTSP",MB_OK);}
 else if(isw==5 && icheck==10){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename VEDshift.dat",L"Partial success with VED",MB_OK);}
 else if(isw==2 && icheck==1) {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempShift.out & timeShift.out",L"Success",MB_OK);}
 else if(isw==4 && icheck==10){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename VEDshift.dat",L"Success",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::tshiftCTSP2(int isw)
//TBD: Write code here to discriminate between solid/shell & set solidshellsw  EFP 7/05/2012
{int solidshellsw=0,nic=0,nrc=0,icheck=0,vcheck=0;
 long nnd=0,id=0,in=0,max1=0,vcount=0,larr[5];
// float tshift=tshiftCTSP->Angle0,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,darr[5];
 float tshift=0.,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,val=0.,peakTime=0.,darr[5];
 char descript[76],descript1[8*1024];  //Allow for 1000 elements per VED line
honk<<isw<<" "<<tshift<<" MergeTshiftCTSP_public() but solid models only\n";
/////////
 icheck=0;
 if(isw==7 || isw==9){
// Typical temp.out results format (but may start at non-zero time)
//  0.0000000E+00           0
//   2.540000              41
//     45        167.27
//     52        241.83
//     53        357.34
//     55        309.45
//      .
//      .
/////////
 OpenDialog1->Filter= "CTSP temp result (*.out)|*.out;*.OUT";
 if(OpenDialog1->Execute())
   {ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile1)
	  {vcount=0;viewfile1.getline(descript,76);
	   if(strlen(descript))
		 {vcheck=parse_cdmV(descript,2,&nic,&nrc,larr,darr);
		  if(!vcount && vcheck<0){extern PACKAGE void __fastcall Beep(void);
								  Application->MessageBox(L"Floating point not found in first number",L"Failure: possible time.out file?",MB_OK);
								  viewfile1.close();return;
								 }
		  else {nnd=larr[0];tstep=darr[0];vcount++;  //Code allows for non-zero nnd on first card
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//				 try {
			 peakTime=tstep+tshift;
			 ofstream outfile1("tempMerge.out");ofstream outfile2("timeMerge.out");max1=1;
honk<<tstep<<" "<<nnd<<" First card of Merge 1st temp.out "<<max1<<"\n";
			 outfile1<<setw(15)<<scientific<<tstep+tshift<<setw(12)<<nnd<<"\n";
			 outfile2<<setw(12)<<max1<<setw(15)<<scientific<<tstep+tshift<<"\n";max1++;icheck=1;
			 if(nnd){if(solidshellsw){for(in=0;in<nnd;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
															outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<setw(14)<<t12<<setw(14)<<t13<<setw(14)<<t14<<setw(14)<<t15<<setw(14)<<"\n";
														   } //setw(5->7) above & below for more space EFP 12/15/2011
									 }
					 else {for(in=0;in<nnd;in++){viewfile1>>id>>t11;
												 outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
												}
						  }
					}
			 while(!viewfile1.eof())
			   {viewfile1.getline(descript,76);
				if(strlen(descript))
				  {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
honk<<tstep<<" "<<nnd<<" Subseq card of Merge 1st temp.out "<<max1<<"\n";
				   peakTime=tstep+tshift;
				   outfile1<<setw(15)<<scientific<<tstep+tshift<<setw(12)<<nnd<<"\n";
				   outfile2<<setw(12)<<max1<<setw(15)<<scientific<<tstep+tshift<<"\n";max1++;
				   if(nnd){if(solidshellsw){for(in=0;in<nnd;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
																  outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<setw(14)<<t12<<setw(14)<<t13<<setw(14)<<t14<<setw(14)<<t15<<setw(14)<<"\n";
																 } //setw(5->7) above & below for more space EFP 12/15/2011
										   }
						   else {for(in=0;in<nnd;in++){viewfile1>>id>>t11;
													   outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
													  }
								}
						  }
				  }
			   }
			 outfile2.close();outfile1.close();
//					 }
//				 __finally {
			 Screen->Cursor=Save_Cursor;
//			 }
///////////////////////////
			}
		  viewfile1.close();
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);
			 viewfile1.close();return;
			}
//	   viewfile1.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);
		  Application->MessageBox(L"Could not open *.out file",L"Failure",MB_OK);return;}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
///////////
					 }
 if(isw==8 || isw==9){
 // Typical ...VED.dat format
//0.000000e+00, 12
//33352, 33351, 33350, 33349, 33360, 33359, 33358, 33357, 33368, 33367, 33366, 33365,
//7.511511e-01, 12
//33348, 33347, 33346, 33345, 33356, 33355, 33354, 33353, 33364, 33363, 33362, 33361,
//1.502439e+00, 12
// .
// .
//2.627592e+04, 12
//32884, 32888, 32932, 32936, 32876, 32880, 32924, 32928, 32868, 32872, 32916, 32920,
//2.987915e+04, 8
//94425, 94433, 94441, 94449, 94427, 94435, 94443, 94451,
//2.988155e+04, 8
//94426, 94434, 94442, 94450, 94428, 94436, 94444, 94452,
 OpenDialog1->Filter= "VED (*.dat)|*.dat;*.DAT";
 if(OpenDialog1->Execute())
   {ifstream viewfile2(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile2)
	  {vcount=0;viewfile2.getline(descript,76);
	   if(strlen(descript))
		 {vcheck=parse_cdmVc(descript,2,&nic,&nrc,larr,darr);
		  if(!vcount && vcheck<0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Failure: possible MatProp.dat file?",MB_OK);
								  viewfile2.close();return;
								 }
		  else
			{nnd=larr[0];tstep=darr[0];vcount++;max1=1;
honk<<tstep<<" "<<nnd<<" First card of 1st VED.dat "<<max1<<"\n";
		  if(nnd)
			{
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//				 try {
			 ofstream outfile3("VEDmerge.dat");icheck=icheck+10;
			 outfile3<<setw(12)<<scientific<<tstep+tshift<<","<<setw(4)<<nnd<<"\n";
			 viewfile2.getline(descript1,8*1024);outfile3<<descript1<<"\n";
			 while(!viewfile2.eof())
			   {viewfile2.getline(descript,76);
				if(strlen(descript))
				  {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];max1++;
honk<<tstep<<" "<<nnd<<" Subseq card of 1st VED.dat "<<max1<<"\n";
				   outfile3<<setw(12)<<scientific<<tstep+tshift<<","<<setw(4)<<nnd<<"\n";
				   viewfile2.getline(descript1,8*1024);outfile3<<descript1<<"\n";
				  }
			   }
			 outfile3.close();
//					 }
//				 __finally {
			 Screen->Cursor=Save_Cursor;
//			 }
///////////////////////////
			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt *VED.dat file. No elements listed.",L"Failure",MB_OK);
				viewfile2.close();return;
			   }
			}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);
			 viewfile2.close();return;
			}
//	   viewfile2.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);
		  Application->MessageBox(L"Could not open *VED.dat file",L"Failure",MB_OK);return;
		 }
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
					 }
 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(FloatToStr(peakTime).w_str(),L"Highest time to date",MB_OK);
 tshiftCTSP=new TForm8(isw,val,this);
 if(isw==7)tshiftCTSP->Caption="Merge+Timeshift CTSP";
 else if(isw==8)tshiftCTSP->Caption="Merge+Timeshift VED";
 else if(isw==9)tshiftCTSP->Caption="Merge+Timeshift CTSP+VED";
 tshiftCTSP->Button2->Caption="Reset";tshiftCTSP->Button3->Caption="Inactive";tshiftCTSP->ShowModal();
///////////
// if(isw==9 && icheck==11)     {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempShift.out & timeShift.out & VEDshift.dat",L"Success",MB_OK);}
// else if(isw==9 && icheck==1) {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempShift.out & timeShift.out",L"Partial success with CTSP",MB_OK);}
// else if(isw==9 && icheck==10){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename VEDshift.dat",L"Partial success with VED",MB_OK);}
// else if(isw==7 && icheck==1) {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempShift.out & timeShift.out",L"Success",MB_OK);}
// else if(isw==8 && icheck==10){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename VEDshift.dat",L"Success",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::tshiftCTSP3_public()
//TBD: Write code here to discriminate between solid/shell & set solidshellsw  EFP 7/05/2012
{int solidshellsw=0,nic=0,nrc=0,icheck=0,vcheck=0,isw=tshiftCTSP->checkISW;
 long nnd=0,id=0,in=0,max1=0,m2ax1=0,vcount=0,larr[5];
 float tshift=tshiftCTSP->Angle0,lastTime=0.,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,darr[5];
 char descript[76],descript1[8*1024];  //Allow for 1000 elements per VED line
honk<<isw<<" "<<tshift<<" Merge2tshiftCTSP_public() but solid models only\n";

//if(1==1)exit(0);
/////////
 icheck=0;
 if(isw==7 || isw==9){
// Typical temp.out results format (but may start at non-zero time)
//  0.0000000E+00           0
//   2.540000              41
//     45        167.27
//     52        241.83
//     53        357.34
//     55        309.45
//      .
//      .
/////////
 OpenDialog1->Filter= "CTSP temp result (*.out)|*.out;*.OUT";
 if(OpenDialog1->Execute())
   {ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile1)
	  {vcount=0;viewfile1.getline(descript,76);
	   if(strlen(descript))
		 {vcheck=parse_cdmV(descript,2,&nic,&nrc,larr,darr);
		  if(!vcount && vcheck<0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Failure: possible time.out file?",MB_OK);}
		  else {nnd=larr[0];tstep=darr[0];vcount++;  //Code allows for non-zero nnd on first card
//honk<<tstep<<" "<<nnd<<" First card of 2nd temp.out\n";
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//				 try {
			 ifstream viewfile3("timeMerge.out",ios::nocreate);max1=0;
			 while(!viewfile3.eof()){viewfile3.getline(descript,76);
									 if(strlen(descript)){vcheck=parse_cdmV(descript,2,&nic,&nrc,larr,darr);
if(vcheck>=0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Integer not found in first number of time.out",L"Terminate: possible temp.out file?",MB_OK);exit(0);}
														  max1++;lastTime=darr[0];
														 }
									}
			 viewfile3.close();
honk<<max1<<" #times in imported timeMerge to date & tstep "<<lastTime<<" "<<tstep<<"\n";

//			 if(tstep+tshift>lastTime){
			 tshift=lastTime-tstep;
			 extern PACKAGE void __fastcall Beep(void);Application->MessageBox(FloatToStr(tshift).w_str(),L"Override user input",MB_OK);
			 ofstream outfile1("tempMerge.out",ios::nocreate | ios::app);ofstream outfile2("timeMerge.out",ios::nocreate | ios::app);
m2ax1=1;honk<<tstep<<" "<<nnd<<" First card of 2nd temp.out (not written) "<<m2ax1<<"\n";m2ax1++;
//			 max1=1;
//			 outfile1<<setw(15)<<scientific<<tstep+tshift<<setw(12)<<nnd<<"\n";
//			 outfile2<<setw(12)<<max1<<setw(15)<<scientific<<tstep+tshift<<"\n";
//			 max1++;
			 icheck=1;
			 if(nnd){if(solidshellsw){for(in=0;in<nnd;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
//															outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<setw(14)<<t12<<setw(14)<<t13<<setw(14)<<t14<<setw(14)<<t15<<setw(14)<<"\n";
														   } //setw(5->7) above & below for more space EFP 12/15/2011
									 }
					 else {for(in=0;in<nnd;in++){viewfile1>>id>>t11;
//												 outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
												}
						  }
					}
			 while(!viewfile1.eof())
			   {viewfile1.getline(descript,76);
				if(strlen(descript))
				  {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
honk<<tstep<<" "<<nnd<<" Subseq card of 2nd temp.out "<<m2ax1<<"\n";m2ax1++;
				   outfile1<<setw(15)<<scientific<<tstep+tshift<<setw(12)<<nnd<<"\n";
				   max1++;outfile2<<setw(12)<<max1<<setw(15)<<scientific<<tstep+tshift<<"\n";
				   if(nnd){if(solidshellsw){for(in=0;in<nnd;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
																  outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<setw(14)<<t12<<setw(14)<<t13<<setw(14)<<t14<<setw(14)<<t15<<setw(14)<<"\n";
																 } //setw(5->7) above & below for more space EFP 12/15/2011
										   }
						   else {for(in=0;in<nnd;in++){viewfile1>>id>>t11;
													   outfile1<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
													  }
								}
						  }
				  }
			   }
			 outfile2.close();outfile1.close();
//									  }
//			 else {DeleteFile("tempMerge.out");DeleteFile("timeMerge.out");if(isw==9)DeleteFile("VEDmerge.dat");
//				   extern PACKAGE void __fastcall Beep(void);
//				   Application->MessageBox(FloatToStr(lastTime-tstep).w_str(),L"Failure (overlap) so increase Timeshift to at least",MB_OK);
//				   return;
//				  }

//					 }
//				 __finally {
			 Screen->Cursor=Save_Cursor;
//			 }
///////////////////////////
			}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);}
	   viewfile1.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.out file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
///////////
					 }
 if(isw==8 || isw==9){
 // Typical ...VED.dat format
//0.000000e+00, 12
//33352, 33351, 33350, 33349, 33360, 33359, 33358, 33357, 33368, 33367, 33366, 33365,
//7.511511e-01, 12
//33348, 33347, 33346, 33345, 33356, 33355, 33354, 33353, 33364, 33363, 33362, 33361,
//1.502439e+00, 12
// .
// .
//2.627592e+04, 12
//32884, 32888, 32932, 32936, 32876, 32880, 32924, 32928, 32868, 32872, 32916, 32920,
//2.987915e+04, 8
//94425, 94433, 94441, 94449, 94427, 94435, 94443, 94451,
//2.988155e+04, 8
//94426, 94434, 94442, 94450, 94428, 94436, 94444, 94452,
 OpenDialog1->Filter= "VED (*.dat)|*.dat;*.DAT";
 if(OpenDialog1->Execute())
   {ifstream viewfile2(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile2)
	  {vcount=0;viewfile2.getline(descript,76);
	   if(strlen(descript))
		 {vcheck=parse_cdmVc(descript,2,&nic,&nrc,larr,darr);
		  if(!vcount && vcheck<0){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Failure: possible MatProp.dat file?",MB_OK);}
		  else
			{nnd=larr[0];tstep=darr[0];vcount++;
m2ax1=1;honk<<tstep<<" "<<nnd<<" First card of 2nd VED.dat "<<m2ax1<<"\n";m2ax1++;
//TBD: Test for nonoverlapping VED only ==> DeleteFile(VEDmerge.dat)
		  if(nnd)
			{
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
////				 try {
			 ofstream outfile3("VEDmerge.dat",ios::nocreate | ios::app);icheck=icheck+10;
			 outfile3<<setw(12)<<scientific<<tstep+tshift<<","<<setw(4)<<nnd<<"\n";
			 viewfile2.getline(descript1,8*1024);
			 outfile3<<descript1<<"\n";
			 while(!viewfile2.eof())
			   {viewfile2.getline(descript,76);
				if(strlen(descript))
				  {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
honk<<tstep<<" "<<nnd<<" Subseq card of 2nd VED.dat "<<m2ax1<<"\n";m2ax1++;
				   outfile3<<setw(12)<<scientific<<tstep+tshift<<","<<setw(4)<<nnd<<"\n";
				   viewfile2.getline(descript1,8*1024);outfile3<<descript1<<"\n";
				  }
			   }
			 outfile3.close();
//					 }
//				 __finally {
			 Screen->Cursor=Save_Cursor;
//			 }
///////////////////////////
			}
		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Corrupt *VED.dat file. No elements listed.",L"Failure",MB_OK);}
			}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);}
	   viewfile2.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *VED.dat file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
					 }
///////////
 if(isw==9 && icheck==11)     {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempMerge.out & timeMerge.out & VEDMerge.dat",L"Success",MB_OK);}
 else if(isw==9 && icheck==1) {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempMerge.out & timeMerge.out",L"Partial success with CTSP",MB_OK);}
 else if(isw==9 && icheck==10){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename VEDMerge.dat",L"Partial success with VED",MB_OK);}
 else if(isw==7 && icheck==1) {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename tempMerge.out & timeMerge.out",L"Success",MB_OK);}
 else if(isw==8 && icheck==10){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User should rename VEDMerge.dat",L"Success",MB_OK);}
}
//---Reset------------------------------------------------------------------
void TForm1::tshiftCTSP1_public(){float val=0.;tshiftCTSP->setAngle0(val);}
//---------------------------------------------------------------------------
void __fastcall TForm1::TempDeltCTSP0Execute(TObject *Sender) //EFP 7/07/2012
//{long val=25.; //Correction: Change "Room temperature" to "Pre-heat T"
{float val=9500.; //Modification: Change "Room temperature" to "Excessive T cutoff" EFP 12/18/2012
 tdeltCTSP=new TForm8(3,val,this);tdeltCTSP->Caption="Excessive T cutoff";
 tdeltCTSP->Button2->Caption="Reset";tdeltCTSP->Button3->Caption="Inactive";
 tdeltCTSP->ShowModal();
}
//---------------------------------------------------------------------------
void TForm1::tdeltCTSP_public() //Single core only
//TBD: Write code here to discriminate between solid/shell & set solidshellsw  EFP 7/05/2012
//TBD: Write a multicore version of this (i.e. user clicks on temp.out in CTSPsubd001 and all others are processed automatically)
{
/*
 int solidshellsw=0,nic=0,nrc=0;long nnd=0,id=0,in=0,ir=0,mdum=0,hinode=0,nsum=0,larr[5];
 float tdelt=tdeltCTSP->Angle0,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,tcutl=0.,tdum=0.,zero=0.,darr[5], *current=NULL, *precede=NULL;
// char descript[76];
 char extensChar1a[]="temp000",extensChar1b[]="temp00",extensChar1c[]="temp0",extensChar1d[]="temp",
	  outChar1[]=".out",descript[76], *otNeed=NULL; //Present limit temp9999.out  EFP 7/19/2012
 char temperature[]="temperature";
//Possibility: Use param.in tcuth instead of user-specified tdelt
honk<<tdelt<<" room temperature tdeltCTSP_public() but solid models only\n";
 OpenDialog1->Filter= "CTSP temp result (*.out)|*.out;*.OUT";
 if(OpenDialog1->Execute())
   {ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile1)
	  {viewfile1.getline(descript,76);
	   if(strlen(descript))
		 {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
//		  if(!nnd)
//			{
			 ifstream viewfile2("param.in",ios::nocreate);
			 if(viewfile2)
			   {
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
				 try {
				viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;
				viewfile2>>hinode;viewfile2>>tdum;viewfile2>>mdum;viewfile2>>tcutl;viewfile2.close();
////////
				if(nnd){
//						if(solidshellsw)for(in=0;in<nnd;in++)viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
//						else
						for(in=0;in<nnd;in++)viewfile1>>id>>t11;
					   }
////////
				nsum=1;
				while(!viewfile1.eof())
				  {viewfile1.getline(descript,76);
				   if(strlen(descript))
					 {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];nsum++;
					  if(nnd){
//							  if(solidshellsw)for(in=0;in<nnd;in++)viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
//							  else
							  for(in=0;in<nnd;in++)viewfile1>>id>>t11;
							 }
					 }
				  }
				viewfile1.close();
honk<<nsum<<" "<<hinode<<" paramREAD "<<tdelt<<" "<<tcuth<<"\n";
				ifstream viewfile3(OpenDialog1->FileName.t_str(),ios::nocreate);
				viewfile3.getline(descript,76);parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
honk<<nnd<<" "<<tstep<<" View3\n";
				current=new float[hinode];precede=new float[hinode];
				ofstream outfile1("tempDelt.out");
//				if(solidshellsw){} //But this is not known (put flag in param.in???)
//				else {
				for(in=0;in<hinode;in++)precede[in]=tdelt;
				if(nnd)for(in=0;in<nnd;in++){viewfile3>>id>>t11;precede[id-1]=t11;}
//                   }
				ir=1;
				while(!viewfile3.eof())
				  {viewfile3.getline(descript,76);
				   if(strlen(descript))
					 {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
honk<<ir<<" "<<nsum-1<<" "<<nnd<<" "<<tstep<<" View3\n";
//					  if(solidshellsw){} //But this is not known (put flag in param.in???)
//					  else
					  for(in=0;in<hinode;in++)current[in]=tdelt;
					  if(nnd){
//					          if(solidshellsw)for(in=0;in<nnd;in++){viewfile3>>id>>t11>>t12>>t13>>t14>>t15;
//																	} //setw(5->7) above & below for more space EFP 12/15/2011
//							  else
							  for(in=0;in<nnd;in++){viewfile3>>id>>t11;current[id-1]=t11;}
							 }  //// Policy below: write all nodes at all time points, regardless if they are trivial
//////////// EFP 7/19/2012
////////////
////////////
////////////
////////////
////////////
////////////
if(ir<10){otNeed=new char[strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
		  StringCchCopy(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1a);
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
		 }
else if(ir<100){otNeed=new char[strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
				StringCchCopy(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1b);
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
			   }
else if(ir<1000){otNeed=new char[strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
				 StringCchCopy(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1c);
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
				}
else {otNeed=new char[strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
	  StringCchCopy(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1d);
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
	 }
ofstream outfile2(otNeed);delete [] otNeed;
////////////
////////////
////////////
////////////
////////////
////////////
					  if(ir==nsum-1) //Last step
						{
//					  if(solidshellsw){} //But this is not known (put flag in param.in???)
//					  else {
							outfile1<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
//							outfile2<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
							for(in=0;in<hinode;in++){if(current[in]>tdelt)current[in]=tdelt; //Coding to cool every node to room temp at last step per Abaqus UMAT  EFP 7/08/2012
													 outfile1<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
////													 outfile2<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
//													 outfile2<<setw(7)<<in+1<<setw(13)<<" temperature "<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
													 outfile2<<setw(7)<<in+1<<setw(12)<<temperature<<setw(13)<<scientific<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
													}
//						   }
						}
					  else {
//					  if(solidshellsw){} //But this is not known (put flag in param.in???)
//					  else {
							outfile1<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
//							outfile2<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
							for(in=0;in<hinode;in++)outfile1<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
////							for(in=0;in<hinode;in++)outfile2<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
//							for(in=0;in<hinode;in++)outfile2<<setw(7)<<in+1<<setw(13)<<" temperature "<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
							for(in=0;in<hinode;in++)outfile2<<setw(7)<<in+1<<setw(12)<<temperature<<setw(13)<<scientific<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
							for(in=0;in<hinode;in++)precede[in]=current[in];
//						   }
						   }
//////////// EFP 7/19/2012
					  outfile2.close();
////////////
					  ir++;
//					 }
					 }
				  }
				viewfile3.close();outfile1.close();delete [] precede;delete [] current;
/////////////  EFP 7/19/2012
/////////////
/////////////
/////////////
/////////////
if(nsum<10000)for(ir=nsum;ir<10000;ir++)
				{
if(ir<10){otNeed=new char[strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
		  StringCchCopy(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1a);
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
		 }
else if(ir<100){otNeed=new char[strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
				StringCchCopy(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1b);
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
			   }
else if(ir<1000){otNeed=new char[strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
				 StringCchCopy(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1c);
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
				}
else {otNeed=new char[strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
	  StringCchCopy(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1d);
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
	 }
				 ifstream outfile3(otNeed,ios::nocreate);
				 if(outfile3){outfile3.close();
							  DeleteFile(otNeed);
							  delete [] otNeed;
							 }
				 else {delete [] otNeed;break;}
				}
/////////////
/////////////
/////////////
/////////////
/////////////
					 }
				 __finally {Screen->Cursor=Save_Cursor;}
///////////////////////////
			   }
			 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open param.in file",L"Failure",MB_OK);}
//			}
//		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Select temp.out, not time.out",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);}
	   viewfile1.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.out file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
*/

// The above code is the version with no first step but second step (+)=DelT on all nodes
// The below code is the version with first step=init temperature but second step (+)=DelT on input nodes only

 int solidshellsw=0,nic=0,nrc=0,vcheck=0;long nnd=0,id=0,in=0,ir=0,mdum=0,hinode=0,nsum=0,isum=0,vcount=0,larr[5];
// float tdelt=tdeltCTSP->Angle0,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,tcutl=0.,tdum=0.,zero=0.,darr[5], *current=NULL, *precede=NULL;
 float tdelt=25.,excessT=tdeltCTSP->Angle0,tstep=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,tcutl=0.,tdum=0.,zero=0.,darr[5], *current=NULL, *precede=NULL;
// char descript[76];
 char buf[3+1];
 char extensChar1a[]="temp000",extensChar1b[]="temp00",extensChar1c[]="temp0",extensChar1d[]="temp",
	  outChar1[]=".out",descript[76], *otNeed=NULL; //Present limit temp9999.out  EFP 7/19/2012
 char temperature[]="temperature";
//Possibility: Use param.in tcuth instead of user-specified tdelt
honk<<tdelt<<" room temperature tdeltCTSP_public() but solid models only\n";
///// EFP 12/15/2012
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User to choose temp.out, not time.out",L"Notice",MB_OK);
/////
 OpenDialog1->Filter= "CTSP temp result (*.out)|*.out;*.OUT";
 if(OpenDialog1->Execute())
   {ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate);
	if(viewfile1)
	  {vcount=0;
//////////////////////////////////////////////////////////////////////////
//viewfile1.getline(descript,76);
//if(strlen(descript)){parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
//honk<<setw(15)<<scientific<<tstep<<setw(12)<<nnd<<"\n";
//for(in=0;in<nnd;in++){viewfile1>>id>>t11;
//					  if(t11>excessT)t11=excessT;honk<<setw(7)<<id<<setw(14)<<scientific<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
//					 }
//				while(!viewfile1.eof()){
//viewfile1.getline(descript,76);
//if(strlen(descript)){parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
//honk<<setw(15)<<scientific<<tstep<<setw(12)<<nnd<<"\n";
//for(in=0;in<nnd;in++){viewfile1>>id>>t11;
//					  if(t11>excessT)t11=excessT;honk<<setw(7)<<id<<setw(14)<<scientific<<dec<<showpoint<<setprecision(5)<<t11<<"\n";
//					 }
//					 }
//									   }
//					 }
//if(1==1)exit(0);//bang
//////////////////////////////////////////////////////////////////////////
	   viewfile1.getline(descript,76);

//honk<<descript;//bang

	   if(strlen(descript))
		 {
//		  parse_cdm(descript,2,&nic,&nrc,larr,darr);
		  vcheck=parse_cdmV(descript,2,&nic,&nrc,larr,darr);
		  if(!vcount && vcheck<0){
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Terminate: possible time.out file?",MB_OK);exit(0);
								 }
		  nnd=larr[0];tstep=darr[0];vcount++;
//		  if(!nnd)
//			{
			 ifstream viewfile2("param.in",ios::nocreate);
			 if(viewfile2)
			   {
///////////////////////////
				 TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//				 try {
				viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;viewfile2>>mdum;
				viewfile2>>hinode;viewfile2>>tdum;viewfile2>>mdum;viewfile2>>tcutl;viewfile2.close();
////////
				ofstream outfile3("temp0000.out");
				outfile3<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
//				for(in=0;in<hinode;in++)outfile3<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<tdelt<<"\n";
				for(in=0;in<hinode;in++)outfile3<<setw(7)<<in+1<<setw(12)<<temperature<<setw(13)<<scientific<<dec<<showpoint<<setprecision(5)<<tdelt<<"\n";
				if(nnd){
//						if(solidshellsw)for(in=0;in<nnd;in++)viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
//						else
						for(in=0;in<nnd;in++){viewfile1>>id>>t11;
//											  outfile3<<setw(7)<<id<<setw(14)<<dec<<showpoint<<setprecision(5)<<t11<<"\n";

//if(t11>643.)t11=643.;honk<<id<<" "<<t11<<"\n"; //bang

											 }
					   }
				outfile3.close();
////////
				nsum=1;
				while(!viewfile1.eof())
				  {viewfile1.getline(descript,76);

//honk<<descript;//bang
				   if(strlen(descript))
					 {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];nsum++;
					  if(nnd){
//							  if(solidshellsw)for(in=0;in<nnd;in++)viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
//							  else
							  for(in=0;in<nnd;in++)viewfile1>>id>>t11;
//if(t11>643.)t11=643.;honk<<id<<" "<<t11<<"\n"; //bang

							 }
					 }
				  }
				viewfile1.close();

//if(1==1)exit(0);//bang

honk<<nsum<<" "<<hinode<<" paramREAD "<<tdelt<<" "<<tcutl<<"\n";
				ifstream viewfile3(OpenDialog1->FileName.t_str(),ios::nocreate);
				viewfile3.getline(descript,76);parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
honk<<nnd<<" "<<tstep<<" View3\n";
				current=new float[hinode];precede=new float[hinode];
				ofstream outfile1("tempDelt.out");
//				if(solidshellsw){} //But this is not known (put flag in param.in???)
//				else {
				for(in=0;in<hinode;in++)precede[in]=tdelt;
				if(nnd)for(in=0;in<nnd;in++){viewfile3>>id>>t11;
if(t11>excessT)t11=excessT;
//honk<<id<<" "<<t11<<"\n";//BANG

											 precede[id-1]=t11;
											}  //old DeltT
//                   }
				ir=1;
				while(!viewfile3.eof())
				  {viewfile3.getline(descript,76);
				   if(strlen(descript))
					 {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
honk<<ir<<" "<<nsum-1<<" "<<nnd<<" "<<tstep<<" View3\n";
////					  if(solidshellsw){} //But this is not known (put flag in param.in???)
////					  else
					  for(in=0;in<hinode;in++)current[in]=tdelt;
//					  for(in=0;in<nnd;in++)current[in]=tdelt;
					  if(nnd){
////					          if(solidshellsw)for(in=0;in<nnd;in++){viewfile3>>id>>t11>>t12>>t13>>t14>>t15;
////																	} //setw(5->7) above & below for more space EFP 12/15/2011
////							  else
							  for(in=0;in<nnd;in++){viewfile3>>id>>t11;
if(t11>excessT)t11=excessT;
													current[id-1]=t11;
												   }
//							  for(in=0;in<nnd;in++){viewfile3>>id>>t11;current[in]=t11;}
							 }  //// Policy below: write all nodes at all time points, regardless if they are trivial
//////////// EFP 7/19/2012
////////////
////////////
////////////
////////////
////////////
////////////
if(ir<10){gcvt(double(ir),1,buf);
//		  otNeed=new char[strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//		  StringCchCopy(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1a);
//		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
		  otNeed=new char[strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1];
		  StringCchCopy(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,extensChar1a);
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,buf);
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,outChar1);
		 }
else if(ir<100){gcvt(double(ir),2,buf);
//				otNeed=new char[strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//				StringCchCopy(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1b);
//				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
				otNeed=new char[strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1];
				StringCchCopy(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,extensChar1b);
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,buf);
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,outChar1);
			   }
else if(ir<1000){gcvt(double(ir),3,buf);
//				 otNeed=new char[strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//				 StringCchCopy(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1c);
//				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
				 otNeed=new char[strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1];
				 StringCchCopy(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,extensChar1c);
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,buf);
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,outChar1);
				}
else {gcvt(double(ir),4,buf);
//	  otNeed=new char[strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//	  StringCchCopy(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1d);
//	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
	  otNeed=new char[strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1];
	  StringCchCopy(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,extensChar1d);
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,buf);
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,outChar1);
	 }
ofstream outfile2(otNeed);delete [] otNeed;
////////////
////////////
////////////
////////////
////////////
////////////
					  if(ir==nsum-1) //Last step
						{
////					  if(solidshellsw){} //But this is not known (put flag in param.in???)
////					  else {
							isum=0;for(in=0;in<hinode;in++){if(current[in]>tdelt)current[in]=tdelt; //Coding to cool every node to room temp at last step per Abaqus UMAT  EFP 7/08/2012
															if(fabs(current[in]-precede[in])>0.001)isum++;
														   }
//							outfile1<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
							outfile1<<setw(15)<<scientific<<tstep<<setw(12)<<isum<<"\n";
////							outfile2<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
							for(in=0;in<hinode;in++){
//							                         if(current[in]>tdelt)current[in]=tdelt; //Coding to cool every node to room temp at last step per Abaqus UMAT  EFP 7/08/2012
//													 outfile1<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
													 if(fabs(current[in]-precede[in])>0.001)outfile1<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
//////													 outfile2<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
////													 outfile2<<setw(7)<<in+1<<setw(13)<<" temperature "<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
//													 outfile2<<setw(7)<<in+1<<setw(12)<<temperature<<setw(13)<<scientific<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
													 if(fabs(current[in]-precede[in])>0.001)outfile2<<setw(7)<<in+1<<setw(12)<<temperature<<setw(13)<<scientific<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
													}
//						   }
						}
					  else {
//					  if(solidshellsw){} //But this is not known (put flag in param.in???)
//					  else {
							isum=0;for(in=0;in<hinode;in++)if(fabs(current[in]-precede[in])>0.001)isum++;
//							outfile1<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
							outfile1<<setw(15)<<scientific<<tstep<<setw(12)<<isum<<"\n";
////							outfile2<<setw(15)<<scientific<<tstep<<setw(12)<<hinode<<"\n";
//							for(in=0;in<hinode;in++)outfile1<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
							for(in=0;in<hinode;in++)if(fabs(current[in]-precede[in])>0.001)outfile1<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
////							for(in=0;in<hinode;in++)outfile2<<setw(7)<<in+1<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
//							for(in=0;in<hinode;in++)outfile2<<setw(7)<<in+1<<setw(13)<<" temperature "<<setw(14)<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
							for(in=0;in<hinode;in++)if(fabs(current[in]-precede[in])>0.001)outfile2<<setw(7)<<in+1<<setw(12)<<temperature<<setw(13)<<scientific<<dec<<showpoint<<setprecision(5)<<current[in]-precede[in]<<"\n";
							for(in=0;in<hinode;in++)precede[in]=current[in];
//						   }
						   }
//////////// EFP 7/19/2012
					  outfile2.close();
////////////
					  ir++;
//					 }
					 }
				  }
				viewfile3.close();outfile1.close();delete [] precede;delete [] current;
/////////////  EFP 7/19/2012
/////////////
/////////////
/////////////
/////////////
if(nsum<10000)for(ir=nsum;ir<10000;ir++)
				{
if(ir<10){gcvt(double(ir),1,buf);
		  otNeed=new char[strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1];
		  StringCchCopy(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,extensChar1a);
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,buf);
		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,outChar1);
		 }
else if(ir<100){gcvt(double(ir),2,buf);
				otNeed=new char[strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1];
				StringCchCopy(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,extensChar1b);
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,buf);
				StringCchCat(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,outChar1);
			   }
else if(ir<1000){gcvt(double(ir),3,buf);
				 otNeed=new char[strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1];
				 StringCchCopy(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,extensChar1c);
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,buf);
				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,outChar1);
				}
else {gcvt(double(ir),4,buf);
	  otNeed=new char[strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1];
	  StringCchCopy(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,extensChar1d);
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,buf);
	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,outChar1);
	 }
				 ifstream outfile3(otNeed,ios::nocreate);
				 if(outfile3){outfile3.close();
							  DeleteFile(otNeed);
							  delete [] otNeed;
							 }
				 else {delete [] otNeed;break;}
				}
/////////////
/////////////
/////////////
/////////////
/////////////
//					 }
//				 __finally {
				Screen->Cursor=Save_Cursor;
//				}
///////////////////////////
			   }
			 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open param.in file",L"Failure",MB_OK);}
//			}
//		  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Select temp.out, not time.out",L"Failure",MB_OK);}
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Empty file",L"Failure",MB_OK);}
	   viewfile1.close();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open *.out file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}

}
//---Reset------------------------------------------------------------------
void TForm1::tdeltCTSP1_public(){float val=0.;tdeltCTSP->setAngle0(val);}
//---------------------------------------------------------------------------
//void __fastcall TForm1::CTSPinterpolateExecute(TObject *Sender)
void TForm1::CTSPinterpolate_prog(int solidshellsw)
{
/*
 int nic=0,nrc=0,solidshellsw=0; //Solid only
 long ntime1=0,nndmax1=0,ntime2=0,nndmax2=0,ir=0,in=0,ic=0,id=0,nnd=0,nnd1=0,nnd2=0,
	  index1old=0,index2old=0,index1=0,index2=0,
	  hinodemin=0,hinodemax=0,isum=0,
	  larr[5],nndval1[2],nndval2[2], *nstor1=NULL, *nstor2=NULL;
 float tstep=0.,tstep1=0.,tstep2=0.,t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,rkm=0.,tstorprox1=0.,tstorprox2=0.,
	   darr[5],tval1[2],tval2[2],
	   *tstor1=NULL, *tstor2=NULL, *rstor1=NULL, *rstor2=NULL, *combo=NULL;
 char descript[76];
 OpenDialog1->Filter= "Out (*.out)|*.out;*.OUT";
 if(OpenDialog1->Execute())
   {ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate,0);
	if(viewfile1)
	  {ntime1=0;nndmax1=0;hinodemin=LONG_INT;hinodemax=0;
	   tstor1=new float[1024*1024]; //speculative million
	   while(!viewfile1.eof())
		 {viewfile1.getline(descript,76);
		  if(strlen(descript))
			{parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
			 tstor1[ntime1]=tstep;ntime1++;if(nndmax1<nnd)nndmax1=nnd;  //TBD: Check for errant time.out
			 if(nnd){   if(solidshellsw)for(in=0;in<nnd;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
															  if(hinodemin>id)hinodemin=id;
															  if(hinodemax<id)hinodemax=id;
															 } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<nnd;in++){viewfile1>>id>>t11;
												   if(hinodemin>id)hinodemin=id;
												   if(hinodemax<id)hinodemax=id;
												  }
					}
			}
		 }
	   viewfile1.close();
	   OpenDialog2->Filter= "Out (*.out)|*.out;*.OUT";
	   if(OpenDialog2->Execute())
		{ifstream viewfile2(OpenDialog2->FileName.t_str(),ios::nocreate,0);
		 if(OpenDialog2->FileName != OpenDialog1->FileName){
		 if(viewfile2)
		   {ntime2=0;nndmax2=0;
			tstor2=new float[1024*1024]; //speculative million
			while(!viewfile2.eof())
			  {viewfile2.getline(descript,76);
			   if(strlen(descript))
				 {parse_cdm(descript,2,&nic,&nrc,larr,darr);nnd=larr[0];tstep=darr[0];
				  tstor2[ntime2]=tstep;ntime2++;if(nndmax2<nnd)nndmax2=nnd;  //TBD: Check for errant time.out
				  if(nnd){   if(solidshellsw)for(in=0;in<nnd;in++){viewfile2>>id>>t11>>t12>>t13>>t14>>t15;
																   if(hinodemin>id)hinodemin=id;
																   if(hinodemax<id)hinodemax=id;
																  }
							 else for(in=0;in<nnd;in++){viewfile2>>id>>t11;
														if(hinodemin>id)hinodemin=id;
														if(hinodemax<id)hinodemax=id;
													   }
						 }
				 }
			  }
			viewfile2.close();
/////////////////////////
honk<<hinodemin<<" "<<hinodemax<<" hinodemin/hinodemax\n";
			ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate,0);
			ifstream viewfile2(OpenDialog2->FileName.t_str(),ios::nocreate,0);
			if(viewfile1 && viewfile2)
			  {nstor1=new long[2*nndmax1];nstor2=new long[2*nndmax2];
			   if(solidshellsw){rstor1=new float[2*nndmax1*5];
								rstor2=new float[2*nndmax2*5];
								combo=new float[5*(hinodemax-hinodemin+1)];
							   }
			   else {rstor1=new float[2*nndmax1];
					 rstor2=new float[2*nndmax2];
					 combo=new float[hinodemax-hinodemin+1];
					}
///////
			   viewfile1>>tstep1>>nnd1; //Note: viewfile1.getline/parse does not combine with viewfile1>>id>>t11, in general.
			   nndval1[1]=nnd1;tval1[1]=tstep1;
			   if(nnd1){if(solidshellsw)for(in=0;in<nnd1;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
															   nstor1[in+nndmax1]=id-1;
															   rstor1[5*(in+nndmax1)  ]=t11;
															   rstor1[5*(in+nndmax1)+1]=t12;
															   rstor1[5*(in+nndmax1)+2]=t13;
															   rstor1[5*(in+nndmax1)+3]=t14;
															   rstor1[5*(in+nndmax1)+4]=t15;
															  } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<nnd1;in++){viewfile1>>id>>t11;
													nstor1[in+nndmax1]=id-1;rstor1[in+nndmax1]=t11;
												   }
					   }
			   viewfile2>>tstep2>>nnd2;
			   nndval2[1]=nnd2;tval2[1]=tstep2;
			   if(nnd2){if(solidshellsw)for(in=0;in<nnd2;in++){viewfile2>>id>>t11>>t12>>t13>>t14>>t15;
															   nstor2[in+nndmax2]=id-1;
															   rstor2[5*(in+nndmax2)  ]=t11;
															   rstor2[5*(in+nndmax2)+1]=t12;
															   rstor2[5*(in+nndmax2)+2]=t13;
															   rstor2[5*(in+nndmax2)+3]=t14;
															   rstor2[5*(in+nndmax2)+4]=t15;
															  } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<nnd2;in++){viewfile2>>id>>t11;
													nstor2[in+nndmax2]=id-1;rstor2[in+nndmax2]=t11;
												   }
					   }
///////
			   index1=index2=0;
			   ofstream outfile1("tempCombine.out");ofstream outfile2("timeCombine.out");
			   for(ic=0;ic<ntime1+ntime2;ic++)
				 {index1old=index1;index2old=index2;
				  if(index1<ntime1)tstorprox1=tstor1[index1];else tstorprox1=1.e25;
				  if(index2<ntime2)tstorprox2=tstor2[index2];else tstorprox2=1.e25;
				  if(fabs(tstorprox2-tstorprox1)<0.001)
					{
/////////////////////// start
					 if(solidshellsw){
						   for(in=0;in<5*(hinodemax-hinodemin+1);in++)combo[in]=0.;
						   for(in=0;in<nndval1[1];in++){combo[5*(nstor1[in+nndmax1]-hinodemin+1)  ]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)  ]+rstor1[5*(in+nndmax1)  ];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+1]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+1]+rstor1[5*(in+nndmax1)+1];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+2]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+2]+rstor1[5*(in+nndmax1)+2];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+3]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+3]+rstor1[5*(in+nndmax1)+3];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+4]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+4]+rstor1[5*(in+nndmax1)+4];
													   }
						   for(in=0;in<nndval2[1];in++){combo[5*(nstor2[in+nndmax2]-hinodemin+1)  ]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)  ]+rstor2[5*(in+nndmax2)  ];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+1]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+1]+rstor2[5*(in+nndmax2)+1];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+2]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+2]+rstor2[5*(in+nndmax2)+2];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+3]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+3]+rstor2[5*(in+nndmax2)+3];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+4]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+4]+rstor2[5*(in+nndmax2)+4];
													   }
						   isum=0;for(in=0;in<hinodemax-hinodemin+1;in++){
															 if(fabs(combo[5*in  ])>0.001 ||
																fabs(combo[5*in+1])>0.001 ||
																fabs(combo[5*in+2])>0.001 ||
																fabs(combo[5*in+3])>0.001 ||
																fabs(combo[5*in+4])>0.001)isum++;
																		 }
									 }
					 else {for(in=0;in<hinodemax-hinodemin+1;in++)combo[in]=0.;
						   for(in=0;in<nndval1[1];in++)combo[nstor1[in+nndmax1]-hinodemin+1]=combo[nstor1[in+nndmax1]-hinodemin+1]+rstor1[in+nndmax1];
						   for(in=0;in<nndval2[1];in++)combo[nstor2[in+nndmax2]-hinodemin+1]=combo[nstor2[in+nndmax2]-hinodemin+1]+rstor2[in+nndmax2];
						   isum=0;for(in=0;in<hinodemax-hinodemin+1;in++){if(fabs(combo[in])>0.001)isum++;}
						  }
					 outfile1<<setw(15)<<scientific<<tstor1[index1]<<setw(12)<<isum<<"\n";
					 outfile2<<setw(12)<<ic+1<<setw(15)<<scientific<<tstor1[index1]<<"\n";
					 if(isum) //This is cats ass coding but it works. EFP 3/29/2012
					   {if(solidshellsw)for(in=0;in<hinodemax-hinodemin+1;in++){
															 if(fabs(combo[5*in  ])>0.001 ||
																fabs(combo[5*in+1])>0.001 ||
																fabs(combo[5*in+2])>0.001 ||
																fabs(combo[5*in+3])>0.001 ||
																fabs(combo[5*in+4])>0.001)
outfile1<<setw(7)<<in+hinodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[5*in]<<setw(14)<<combo[5*in+1]<<setw(14)<<combo[5*in+2]<<setw(14)<<combo[5*in+3]<<setw(14)<<combo[5*in+4]<<"\n";
																			   } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<hinodemax-hinodemin+1;in++){if(fabs(combo[in])>0.001)outfile1<<setw(7)<<in+hinodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[in]<<"\n";
																	}
					   }
/////////////////////// end
					 index1++;index2++;
					}
				  else if(tstorprox2>tstorprox1)
						 {
/////////////////////// start
					 if(solidshellsw){
						   for(in=0;in<5*(hinodemax-hinodemin+1);in++)combo[in]=0.;
						   for(in=0;in<nndval1[1];in++){combo[5*(nstor1[in+nndmax1]-hinodemin+1)  ]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)  ]+rstor1[5*(in+nndmax1)  ];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+1]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+1]+rstor1[5*(in+nndmax1)+1];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+2]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+2]+rstor1[5*(in+nndmax1)+2];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+3]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+3]+rstor1[5*(in+nndmax1)+3];
														combo[5*(nstor1[in+nndmax1]-hinodemin+1)+4]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+4]+rstor1[5*(in+nndmax1)+4];
													   }
						   if(index2>0 && index2<ntime2)
							 {rkm=(tstor1[index1]-tstor2[index2-1])/(tstor2[index2]-tstor2[index2-1]);
							  for(in=0;in<nndval2[1];in++){combo[5*(nstor2[in+nndmax2]-hinodemin+1)  ]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)  ]+rkm*rstor2[5*(in+nndmax2)  ];
														   combo[5*(nstor2[in+nndmax2]-hinodemin+1)+1]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+1]+rkm*rstor2[5*(in+nndmax2)+1];
														   combo[5*(nstor2[in+nndmax2]-hinodemin+1)+2]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+2]+rkm*rstor2[5*(in+nndmax2)+2];
														   combo[5*(nstor2[in+nndmax2]-hinodemin+1)+3]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+3]+rkm*rstor2[5*(in+nndmax2)+3];
														   combo[5*(nstor2[in+nndmax2]-hinodemin+1)+4]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+4]+rkm*rstor2[5*(in+nndmax2)+4];
														  }
							  for(in=0;in<nndval2[0];in++){combo[5*(nstor2[in]-hinodemin+1)  ]=combo[5*(nstor2[in]-hinodemin+1)  ]+(1.-rkm)*rstor2[5*in  ];
														   combo[5*(nstor2[in]-hinodemin+1)+1]=combo[5*(nstor2[in]-hinodemin+1)+1]+(1.-rkm)*rstor2[5*in+1];
														   combo[5*(nstor2[in]-hinodemin+1)+2]=combo[5*(nstor2[in]-hinodemin+1)+2]+(1.-rkm)*rstor2[5*in+2];
														   combo[5*(nstor2[in]-hinodemin+1)+3]=combo[5*(nstor2[in]-hinodemin+1)+3]+(1.-rkm)*rstor2[5*in+3];
														   combo[5*(nstor2[in]-hinodemin+1)+4]=combo[5*(nstor2[in]-hinodemin+1)+4]+(1.-rkm)*rstor2[5*in+4];
														  }
							 }
						   isum=0;for(in=0;in<hinodemax-hinodemin+1;in++){
															 if(fabs(combo[5*in  ])>0.001 ||
																fabs(combo[5*in+1])>0.001 ||
																fabs(combo[5*in+2])>0.001 ||
																fabs(combo[5*in+3])>0.001 ||
																fabs(combo[5*in+4])>0.001)isum++;
																		 }
									 }
					 else {for(in=0;in<hinodemax-hinodemin+1;in++)combo[in]=0.;
						   for(in=0;in<nndval1[1];in++)combo[nstor1[in+nndmax1]-hinodemin+1]=combo[nstor1[in+nndmax1]-hinodemin+1]+rstor1[in+nndmax1];
						   if(index2>0 && index2<ntime2)
							 {rkm=(tstor1[index1]-tstor2[index2-1])/(tstor2[index2]-tstor2[index2-1]);
for(in=0;in<nndval2[1];in++)combo[nstor2[in+nndmax2]-hinodemin+1]=combo[nstor2[in+nndmax2]-hinodemin+1]+rkm*rstor2[in+nndmax2];
for(in=0;in<nndval2[0];in++)combo[nstor2[in]-hinodemin+1]=combo[nstor2[in]-hinodemin+1]+(1.-rkm)*rstor2[in];
							 }
						   isum=0;for(in=0;in<hinodemax-hinodemin+1;in++){if(fabs(combo[in])>0.001)isum++;}
						  }
					 outfile1<<setw(15)<<scientific<<tstor1[index1]<<setw(12)<<isum<<"\n";
					 outfile2<<setw(12)<<ic+1<<setw(15)<<scientific<<tstor1[index1]<<"\n";
					 if(isum) //This is cats ass coding but it works. EFP 3/29/2012
					   {if(solidshellsw)for(in=0;in<hinodemax-hinodemin+1;in++){
															 if(fabs(combo[5*in  ])>0.001 ||
																fabs(combo[5*in+1])>0.001 ||
																fabs(combo[5*in+2])>0.001 ||
																fabs(combo[5*in+3])>0.001 ||
																fabs(combo[5*in+4])>0.001)
outfile1<<setw(7)<<in+hinodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[5*in]<<setw(14)<<combo[5*in+1]<<setw(14)<<combo[5*in+2]<<setw(14)<<combo[5*in+3]<<setw(14)<<combo[5*in+4]<<"\n";
																			   } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<hinodemax-hinodemin+1;in++){if(fabs(combo[in])>0.001)outfile1<<setw(7)<<in+hinodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[in]<<"\n";
																	 }
					   }
/////////////////////// end
						  index1++;
						 }
				  else {
/////////////////////// start
					 if(solidshellsw){
						   for(in=0;in<5*(hinodemax-hinodemin+1);in++)combo[in]=0.;
						   for(in=0;in<nndval2[1];in++){combo[5*(nstor2[in+nndmax2]-hinodemin+1)  ]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)  ]+rstor2[5*(in+nndmax2)  ];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+1]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+1]+rstor2[5*(in+nndmax2)+1];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+2]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+2]+rstor2[5*(in+nndmax2)+2];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+3]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+3]+rstor2[5*(in+nndmax2)+3];
														combo[5*(nstor2[in+nndmax2]-hinodemin+1)+4]=combo[5*(nstor2[in+nndmax2]-hinodemin+1)+4]+rstor2[5*(in+nndmax2)+4];
													   }
						   if(index1>0 && index1<ntime1)
							 {rkm=(tstor2[index2]-tstor1[index1-1])/(tstor1[index1]-tstor1[index1-1]);
							  for(in=0;in<nndval1[1];in++){combo[5*(nstor1[in+nndmax1]-hinodemin+1)  ]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)  ]+rkm*rstor1[5*(in+nndmax1)  ];
														   combo[5*(nstor1[in+nndmax1]-hinodemin+1)+1]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+1]+rkm*rstor1[5*(in+nndmax1)+1];
														   combo[5*(nstor1[in+nndmax1]-hinodemin+1)+2]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+2]+rkm*rstor1[5*(in+nndmax1)+2];
														   combo[5*(nstor1[in+nndmax1]-hinodemin+1)+3]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+3]+rkm*rstor1[5*(in+nndmax1)+3];
														   combo[5*(nstor1[in+nndmax1]-hinodemin+1)+4]=combo[5*(nstor1[in+nndmax1]-hinodemin+1)+4]+rkm*rstor1[5*(in+nndmax1)+4];
														  }
							  for(in=0;in<nndval1[0];in++){combo[5*(nstor1[in]-hinodemin+1)  ]=combo[5*(nstor1[in]-hinodemin+1)  ]+(1.-rkm)*rstor1[5*in  ];
														   combo[5*(nstor1[in]-hinodemin+1)+1]=combo[5*(nstor1[in]-hinodemin+1)+1]+(1.-rkm)*rstor1[5*in+1];
														   combo[5*(nstor1[in]-hinodemin+1)+2]=combo[5*(nstor1[in]-hinodemin+1)+2]+(1.-rkm)*rstor1[5*in+2];
														   combo[5*(nstor1[in]-hinodemin+1)+3]=combo[5*(nstor1[in]-hinodemin+1)+3]+(1.-rkm)*rstor1[5*in+3];
														   combo[5*(nstor1[in]-hinodemin+1)+4]=combo[5*(nstor1[in]-hinodemin+1)+4]+(1.-rkm)*rstor1[5*in+4];
														  }
							 }
						   isum=0;for(in=0;in<hinodemax-hinodemin+1;in++){
															 if(fabs(combo[5*in  ])>0.001 ||
																fabs(combo[5*in+1])>0.001 ||
																fabs(combo[5*in+2])>0.001 ||
																fabs(combo[5*in+3])>0.001 ||
																fabs(combo[5*in+4])>0.001)isum++;
																		 }
									 }
					 else {for(in=0;in<hinodemax-hinodemin+1;in++)combo[in]=0.;
						   for(in=0;in<nndval2[1];in++)combo[nstor2[in+nndmax2]-hinodemin+1]=combo[nstor2[in+nndmax2]-hinodemin+1]+rstor2[in+nndmax2];
						   if(index1>0 && index1<ntime1)
							 {rkm=(tstor2[index2]-tstor1[index1-1])/(tstor1[index1]-tstor1[index1-1]);
for(in=0;in<nndval1[1];in++)combo[nstor1[in+nndmax1]-hinodemin+1]=combo[nstor1[in+nndmax1]-hinodemin+1]+rkm*rstor1[in+nndmax1];
for(in=0;in<nndval1[0];in++)combo[nstor1[in]-hinodemin+1]=combo[nstor1[in]-hinodemin+1]+(1.-rkm)*rstor1[in];
							 }
						   isum=0;for(in=0;in<hinodemax-hinodemin+1;in++){if(fabs(combo[in])>0.001)isum++;}
						  }
					 outfile1<<setw(15)<<scientific<<tstor2[index2]<<setw(12)<<isum<<"\n";
					 outfile2<<setw(12)<<ic+1<<setw(15)<<scientific<<tstor2[index2]<<"\n";
					 if(isum) //This is cats ass coding but it works. EFP 3/29/2012
					   {if(solidshellsw)for(in=0;in<hinodemax-hinodemin+1;in++){
															 if(fabs(combo[5*in  ])>0.001 ||
																fabs(combo[5*in+1])>0.001 ||
																fabs(combo[5*in+2])>0.001 ||
																fabs(combo[5*in+3])>0.001 ||
																fabs(combo[5*in+4])>0.001)
outfile1<<setw(7)<<in+hinodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[5*in]<<setw(14)<<combo[5*in+1]<<setw(14)<<combo[5*in+2]<<setw(14)<<combo[5*in+3]<<setw(14)<<combo[5*in+4]<<"\n";
																			   } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<hinodemax-hinodemin+1;in++){if(fabs(combo[in])>0.001)outfile1<<setw(7)<<in+hinodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[in]<<"\n";
																	 }
					   }
/////////////////////// end
						index2++;
					   }
				  if(index1==ntime1 && index2==ntime2)break;
////
				  if(index1<ntime1 && index1!=index1old){
nndval1[0]=nndval1[1];tval1[0]=tval1[1];
if(nndval1[0]){if(solidshellsw)for(in=0;in<nndval1[0];in++){nstor1[in]=nstor1[in+nndmax1];
															rstor1[5*in  ]=rstor1[5*(in+nndmax1)  ];
															rstor1[5*in+1]=rstor1[5*(in+nndmax1)+1];
															rstor1[5*in+2]=rstor1[5*(in+nndmax1)+2];
															rstor1[5*in+3]=rstor1[5*(in+nndmax1)+3];
															rstor1[5*in+4]=rstor1[5*(in+nndmax1)+4];
														   }
			   else for(in=0;in<nndval1[0];in++){nstor1[in]=nstor1[in+nndmax1];
												 rstor1[in]=rstor1[in+nndmax1];
												}
			  }
viewfile1>>tstep1>>nnd1;
nndval1[1]=nnd1;tval1[1]=tstep1;
if(nnd1){if(solidshellsw)for(in=0;in<nnd1;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
												nstor1[in+nndmax1]=id-1;
												rstor1[5*(in+nndmax1)  ]=t11;
												rstor1[5*(in+nndmax1)+1]=t12;
												rstor1[5*(in+nndmax1)+2]=t13;
												rstor1[5*(in+nndmax1)+3]=t14;
												rstor1[5*(in+nndmax1)+4]=t15;
											   } //setw(5->7) above & below for more space EFP 12/15/2011
		 else for(in=0;in<nnd1;in++){viewfile1>>id>>t11;
									 nstor1[in+nndmax1]=id-1;rstor1[in+nndmax1]=t11;
									}
		}
														}
				  if(index2<ntime2 && index2!=index2old){
nndval2[0]=nndval2[1];tval2[0]=tval2[1];
if(nndval2[0]){if(solidshellsw)for(in=0;in<nndval2[0];in++){nstor2[in]=nstor2[in+nndmax2];
															rstor2[5*in  ]=rstor2[5*(in+nndmax2)  ];
															rstor2[5*in+1]=rstor2[5*(in+nndmax2)+1];
															rstor2[5*in+2]=rstor2[5*(in+nndmax2)+2];
															rstor2[5*in+3]=rstor2[5*(in+nndmax2)+3];
															rstor2[5*in+4]=rstor2[5*(in+nndmax2)+4];
														   }
			   else for(in=0;in<nndval2[0];in++){nstor2[in]=nstor2[in+nndmax2];
												 rstor2[in]=rstor2[in+nndmax2];
												}
			  }
viewfile2>>tstep2>>nnd2;
nndval2[1]=nnd2;tval2[1]=tstep2;
if(nnd2){if(solidshellsw)for(in=0;in<nnd2;in++){viewfile2>>id>>t11>>t12>>t13>>t14>>t15;
												nstor2[in+nndmax2]=id-1;
												rstor2[5*(in+nndmax2)  ]=t11;
												rstor2[5*(in+nndmax2)+1]=t12;
												rstor2[5*(in+nndmax2)+2]=t13;
												rstor2[5*(in+nndmax2)+3]=t14;
												rstor2[5*(in+nndmax2)+4]=t15;
											   } //setw(5->7) above & below for more space EFP 12/15/2011
		 else for(in=0;in<nnd2;in++){viewfile2>>id>>t11;
									 nstor2[in+nndmax2]=id-1;rstor2[in+nndmax2]=t11;
									}
		}
														}
////
				 }
			   outfile1.close();outfile2.close();
			   delete [] nstor1;delete [] nstor2;delete [] rstor1;delete [] rstor2;delete [] combo;
			  }
			else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen *.out files",L"Failure",MB_OK);}
/////////////////////////
			delete [] tstor2;
		   }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open second *.out file",L"Failure",MB_OK);}
														   }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User selected first *.out file twice.",L"Failure",MB_OK);}
		}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User did not choose second *.out",L"Abandon",MB_OK);}
	   delete [] tstor1;
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open first *.out file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
*/

// Note: Only positive temperatures are output, based on tol=0.001  EFP 8/26/2012
// Correctly, tcuth should be obtained & used for this.... but this code should be OK for combination?
 int nic=0,nrc=0,vcheck=0;
// int solidshellsw=0; //Solid only
 long ntime1=0,nndmax1=0,ntime2=0,nndmax2=0,ir=0,in=0,ic=0,id=0,
	  index1old=0,index2old=0,index1=0,index2=0,inodemin=0,inodemax=0,isum=0,
	  nndv1=0,nndm1=0,nndv2=0,nndm2=0,larr[5], *nstor1=NULL, *nstor2=NULL;
 float t11=0.,t12=0.,t13=0.,t14=0.,t15=0.,rkm=0.,tstorprox1=0.,tstorprox2=0.,tvalv1=0.,tvalm1=0.,tvalv2=0.,tvalm2=0.,
	   tol=0.001,darr[5], *rstor1=NULL, *rstor2=NULL, *combo=NULL;
 char descript[76];
 OpenDialog1->Filter= "Out (*.out)|*.out;*.OUT";
 if(OpenDialog1->Execute())
   {ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate,0);
	if(viewfile1)
	  {
///////////////
//	   TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//	   try {
///////////////
	   ntime1=nndmax1=inodemax=0;inodemin=LONG_INT;
	   while(!viewfile1.eof())
		 {viewfile1.getline(descript,76);
		  if(strlen(descript))
			{
//			 parse_cdm(descript,2,&nic,&nrc,larr,darr);
			 vcheck=parse_cdmV(descript,2,&nic,&nrc,larr,darr);
honk<<ntime1<<" "<<vcheck<<" 1v\n";
			 if(!ntime1 && vcheck<0){
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Terminate: possible time.out file?",MB_OK);exit(0);
									}
			 nndv1=larr[0];ntime1++;if(nndmax1<nndv1)nndmax1=nndv1;  //TBD: Check for errant time.out
			 if(nndv1){if(solidshellsw)for(in=0;in<nndv1;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;if(inodemin>id)inodemin=id;if(inodemax<id)inodemax=id;} //setw(5->7) above & below for more space EFP 12/15/2011
					   else for(in=0;in<nndv1;in++){viewfile1>>id>>t11;if(inodemin>id)inodemin=id;if(inodemax<id)inodemax=id;}
					  }
			}
		 }
	   viewfile1.close();
///////////////
//		   }
//	   __finally {Screen->Cursor=Save_Cursor;}
///////////////
	   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Reading first temp@@@.out file.\nNext, select second file.",L"Status",MB_OK);
	   OpenDialog2->Filter= "Out (*.out)|*.out;*.OUT";
	   if(OpenDialog2->Execute())
		{ifstream viewfile2(OpenDialog2->FileName.t_str(),ios::nocreate,0);
		 if(OpenDialog2->FileName != OpenDialog1->FileName){
		 if(viewfile2)
		   {
///////////////
//	   TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//	   try {
///////////////
			ntime2=nndmax2=0;
			while(!viewfile2.eof())
			  {viewfile2.getline(descript,76);
			   if(strlen(descript))
				 {
//				  parse_cdm(descript,2,&nic,&nrc,larr,darr);
				  vcheck=parse_cdmV(descript,2,&nic,&nrc,larr,darr);
honk<<ntime2<<" "<<vcheck<<" 2v\n";
				  if(!ntime2 && vcheck<0){
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Floating point not found in first number",L"Terminate: possible time.out file?",MB_OK);exit(0);
										 }
				  nndv2=larr[0];ntime2++;if(nndmax2<nndv2)nndmax2=nndv2;  //TBD: Check for errant time.out
				  if(nndv2){if(solidshellsw)for(in=0;in<nndv2;in++){viewfile2>>id>>t11>>t12>>t13>>t14>>t15;if(inodemin>id)inodemin=id;if(inodemax<id)inodemax=id;}
							else for(in=0;in<nndv2;in++){viewfile2>>id>>t11;if(inodemin>id)inodemin=id;if(inodemax<id)inodemax=id;}
						   }
				 }
			  }
			viewfile2.close();
/////////////////////////
			ifstream viewfile1(OpenDialog1->FileName.t_str(),ios::nocreate,0);
			ifstream viewfile2(OpenDialog2->FileName.t_str(),ios::nocreate,0);
			if(viewfile1 && viewfile2)
			  {nstor1=new long[2*nndmax1];nstor2=new long[2*nndmax2];
			   if(solidshellsw){rstor1=new float[2*nndmax1*5];rstor2=new float[2*nndmax2*5];combo=new float[5*(inodemax-inodemin+1)];}
			   else {rstor1=new float[2*nndmax1];rstor2=new float[2*nndmax2];combo=new float[inodemax-inodemin+1];}
///////
			   viewfile1>>tvalv1>>nndv1; //Note: viewfile1.getline/parse does not combine with viewfile1>>id>>t11, in general.
			   if(nndv1){if(solidshellsw)for(in=0;in<nndv1;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
																 nstor1[in+nndmax1]=id-1;
															   rstor1[5*(in+nndmax1)  ]=t11;
															   rstor1[5*(in+nndmax1)+1]=t12;
															   rstor1[5*(in+nndmax1)+2]=t13;
															   rstor1[5*(in+nndmax1)+3]=t14;
															   rstor1[5*(in+nndmax1)+4]=t15;
															  } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<nndv1;in++){viewfile1>>id>>t11;nstor1[in+nndmax1]=id-1;rstor1[in+nndmax1]=t11;}
					   }
			   viewfile2>>tvalv2>>nndv2;
			   if(nndv2){if(solidshellsw)for(in=0;in<nndv2;in++){viewfile2>>id>>t11>>t12>>t13>>t14>>t15;
															   nstor2[in+nndmax2]=id-1;
															   rstor2[5*(in+nndmax2)  ]=t11;
															   rstor2[5*(in+nndmax2)+1]=t12;
															   rstor2[5*(in+nndmax2)+2]=t13;
															   rstor2[5*(in+nndmax2)+3]=t14;
															   rstor2[5*(in+nndmax2)+4]=t15;
															  } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<nndv2;in++){viewfile2>>id>>t11;nstor2[in+nndmax2]=id-1;rstor2[in+nndmax2]=t11;}
					   }
///////
			   index1=index2=0;
			   ofstream outfile1("tempCombine.out");ofstream outfile2("timeCombine.out");
			   for(ic=0;ic<ntime1+ntime2;ic++)
				 {index1old=index1;index2old=index2;
				  if(index1<ntime1)tstorprox1=tvalv1;else tstorprox1=1.e25;
				  if(index2<ntime2)tstorprox2=tvalv2;else tstorprox2=1.e25;
				  if(fabs(tstorprox2-tstorprox1)<tol)
					{
/////////////////////// start
					 if(solidshellsw){
						   for(in=0;in<5*(inodemax-inodemin+1);in++)combo[in]=0.;
						   for(in=0;in<nndv1;in++){combo[5*(nstor1[in+nndmax1]-inodemin+1)  ]=combo[5*(nstor1[in+nndmax1]-inodemin+1)  ]+rstor1[5*(in+nndmax1)  ];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+1]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+1]+rstor1[5*(in+nndmax1)+1];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+2]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+2]+rstor1[5*(in+nndmax1)+2];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+3]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+3]+rstor1[5*(in+nndmax1)+3];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+4]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+4]+rstor1[5*(in+nndmax1)+4];
													   }
						   for(in=0;in<nndv2;in++){combo[5*(nstor2[in+nndmax2]-inodemin+1)  ]=combo[5*(nstor2[in+nndmax2]-inodemin+1)  ]+rstor2[5*(in+nndmax2)  ];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+1]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+1]+rstor2[5*(in+nndmax2)+1];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+2]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+2]+rstor2[5*(in+nndmax2)+2];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+3]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+3]+rstor2[5*(in+nndmax2)+3];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+4]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+4]+rstor2[5*(in+nndmax2)+4];
													   }
						   isum=0;for(in=0;in<inodemax-inodemin+1;in++){
															 if(combo[5*in  ]>tol ||
																combo[5*in+1]>tol ||
																combo[5*in+2]>tol ||
																combo[5*in+3]>tol ||
																combo[5*in+4]>tol)isum++;
																	   }
									 }
					 else {for(in=0;in<inodemax-inodemin+1;in++)combo[in]=0.;
						   for(in=0;in<nndv1;in++)combo[nstor1[in+nndmax1]-inodemin+1]=combo[nstor1[in+nndmax1]-inodemin+1]+rstor1[in+nndmax1];
						   for(in=0;in<nndv2;in++)combo[nstor2[in+nndmax2]-inodemin+1]=combo[nstor2[in+nndmax2]-inodemin+1]+rstor2[in+nndmax2];
						   isum=0;for(in=0;in<inodemax-inodemin+1;in++){if(combo[in]>tol)isum++;}
						  }
					 outfile1<<setw(15)<<scientific<<tvalv1<<setw(12)<<isum<<"\n";
					 outfile2<<setw(12)<<ic+1<<setw(15)<<scientific<<tvalv1<<"\n";
					 if(isum) //This is cats ass coding but it works. EFP 3/29/2012
					   {if(solidshellsw)for(in=0;in<inodemax-inodemin+1;in++){
															 if(combo[5*in  ]>tol ||
																combo[5*in+1]>tol ||
																combo[5*in+2]>tol ||
																combo[5*in+3]>tol ||
																combo[5*in+4]>tol)
outfile1<<setw(7)<<in+inodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[5*in]<<setw(14)<<combo[5*in+1]<<setw(14)<<combo[5*in+2]<<setw(14)<<combo[5*in+3]<<setw(14)<<combo[5*in+4]<<"\n";
																			 } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<inodemax-inodemin+1;in++){if(combo[in]>tol)outfile1<<setw(7)<<in+inodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[in]<<"\n";}
					   }
/////////////////////// end
					 index1++;index2++;
					}
				  else if(tstorprox2>tstorprox1)
						 {
/////////////////////// start
					 if(solidshellsw){
						   for(in=0;in<5*(inodemax-inodemin+1);in++)combo[in]=0.;
						   for(in=0;in<nndv1;in++){combo[5*(nstor1[in+nndmax1]-inodemin+1)  ]=combo[5*(nstor1[in+nndmax1]-inodemin+1)  ]+rstor1[5*(in+nndmax1)  ];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+1]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+1]+rstor1[5*(in+nndmax1)+1];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+2]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+2]+rstor1[5*(in+nndmax1)+2];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+3]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+3]+rstor1[5*(in+nndmax1)+3];
														combo[5*(nstor1[in+nndmax1]-inodemin+1)+4]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+4]+rstor1[5*(in+nndmax1)+4];
													   }
						   if(index2>0 && index2<ntime2)
							 {rkm=(tvalv1-tvalm2)/(tvalv2-tvalm2);
							  for(in=0;in<nndv2;in++){combo[5*(nstor2[in+nndmax2]-inodemin+1)  ]=combo[5*(nstor2[in+nndmax2]-inodemin+1)  ]+rkm*rstor2[5*(in+nndmax2)  ];
														   combo[5*(nstor2[in+nndmax2]-inodemin+1)+1]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+1]+rkm*rstor2[5*(in+nndmax2)+1];
														   combo[5*(nstor2[in+nndmax2]-inodemin+1)+2]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+2]+rkm*rstor2[5*(in+nndmax2)+2];
														   combo[5*(nstor2[in+nndmax2]-inodemin+1)+3]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+3]+rkm*rstor2[5*(in+nndmax2)+3];
														   combo[5*(nstor2[in+nndmax2]-inodemin+1)+4]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+4]+rkm*rstor2[5*(in+nndmax2)+4];
														  }
							  for(in=0;in<nndm2;in++){combo[5*(nstor2[in]-inodemin+1)  ]=combo[5*(nstor2[in]-inodemin+1)  ]+(1.-rkm)*rstor2[5*in  ];
														   combo[5*(nstor2[in]-inodemin+1)+1]=combo[5*(nstor2[in]-inodemin+1)+1]+(1.-rkm)*rstor2[5*in+1];
														   combo[5*(nstor2[in]-inodemin+1)+2]=combo[5*(nstor2[in]-inodemin+1)+2]+(1.-rkm)*rstor2[5*in+2];
														   combo[5*(nstor2[in]-inodemin+1)+3]=combo[5*(nstor2[in]-inodemin+1)+3]+(1.-rkm)*rstor2[5*in+3];
														   combo[5*(nstor2[in]-inodemin+1)+4]=combo[5*(nstor2[in]-inodemin+1)+4]+(1.-rkm)*rstor2[5*in+4];
														  }
							 }
						   isum=0;for(in=0;in<inodemax-inodemin+1;in++){
															 if(combo[5*in  ]>tol ||
																combo[5*in+1]>tol ||
																combo[5*in+2]>tol ||
																combo[5*in+3]>tol ||
																combo[5*in+4]>tol)isum++;
																	   }
									 }
					 else {for(in=0;in<inodemax-inodemin+1;in++)combo[in]=0.;
						   for(in=0;in<nndv1;in++)combo[nstor1[in+nndmax1]-inodemin+1]=combo[nstor1[in+nndmax1]-inodemin+1]+rstor1[in+nndmax1];
						   if(index2>0 && index2<ntime2){rkm=(tvalv1-tvalm2)/(tvalv2-tvalm2);
for(in=0;in<nndv2;in++)combo[nstor2[in+nndmax2]-inodemin+1]=combo[nstor2[in+nndmax2]-inodemin+1]+rkm*rstor2[in+nndmax2];
for(in=0;in<nndm2;in++)combo[nstor2[in]-inodemin+1]=combo[nstor2[in]-inodemin+1]+(1.-rkm)*rstor2[in];
														}
						   isum=0;for(in=0;in<inodemax-inodemin+1;in++){if(combo[in]>tol)isum++;}
						  }
					 outfile1<<setw(15)<<scientific<<tvalv1<<setw(12)<<isum<<"\n";
					 outfile2<<setw(12)<<ic+1<<setw(15)<<scientific<<tvalv1<<"\n";
					 if(isum) //This is cats ass coding but it works. EFP 3/29/2012
					   {if(solidshellsw)for(in=0;in<inodemax-inodemin+1;in++){
															 if(combo[5*in  ]>tol ||
																combo[5*in+1]>tol ||
																combo[5*in+2]>tol ||
																combo[5*in+3]>tol ||
																combo[5*in+4]>tol)
outfile1<<setw(7)<<in+inodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[5*in]<<setw(14)<<combo[5*in+1]<<setw(14)<<combo[5*in+2]<<setw(14)<<combo[5*in+3]<<setw(14)<<combo[5*in+4]<<"\n";
																			 } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<inodemax-inodemin+1;in++){if(combo[in]>tol)outfile1<<setw(7)<<in+inodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[in]<<"\n";}
					   }
/////////////////////// end
						  index1++;
						 }
				  else {
/////////////////////// start
					 if(solidshellsw){
						   for(in=0;in<5*(inodemax-inodemin+1);in++)combo[in]=0.;
						   for(in=0;in<nndv2;in++){combo[5*(nstor2[in+nndmax2]-inodemin+1)  ]=combo[5*(nstor2[in+nndmax2]-inodemin+1)  ]+rstor2[5*(in+nndmax2)  ];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+1]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+1]+rstor2[5*(in+nndmax2)+1];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+2]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+2]+rstor2[5*(in+nndmax2)+2];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+3]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+3]+rstor2[5*(in+nndmax2)+3];
														combo[5*(nstor2[in+nndmax2]-inodemin+1)+4]=combo[5*(nstor2[in+nndmax2]-inodemin+1)+4]+rstor2[5*(in+nndmax2)+4];
													   }
						   if(index1>0 && index1<ntime1)
							 {rkm=(tvalv2-tvalm1)/(tvalv1-tvalm1);
							  for(in=0;in<nndv1;in++){combo[5*(nstor1[in+nndmax1]-inodemin+1)  ]=combo[5*(nstor1[in+nndmax1]-inodemin+1)  ]+rkm*rstor1[5*(in+nndmax1)  ];
														   combo[5*(nstor1[in+nndmax1]-inodemin+1)+1]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+1]+rkm*rstor1[5*(in+nndmax1)+1];
														   combo[5*(nstor1[in+nndmax1]-inodemin+1)+2]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+2]+rkm*rstor1[5*(in+nndmax1)+2];
														   combo[5*(nstor1[in+nndmax1]-inodemin+1)+3]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+3]+rkm*rstor1[5*(in+nndmax1)+3];
														   combo[5*(nstor1[in+nndmax1]-inodemin+1)+4]=combo[5*(nstor1[in+nndmax1]-inodemin+1)+4]+rkm*rstor1[5*(in+nndmax1)+4];
														  }
							  for(in=0;in<nndm1;in++){combo[5*(nstor1[in]-inodemin+1)  ]=combo[5*(nstor1[in]-inodemin+1)  ]+(1.-rkm)*rstor1[5*in  ];
														   combo[5*(nstor1[in]-inodemin+1)+1]=combo[5*(nstor1[in]-inodemin+1)+1]+(1.-rkm)*rstor1[5*in+1];
														   combo[5*(nstor1[in]-inodemin+1)+2]=combo[5*(nstor1[in]-inodemin+1)+2]+(1.-rkm)*rstor1[5*in+2];
														   combo[5*(nstor1[in]-inodemin+1)+3]=combo[5*(nstor1[in]-inodemin+1)+3]+(1.-rkm)*rstor1[5*in+3];
														   combo[5*(nstor1[in]-inodemin+1)+4]=combo[5*(nstor1[in]-inodemin+1)+4]+(1.-rkm)*rstor1[5*in+4];
														  }
							 }
						   isum=0;for(in=0;in<inodemax-inodemin+1;in++){
															 if(combo[5*in  ]>tol ||
																combo[5*in+1]>tol ||
																combo[5*in+2]>tol ||
																combo[5*in+3]>tol ||
																combo[5*in+4]>tol)isum++;
																	   }
									 }
					 else {for(in=0;in<inodemax-inodemin+1;in++)combo[in]=0.;
						   for(in=0;in<nndv2;in++)combo[nstor2[in+nndmax2]-inodemin+1]=combo[nstor2[in+nndmax2]-inodemin+1]+rstor2[in+nndmax2];
						   if(index1>0 && index1<ntime1){rkm=(tvalv2-tvalm1)/(tvalv1-tvalm1);
for(in=0;in<nndv1;in++)combo[nstor1[in+nndmax1]-inodemin+1]=combo[nstor1[in+nndmax1]-inodemin+1]+rkm*rstor1[in+nndmax1];
for(in=0;in<nndm1;in++)combo[nstor1[in]-inodemin+1]=combo[nstor1[in]-inodemin+1]+(1.-rkm)*rstor1[in];
														}
						   isum=0;for(in=0;in<inodemax-inodemin+1;in++){if(combo[in]>tol)isum++;}
						  }
					 outfile1<<setw(15)<<scientific<<tvalv2<<setw(12)<<isum<<"\n";
					 outfile2<<setw(12)<<ic+1<<setw(15)<<scientific<<tvalv2<<"\n";
					 if(isum) //This is cats ass coding but it works. EFP 3/29/2012
					   {if(solidshellsw)for(in=0;in<inodemax-inodemin+1;in++){
															 if(combo[5*in  ]>tol ||
																combo[5*in+1]>tol ||
																combo[5*in+2]>tol ||
																combo[5*in+3]>tol ||
																combo[5*in+4]>tol)
outfile1<<setw(7)<<in+inodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[5*in]<<setw(14)<<combo[5*in+1]<<setw(14)<<combo[5*in+2]<<setw(14)<<combo[5*in+3]<<setw(14)<<combo[5*in+4]<<"\n";
																			 } //setw(5->7) above & below for more space EFP 12/15/2011
						else for(in=0;in<inodemax-inodemin+1;in++){if(combo[in]>tol)outfile1<<setw(7)<<in+inodemin<<setw(14)<<dec<<showpoint<<setprecision(5)<<combo[in]<<"\n";}
					   }
/////////////////////// end
						index2++;
					   }
				  if(index1==ntime1 && index2==ntime2)break;
////
				  if(index1<ntime1 && index1!=index1old){nndm1=nndv1;tvalm1=tvalv1;
if(nndm1){if(solidshellsw)for(in=0;in<nndm1;in++){nstor1[in]=nstor1[in+nndmax1];
															rstor1[5*in  ]=rstor1[5*(in+nndmax1)  ];
															rstor1[5*in+1]=rstor1[5*(in+nndmax1)+1];
															rstor1[5*in+2]=rstor1[5*(in+nndmax1)+2];
															rstor1[5*in+3]=rstor1[5*(in+nndmax1)+3];
															rstor1[5*in+4]=rstor1[5*(in+nndmax1)+4];
														   }
		  else for(in=0;in<nndm1;in++){nstor1[in]=nstor1[in+nndmax1];rstor1[in]=rstor1[in+nndmax1];}
		 }
viewfile1>>tvalv1>>nndv1;
if(nndv1){if(solidshellsw)for(in=0;in<nndv1;in++){viewfile1>>id>>t11>>t12>>t13>>t14>>t15;
												nstor1[in+nndmax1]=id-1;
												rstor1[5*(in+nndmax1)  ]=t11;
												rstor1[5*(in+nndmax1)+1]=t12;
												rstor1[5*(in+nndmax1)+2]=t13;
												rstor1[5*(in+nndmax1)+3]=t14;
												rstor1[5*(in+nndmax1)+4]=t15;
											   } //setw(5->7) above & below for more space EFP 12/15/2011
		  else for(in=0;in<nndv1;in++){viewfile1>>id>>t11;nstor1[in+nndmax1]=id-1;rstor1[in+nndmax1]=t11;}
		 }
														}
				  if(index2<ntime2 && index2!=index2old){nndm2=nndv2;tvalm2=tvalv2;
if(nndm2){if(solidshellsw)for(in=0;in<nndm2;in++){nstor2[in]=nstor2[in+nndmax2];
															rstor2[5*in  ]=rstor2[5*(in+nndmax2)  ];
															rstor2[5*in+1]=rstor2[5*(in+nndmax2)+1];
															rstor2[5*in+2]=rstor2[5*(in+nndmax2)+2];
															rstor2[5*in+3]=rstor2[5*(in+nndmax2)+3];
															rstor2[5*in+4]=rstor2[5*(in+nndmax2)+4];
														   }
		  else for(in=0;in<nndm2;in++){nstor2[in]=nstor2[in+nndmax2];rstor2[in]=rstor2[in+nndmax2];}
		 }
viewfile2>>tvalv2>>nndv2;
if(nndv2){if(solidshellsw)for(in=0;in<nndv2;in++){viewfile2>>id>>t11>>t12>>t13>>t14>>t15;
												nstor2[in+nndmax2]=id-1;
												rstor2[5*(in+nndmax2)  ]=t11;
												rstor2[5*(in+nndmax2)+1]=t12;
												rstor2[5*(in+nndmax2)+2]=t13;
												rstor2[5*(in+nndmax2)+3]=t14;
												rstor2[5*(in+nndmax2)+4]=t15;
											   } //setw(5->7) above & below for more space EFP 12/15/2011
		  else for(in=0;in<nndv2;in++){viewfile2>>id>>t11;nstor2[in+nndmax2]=id-1;rstor2[in+nndmax2]=t11;}
		 }
														}
////
				 }
			   outfile1.close();outfile2.close();delete [] nstor1;delete [] nstor2;delete [] rstor1;delete [] rstor2;delete [] combo;
///////////////
//		   }
//	   __finally {Screen->Cursor=Save_Cursor;}
///////////////
			   extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"tempCombine.out & timeCombine.out files written",L"Success",MB_OK);
			  }
			else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not reopen *.out files",L"Failure",MB_OK);}
/////////////////////////
		   }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open second *.out file",L"Failure",MB_OK);}
														   }
		 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User selected first *.out file twice.",L"Failure",MB_OK);}
		}
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User did not choose second *.out",L"Abandon",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open first *.out file",L"Failure",MB_OK);}
   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::CTSPinterpSolidExecute(TObject *Sender){int solidshellsw=0;CTSPinterpolate_prog(solidshellsw);}
//---------------------------------------------------------------------------
void __fastcall TForm1::CTSPinterpShellExecute(TObject *Sender){int solidshellsw=1;CTSPinterpolate_prog(solidshellsw);}
//---------------------------------------------------------------------------
void __fastcall TForm1::exportWARP3DExecute(TObject *Sender)
/*
{long i=0;float timesave2;
//extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Choose -Write ABAQUS- and use documented modifications.",L"Halt",MB_OK);
 if(base.nop1)
   {ofstream viewfile1("default_coordinates.COORDINATES");
	if(viewfile1)
	  {TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
	   for(i=0;i<base.npoin;i++)viewfile1<<base.node_map[i]+1<<" "<<base.c1[NDF*i]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n";
	   viewfile1.close();
	   Screen->Cursor=Save_Cursor;
	   ofstream viewfile2("default_INCIDandBLOCK.INCIDandBLOCK");
	   if(viewfile2) //8-n elements throughout
		 {TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
		  viewfile2<<"c\nincidences\n*echo\n";
		  for(i=0;i<base.nelt;i++)viewfile2<<base.el_map[i]+1<<" "<<
base.nop1[MXNPEL*i+0]+1<<" "<<base.nop1[MXNPEL*i+1]+1<<" "<<base.nop1[MXNPEL*i+2]+1<<" "<<base.nop1[MXNPEL*i+3]+1<<" "<<
base.nop1[MXNPEL*i+4]+1<<" "<<base.nop1[MXNPEL*i+5]+1<<" "<<base.nop1[MXNPEL*i+6]+1<<" "<<base.nop1[MXNPEL*i+7]+1<<"\n";
		  viewfile2<<"c\n*echo\n";viewfile2.close();
		  export_VED("default",&timesave2); // VED= virtual element detection
		  WARP3DepBlock1(20);
		  Screen->Cursor=Save_Cursor;
		  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"default_coordinates.COORDINATES & default_INCIDandBLOCK.INCIDandBLOCK\nwritten but user must use PATGO to create default_constraints.CONSTRAINTS\nBlocking info must be added to default_INCIDandBLOCK.INCIDandBLOCK",L"Successful first step",MB_OK);
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unable to create default_INCIDandBLOCK.INCIDandBLOCK",L"Failure",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unable to create default_coordinates.COORDINATES",L"Failure",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"121Get geometry file->File/Open",L"Halt",MB_OK);}
*/
{if(base.nop1)
   {if(wp.nWeldPass)
	  {ABAQnames=new TForm25(2,this);
	   ABAQnames->Caption="Enter file names for WARP3D input deck.";
	   ABAQnames->Label1->Caption="WARP3D main file";
	   ABAQnames->Label2->Caption="WARP3D node file";
	   ABAQnames->Label3->Caption="WARP3D element file";
	   ABAQnames->Label4->Caption="WARP3D VED file";
//	   ABAQnames->Label5->Caption="S/ABAQUS ufield file";
//	   ABAQnames->Label6->Caption="Directory where S/ABAQUS will run";
	   ABAQnames->Label7->Caption=".wrp";
	   ABAQnames->Label8->Caption=".coordinates";
	   ABAQnames->Label9->Caption=".incid";
	   ABAQnames->Label10->Caption="_VED.inp";
//	   ABAQnames->Label11->Caption="_ufield.f";
	   ABAQnames->Button1->Caption="OK";
	   ABAQnames->Button2->Caption="Cancel";
	   ABAQnames->Label2->Enabled=false;ABAQnames->Label3->Enabled=false;ABAQnames->Label4->Enabled=false;
	   ABAQnames->Label5->Enabled=false;ABAQnames->Label6->Enabled=false;ABAQnames->Label8->Enabled=false;
	   ABAQnames->Label9->Enabled=false;ABAQnames->Label10->Enabled=false;ABAQnames->Label11->Enabled=false;
	   ABAQnames->Edit2->Visible=false;ABAQnames->Edit3->Visible=false;ABAQnames->Edit4->Visible=false;
	   ABAQnames->Edit5->Visible=false;ABAQnames->Edit6->Visible=false;
	   ABAQnames->CheckEdit1=gWsiAlias.t_str();
	   ABAQnames->ShowModal();
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Must create weld passes->Weld",L"Halt",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"122Get geometry file->File/Open",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void TForm1::exportWARP3D_public()
{gWsiAlias=ABAQnames->CheckEdit1;
	   ABAQnames->CheckIsel=3;ABAQnames->Edit2->Visible=true;ABAQnames->Edit3->Visible=true;
	   ABAQnames->Edit4->Visible=true;
	   ABAQnames->Edit5->Visible=false;
	   ABAQnames->Edit6->Visible=false;
	   ABAQnames->Label1->Enabled=false;
	   ABAQnames->Label2->Enabled=true;ABAQnames->Label3->Enabled=true;ABAQnames->Label4->Enabled=true;
	   ABAQnames->Label5->Enabled=false;
	   ABAQnames->Label6->Enabled=false;
	   ABAQnames->Label8->Enabled=true;
	   ABAQnames->Label9->Enabled=true;ABAQnames->Label10->Enabled=true;
	   ABAQnames->Label11->Enabled=false;
	   ABAQnames->CheckEdit1=gWsiAlias;ABAQnames->CheckEdit2=gWsiAlias;ABAQnames->CheckEdit3=gWsiAlias;
	   ABAQnames->CheckEdit4=gWsiAlias;
//	   ABAQnames->CheckEdit5=gWsiAlias;ABAQnames->CheckEdit6="****";
	   ABAQnames->Edit1->Enabled=false;ABAQnames->Button1->Caption="Write files";

//	   ABAQnames->ShowModal();
}
//---------------------------------------------------------------------------
void TForm1::exportWARP3D1_public()
//To reverse, delete this subr and modify below //void TForm1::exportWARP3D1_public()-->exportWARP3D_public()
//Remember to change Form8 (line 32) and exportWARP3D1a_public() (line 40773)
// and epStepsPerT=long(tdeltCTSP->Angle0 +0.5) (line 40690)
{float val=20.; //epWARP3D EFP 12/19/2012
 tdeltCTSP=new TForm8(6,val,this);tdeltCTSP->Caption="Enter WARP3D steps";
 tdeltCTSP->Button2->Caption="Inactive";tdeltCTSP->Button3->Caption="Inactive";
 tdeltCTSP->ShowModal();
}
//---------------------------------------------------------------------------
//void TForm1::exportWARP3D1_public()
void TForm1::exportWARP3D1a_public()
{long i=0,eltype=0,bscode=0,node=0,t7=10000000,t5=100000,t3=1000;
 float timesave2=0.;
// long epStepsPerT=long(tdeltCTSP->Angle0 +0.5); //To reverse, comment this
 wchar_t curMess0[]=L".wrp\n",    //curMess0[]=L"_ABA_input.inp\n",
		 curMess1[]=L"_VED.dat\n",curMess2[]=L".coordinates\n",
		 curMess3[]=L".incid\n",string0[160]; //Correction EFP 11/12/2012
 StringCchCopyW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess0);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess1);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess2);
 StringCchCatW(string0,160,gWsiAlias.w_str());StringCchCatW(string0,160,curMess3);

//			   export_ABA_NODE(ABAQnames->CheckEdit2.t_str()); // Write ABAQUS-format ASCII nodal geometry file *.inp (or *.in), delimited by ","
//			   export_ABA_ELEMENT8(ABAQnames->CheckEdit3.t_str()); // Write ABAQUS-format ASCII element (8n only, with mapping) connectivity file *.inp (or *.in), delimited by ","
//// Dire warning: Must call export_VED() before export_ABA() or export_UFIELD() because it computes .......
//			   export_VED(ABAQnames->CheckEdit4.t_str(),&timesave2); // VED= virtual element detection
//			   export_ABA(ABAQnames->CheckEdit1.t_str());
//			   export_UFIELD(ABAQnames->CheckEdit5.t_str(),ABAQnames->CheckEdit6.t_str(),timesave2); // EFP 03/02/2010
//// ToCTSP2->Enabled=true;


 char extensChar1[]=".coordinates";char *fnNeed1=new char[strlen(gWsiAlias.t_str())+strlen(extensChar1)+1];
 StringCchCopy(fnNeed1,strlen(gWsiAlias.t_str())+strlen(extensChar1)+1,gWsiAlias.t_str());StringCchCat(fnNeed1,strlen(gWsiAlias.t_str())+strlen(extensChar1)+1,extensChar1);
 char extensChar2[]=".incid";char *fnNeed2=new char[strlen(gWsiAlias.t_str())+strlen(extensChar2)+1];
 StringCchCopy(fnNeed2,strlen(gWsiAlias.t_str())+strlen(extensChar2)+1,gWsiAlias.t_str());StringCchCat(fnNeed2,strlen(gWsiAlias.t_str())+strlen(extensChar2)+1,extensChar2);

 if(base.nop1)
   {
//	ofstream viewfile1("default.coordinates");
	ofstream viewfile1(fnNeed1);delete [] fnNeed1;
	if(viewfile1)
	  {TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
//	   for(i=0;i<base.npoin;i++)viewfile1<<base.node_map[i]+1<<" "<<base.c1[NDF*i]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n";
	   viewfile1<<"c\ncoordinates\n*echo off\n";
	   viewfile1.setf(ios::scientific);viewfile1.precision(6); //Correction BB 1/07/2013
	   for(i=0;i<base.npoin;i++)viewfile1<<base.node_map[i]+1<<" "<<base.c1[NDF*i]<<" "<<base.c1[NDF*i+1]<<" "<<base.c1[NDF*i+2]<<"\n";
	   viewfile1<<"*echo on\nc\n";viewfile1.close();
	   Screen->Cursor=Save_Cursor;
//	   ofstream viewfile2("default.incid_and_blocking");
	   ofstream viewfile2(fnNeed2);delete [] fnNeed2;
	   if(viewfile2) //8-n elements throughout
		 {TCursor Save_Cursor=Screen->Cursor;Screen->Cursor=crHourGlass;
		  viewfile2<<"c\nincidences\n*echo off\n";

//		  for(i=0;i<base.nelt;i++)viewfile2<<base.el_map[i]+1<<" "<<
//base.nop1[MXNPEL*i+0]+1<<" "<<base.nop1[MXNPEL*i+1]+1<<" "<<base.nop1[MXNPEL*i+2]+1<<" "<<base.nop1[MXNPEL*i+3]+1<<" "<<
//base.nop1[MXNPEL*i+4]+1<<" "<<base.nop1[MXNPEL*i+5]+1<<" "<<base.nop1[MXNPEL*i+6]+1<<" "<<base.nop1[MXNPEL*i+7]+1<<"\n";

// Why no base.node_map[]?
				 for(i=0;i<base.nelt;i++){eltype=base.matno[i]/t7;bscode=(base.matno[i]-eltype*t7)/t5;node=(base.matno[i]-eltype*t7-bscode*t5)/t3;
										  if(eltype==8){if(node==8) //EFP 6/12/2014
viewfile2<<base.el_map[i]+1<<" "<<base.nop1[MXNPEL*i  ]+1<<" "<<base.nop1[MXNPEL*i+1]+1<<" "<<base.nop1[MXNPEL*i+2]+1<<" "<<base.nop1[MXNPEL*i+3]+1<<" "<<
							  base.nop1[MXNPEL*i+4]+1<<" "<<base.nop1[MXNPEL*i+5]+1<<" "<<base.nop1[MXNPEL*i+6]+1<<" "<<base.nop1[MXNPEL*i+7]+1<<"\n";
														else
viewfile2<<base.el_map[i]+1<<" "<<base.nop1[MXNPEL*i   ]+1<<" "<<base.nop1[MXNPEL*i+ 1]+1<<" "<<base.nop1[MXNPEL*i+ 2]+1<<" "<<base.nop1[MXNPEL*i+ 3]+1<<" "<<
							  base.nop1[MXNPEL*i+ 4]+1<<" "<<base.nop1[MXNPEL*i+ 5]+1<<" "<<base.nop1[MXNPEL*i+ 6]+1<<" "<<base.nop1[MXNPEL*i+ 7]+1<<" "<<
							  base.nop1[MXNPEL*i+ 8]+1<<" "<<base.nop1[MXNPEL*i+ 9]+1<<" "<<base.nop1[MXNPEL*i+10]+1<<" "<<base.nop1[MXNPEL*i+11]+1<<" "<<
							  base.nop1[MXNPEL*i+12]+1<<" "<<base.nop1[MXNPEL*i+13]+1<<" "<<base.nop1[MXNPEL*i+14]+1<<" "<<base.nop1[MXNPEL*i+15]+1<<" "<<
							  base.nop1[MXNPEL*i+16]+1<<" "<<base.nop1[MXNPEL*i+17]+1<<" "<<base.nop1[MXNPEL*i+18]+1<<" "<<base.nop1[MXNPEL*i+19]+1<<"\n";
													   }
										  else if(eltype==7){if(node==6)
viewfile2<<base.el_map[i]+1<<" "<<base.nop1[MXNPEL*i  ]+1<<" "<<base.nop1[MXNPEL*i+1]+1<<" "<<base.nop1[MXNPEL*i+2]+1<<" "<<base.nop1[MXNPEL*i+3]+1<<" "<<
							  base.nop1[MXNPEL*i+4]+1<<" "<<base.nop1[MXNPEL*i+5]+1<<"\n";
															 else
viewfile2<<base.el_map[i]+1<<" "<<base.nop1[MXNPEL*i   ]+1<<" "<<base.nop1[MXNPEL*i+ 1]+1<<" "<<base.nop1[MXNPEL*i+ 2]+1<<" "<<base.nop1[MXNPEL*i+ 3]+1<<" "<<
							  base.nop1[MXNPEL*i+ 4]+1<<" "<<base.nop1[MXNPEL*i+ 5]+1<<" "<<base.nop1[MXNPEL*i+ 6]+1<<" "<<base.nop1[MXNPEL*i+ 7]+1<<" "<<
							  base.nop1[MXNPEL*i+ 8]+1<<" "<<base.nop1[MXNPEL*i+ 9]+1<<" "<<base.nop1[MXNPEL*i+10]+1<<" "<<base.nop1[MXNPEL*i+11]+1<<" "<<
							  base.nop1[MXNPEL*i+12]+1<<" "<<base.nop1[MXNPEL*i+13]+1<<" "<<base.nop1[MXNPEL*i+14]+1<<"\n";
															}
										  else if(eltype==5){if(node==4)
viewfile2<<base.el_map[i]+1<<" "<<base.nop1[MXNPEL*i  ]+1<<" "<<base.nop1[MXNPEL*i+1]+1<<" "<<base.nop1[MXNPEL*i+2]+1<<" "<<base.nop1[MXNPEL*i+3]+1<<"\n";
															 else
viewfile2<<base.el_map[i]+1<<" "<<base.nop1[MXNPEL*i   ]+1<<" "<<base.nop1[MXNPEL*i+ 1]+1<<" "<<base.nop1[MXNPEL*i+ 2]+1<<" "<<base.nop1[MXNPEL*i+ 3]+1<<" "<<
							  base.nop1[MXNPEL*i+ 4]+1<<" "<<base.nop1[MXNPEL*i+ 5]+1<<" "<<base.nop1[MXNPEL*i+ 6]+1<<" "<<base.nop1[MXNPEL*i+ 7]+1<<" "<<
							  base.nop1[MXNPEL*i+ 8]+1<<" "<<base.nop1[MXNPEL*i+ 9]+1<<"\n";
															}
										  else {
honk<<i+1<<" Unsupp in exportWARP3D1a_public() "<<eltype<<" "<<bscode<<" "<<node<<"\n";
												extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"exportWARP3D1a_public() unsupported element type",L"Terminate",MB_OK);
												exit(0);}
										 }


//		  viewfile2<<"c\n*echo on\nc\nc\nc\n*echo off\nblocking automatic\n"; //BobD request to remove BLOCKING 9/04/2014
		  viewfile2<<"c\n*echo on\nc\nc\nc\n*echo off\n";
		  viewfile2<<"c\nc   *** MPI + threads version: sparse and pcg solvers allowed\n";
		  viewfile2<<"c\nc   *** Threads version: sparse solver only\nc\n*echo on\n";
		  viewfile2.close();
//		  export_VED("default",&timesave2); // VED= virtual element detection
		  export_VED(gWsiAlias.t_str(),&timesave2); // VED= virtual element detection

////		  WARP3DepBlock1(20);
//		  WARP3DepBlock1(epStepsPerT); //To reverse, go back to preceding WARP3DepBlock1(20) EFP 12/19/2012
		  WARP3DepBlock(20);
		  Screen->Cursor=Save_Cursor;
//		  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"default_coordinates.COORDINATES & default_INCIDandBLOCK.INCIDandBLOCK\nwritten but user must use PATGO to create default_constraints.CONSTRAINTS\nBlocking info must be added to default_INCIDandBLOCK.INCIDandBLOCK",L"Successful first step",MB_OK);
honk<<"\n"<<" Writing four WARP3D datafiles...\n";
		  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(string0,L"Writing 4 WARP3D files",MB_OK);
		 }
	   else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unable to create default_INCID.INCID",L"Failure",MB_OK);}
	  }
	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unable to create default_coordinates.COORDINATES",L"Failure",MB_OK);}
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"123Get geometry file->File/Open",L"Halt",MB_OK);}



//honk<<"\n"<<" Writing four WARP3D datafiles...\n";
//			   extern PACKAGE void __fastcall Beep(void);
//			   Application->MessageBox(string0,L"Writing 4 WARP3D files",MB_OK);
////			   delete ABAQnames;  // Why? Why? Why? EFP 4/19/2010
			   ABAQnames=NULL;
/////////// Cursor EFP 1/21/2011
Screen->Cursor=crSizeAll;
///////////
}
//---------------------------------------------------------------------------
void __fastcall TForm1::WARP3DconvenienceExecute(TObject *Sender) //Create WARP3D *.wrp file  EFP 9/11/2012
{long vl0=20,vlmin=1,vlmax=100000;  //WARP3D is stable for 20 but user might prefer 10
 float vf0=0.,vfmin=0.,vfmax=0.;
 F28_Form=new TForm28(26,0,0,vl0,vlmin,vlmax,vf0,vfmin,vfmax,this); //Should test for existence of modeless F28_Form here...
// F28_Form->Caption="Elastoplastic steps per weld step";
 F28_Form->Caption="WARP3D steps per deposition layer"; //Discussion with SK 12/13/2012
 F28_Form->Button3->Caption="Cancel";
 F28_Form->Width=245;F28_Form->ShowModal();
}
//---------------------------------------------------------------------------
void TForm1::WARP3DepBlock(long epStepsPerT) //THIS IS ORIGINAL OUTPUT FORMAT (pre 12/2012)
//Routine to create (e.g.) tee2-warp-finalPARTIAL.inp from time.out & param.in  EFP 9/16/2012
{int solidshellsw=0;
 long ic=0,ir=0,in=0,lolim=0,uplim=0,ntimeSer=0,mdummy=0,hinode=0,hielem=0;
 float epval=0.,tcuth=0.,tdummy=0., *timeSeries=NULL;
 char buf[3+1];
// char extensChar1a[]="*input from \'temp000",extensChar1b[]="*input from \'temp00",extensChar1c[]="*input from \'temp0",extensChar1d[]="*input from \'temp",
//	  outChar1[]=".out\'",descript[76], *otNeed=NULL;
 char descript[76];
///// EFP 12/15/2012
//extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"User to choose time.out, not temp.out",L"Notice",MB_OK);
/////
// OpenDialog1->Filter= "Out (*.out)|*.out;*.OUT"; //TBD: Add check on time.out vs temp.out
// if(OpenDialog1->Execute())
//   {ifstream viewfile3(OpenDialog1->FileName.c_str(),ios::nocreate,0);
//	if(viewfile3){ntimeSer=0;epval=1./float(epStepsPerT);
//				  while(!viewfile3.eof()) //EFP 7/02/2012
//					{viewfile3.getline(descript,76);
//					 if(strlen(descript))ntimeSer++;
//					}
//				  viewfile3.close();
//				  ifstream viewfile3(OpenDialog1->FileName.c_str(),ios::nocreate);
//				  timeSeries=new float[ntimeSer];
//				  for(ic=0;ic<ntimeSer;ic++)viewfile3>>in>>timeSeries[ic];
//				  viewfile3.close();
//honk<<ntimeSer<<" ntimeSer\n";
//////////////
//////////////
				  ifstream viewfile4("param.in",ios::nocreate,0); //Global param.in, in case of multi-core
				  if(viewfile4){ //Read 11-parameter param.in
viewfile4>>mdummy;viewfile4>>mdummy;viewfile4>>mdummy;viewfile4>>mdummy;viewfile4>>mdummy;
viewfile4>>mdummy;viewfile4>>mdummy;viewfile4>>mdummy;viewfile4>>hinode;viewfile4>>tdummy;
viewfile4>>mdummy;viewfile4>>tdummy;viewfile4>>solidshellsw;viewfile4>>tdummy;viewfile4>>tcuth;
viewfile4>>hielem;viewfile4.close();
								if(!solidshellsw){
////////////////
////////////////
//////				  ofstream outfile("default.wrp");
////				  ofstream outfile("warp-finalPARTIAL.inp");
//				  ofstream outfile("warp-finalFULL.inp");

 char extensChar1[]=".wrp";char *fnNeed1=new char[strlen(gWsiAlias.t_str())+strlen(extensChar1)+1];
 StringCchCopy(fnNeed1,strlen(gWsiAlias.t_str())+strlen(extensChar1)+1,gWsiAlias.t_str());StringCchCat(fnNeed1,strlen(gWsiAlias.t_str())+strlen(extensChar1)+1,extensChar1);
 ofstream outfile(fnNeed1);delete [] fnNeed1;

//outfile<<"c\nc\ncFEMAP 8.20\nc\nc\nc\n";
outfile<<"c\nc\nc *.wrp file\n";
//outfile<<"structure warp3d_model\nc\nc\nc\n"; //Make this the same name as *.VFTr
outfile<<"structure "<<gWsiAlias.t_str()<<"\n";
outfile<<"c\nc\nc\n";
outfile<<"c Material VFT UMAT commands\n";
//outfile<<"material steel_1e650_umat\n";  //Make name=defined material name & note that it is umat
outfile<<"material MATERIAL_umat\n";  //Make name=defined material name & note that it is umat
outfile<<"  properties umat  rho 0.0  alpha 0.0,\n";
outfile<<"       um_1 1 um_2 7.5E+02 um_3 1.5E+03,\n";
outfile<<"       um_4 1.5E+03 um_5 -1.0,\n";
outfile<<"       um_6 -1.0  um_7 0 um_8 0\n";
outfile<<"c     ***************************************\n";
outfile<<"c     *       end of sample materials       *\n";
outfile<<"c     ***************************************\n";
outfile<<"c\nc\n";
//outfile<<"number of nodes "<<hinode<<"\n";
//outfile<<"number of elements "<<hielem<<"\n";
outfile<<"number of nodes "<<hinode<<" elements "<<hielem<<"\n";
outfile<<"c\n";
////outfile<<"*input from \'Tee2.coordinates\'\n"; //Properly name (e.g.) 'Tee2.coordinates'
//outfile<<"*input from \'default.coordinates\'\n"; //Properly name (e.g.) 'Tee2.coordinates'
outfile<<"*input from \'"<<gWsiAlias.t_str()<<".coordinates\'\n"; //Properly name (e.g.) 'Tee2.coordinates'
outfile<<"c\nc\n";
outfile<<"elements\n";
outfile<<"c   for config number   0\n";
//outfile<<"            1 -   "<<hielem<<" type l3disop    linear material steel_1e650_umat,\n"; //Proper name
outfile<<"            1 -   "<<hielem<<" type l3disop    linear material MATERIAL_umat,\n"; //Proper name
outfile<<"					   order 2x2x2 bbar center_output short\n";
outfile<<"c\n";
////outfile<<"*input from \'Tee2.incid\'\n";
//outfile<<"*input from \'default.incid\'\n";
outfile<<"*input from \'"<<gWsiAlias.t_str()<<".incid\'\n";
outfile<<"c default blocking is 128 elem/blk\n";
outfile<<"blocking automatic\n";
outfile<<"c\nc\n";
////outfile<<"*input from \'Tee2.constraints\'\n";
//outfile<<"*input from \'default.constraints\'\n";
outfile<<"*input from \'"<<gWsiAlias.t_str()<<".constraints\'\n";
outfile<<"c\n";
outfile<<"c  Define initial temperatures\n";
outfile<<"initial conditions\n";
outfile<<"   temperature\n";
outfile<<"	 nodes 1-"<<hinode<<" temperature "<<tcuth<<"\n";
outfile<<"c\n";
////outfile<<"output patran neutral \"Tee2.neut\"\n";
//outfile<<"output patran neutral \'default.neut\'\n";
outfile<<"output patran neutral \'"<<gWsiAlias.t_str()<<".neut\'\n";
outfile<<"c\n";
outfile<<"c  From the template here are the load definitions.\n";
outfile<<"c  Total weld times are also included for convenience, not necessity\n";
outfile<<"c\n";
				  outfile<<"*echo off\n";
//
//				  lolim=1;uplim=epStepsPerT;
//				  for(ir=1;ir<ntimeSer;ir++)
//					{
//if(ir<10){gcvt(double(ir),1,buf);
//		  otNeed=new char[strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1];
//		  StringCchCopy(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,extensChar1a);
//		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,buf);
//		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(buf)+strlen(outChar1)+1,outChar1);
//		 }
//else if(ir<100){gcvt(double(ir),2,buf);
//				otNeed=new char[strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1];
//				StringCchCopy(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,extensChar1b);
//				StringCchCat(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,buf);
//				StringCchCat(otNeed,strlen(extensChar1b)+strlen(buf)+strlen(outChar1)+1,outChar1);
//			   }
//else if(ir<1000){gcvt(double(ir),3,buf);
//				 otNeed=new char[strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1];
//				 StringCchCopy(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,extensChar1c);
//				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,buf);
//				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(buf)+strlen(outChar1)+1,outChar1);
//				}
//else {gcvt(double(ir),4,buf);
//	  otNeed=new char[strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1];
//	  StringCchCopy(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,extensChar1d);
//	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,buf);
//	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(buf)+strlen(outChar1)+1,outChar1);
//	 }
////c  step 1-20 t=12.7
//					 outfile<<"c  step "<<lolim<<"-"<<uplim<<" t="<<timeSeries[ir]<<"\n";
//					 outfile<<"loading t"<<ir<<"\n";
//					 outfile<<"nodal loads\n";
//					 outfile<<otNeed<<"\n";
//					 outfile<<"c\n";
//					 delete [] otNeed;
//					 lolim=lolim+epStepsPerT;uplim=uplim+epStepsPerT;
//					}
				  outfile<<"loading weld_temps\n";
				  outfile<<" nodal loads\n";
				  outfile<<"  user_routine\n";

outfile<<"c\nc The loading steps\nc\n";
outfile<<"c This name must be used in the following: weld_sim\n";
//				  outfile<<"loading null\n";
				  outfile<<"loading weld_sim\n";
				  outfile<<" nonlinear\n";
//				  lolim=1;uplim=epStepsPerT;
//				  for(ic=1;ic<ntimeSer;ic++)
//					{
//					 outfile<<"  step "<<lolim<<"-"<<uplim<<" t"<<ic<<" "<<epval<<" constraints "<<epval<<"\n";
//					 lolim=lolim+epStepsPerT;uplim=uplim+epStepsPerT;
//					}
				  lolim=1;uplim=10000;
				  outfile<<"  step "<<lolim<<"-"<<uplim<<" weld_temps 1.0\n";
outfile<<"c Always define 5000 or more steps\n";
outfile<<"c Actual number of steps solved is determined dynamically by the\n";
outfile<<"c user_solution routine in response to features of thermal profiles.\n";

				  outfile<<"c\nc\nc Solution parameters.\nc\n";
outfile<<" nonlinear analysis parameters\n";

//outfile<<"   solution technique direct sparse\n";
//outfile<<"c   solution technique lnpcg\n";
//outfile<<"c   solution technique direct sparse\n";
//outfile<<"c   solution technique direct sparse hp\n";
//outfile<<"c   solution technique direct sparse bcs\n";
//outfile<<"c   solution technique direct sparse sgi\n";
//outfile<<"c   preconditioner type diagonal\n";
//outfile<<"c   preconditioner type hughes-winget\n";
////outfile<<"   lnr_pcg conv test res tol 0.01\n";  //Disconnected at BBB request 12/15/2012
////outfile<<"   maximum linear iterations 20000\n"; //Disconnected at BBB request 12/15/2012
////outfile<<"   maximum iterations 5\n";
//outfile<<"   maximum iterations 10\n";
////outfile<<"   minimum iterations 2\n";
//outfile<<"   minimum iterations 1\n";
//outfile<<"   threads for warp3d 8\n";  //Added EFP 12/15/2012
//outfile<<"   threads for umat 1\n";    //Added EFP 12/15/2012
////outfile<<"   convergence test norm res tol 0.01\n";
//outfile<<"   convergence test norm res tol 0.05\n";
//outfile<<"   nonconvergent solutions stop\n";
//outfile<<"   adaptive on\n";
////outfile<<"   linear stiffness for iteration one on\n";
//outfile<<"   linear stiffness for iteration one off\n";
//outfile<<"   batch messages off\n";
//outfile<<"   cpu time limit off\n";
//outfile<<"   material messages off\n";
//outfile<<"   bbar stabilization factor 0.05\n";
//outfile<<"   consistent q-matrix on\n";
//outfile<<"   time step 0.09436531\n"; //NOTE: Time for first slice of first WP???
//outfile<<"   trace solution on lpcg_solution off\n";
//outfile<<"   extrapolate on\n";
//outfile<<"   display tied mesh mpcs off\n";

//////////////////// TBD  EFP 9/23/2012
////outfile<<" nonlinear analysis parameters\n";
////outfile<<"   solution technique direct sparse\n";
////c Next command specifies 8 threads for solver
////outfile<<"   threads for mkl 8\n";
////outfile<<"   maximum iterations 10\n";
////outfile<<"   minimum iterations 1\n";
////outfile<<"   convergence test norm res tol 0.05\n";
////outfile<<"   nonconvergent solutions stop\n";
////outfile<<"   adaptive on\n";
////outfile<<"   linear stiffness for iteration one off\n";
////outfile<<"   batch messages off\n";
////outfile<<"   cpu time limit off\n";
////outfile<<"   material messages off\n";
////outfile<<"   bbar stabilization factor 0.05\n";
////outfile<<"   time step 0.0466683\n"; //NOTE: This must be time for first slice of first WP
////outfile<<"   trace solution on\n";
////outfile<<"   extrapolate on\n";
////////////////////
outfile<<" user_routine on\n";
outfile<<" umat serial off\n";
outfile<<" solution technique direct sparse\n";
outfile<<" convergence test maximum residual tolerance 0.5\n";
outfile<<" nonconvergent solutions stop\n";
outfile<<" divergence check on\n";
outfile<<" batch messages on\n";
outfile<<" cpu time limit off\n";
outfile<<" material messages off\n";
outfile<<" bbar stabilization factor 0.05\n";
outfile<<"c The following is only used for large displ analysis\n";
outfile<<" consistent q-matrix off\n";
outfile<<" trace solution on\n";
outfile<<"c The following values ignored because controlled by user_routine\n";
outfile<<"   time step 0.09436531\n";
outfile<<"   maximum iterations 7\n";
outfile<<"   minimum iterations 1\n";
outfile<<"   adaptive solution on\n";
outfile<<"   linear stiffness for iteration one off\n";
outfile<<"   extrapolate off\n";

//outfile<<"c\nc\nc Compute steps. Makes sure delta times are correct so WARP3D can\nc obtain accurate total times.\nc\n";
//				  lolim=1;uplim=epStepsPerT;
//				  for(ic=1;ic<ntimeSer;ic++)
//					{outfile<<"c t"<<ic<<"\n";
//					 outfile<<" compute displacements for loading null step "<<lolim<<"-"<<uplim<<"\n";
//					 outfile<<" nonlinear analysis parameters\n";
//					 outfile<<" time step "<<(timeSeries[ic]-timeSeries[ic-1])/float(epStepsPerT)<<"\n";
//					 outfile<<" output patran format displacements\n";
//					 outfile<<" output patran format element strains\n";
//					 outfile<<" output patran format element stresses\n";
////					 outfile<<" output patran format stresses\n";
//					 outfile<<" save to file 'pantleg'\n"; //TBD: Replace pantleg with actual Abaqus model name
//					 lolim=lolim+epStepsPerT;uplim=uplim+epStepsPerT;
//					}
				  outfile<<"*input 'compute_commands_all_profiles.inp'\n";
				  outfile<<"stop\n";
				  outfile.close();
/////////////////////////////				  delete [] timeSeries;
 ofstream outfile1("compute_commands_all_profiles.inp");
// for(ipp=0;ipp<wp.stepInterval[k];ipp++)
 for(ic=0;ic<10000;ic++) // Allow for max 10000 "on the fly" steps per BobD's request  EFP 10/09/2014
   {outfile1<<" compute displacements loading weld_sim step "<<ic+1<<"\n"; //Name weld_sim ESSENTIAL
	outfile1<<"   *input from 'vft_solution_cmds.inp'\n"; //vft_solution_cmds.inp is created by WARP3D on the fly, not by us
   }
 outfile1<<"stop\n";
 outfile1.close();
//				  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"warp-finalPARTIAL.inp written",L"Success",MB_OK);
				  extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"*.wrp & compute_commands_all_profiles.inp written",L"Success",MB_OK);
////////////////
////////////////
												 }
								else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"WARP3D is for solid models only",L"Failure: Shell model detected",MB_OK);}
							   }
				  else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Missing param.in file",L"Failure",MB_OK);}
//////////////
//////////////
//				 }
//	else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not open time.out",L"Failure",MB_OK);}
//   }
// else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Could not create FileOpen selector",L"Failure",MB_OK);}
// F28_Form->Close();
// delete F28_Form;
}

// Post Sept 20014 version from BobD
//---------------------------------------------------------------------------
// THIS ROUTINE IS NOT CALLED ANYMORE?
void TForm1::WARP3DepBlock1(long epStepsPerT) //CONSTANT epStepPerT==20 + User-specified filename
//Routine to create (e.g.) tee2-warp-finalPARTIAL.inp from time.out & param.in  EFP 9/16/2012
{int solidshellsw=0;
 int gdata8[24]={0,1,5,4, //Revised to get counterclock faces
				 1,2,6,5,
				 2,3,7,6,
				 3,0,4,7,
				 3,2,1,0,
				 4,5,6,7},
	 opp_arr8[6]={2,3,0,1,5,4};//TBD: Add vertplot[15] coding
 long ic=0,ir=0,in=0,lolim=0,uplim=0,ntimeSer=0,mdummy=0,hinode=0,hielem=0
 ,i=0,j=0,max1=0,k=0,eles_size=0,iseq=0,ipp=0,ie1=0,iside1=0,is1=0
 ,eltype=0,t7=10000000;
 float epval=0.,tcuth=0.,tdummy=0.
 ,heritageTime=0.,dist=0.,xc=0.,yc=0.,zc=0.,delt=0.,echo=0.,aval=0.,sum=0.,a0=0.
 , *timeSeries=NULL
 ;
 char extensChar1a[]="*input from \'temp000",extensChar1b[]="*input from \'temp00",extensChar1c[]="*input from \'temp0",extensChar1d[]="*input from \'temp",
	  outChar1[]=".out\'",descript[76], *otNeed=NULL;
 hinode=0;for(i=0;i<base.npoin;i++)if(hinode<base.node_map[i])hinode=base.node_map[i];
 hinode++;
 hielem=0;for(i=0;i<base.nelt;i++)if(hielem<base.el_map[i])hielem=base.el_map[i];
 hielem++;
// tcuth=25.;
 tcuth=wp.tcuth[0];
 epval=1./float(epStepsPerT);
 max1=1;
 for(k=0;k<wp.nWeldPass;k++)
		{eles_size=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.eles[i]> -1)eles_size++;else break;}
		 if(!eles_size){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Terminate: Corrupt data",L"Writing zero #weld group elements",MB_OK);exit(0);}
		 max1=max1+eles_size/wp.n_curr_sttEl[k]+wp.stepInterval[k];
		}
 timeSeries=new float[max1];
 max1=0;heritageTime=0.;timeSeries[max1]=heritageTime;max1++;
	  for(iseq=0;iseq<wp.nWeldPass;iseq++)
		{for(k=0;k<wp.nWeldPass;k++)if(iseq+1==wp.seqNum[k])break;
		 eles_size=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.eles[i]> -1)eles_size++;else break;}

						  for(ipp=0;ipp<eles_size/wp.n_curr_sttEl[k];ipp++){dist=0.;
					   for(in=0;in<wp.n_curr_sttEl[k];in++){
ie1=wp.eles[wp.memWGa*k+wp.n_curr_sttEl[k]*ipp+in]/10;iside1=wp.eles[wp.memWGa*k+wp.n_curr_sttEl[k]*ipp+in]-10*ie1;
///////////  EFP 6/12/2014
eltype=base.matno[ie1]/t7;if(eltype!=8){extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Non-hex element found in a WP",L"Terminate: Mesh must have hex in WPs",MB_OK);exit(0);}
///////////
xc=yc=zc=0.;
for(is1=0;is1<4;is1++){xc=xc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+0]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+0];
					   yc=yc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+1]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+1];
					   zc=zc+base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*iside1+is1]]+2]-base.c1[NDF*base.nop1[MXNPEL*ie1+gdata8[4*opp_arr8[iside1]+is1]]+2];
					  }
xc=xc/4.;yc=yc/4.;zc=zc/4.;dist=dist+sqrt(xc*xc+yc*yc+zc*zc);//EFP dislikes this non-area-weighted centroid
														   }
delt=dist/(float(wp.n_curr_sttEl[k])*wp.speed[k]);
heritageTime=heritageTime+delt;
timeSeries[max1]=heritageTime;max1++;									   }
////////////
if(wp.stepInterval[k]==1){heritageTime=heritageTime+wp.timeInterval[k];
timeSeries[max1]=heritageTime;max1++;
						 }
else {echo=heritageTime;
	  aval=1.;sum=aval; //EFP 11/24/2012
	  for(j=0;j<wp.stepInterval[k]-1;j++){aval=aval*1.2;sum=sum+aval;}
	  a0=wp.timeInterval[k]/sum;
	  for(j=0;j<wp.stepInterval[k]-1;j++){
heritageTime=heritageTime+a0;a0=a0*1.2;  //TBD: UPDATE mergeCTSP CODING  EFP 1/18/2013
//heritageTime=heritageTime+wp.timeInterval[k]*log((wp.stepInterval[k]-float(j)+float(j)*0.0353)/((wp.stepInterval[k]-float(j)-1+float(j+1)*0.0353))/log(1./0.0353);
timeSeries[max1]=heritageTime;max1++;
									   }
heritageTime=echo+wp.timeInterval[k];
timeSeries[max1]=heritageTime;max1++;
	 }


		}
 ntimeSer=max1;
 char extensChar1[]=".wrp";char *fnNeed1=new char[strlen(gWsiAlias.t_str())+strlen(extensChar1)+1];
 StringCchCopy(fnNeed1,strlen(gWsiAlias.t_str())+strlen(extensChar1)+1,gWsiAlias.t_str());StringCchCat(fnNeed1,strlen(gWsiAlias.t_str())+strlen(extensChar1)+1,extensChar1);
 ofstream outfile(fnNeed1);delete [] fnNeed1;

//outfile<<"c\nc\ncFEMAP 8.20\nc\nc\nc\n";
//outfile<<"c\nc\nc *.wrp file\n";
outfile<<"structure warp3d_model\nc\nc\nc\n";
outfile<<"c Material VFT UMAT commands\n";
outfile<<"material steel\n";
outfile<<"  properties umat  rho 0.0  alpha 0.0,\n";
outfile<<"       um_1 1 um_2 7.5E+02 um_3 1.5E+03,\n";
outfile<<"       um_4 1.5E+03 um_5 -1.0,\n";
outfile<<"       um_6 -1.0  um_7 0 um_8 0\n";
outfile<<"c     ***************************************\n";
outfile<<"c     *       end of sample materials       *\n";
outfile<<"c     ***************************************\n";
outfile<<"c\nc\n";
outfile<<"number of nodes "<<hinode<<" number of elements "<<hielem<<"\n"; //Correction 9/01/2014
//outfile<<"c\n";
//outfile<<"*input from \'"<<gWsiAlias.t_str()<<".coordinates\'\n";
outfile<<"c\nc\n";
outfile<<"elements\n";
outfile<<"c   for config number   0\n";
outfile<<"            1 -   "<<hielem<<" type l3disop    linear material steel,\n";
outfile<<"					   order 2x2x2 bbar center_output short\n";
outfile<<"c\n";
outfile<<"*input from \'"<<gWsiAlias.t_str()<<".coordinates\'\n";
outfile<<"c\n";
outfile<<"*input from \'"<<gWsiAlias.t_str()<<".incid\'\n";
outfile<<"blocking automatic\n";
outfile<<"c\nc\n";
outfile<<"*input from \'"<<gWsiAlias.t_str()<<".constraints\'\n";
//outfile<<"c\n";
//outfile<<"c\ncBlocking automatic\n";
outfile<<"c  Define initial temperatures\n";
outfile<<"initial conditions\n";
outfile<<"   temperature\n";
outfile<<"	 nodes 1-"<<hinode<<" temperature "<<tcuth<<"\n";
outfile<<"c\nc\n";
outfile<<"c  From the template here are the load definitions.\n";
outfile<<"c  Note: Total weld times are also included for convenience, not necessity.\n";
outfile<<"c\n";
				  outfile<<"*echo off\n";
////////////////////////
//////////////////////////
////////////////////////////
//				  lolim=1;uplim=epStepsPerT;
//				  for(ir=1;ir<ntimeSer;ir++)
//					{
//if(ir<10){otNeed=new char[strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//		  StringCchCopy(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1a);
//		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//		  StringCchCat(otNeed,strlen(extensChar1a)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
//		 }
//else if(ir<100){otNeed=new char[strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//				StringCchCopy(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1b);
//				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//				StringCchCat(otNeed,strlen(extensChar1b)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
//			   }
//else if(ir<1000){otNeed=new char[strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//				 StringCchCopy(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1c);
//				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//				 StringCchCat(otNeed,strlen(extensChar1c)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
//				}
//else {otNeed=new char[strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1];
//	  StringCchCopy(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,extensChar1d);
//	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,IntToStr((__int64)ir).c_str());
//	  StringCchCat(otNeed,strlen(extensChar1d)+strlen(IntToStr((__int64)ir).c_str())+strlen(outChar1)+1,outChar1);
//	 }
////c  step 1-20 t=12.7
//					 outfile<<"c  step "<<lolim<<"-"<<uplim<<" t="<<timeSeries[ir]<<"\n";
//					 outfile<<"loading t"<<ir<<"\n";
//					 outfile<<"nodal loads\n";
//					 outfile<<otNeed<<"\n";
//					 outfile<<"c\n";
//					 delete [] otNeed;
//					 lolim=lolim+epStepsPerT;uplim=uplim+epStepsPerT;
//					}
//
//outfile<<"loading "<<otNeed<<"\n"; //Use any name e.g. weld_temps
outfile<<"loading weld_temps\n"; //Use any name e.g. weld_temps
outfile<<" nodal loads\n";
outfile<<"  user_routine\n";
////////////////////////////
//////////////////////////
////////////////////////

outfile<<"c\nc The loading steps\nc\n";
//				  outfile<<"loading null\n";
				  outfile<<"loading weld_sim\n"; //The load name name weld_sim MUST BE USED.
				  outfile<<" nonlinear\n";
//				  lolim=1;uplim=epStepsPerT;
//				  for(ic=1;ic<ntimeSer;ic++)
//					{
//					 outfile<<"  step "<<lolim<<"-"<<uplim<<" t"<<ic<<" "<<epval<<" constraints "<<epval<<"\n";
//					 lolim=lolim+epStepsPerT;uplim=uplim+epStepsPerT;
//					}
				  lolim=1;uplim=10000;
				  outfile<<"  step "<<lolim<<"-"<<uplim<<" weld_temps "<<1.0<<"\n"; //Name can be other than weld_temps.WARP3D will reset 1.0

				  outfile<<"c\nc\nc Solution parameters.\nc\n";
outfile<<" nonlinear analysis parameters\n";
outfile<<" user_routine on\n"; //ESSENTIAL
outfile<<" umat serial off\n"; //ESSENTIAL
outfile<<"   solution technique direct sparse\n";
//outfile<<"c   solution technique lnpcg\n";
//outfile<<"c   solution technique direct sparse\n";
//outfile<<"c   solution technique direct sparse hp\n";
//outfile<<"c   solution technique direct sparse bcs\n";
//outfile<<"c   solution technique direct sparse sgi\n";
//outfile<<"c   preconditioner type diagonal\n";
//outfile<<"c   preconditioner type hughes-winget\n";
////outfile<<"   lnr_pcg conv test res tol 0.01\n";  //Disconnected at BBB request 12/15/2012
////outfile<<"   maximum linear iterations 20000\n"; //Disconnected at BBB request 12/15/2012
////outfile<<"   maximum iterations 5\n";
//outfile<<"   maximum iterations 10\n";
////outfile<<"   minimum iterations 2\n";
//outfile<<"   minimum iterations 1\n";
//outfile<<"   threads for warp3d 8\n";  //Added EFP 12/15/2012
//outfile<<"   threads for umat 1\n";    //Added EFP 12/15/2012
////outfile<<"   convergence test norm res tol 0.01\n";
outfile<<"   convergence test norm res tol 0.05\n";
outfile<<"   nonconvergent solutions stop\n";
outfile<<"   divergence check on\n"; //NEW
//outfile<<"   adaptive on\n";
////outfile<<"   linear stiffness for iteration one on\n";
//outfile<<"   linear stiffness for iteration one off\n";
outfile<<"   batch messages off\n";
outfile<<"   cpu time limit off\n";
outfile<<"   material messages off\n";
outfile<<"   bbar stabilization factor 0.05\n";
outfile<<"   consistent q-matrix off\n"; // on for large-strain solutions
outfile<<"   trace solution on\n";
outfile<<"   time step "<<timeSeries[1]-timeSeries[0]<<"\n"; //The following IGNORED by user_routine
outfile<<"   maximum iterations 13\n";
outfile<<"   minimum iterations 1\n";
outfile<<"   adaptive solution on\n";
outfile<<"   linear stiffness for iteration one off\n";
outfile<<"   extrapolate off\n";
				  outfile<<"input 'compute_commands_all_profiles.inp'\n";
				  outfile<<"stop\n";
				  outfile.close();
				  delete [] timeSeries;


//outfile<<"c\nc\nc Compute steps. Makes sure delta times are correct so WARP3D can\nc obtain accurate total times.\nc\n";
//				  lolim=1;uplim=epStepsPerT;
//				  ic=1;
//				  for(iseq=0;iseq<wp.nWeldPass;iseq++)
//					{for(k=0;k<wp.nWeldPass;k++)if(iseq+1==wp.seqNum[k])break;
//					 eles_size=0;for(i=wp.memWGa*k;i<wp.memWGa*(k+1);i++){if(wp.eles[i]> -1)eles_size++;else break;}
//					 for(ipp=0;ipp<eles_size/wp.n_curr_sttEl[k];ipp++)
//					   {outfile<<"c t"<<ic<<"\n";
//						outfile<<" compute displacements for loading null step "<<lolim<<"-"<<uplim<<"\n";
//						outfile<<" nonlinear analysis parameters\n";
//						outfile<<" time step "<<(timeSeries[ic]-timeSeries[ic-1])/float(epStepsPerT)<<"\n";
//						lolim=lolim+epStepsPerT;uplim=uplim+epStepsPerT;ic++;
//					   }
//					 for(ipp=0;ipp<wp.stepInterval[k];ipp++)
//					   {outfile<<"c t"<<ic<<"\n";
//						outfile<<" compute displacements for loading null step "<<lolim<<"-"<<uplim<<"\n";
//						outfile<<" nonlinear analysis parameters\n";
//						outfile<<" time step "<<(timeSeries[ic]-timeSeries[ic-1])/float(epStepsPerT)<<"\n";
// 						if(ipp==wp.stepInterval[k]-1)
//						  {outfile<<" output patran format displacements\n";
//						   outfile<<" output patran format element strains\n";
//						   outfile<<" output patran format element stresses\n";
//						   outfile<<" save to file \'"<<gWsiAlias.t_str()<<"\'\n"; //WARP3D EFP 12/19/2012
//						  }
//						lolim=lolim+epStepsPerT;uplim=uplim+epStepsPerT;ic++;
//					   }
//					}
////				  outfile<<"stop\n";
////				  outfile.close();
////				  delete [] timeSeries;
 ofstream outfile1("compute_commands_all_profiles.inp");
// for(ipp=0;ipp<wp.stepInterval[k];ipp++)
 for(ipp=0;ipp<10000;ipp++) // Allow for max 10000 "on the fly" steps per BobD's request  EFP 10/09/2014
   {outfile1<<" compute displacements loading weld_sim step "<<ipp+1<<"\n"; //Name weld_sim ESSENTIAL
	outfile1<<"   *input from 'vft_solution_cmds.inp'\n"; //vft_solution_cmds.inp is created by WARP3D on the fly, not by us
   }
 outfile1<<"stop\n";
 outfile1.close();
}

//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick0Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=30;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"124Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick1Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=31;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"125Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick2Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=32;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"126Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick3Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=33;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"127Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick4Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=34;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"128Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick5Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=35;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"129Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick6Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=36;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"130Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::BCsNclick7Execute(TObject *Sender)
{if(base.nop1)
   {FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=37;
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"131Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
void __fastcall TForm1::ElFacetAreaExecute(TObject *Sender) //EFP 5/01/2013
{if(base.nop1)
   {Screen->Cursor=crDefault;
	FD_LBrec=FD_LButtonstatus;FD_LButtonstatus=23; //Element facet area
   }
 else {extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"132Get geometry file->File/Open.",L"Halt",MB_OK);}
}
//---------------------------------------------------------------------------
float TForm1::ElemFacetArea(long ie,long iside,long nop1[],long matno[],float c1[])
{int ngaus8=2,ig=0,jg=0;long eltype=0,bscode=0,node=0,t3=1000,t5=100000,t7=10000000;
 float area=0.,xn=0.,yn=0.,zn=0.,DJD=0.,HN[9],SN[MXNPELS],SG[NDF*MXNPELS],DJR[9],POSGP8[2],WEIGP8[2];
 POSGP8[0]= -1./sqrt(3.);POSGP8[1]=1./sqrt(3.);WEIGP8[0]=WEIGP8[1]=1.00000;
 area=0.;eltype=matno[ie]/t7;bscode=(matno[ie]-eltype*t7)/t5;node=(matno[ie]-eltype*t7-bscode*t5)/t3;
 if(eltype==5)
	  {
//	   if(iside==0){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat; // STFISO4(ISL,G,E,T...) where S=1-G-E-T=0
//					if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
//					if(znat<PRMT)zn=2.*PRMT;else zn=znat;
//					zn=1.-xn-yn;
//				   }
//	   else if(iside==1){xn=0.; // G=0
//						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
//						 if(znat<PRMT)zn=2.*PRMT;else zn=znat;
//						}
//	   else if(iside==2){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat; // E=0
//						 yn=0.;
//						 if(znat<PRMT)zn=2.*PRMT;else zn=znat;
//						}
//	   else {if(xnat<PRMT)xn=2.*PRMT;else xn=xnat; // T=0
//			 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
//			 zn=0.;
//			}
//	   if(node==4)STFISO4(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
//	   else       STFISO10(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element type 5",L"Failure",MB_OK);
	  }
 else if(eltype==7)
	  {
//	   if     (iside==0){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
//						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
//						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
//						 yn=1.-xn;
//						}
//	   else if(iside==1){xn=0.;
//						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
//						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
//						}
//	   else if(iside==2){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
//						 yn=0.;
//						 if(znat< -1.+2.*PRMT)zn= -1.+2.*PRMT;else if(znat> 1.-2.*PRMT)zn=1.-2.*PRMT;else zn=znat;
//						}
//	   else if(iside==3){if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
//						 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
//						 zn= -1.;
// 						}
//	   else {if(xnat<PRMT)xn=2.*PRMT;else xn=xnat;
//			 if(ynat<PRMT)yn=2.*PRMT;else yn=ynat;
//			 zn=1.;
//			}
//	   if(node==6)STFISO6(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
//	   else       STFISO15(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
extern PACKAGE void __fastcall Beep(void);Application->MessageBox(L"Unsupported element type 7",L"Failure",MB_OK);
	  }
 else
   {for(ig=0;ig<ngaus8;ig++)
	{for(jg=0;jg<ngaus8;jg++)
	  {if     (iside==0){xn=POSGP8[ig];yn= -1.;zn=POSGP8[jg];}
	   else if(iside==1){xn=  1.;yn=POSGP8[ig];zn=POSGP8[jg];}
	   else if(iside==2){xn=POSGP8[ig];yn=  1.;zn=POSGP8[jg];}
	   else if(iside==3){xn= -1.;yn=POSGP8[ig];zn=POSGP8[jg];}
	   else if(iside==4){xn=POSGP8[ig];yn=POSGP8[jg];zn= -1.;}
	   else             {xn=POSGP8[ig];yn=POSGP8[jg];zn=1.;}
	   if(node==8)STFISO8(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
	   else       STFISO20(3,xn,yn,zn,&DJD,HN,SN,SG,DJR,nop1+MXNPEL*ie,c1);
	   area=area+DJD*WEIGP8[ig]*WEIGP8[jg];
	  }
	}
   }
 return area;
}
//---------------------------------------------------------------------------

